<!DOCTYPE HTML>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="viewport" content="width=device-width">
    <link rel="canonical" href="http://knexjs.org" />

    <link rel="apple-touch-icon" sizes="180x180" href="assets/favicons/apple-touch-icon.png" />
    <link rel="icon" type="image/png" href="assets/favicons/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="assets/favicons/favicon-16x16.png" sizes="16x16" />
    <link rel="manifest" href="assets/favicons/manifest.json" />
    <link rel="mask-icon" href="assets/favicons/safari-pinned-tab.svg" color="#e16426" />
    <meta name="theme-color" content="#ffffff" />

    <link rel="stylesheet" href="build/bundle.css" />
    <title>Knex.js - A SQL Query Builder for Javascript</title>
  </head>
  <body>
    <div id="documentation"><div data-reactroot="" data-reactid="1" data-react-checksum="-1133865679"><div id="sidebar" class="interface" data-reactid="2"><a class="toc_title" href="#changelog" data-reactid="3"><!-- react-text: 4 -->Knex.js <!-- /react-text --><span class="version" data-reactid="5"><!-- react-text: 6 -->(<!-- /react-text --><!-- react-text: 7 -->0.16.2<!-- /react-text --><!-- react-text: 8 -->)<!-- /react-text --></span></a><ul class="toc_section" data-reactid="9"><li data-reactid="10"><!-- react-text: 11 -->» <!-- /react-text --><a href="https://github.com/tgriesser/knex" data-reactid="12">GitHub Repository</a></li><li data-reactid="13"><!-- react-text: 14 -->» <!-- /react-text --><a href="#support" data-reactid="15">Support</a></li><li data-reactid="16"><!-- react-text: 17 -->» <!-- /react-text --><a href="#faq" data-reactid="18">FAQ</a></li><li data-reactid="19"><!-- react-text: 20 -->» <!-- /react-text --><a href="#changelog" data-reactid="21">Change Log</a></li></ul><a class="toc_title" href="#Installation" data-reactid="22">Installation</a><ul class="toc_section" data-reactid="23"><li data-reactid="24"><!-- react-text: 25 -->– <!-- /react-text --><a href="#Installation-node" data-reactid="26">Node.js</a></li><li data-reactid="27"><!-- react-text: 28 -->– <!-- /react-text --><a href="#Installation-browser" data-reactid="29">Browser</a></li><li data-reactid="30"><b data-reactid="31"><a href="#Installation-client" data-reactid="32">Config Options:</a></b></li><li data-reactid="33"><!-- react-text: 34 -->  – <!-- /react-text --><a href="#Installation-client" data-reactid="35">client</a></li><li data-reactid="36"><!-- react-text: 37 -->  – <!-- /react-text --><a href="#Installation-debug" data-reactid="38">debug</a></li><li data-reactid="39"><!-- react-text: 40 -->  – <!-- /react-text --><a href="#Installation-async-stack-traces" data-reactid="41">Async stacktraces</a></li><li data-reactid="42"><!-- react-text: 43 -->  – <!-- /react-text --><a href="#Installation-pooling" data-reactid="44">pooling</a></li><li data-reactid="45"><!-- react-text: 46 -->  – <!-- /react-text --><a href="#Installation-pooling-afterCreate" data-reactid="47">afterCreate</a></li><li data-reactid="48"><!-- react-text: 49 -->  – <!-- /react-text --><a href="#Installation-acquireConnectionTimeout" data-reactid="50">acquireConnectionTimeout</a></li><li data-reactid="51"><!-- react-text: 52 -->  – <!-- /react-text --><a href="#Installation-fetchAsString" data-reactid="53">fetchAsString</a></li><li data-reactid="54"><!-- react-text: 55 -->  – <!-- /react-text --><a href="#Installation-migrations" data-reactid="56">migrations</a></li><li data-reactid="57"><!-- react-text: 58 -->  – <!-- /react-text --><a href="#Installation-post-process-response" data-reactid="59">postProcessResponse</a></li><li data-reactid="60"><!-- react-text: 61 -->  – <!-- /react-text --><a href="#Installation-wrap-identifier" data-reactid="62">wrapIdentifier</a></li><li data-reactid="63"><!-- react-text: 64 -->  – <!-- /react-text --><a href="#Installation-log" data-reactid="65">log</a></li></ul><a class="toc_title" href="#Builder" data-reactid="66">Query Builder</a><ul class="toc_section" data-reactid="67"><li data-reactid="68"><!-- react-text: 69 -->– <!-- /react-text --><a href="#Builder-identifier-syntax" data-reactid="70"><b data-reactid="71">Identifier Syntax</b></a></li><li data-reactid="72"><!-- react-text: 73 -->– <!-- /react-text --><a href="#Builder-knex" data-reactid="74"><b data-reactid="75">constructor</b></a></li><li data-reactid="76"><!-- react-text: 77 -->– <!-- /react-text --><a href="#Builder-timeout" data-reactid="78">timeout</a></li><li data-reactid="79"><!-- react-text: 80 -->– <!-- /react-text --><a href="#Builder-select" data-reactid="81">select</a></li><li data-reactid="82"><!-- react-text: 83 -->– <!-- /react-text --><a href="#Builder-as" data-reactid="84">as</a></li><li data-reactid="85"><!-- react-text: 86 -->– <!-- /react-text --><a href="#Builder-column" data-reactid="87">column</a></li><li data-reactid="88"><!-- react-text: 89 -->– <!-- /react-text --><a href="#Builder-from" data-reactid="90">from</a></li><li data-reactid="91"><!-- react-text: 92 -->– <!-- /react-text --><a href="#Builder-with" data-reactid="93">with</a></li><li data-reactid="94"><!-- react-text: 95 -->– <!-- /react-text --><a href="#Builder-withRecursive" data-reactid="96">withRecursive</a></li><li data-reactid="97"><!-- react-text: 98 -->– <!-- /react-text --><a href="#Builder-withSchema" data-reactid="99">withSchema</a></li><li data-reactid="100"><b data-reactid="101"><a href="#Builder-wheres" data-reactid="102">Where Methods:</a></b></li><li data-reactid="103"><!-- react-text: 104 -->  – <!-- /react-text --><a href="#Builder-where" data-reactid="105">where</a></li><li data-reactid="106"><!-- react-text: 107 -->  – <!-- /react-text --><a href="#Builder-whereNot" data-reactid="108">whereNot</a></li><li data-reactid="109"><!-- react-text: 110 -->  – <!-- /react-text --><a href="#Builder-whereIn" data-reactid="111">whereIn</a></li><li data-reactid="112"><!-- react-text: 113 -->  – <!-- /react-text --><a href="#Builder-whereNotIn" data-reactid="114">whereNotIn</a></li><li data-reactid="115"><!-- react-text: 116 -->  – <!-- /react-text --><a href="#Builder-whereNull" data-reactid="117">whereNull</a></li><li data-reactid="118"><!-- react-text: 119 -->  – <!-- /react-text --><a href="#Builder-whereNotNull" data-reactid="120">whereNotNull</a></li><li data-reactid="121"><!-- react-text: 122 -->  – <!-- /react-text --><a href="#Builder-whereExists" data-reactid="123">whereExists</a></li><li data-reactid="124"><!-- react-text: 125 -->  – <!-- /react-text --><a href="#Builder-whereNotExists" data-reactid="126">whereNotExists</a></li><li data-reactid="127"><!-- react-text: 128 -->  – <!-- /react-text --><a href="#Builder-whereBetween" data-reactid="129">whereBetween</a></li><li data-reactid="130"><!-- react-text: 131 -->  – <!-- /react-text --><a href="#Builder-whereNotBetween" data-reactid="132">whereNotBetween</a></li><li data-reactid="133"><!-- react-text: 134 -->  – <!-- /react-text --><a href="#Builder-whereRaw" data-reactid="135">whereRaw</a></li><li data-reactid="136"><b data-reactid="137"><a href="#Builder-join" data-reactid="138">Join Methods:</a></b></li><li data-reactid="139"><!-- react-text: 140 -->  – <!-- /react-text --><a href="#Builder-innerJoin" data-reactid="141">innerJoin</a></li><li data-reactid="142"><!-- react-text: 143 -->  – <!-- /react-text --><a href="#Builder-leftJoin" data-reactid="144">leftJoin</a></li><li data-reactid="145"><!-- react-text: 146 -->  – <!-- /react-text --><a href="#Builder-leftOuterJoin" data-reactid="147">leftOuterJoin</a></li><li data-reactid="148"><!-- react-text: 149 -->  – <!-- /react-text --><a href="#Builder-rightJoin" data-reactid="150">rightJoin</a></li><li data-reactid="151"><!-- react-text: 152 -->  – <!-- /react-text --><a href="#Builder-rightOuterJoin" data-reactid="153">rightOuterJoin</a></li><li data-reactid="154"><!-- react-text: 155 -->  – <!-- /react-text --><a href="#Builder-fullOuterJoin" data-reactid="156">fullOuterJoin</a></li><li data-reactid="157"><!-- react-text: 158 -->  – <!-- /react-text --><a href="#Builder-crossJoin" data-reactid="159">crossJoin</a></li><li data-reactid="160"><!-- react-text: 161 -->  – <!-- /react-text --><a href="#Builder-joinRaw" data-reactid="162">joinRaw</a></li><li data-reactid="163"><b data-reactid="164"><a href="#Builder-on" data-reactid="165">On Methods:</a></b></li><li data-reactid="166"><!-- react-text: 167 -->  – <!-- /react-text --><a href="#Builder-onIn" data-reactid="168">onIn</a></li><li data-reactid="169"><!-- react-text: 170 -->  – <!-- /react-text --><a href="#Builder-onNotIn" data-reactid="171">onNotIn</a></li><li data-reactid="172"><!-- react-text: 173 -->  – <!-- /react-text --><a href="#Builder-onNull" data-reactid="174">onNull</a></li><li data-reactid="175"><!-- react-text: 176 -->  – <!-- /react-text --><a href="#Builder-onNotNull" data-reactid="177">onNotNull</a></li><li data-reactid="178"><!-- react-text: 179 -->  – <!-- /react-text --><a href="#Builder-onExists" data-reactid="180">onExists</a></li><li data-reactid="181"><!-- react-text: 182 -->  – <!-- /react-text --><a href="#Builder-onNotExists" data-reactid="183">onNotExists</a></li><li data-reactid="184"><!-- react-text: 185 -->  – <!-- /react-text --><a href="#Builder-onBetween" data-reactid="186">onBetween</a></li><li data-reactid="187"><!-- react-text: 188 -->  – <!-- /react-text --><a href="#Builder-onNotBetween" data-reactid="189">onNotBetween</a></li><li data-reactid="190"><b data-reactid="191"><a href="#Builder-havings" data-reactid="192">Having Methods:</a></b></li><li data-reactid="193"><!-- react-text: 194 -->  – <!-- /react-text --><a href="#Builder-having" data-reactid="195">having</a></li><li data-reactid="196"><!-- react-text: 197 -->  – <!-- /react-text --><a href="#Builder-havingIn" data-reactid="198">havingIn</a></li><li data-reactid="199"><!-- react-text: 200 -->  – <!-- /react-text --><a href="#Builder-havingNotIn" data-reactid="201">havingNotIn</a></li><li data-reactid="202"><!-- react-text: 203 -->  – <!-- /react-text --><a href="#Builder-havingNull" data-reactid="204">havingNull</a></li><li data-reactid="205"><!-- react-text: 206 -->  – <!-- /react-text --><a href="#Builder-havingNotNull" data-reactid="207">havingNotNull</a></li><li data-reactid="208"><!-- react-text: 209 -->  – <!-- /react-text --><a href="#Builder-havingExists" data-reactid="210">havingExists</a></li><li data-reactid="211"><!-- react-text: 212 -->  – <!-- /react-text --><a href="#Builder-havingNotExists" data-reactid="213">havingNotExists</a></li><li data-reactid="214"><!-- react-text: 215 -->  – <!-- /react-text --><a href="#Builder-havingBetween" data-reactid="216">havingBetween</a></li><li data-reactid="217"><!-- react-text: 218 -->  – <!-- /react-text --><a href="#Builder-havingNotBetween" data-reactid="219">havingNotBetween</a></li><li data-reactid="220"><!-- react-text: 221 -->  – <!-- /react-text --><a href="#Builder-havingRaw" data-reactid="222">havingRaw</a></li><li data-reactid="223"><b data-reactid="224"><a href="#Builder-clear" data-reactid="225">Clear Methods:</a></b></li><li data-reactid="226"><!-- react-text: 227 -->  – <!-- /react-text --><a href="#Builder-clearSelect" data-reactid="228">clearSelect</a></li><li data-reactid="229"><!-- react-text: 230 -->  – <!-- /react-text --><a href="#Builder-clearWhere" data-reactid="231">clearWhere</a></li><li data-reactid="232"><!-- react-text: 233 -->  – <!-- /react-text --><a href="#Builder-clearOrder" data-reactid="234">clearOrder</a></li><li data-reactid="235"><!-- react-text: 236 -->– <!-- /react-text --><a href="#Builder-distinct" data-reactid="237">distinct</a></li><li data-reactid="238"><!-- react-text: 239 -->– <!-- /react-text --><a href="#Builder-groupBy" data-reactid="240">groupBy</a></li><li data-reactid="241"><!-- react-text: 242 -->– <!-- /react-text --><a href="#Builder-groupByRaw" data-reactid="243">groupByRaw</a></li><li data-reactid="244"><!-- react-text: 245 -->– <!-- /react-text --><a href="#Builder-orderBy" data-reactid="246">orderBy</a></li><li data-reactid="247"><!-- react-text: 248 -->– <!-- /react-text --><a href="#Builder-orderByRaw" data-reactid="249">orderByRaw</a></li><li data-reactid="250"><!-- react-text: 251 -->– <!-- /react-text --><a href="#Builder-offset" data-reactid="252">offset</a></li><li data-reactid="253"><!-- react-text: 254 -->– <!-- /react-text --><a href="#Builder-limit" data-reactid="255">limit</a></li><li data-reactid="256"><!-- react-text: 257 -->– <!-- /react-text --><a href="#Builder-union" data-reactid="258">union</a></li><li data-reactid="259"><!-- react-text: 260 -->– <!-- /react-text --><a href="#Builder-unionAll" data-reactid="261">unionAll</a></li><li data-reactid="262"><!-- react-text: 263 -->– <!-- /react-text --><a href="#Builder-insert" data-reactid="264">insert</a></li><li data-reactid="265"><!-- react-text: 266 -->– <!-- /react-text --><a href="#Builder-returning" data-reactid="267">returning</a></li><li data-reactid="268"><!-- react-text: 269 -->– <!-- /react-text --><a href="#Builder-update" data-reactid="270">update</a></li><li data-reactid="271"><!-- react-text: 272 -->– <!-- /react-text --><a href="#Builder-del / delete" data-reactid="273">del / delete</a></li><li data-reactid="274"><!-- react-text: 275 -->– <!-- /react-text --><a href="#Builder-transacting" data-reactid="276">transacting</a></li><li data-reactid="277"><!-- react-text: 278 -->  – <!-- /react-text --><a href="#Builder-forUpdate" data-reactid="279">forUpdate</a></li><li data-reactid="280"><!-- react-text: 281 -->  – <!-- /react-text --><a href="#Builder-forShare" data-reactid="282">forShare</a></li><li data-reactid="283"><!-- react-text: 284 -->– <!-- /react-text --><a href="#Builder-count" data-reactid="285">count</a></li><li data-reactid="286"><!-- react-text: 287 -->– <!-- /react-text --><a href="#Builder-min" data-reactid="288">min</a></li><li data-reactid="289"><!-- react-text: 290 -->– <!-- /react-text --><a href="#Builder-max" data-reactid="291">max</a></li><li data-reactid="292"><!-- react-text: 293 -->– <!-- /react-text --><a href="#Builder-sum" data-reactid="294">sum</a></li><li data-reactid="295"><!-- react-text: 296 -->– <!-- /react-text --><a href="#Builder-avg" data-reactid="297">avg</a></li><li data-reactid="298"><!-- react-text: 299 -->– <!-- /react-text --><a href="#Builder-increment" data-reactid="300">increment</a></li><li data-reactid="301"><!-- react-text: 302 -->– <!-- /react-text --><a href="#Builder-decrement" data-reactid="303">decrement</a></li><li data-reactid="304"><!-- react-text: 305 -->– <!-- /react-text --><a href="#Builder-clearCounters" data-reactid="306">clearCounters</a></li><li data-reactid="307"><!-- react-text: 308 -->– <!-- /react-text --><a href="#Builder-truncate" data-reactid="309">truncate</a></li><li data-reactid="310"><!-- react-text: 311 -->– <!-- /react-text --><a href="#Builder-pluck" data-reactid="312">pluck</a></li><li data-reactid="313"><!-- react-text: 314 -->– <!-- /react-text --><a href="#Builder-first" data-reactid="315">first</a></li><li data-reactid="316"><!-- react-text: 317 -->– <!-- /react-text --><a href="#Builder-clone" data-reactid="318">clone</a></li><li data-reactid="319"><!-- react-text: 320 -->– <!-- /react-text --><a href="#Builder-modify" data-reactid="321">modify</a></li><li data-reactid="322"><!-- react-text: 323 -->– <!-- /react-text --><a href="#Builder-columnInfo" data-reactid="324">columnInfo</a></li><li data-reactid="325"><!-- react-text: 326 -->– <!-- /react-text --><a href="#Builder-debug" data-reactid="327">debug</a></li><li data-reactid="328"><!-- react-text: 329 -->– <!-- /react-text --><a href="#Builder-connection" data-reactid="330">connection</a></li><li data-reactid="331"><!-- react-text: 332 -->– <!-- /react-text --><a href="#Builder-options" data-reactid="333">options</a></li><li data-reactid="334"><!-- react-text: 335 -->- <!-- /react-text --><a href="#Builder-queryContext" data-reactid="336">queryContext</a></li></ul><a class="toc_title" href="#Transactions" data-reactid="337">Transactions</a><ul class="toc_section" data-reactid="338"><li data-reactid="339"><!-- react-text: 340 -->– <!-- /react-text --><a href="#Transactions" data-reactid="341"><b data-reactid="342">overview</b></a></li></ul><a class="toc_title" href="#Schema" data-reactid="343">Schema Builder</a><ul class="toc_section" data-reactid="344"><li data-reactid="345"><!-- react-text: 346 -->– <!-- /react-text --><a href="#Schema-with" data-reactid="347">with</a></li><li data-reactid="348"><!-- react-text: 349 -->– <!-- /react-text --><a href="#Schema-withSchema" data-reactid="350">withSchema</a></li><li data-reactid="351"><!-- react-text: 352 -->– <!-- /react-text --><a href="#Schema-createTable" data-reactid="353">createTable</a></li><li data-reactid="354"><!-- react-text: 355 -->– <!-- /react-text --><a href="#Schema-renameTable" data-reactid="356">renameTable</a></li><li data-reactid="357"><!-- react-text: 358 -->– <!-- /react-text --><a href="#Schema-dropTable" data-reactid="359">dropTable</a></li><li data-reactid="360"><!-- react-text: 361 -->– <!-- /react-text --><a href="#Schema-hasColumn" data-reactid="362">hasColumn</a></li><li data-reactid="363"><!-- react-text: 364 -->– <!-- /react-text --><a href="#Schema-hasTable" data-reactid="365">hasTable</a></li><li data-reactid="366"><!-- react-text: 367 -->– <!-- /react-text --><a href="#Schema-dropTableIfExists" data-reactid="368">dropTableIfExists</a></li><li data-reactid="369"><!-- react-text: 370 -->– <!-- /react-text --><a href="#Schema-table" data-reactid="371">table</a></li><li data-reactid="372"><!-- react-text: 373 -->– <!-- /react-text --><a href="#Schema-raw" data-reactid="374">raw</a></li><li data-reactid="375"><!-- react-text: 376 -->– <!-- /react-text --><a href="#Schema-queryContext" data-reactid="377">queryContext</a></li><li data-reactid="378"><b data-reactid="379"><a href="#Schema-Building" data-reactid="380">Schema Building:</a></b></li><li data-reactid="381"><!-- react-text: 382 -->– <!-- /react-text --><a href="#Schema-dropColumn" data-reactid="383">dropColumn</a></li><li data-reactid="384"><!-- react-text: 385 -->– <!-- /react-text --><a href="#Schema-dropColumns" data-reactid="386">dropColumns</a></li><li data-reactid="387"><!-- react-text: 388 -->– <!-- /react-text --><a href="#Schema-renameColumn" data-reactid="389">renameColumn</a></li><li data-reactid="390"><!-- react-text: 391 -->– <!-- /react-text --><a href="#Schema-increments" data-reactid="392">increments</a></li><li data-reactid="393"><!-- react-text: 394 -->– <!-- /react-text --><a href="#Schema-integer" data-reactid="395">integer</a></li><li data-reactid="396"><!-- react-text: 397 -->– <!-- /react-text --><a href="#Schema-bigInteger" data-reactid="398">bigInteger</a></li><li data-reactid="399"><!-- react-text: 400 -->– <!-- /react-text --><a href="#Schema-text" data-reactid="401">text</a></li><li data-reactid="402"><!-- react-text: 403 -->– <!-- /react-text --><a href="#Schema-string" data-reactid="404">string</a></li><li data-reactid="405"><!-- react-text: 406 -->– <!-- /react-text --><a href="#Schema-float" data-reactid="407">float</a></li><li data-reactid="408"><!-- react-text: 409 -->– <!-- /react-text --><a href="#Schema-decimal" data-reactid="410">decimal</a></li><li data-reactid="411"><!-- react-text: 412 -->– <!-- /react-text --><a href="#Schema-boolean" data-reactid="413">boolean</a></li><li data-reactid="414"><!-- react-text: 415 -->– <!-- /react-text --><a href="#Schema-date" data-reactid="416">date</a></li><li data-reactid="417"><!-- react-text: 418 -->– <!-- /react-text --><a href="#Schema-datetime" data-reactid="419">datetime</a></li><li data-reactid="420"><!-- react-text: 421 -->– <!-- /react-text --><a href="#Schema-time" data-reactid="422">time</a></li><li data-reactid="423"><!-- react-text: 424 -->– <!-- /react-text --><a href="#Schema-timestamp" data-reactid="425">timestamp</a></li><li data-reactid="426"><!-- react-text: 427 -->– <!-- /react-text --><a href="#Schema-timestamps" data-reactid="428">timestamps</a></li><li data-reactid="429"><!-- react-text: 430 -->– <!-- /react-text --><a href="#Schema-dropTimestamps" data-reactid="431">dropTimestamps</a></li><li data-reactid="432"><!-- react-text: 433 -->– <!-- /react-text --><a href="#Schema-binary" data-reactid="434">binary</a></li><li data-reactid="435"><!-- react-text: 436 -->– <!-- /react-text --><a href="#Schema-enum" data-reactid="437">enum / enu</a></li><li data-reactid="438"><!-- react-text: 439 -->– <!-- /react-text --><a href="#Schema-json" data-reactid="440">json</a></li><li data-reactid="441"><!-- react-text: 442 -->– <!-- /react-text --><a href="#Schema-jsonb" data-reactid="443">jsonb</a></li><li data-reactid="444"><!-- react-text: 445 -->– <!-- /react-text --><a href="#Schema-uuid" data-reactid="446">uuid</a></li><li data-reactid="447"><!-- react-text: 448 -->– <!-- /react-text --><a href="#Schema-comment" data-reactid="449">comment</a></li><li data-reactid="450"><!-- react-text: 451 -->– <!-- /react-text --><a href="#Schema-engine" data-reactid="452">engine</a></li><li data-reactid="453"><!-- react-text: 454 -->– <!-- /react-text --><a href="#Schema-charset" data-reactid="455">charset</a></li><li data-reactid="456"><!-- react-text: 457 -->– <!-- /react-text --><a href="#Schema-collate" data-reactid="458">collate</a></li><li data-reactid="459"><!-- react-text: 460 -->– <!-- /react-text --><a href="#Schema-inherits" data-reactid="461">inherits</a></li><li data-reactid="462"><!-- react-text: 463 -->– <!-- /react-text --><a href="#Schema-specificType" data-reactid="464">specificType</a></li><li data-reactid="465"><!-- react-text: 466 -->– <!-- /react-text --><a href="#Schema-index" data-reactid="467">index</a></li><li data-reactid="468"><!-- react-text: 469 -->– <!-- /react-text --><a href="#Schema-dropIndex" data-reactid="470">dropIndex</a></li><li data-reactid="471"><!-- react-text: 472 -->– <!-- /react-text --><a href="#Schema-unique" data-reactid="473">unique</a></li><li data-reactid="474"><!-- react-text: 475 -->– <!-- /react-text --><a href="#Schema-foreign" data-reactid="476">foreign</a></li><li data-reactid="477"><!-- react-text: 478 -->– <!-- /react-text --><a href="#Schema-dropForeign" data-reactid="479">dropForeign</a></li><li data-reactid="480"><!-- react-text: 481 -->– <!-- /react-text --><a href="#Schema-dropUnique" data-reactid="482">dropUnique</a></li><li data-reactid="483"><!-- react-text: 484 -->– <!-- /react-text --><a href="#Schema-dropPrimary" data-reactid="485">dropPrimary</a></li><li data-reactid="486"><!-- react-text: 487 -->– <!-- /react-text --><a href="#Schema-table-queryContext" data-reactid="488">queryContext</a></li><li data-reactid="489"><a href="#Chainable" data-reactid="490"><b data-reactid="491">Chainable:</b></a></li><li data-reactid="492"><!-- react-text: 493 -->– <!-- /react-text --><a href="#Schema-alter" data-reactid="494">alter</a></li><li data-reactid="495"><!-- react-text: 496 -->– <!-- /react-text --><a href="#Schema-index" data-reactid="497">index</a></li><li data-reactid="498"><!-- react-text: 499 -->– <!-- /react-text --><a href="#Schema-primary" data-reactid="500">primary</a></li><li data-reactid="501"><!-- react-text: 502 -->– <!-- /react-text --><a href="#Schema-unique" data-reactid="503">unique</a></li><li data-reactid="504"><!-- react-text: 505 -->– <!-- /react-text --><a href="#Schema-references" data-reactid="506">references</a></li><li data-reactid="507"><!-- react-text: 508 -->– <!-- /react-text --><a href="#Schema-inTable" data-reactid="509">inTable</a></li><li data-reactid="510"><!-- react-text: 511 -->– <!-- /react-text --><a href="#Schema-onDelete" data-reactid="512">onDelete</a></li><li data-reactid="513"><!-- react-text: 514 -->– <!-- /react-text --><a href="#Schema-onUpdate" data-reactid="515">onUpdate</a></li><li data-reactid="516"><!-- react-text: 517 -->– <!-- /react-text --><a href="#Schema-defaultTo" data-reactid="518">defaultTo</a></li><li data-reactid="519"><!-- react-text: 520 -->– <!-- /react-text --><a href="#Schema-unsigned" data-reactid="521">unsigned</a></li><li data-reactid="522"><!-- react-text: 523 -->– <!-- /react-text --><a href="#Schema-notNullable" data-reactid="524">notNullable</a></li><li data-reactid="525"><!-- react-text: 526 -->– <!-- /react-text --><a href="#Schema-nullable" data-reactid="527">nullable</a></li><li data-reactid="528"><!-- react-text: 529 -->– <!-- /react-text --><a href="#Schema-first" data-reactid="530">first</a></li><li data-reactid="531"><!-- react-text: 532 -->– <!-- /react-text --><a href="#Schema-after" data-reactid="533">after</a></li><li data-reactid="534"><!-- react-text: 535 -->– <!-- /react-text --><a href="#Column-comment" data-reactid="536">comment</a></li><li data-reactid="537"><!-- react-text: 538 -->– <!-- /react-text --><a href="#Column-collate" data-reactid="539">collate</a></li></ul><a class="toc_title" href="#Raw" data-reactid="540">Raw</a><ul class="toc_section" data-reactid="541"><li data-reactid="542"><!-- react-text: 543 -->– <!-- /react-text --><a href="#Raw-Bindings" data-reactid="544">Raw Parameter Binding</a></li><li data-reactid="545"><!-- react-text: 546 -->– <!-- /react-text --><a href="#Raw-Expressions" data-reactid="547">Raw Expressions</a></li><li data-reactid="548"><!-- react-text: 549 -->– <!-- /react-text --><a href="#Raw-Queries" data-reactid="550">Raw Queries</a></li><li data-reactid="551"><!-- react-text: 552 -->- <!-- /react-text --><a href="#Raw-queries-wrapped" data-reactid="553">Wrapped Queries</a></li></ul><a class="toc_title" href="#Ref" data-reactid="554">Ref</a><ul class="toc_section" data-reactid="555"><li data-reactid="556"><!-- react-text: 557 -->– <!-- /react-text --><a href="#Ref-Usage" data-reactid="558">Usage</a></li><li data-reactid="559"><!-- react-text: 560 -->– <!-- /react-text --><a href="#Ref-withSchema" data-reactid="561">withSchema</a></li><li data-reactid="562"><!-- react-text: 563 -->– <!-- /react-text --><a href="#Ref-alias" data-reactid="564">alias</a></li></ul><a class="toc_title" href="#Utility" data-reactid="565">Utility</a><ul class="toc_section" data-reactid="566"><li data-reactid="567"><!-- react-text: 568 -->- <!-- /react-text --><a href="#Utility-BatchInsert" data-reactid="569">Batch Insert</a></li></ul><a class="toc_title" href="#Interfaces" data-reactid="570">Interfaces</a><ul class="toc_section" data-reactid="571"><li data-reactid="572"><b data-reactid="573"><a href="#Interfaces-Promises" data-reactid="574">Promises</a></b></li><li data-reactid="575"><!-- react-text: 576 -->  – <!-- /react-text --><a href="#Interfaces-then" data-reactid="577">then</a></li><li data-reactid="578"><!-- react-text: 579 -->  – <!-- /react-text --><a href="#Interfaces-catch" data-reactid="580">catch</a></li><li data-reactid="581"><!-- react-text: 582 -->  – <!-- /react-text --><a href="#Interfaces-tap" data-reactid="583">tap</a></li><li data-reactid="584"><!-- react-text: 585 -->  – <!-- /react-text --><a href="#Interfaces-map" data-reactid="586">map</a></li><li data-reactid="587"><!-- react-text: 588 -->  – <!-- /react-text --><a href="#Interfaces-reduce" data-reactid="589">reduce</a></li><li data-reactid="590"><!-- react-text: 591 -->  – <!-- /react-text --><a href="#Interfaces-bind" data-reactid="592">bind</a></li><li data-reactid="593"><!-- react-text: 594 -->  – <!-- /react-text --><a href="#Interfaces-return" data-reactid="595">return</a></li><li data-reactid="596"><b data-reactid="597"><a href="#Interfaces-Callbacks" data-reactid="598">Callbacks</a></b></li><li data-reactid="599"><!-- react-text: 600 -->  – <!-- /react-text --><a href="#Interfaces-asCallback" data-reactid="601">asCallback</a></li><li data-reactid="602"><b data-reactid="603"><a href="#Interfaces-Streams" data-reactid="604">Streams</a></b></li><li data-reactid="605"><!-- react-text: 606 -->  – <!-- /react-text --><a href="#Interfaces-stream" data-reactid="607">stream</a></li><li data-reactid="608"><!-- react-text: 609 -->  – <!-- /react-text --><a href="#Interfaces-pipe" data-reactid="610">pipe</a></li><li data-reactid="611"><b data-reactid="612"><a href="#Interfaces-Events" data-reactid="613">Events</a></b></li><li data-reactid="614"><!-- react-text: 615 -->  – <!-- /react-text --><a href="#Interfaces-query" data-reactid="616">query</a></li><li data-reactid="617"><!-- react-text: 618 -->  – <!-- /react-text --><a href="#Interfaces-query-error" data-reactid="619">query-error</a></li><li data-reactid="620"><!-- react-text: 621 -->  – <!-- /react-text --><a href="#Interfaces-query-response" data-reactid="622">query-response</a></li><li data-reactid="623"><b data-reactid="624"><a href="#Interfaces-Other" data-reactid="625">Other:</a></b></li><li data-reactid="626"><!-- react-text: 627 -->  – <!-- /react-text --><a href="#Interfaces-toString" data-reactid="628">toString</a></li><li data-reactid="629"><!-- react-text: 630 -->  – <!-- /react-text --><a href="#Interfaces-toSQL" data-reactid="631">toSQL</a></li><li data-reactid="632"><!-- react-text: 633 -->  – <!-- /react-text --><a href="#Interfaces-toSQL" data-reactid="634">toSQL().toNative()</a></li></ul><a class="toc_title" href="#Migrations" data-reactid="635">Migrations</a><ul class="toc_section" data-reactid="636"><li data-reactid="637"><a href="#Migrations-CLI" data-reactid="638"><b data-reactid="639">CLI</b></a></li><li data-reactid="640"><!-- react-text: 641 -->– <!-- /react-text --><a href="#Migrations-CLI" data-reactid="642">Migrations</a></li><li data-reactid="643"><!-- react-text: 644 -->– <!-- /react-text --><a href="#Seeds-CLI" data-reactid="645">Seed files</a></li><li data-reactid="646"><!-- react-text: 647 -->– <!-- /react-text --><a href="#knexfile" data-reactid="648">knexfile.js</a></li><li data-reactid="649"><a href="#Migrations-API" data-reactid="650"><b data-reactid="651">Migration API</b></a></li><li data-reactid="652"><!-- react-text: 653 -->– <!-- /react-text --><a href="#Migrations-make" data-reactid="654">make</a></li><li data-reactid="655"><!-- react-text: 656 -->– <!-- /react-text --><a href="#Migrations-latest" data-reactid="657">latest</a></li><li data-reactid="658"><!-- react-text: 659 -->– <!-- /react-text --><a href="#Migrations-rollback" data-reactid="660">rollback</a></li><li data-reactid="661"><!-- react-text: 662 -->– <!-- /react-text --><a href="#Migrations-currentVersion" data-reactid="663">currentVersion</a></li><li data-reactid="664"><a href="#Notes-about-locks" data-reactid="665"><b data-reactid="666">Notes about locks</b></a></li><li data-reactid="667"><a href="#Seeds-API" data-reactid="668"><b data-reactid="669">Seed API</b></a></li><li data-reactid="670"><!-- react-text: 671 -->– <!-- /react-text --><a href="#Seeds-make" data-reactid="672">make</a></li><li data-reactid="673"><!-- react-text: 674 -->– <!-- /react-text --><a href="#Seeds-run" data-reactid="675">run</a></li></ul><a class="toc_title" href="#support" data-reactid="676">Support</a><a class="toc_title" href="#faq" data-reactid="677">F.A.Q.</a><a class="toc_title" href="#changelog" data-reactid="678">Change Log</a></div><div class="language" data-reactid="679"><!-- react-text: 680 -->Show example query output as:<!-- /react-text --><br data-reactid="681"/><select data-reactid="682"><option selected="" value="mysql" data-reactid="683">MySQL / MariaDB</option><option value="pg" data-reactid="684">PostgreSQL</option><option value="redshift" data-reactid="685">Amazon Redshift</option><option value="sqlite3" data-reactid="686">SQLite3</option><option value="oracle" data-reactid="687">Oracle</option><option value="mssql" data-reactid="688">MSSQL</option></select></div><a href="https://github.com/tgriesser/knex" data-reactid="689"><img style="position:fixed;top:0;right:0;border:0;" src="assets/images/github.png" alt="Fork me on GitHub" data-reactid="690"/></a><div class="container" data-reactid="691"><div id="Prelude" data-reactid="692"><div data-reactid="693"><p data-reactid="694"><img height="108" id="logo" src="assets/images/knex.png" alt="Knex.js" /></p><p data-reactid="695"><strong>Knex.js</strong> is a &quot;batteries included&quot; SQL query builder for <strong>Postgres</strong>, <strong>MSSQL</strong>, <strong>MySQL</strong>, <strong>MariaDB</strong>, <strong>SQLite3</strong>, <strong>Oracle</strong>, and <strong>Amazon Redshift</strong> designed to be flexible, portable, and fun to use. It features both traditional node style <a href="#Interfaces-Callbacks">callbacks</a> as well as a <a href="#Interfaces-Promises">promise</a> interface for cleaner async flow control, <a href="#Interfaces-Streams">a stream interface</a>, full featured <a href="#Builder">query</a> and <a href="#Schema">schema</a> builders, <a href="#Transactions"><strong>transaction support (with savepoints)</strong></a>, connection <a href="#Installation-pooling">pooling</a> and standardized responses between different query clients and dialects.</p><p data-reactid="696">The project is <a href="http://github.com/tgriesser/knex">hosted on GitHub</a>, and has a comprehensive <a href="https://travis-ci.org/tgriesser/knex">test suite</a>.</p><p data-reactid="697">Knex is available for use under the <a href="http://github.com/tgriesser/knex/blob/master/LICENSE">MIT software license</a>.</p><p data-reactid="698">You can report bugs and discuss features on the <a href="http://github.com/tgriesser/knex/issues">GitHub issues page</a>, add pages to the <a href="https://github.com/tgriesser/knex/wiki">wiki</a> or send tweets to <a href="http://twitter.com/tgriesser">@tgriesser</a>.</p><p data-reactid="699">Thanks to all of the great <a href="https://github.com/tgriesser/knex/graphs/contributors">contributions</a> to the project.</p></div><p class="info" data-reactid="700">Special thanks to <a href="https://twitter.com/taylorotwell">Taylor Otwell</a> and his work on the <a href="http://laravel.com/docs/queries">Laravel Query Builder</a>, from which much of the builder&#39;s code and syntax was originally derived.</p><h2 data-reactid="701">Latest Release: 0.16.2 - <span class="small"><a href="#changelog">Change Log</a></span></h2><p data-reactid="702">Current Develop — <a href="https://travis-ci.org/tgriesser/knex"><img src="https://travis-ci.org/tgriesser/knex.png?branch=master" alt="Travis Badge"></a></p></div><div id="Upgrading" data-reactid="703"></div><div id="Installation" data-reactid="704"><h2 id="Installation" data-reactid="705">Installation</h2><p data-reactid="706">Knex can be used as an SQL query builder in both Node.JS and the browser, limited to WebSQL&#39;s constraints (like the inability to drop tables or read schemas). Composing SQL queries in the browser for execution on the server is highly discouraged, as this can be the cause of serious security vulnerabilities. The browser builds outside of WebSQL are primarily for learning purposes - for example, you can pop open the console and build queries on this page using the <a href="javascript:alert(knex)">knex</a> object.</p><h3 id="Installation-node" data-reactid="707">Node.js</h3><p data-reactid="708">The primary target environment for Knex is Node.js, you will need to install the <code>knex</code> library, and then install the appropriate database library: <a href="https://github.com/brianc/node-postgres"><code>pg</code></a> for PostgreSQL and Amazon Redshift, <a href="https://github.com/felixge/node-mysql"><code>mysql</code></a> for MySQL or MariaDB, <a href="https://github.com/mapbox/node-sqlite3"><code>sqlite3</code></a> for SQLite3, or <a href="https://github.com/patriksimek/node-mssql"><code>mssql</code></a> for MSSQL.</p><pre data-reactid="709"><code data-reactid="710">$ npm install knex --save

# Then add one of the following (adding a --save) flag:
$ npm install pg
$ npm install sqlite3
$ npm install mysql
$ npm install mysql2
$ npm install oracle
$ npm install mssql</code></pre><p data-reactid="711"><em>If you want to use a MariaDB instance, you can use the <code>mysql</code> driver.</em></p><h3 id="Installation-browser" data-reactid="712">Browser</h3><p data-reactid="713">Knex can be built using a JavaScript build tool such as <a href="http://browserify.org/">browserify</a> or <a href="https://github.com/webpack/webpack">webpack</a>. In fact, this documentation uses a webpack build which <a href="https://github.com/knex/documentation/blob/a4de1b2eb50d6699f126be8d134f3d1acc4fc69d/components/Container.jsx#L3">includes knex</a>. View source on this page to see the browser build in-action (the global <code>knex</code> variable).</p><h3 id="Installation-client" data-reactid="714">Initializing the Library</h3><p data-reactid="715">The <code>knex</code> module is itself a function which takes a configuration object for Knex, accepting a few parameters. The <code>client</code> parameter is required and determines which client adapter will be used with the library.</p><pre data-reactid="716"><code class="hljs js" data-reactid="717"><span class="hljs-keyword">var</span> knex = <span class="hljs-built_in">require</span>(<span class="hljs-string">'knex'</span>)({
  <span class="hljs-attr">client</span>: <span class="hljs-string">'mysql'</span>,
  <span class="hljs-attr">connection</span>: {
    <span class="hljs-attr">host</span> : <span class="hljs-string">'127.0.0.1'</span>,
    <span class="hljs-attr">user</span> : <span class="hljs-string">'your_database_user'</span>,
    <span class="hljs-attr">password</span> : <span class="hljs-string">'your_database_password'</span>,
    <span class="hljs-attr">database</span> : <span class="hljs-string">'myapp_test'</span>
  }
});</code></pre><p data-reactid="718">The connection options are passed directly to the appropriate database client to create the connection, and may be either an object, or a connection string:</p><p class="info" data-reactid="719">Note: Knex&#39;s PostgreSQL client allows you to set the initial search path for each connection automatically using an additional option &quot;searchPath&quot; as shown below.</p><pre data-reactid="720"><code class="hljs js" data-reactid="721"><span class="hljs-keyword">var</span> pg = <span class="hljs-built_in">require</span>(<span class="hljs-string">'knex'</span>)({
  <span class="hljs-attr">client</span>: <span class="hljs-string">'pg'</span>,
  <span class="hljs-attr">connection</span>: process.env.PG_CONNECTION_STRING,
  <span class="hljs-attr">searchPath</span>: [<span class="hljs-string">'knex'</span>, <span class="hljs-string">'public'</span>],
});</code></pre><p class="info" data-reactid="722">Note: When you use the SQLite3 adapter, there is a filename required, not a network connection. For example:</p><pre data-reactid="723"><code class="hljs js" data-reactid="724"><span class="hljs-keyword">var</span> knex = <span class="hljs-built_in">require</span>(<span class="hljs-string">'knex'</span>)({
  <span class="hljs-attr">client</span>: <span class="hljs-string">'sqlite3'</span>,
  <span class="hljs-attr">connection</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">"./mydb.sqlite"</span>
  }
});</code></pre><p class="info" data-reactid="725">Note: The database version can be added in knex configuration, when you use the PostgreSQL adapter to connect a non-standard database.</p><pre data-reactid="726"><code class="hljs js" data-reactid="727"><span class="hljs-keyword">var</span> knex = <span class="hljs-built_in">require</span>(<span class="hljs-string">'knex'</span>)({
  <span class="hljs-attr">client</span>: <span class="hljs-string">'pg'</span>,
  <span class="hljs-attr">version</span>: <span class="hljs-string">'7.2'</span>,
  <span class="hljs-attr">connection</span>: {
    <span class="hljs-attr">host</span> : <span class="hljs-string">'127.0.0.1'</span>,
    <span class="hljs-attr">user</span> : <span class="hljs-string">'your_database_user'</span>,
    <span class="hljs-attr">password</span> : <span class="hljs-string">'your_database_password'</span>,
    <span class="hljs-attr">database</span> : <span class="hljs-string">'myapp_test'</span>
  }
});</code></pre><pre data-reactid="728"><code class="hljs js" data-reactid="729"><span class="hljs-keyword">var</span> knex = <span class="hljs-built_in">require</span>(<span class="hljs-string">'knex'</span>)({
  <span class="hljs-attr">client</span>: <span class="hljs-string">'mysql'</span>,
  <span class="hljs-attr">version</span>: <span class="hljs-string">'5.7'</span>,
  <span class="hljs-attr">connection</span>: {
    <span class="hljs-attr">host</span> : <span class="hljs-string">'127.0.0.1'</span>,
    <span class="hljs-attr">user</span> : <span class="hljs-string">'your_database_user'</span>,
    <span class="hljs-attr">password</span> : <span class="hljs-string">'your_database_password'</span>,
    <span class="hljs-attr">database</span> : <span class="hljs-string">'myapp_test'</span>
  }
});</code></pre><p data-reactid="730">You can also connect via an unix domain socket, which will ignore host and port.</p><pre data-reactid="731"><code class="hljs js" data-reactid="732"><span class="hljs-keyword">var</span> knex = <span class="hljs-built_in">require</span>(<span class="hljs-string">'knex'</span>)({
  <span class="hljs-attr">client</span>: <span class="hljs-string">'mysql'</span>,
  <span class="hljs-attr">connection</span>: {
    <span class="hljs-attr">socketPath</span> : <span class="hljs-string">'/path/to/socket.sock'</span>,
    <span class="hljs-attr">user</span> : <span class="hljs-string">'your_database_user'</span>,
    <span class="hljs-attr">password</span> : <span class="hljs-string">'your_database_password'</span>,
    <span class="hljs-attr">database</span> : <span class="hljs-string">'myapp_test'</span>
  }
});</code></pre><p data-reactid="733"><code>userParams</code> is an optional parameter that allows you to pass arbitrary parameters which will be accessible via <code>knex.userParams</code> property:</p><pre data-reactid="734"><code class="hljs js" data-reactid="735"><span class="hljs-keyword">var</span> knex = <span class="hljs-built_in">require</span>(<span class="hljs-string">'knex'</span>)({
  <span class="hljs-attr">client</span>: <span class="hljs-string">'mysql'</span>,
  <span class="hljs-attr">connection</span>: {
    <span class="hljs-attr">host</span> : <span class="hljs-string">'127.0.0.1'</span>,
    <span class="hljs-attr">user</span> : <span class="hljs-string">'your_database_user'</span>,
    <span class="hljs-attr">password</span> : <span class="hljs-string">'your_database_password'</span>,
    <span class="hljs-attr">database</span> : <span class="hljs-string">'myapp_test'</span>
  },
  <span class="hljs-attr">userParams</span>: {
    <span class="hljs-attr">userParam1</span>: <span class="hljs-string">'451'</span>
  }
});</code></pre><p class="info" data-reactid="736">Initializing the library should normally only ever happen once in your application, as it creates a connection pool for the current database, you should use the instance returned from the initialize call throughout your library.</p><p data-reactid="737">Specify the client for the particular flavour of SQL you are interested in.</p><pre data-reactid="738"><code class="hljs js" data-reactid="739"><span class="hljs-keyword">var</span> pg = <span class="hljs-built_in">require</span>(<span class="hljs-string">'knex'</span>)({<span class="hljs-attr">client</span>: <span class="hljs-string">'pg'</span>});
knex(<span class="hljs-string">'table'</span>).insert({<span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>}).returning(<span class="hljs-string">'*'</span>).toString();
<span class="hljs-comment">// "insert into "table" ("a") values ('b')"</span>

pg(<span class="hljs-string">'table'</span>).insert({<span class="hljs-attr">a</span>: <span class="hljs-string">'b'</span>}).returning(<span class="hljs-string">'*'</span>).toString();
<span class="hljs-comment">// "insert into "table" ("a") values ('b') returning *"</span></code></pre><h3 id="Installation-parametrization" data-reactid="740">Getting parametrized instance</h3><p data-reactid="741">You can call method <code>withUserParams</code> on a Knex instance if you want to get a copy (with same connections) with custom parameters (e. g. to execute same migrations with different parameters)</p><pre data-reactid="742"><code class="hljs js" data-reactid="743"><span class="hljs-keyword">var</span> knex = <span class="hljs-built_in">require</span>(<span class="hljs-string">'knex'</span>)({
  <span class="hljs-comment">// Params</span>
};

<span class="hljs-keyword">var</span> knexWithParams = knex.withUserParams({<span class="hljs-attr">customUserParam</span>: <span class="hljs-string">'table1'</span>});
<span class="hljs-keyword">var</span> customUserParam = knexWithParams.userParams.customUserParam;</code></pre><h3 id="Installation-debug" data-reactid="744">Debugging</h3><p data-reactid="745">Passing a <code>debug: true</code> flag on your initialization object will turn on <a href="#Builder-debug">debugging</a> for all queries.</p><h3 id="Installation-asyncStackTraces" data-reactid="746">asyncStackTraces</h3><p data-reactid="747">Passing an <code>asyncStackTraces: true</code> flag on your initialization object will turn on stack trace capture for all query builders, raw queries and schema builders. When a DB driver returns an error, this previously captured stack trace is thrown instead of a new one. This helps to mitigate default behaviour of <code>await</code> in node.js/V8 which blows the stack away. 
 This has small performance overhead, so it is advised to use only for development. Turned off by default.</p><h3 id="Installation-pooling" data-reactid="748">Pooling</h3><div data-reactid="749"><p data-reactid="750">The client created by the configuration initializes a connection pool, using the <a href="https://github.com/vincit/tarn.js">tarn.js</a> library. This connection pool has a default setting of a <code>min: 2, max: 10</code> for the MySQL and PG libraries, and a single connection for sqlite3 (due to issues with utilizing multiple connections on a single file). To change the config settings for the pool, pass a <code>pool</code> option as one of the keys in the initialize block.</p><p data-reactid="751">Checkout the <a href="https://github.com/vincit/tarn.js">tarn.js</a> library for more information.</p></div><pre data-reactid="752"><code class="hljs js" data-reactid="753"><span class="hljs-keyword">var</span> knex = <span class="hljs-built_in">require</span>(<span class="hljs-string">'knex'</span>)({
  <span class="hljs-attr">client</span>: <span class="hljs-string">'mysql'</span>,
  <span class="hljs-attr">connection</span>: {
    <span class="hljs-attr">host</span> : <span class="hljs-string">'127.0.0.1'</span>,
    <span class="hljs-attr">user</span> : <span class="hljs-string">'your_database_user'</span>,
    <span class="hljs-attr">password</span> : <span class="hljs-string">'your_database_password'</span>,
    <span class="hljs-attr">database</span> : <span class="hljs-string">'myapp_test'</span>
  },
  <span class="hljs-attr">pool</span>: { <span class="hljs-attr">min</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">max</span>: <span class="hljs-number">7</span> }
});</code></pre><p data-reactid="754">If you ever need to explicitly teardown the connection pool, you may use <code>knex.destroy([callback])</code>. You may use <code>knex.destroy</code> by passing a callback, or by chaining as a promise, just not both. To manually initialize a destroyed connection pool, you may use knex.initialize([config]), if no config is passed, it will use the first knex configuration used.</p><h3 id="Installation-pooling-afterCreate" data-reactid="755">afterCreate</h3><p data-reactid="756"><code>afterCreate</code> callback (rawDriverConnection, done) is called when the pool aquires a new connection from the database server. done(err, connection) callback must be called for <code>knex</code> to be able to decide if the connection is ok or if it should be discarded right away from the pool.</p><pre data-reactid="757"><code class="hljs js" data-reactid="758"><span class="hljs-keyword">var</span> knex = <span class="hljs-built_in">require</span>(<span class="hljs-string">'knex'</span>)({
  <span class="hljs-attr">client</span>: <span class="hljs-string">'pg'</span>,
  <span class="hljs-attr">connection</span>: {...},
  <span class="hljs-attr">pool</span>: {
    <span class="hljs-attr">afterCreate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">conn, done</span>) </span>{
      <span class="hljs-comment">// in this example we use pg driver's connection API</span>
      conn.query(<span class="hljs-string">'SET timezone="UTC";'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
        <span class="hljs-keyword">if</span> (err) {
          <span class="hljs-comment">// first query failed, return error and don't try to make next query</span>
          done(err, conn);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// do the second query...</span>
          conn.query(<span class="hljs-string">'SELECT set_limit(0.01);'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
            <span class="hljs-comment">// if err is not falsy, connection is discarded from pool</span>
            <span class="hljs-comment">// if connection aquire was triggered by a query the error is passed to query promise</span>
            done(err, conn);
          });
        }
      });
    }
  }
});</code></pre><h3 id="Installation-acquireConnectionTimeout" data-reactid="759">acquireConnectionTimeout</h3><p data-reactid="760"><code>acquireConnectionTimeout</code> defaults to 60000ms and is used to determine how long knex should wait before throwing a timeout error when acquiring a connection is not possible. The most common cause for this is using up all the pool for transaction connections and then attempting to run queries outside of transactions while the pool is still full. The error thrown will provide information on the query the connection was for to simplify the job of locating the culprit.</p><pre data-reactid="761"><code class="hljs js" data-reactid="762"><span class="hljs-keyword">var</span> knex = <span class="hljs-built_in">require</span>(<span class="hljs-string">'knex'</span>)({
  <span class="hljs-attr">client</span>: <span class="hljs-string">'pg'</span>,
  <span class="hljs-attr">connection</span>: {...},
  <span class="hljs-attr">pool</span>: {...},
  <span class="hljs-attr">acquireConnectionTimeout</span>: <span class="hljs-number">10000</span>
});</code></pre><h3 id="Installation-fetchAsString" data-reactid="763">fetchAsString</h3><p data-reactid="764">Utilized by Oracledb. An array of types. The valid types are &#39;DATE&#39;, &#39;NUMBER&#39; and &#39;CLOB&#39;. When any column having one of the specified types is queried, the column data is returned as a string instead of the default representation.</p><pre data-reactid="765"><code class="hljs js" data-reactid="766"><span class="hljs-keyword">var</span> knex = <span class="hljs-built_in">require</span>(<span class="hljs-string">'knex'</span>)({
  <span class="hljs-attr">client</span>: <span class="hljs-string">'oracledb'</span>,
  <span class="hljs-attr">connection</span>: {...},
  <span class="hljs-attr">fetchAsString</span>: [ <span class="hljs-string">'number'</span>, <span class="hljs-string">'clob'</span> ]
});</code></pre><h3 id="Installation-migrations" data-reactid="767">Migrations</h3><p data-reactid="768">For convenience, the any migration configuration may be specified when initializing the library. Read the <a href="#Migrations">Migrations</a> section for more information and a full list of configuration options.</p><pre data-reactid="769"><code class="hljs js" data-reactid="770"><span class="hljs-keyword">var</span> knex = <span class="hljs-built_in">require</span>(<span class="hljs-string">'knex'</span>)({
  <span class="hljs-attr">client</span>: <span class="hljs-string">'mysql'</span>,
  <span class="hljs-attr">connection</span>: {
    <span class="hljs-attr">host</span> : <span class="hljs-string">'127.0.0.1'</span>,
    <span class="hljs-attr">user</span> : <span class="hljs-string">'your_database_user'</span>,
    <span class="hljs-attr">password</span> : <span class="hljs-string">'your_database_password'</span>,
    <span class="hljs-attr">database</span> : <span class="hljs-string">'myapp_test'</span>
  },
  <span class="hljs-attr">migrations</span>: {
    <span class="hljs-attr">tableName</span>: <span class="hljs-string">'migrations'</span>
  }
});</code></pre><h3 id="Installation-post-process-response" data-reactid="771">postProcessResponse</h3><p data-reactid="772">Hook for modifying returned rows, before passing them forward to user. One can do for example snake_case -&gt; camelCase conversion for returned columns with this hook. The <code>queryContext</code> is only available if configured for a query builder instance via <a href="#Builder-queryContext">queryContext</a>.</p><pre data-reactid="773"><code class="hljs js" data-reactid="774"><span class="hljs-keyword">var</span> knex = <span class="hljs-built_in">require</span>(<span class="hljs-string">'knex'</span>)({
  <span class="hljs-attr">client</span>: <span class="hljs-string">'mysql'</span>,
  <span class="hljs-comment">// overly simplified snake_case -&gt; camelCase converter</span>
  postProcessResponse: <span class="hljs-function">(<span class="hljs-params">result, queryContext</span>) =&gt;</span> {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> add special case for raw results (depends on dialect)</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(result)) {
      <span class="hljs-keyword">return</span> result.map(<span class="hljs-function"><span class="hljs-params">row</span> =&gt;</span> convertToCamel(row));
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> convertToCamel(result);
    }
  }
});</code></pre><h3 id="Installation-wrap-identifier" data-reactid="775">wrapIdentifier</h3><p data-reactid="776">Knex supports transforming identifier names automatically to quoted versions for each dialect. For example <code>&#39;Table.columnName as foo&#39;</code> for PostgreSQL is converted to &quot;Table&quot;.&quot;columnName&quot; as &quot;foo&quot;.</p><p data-reactid="777">With <code>wrapIdentifier</code> one may override the way how identifiers are transformed. It can be used to override default functionality and for example to help doing <code>camelCase</code> -&gt; <code>snake_case</code> conversion.</p><p data-reactid="778">Conversion function <code>wrapIdentifier(value, dialectImpl, context): string</code> gets each part of the identifier as a single <code>value</code>, the original conversion function from the dialect implementation and the <code>queryContext</code>, which is only available if configured for a query builder instance via <a href="#Builder-queryContext">builder.queryContext</a>, and for schema builder instances via <a href="#Schema-queryContext">schema.queryContext</a> or <a href="#Schema-table-queryContext">table.queryContext</a>. For example, with the query builder, <code>knex(&#39;table&#39;).withSchema(&#39;foo&#39;).select(&#39;table.field as otherName&#39;).where(&#39;id&#39;, 1)</code> will call <code>wrapIdentifier</code> converter for following values <code>&#39;table&#39;</code>, <code>&#39;foo&#39;</code>, <code>&#39;table&#39;</code>, <code>&#39;field&#39;</code>, <code>&#39;otherName&#39;</code> and <code>&#39;id&#39;</code>.</p><pre data-reactid="779"><code class="hljs js" data-reactid="780"><span class="hljs-keyword">var</span> knex = <span class="hljs-built_in">require</span>(<span class="hljs-string">'knex'</span>)({
  <span class="hljs-attr">client</span>: <span class="hljs-string">'mysql'</span>,
  <span class="hljs-comment">// overly simplified camelCase -&gt; snake_case converter</span>
  wrapIdentifier: <span class="hljs-function">(<span class="hljs-params">value, origImpl, queryContext</span>) =&gt;</span> origImpl(convertToSnakeCase(value))
});</code></pre><h3 id="Installation-log" data-reactid="781">log</h3><p data-reactid="782">Knex contains some internal log functions for printing warnings, errors, deprecations, and debug information when applicable. These log functions typically log to the console, but can be overwritten using the log option and providing alternative functions. Different log functions can be used for separate knex instances.</p><pre data-reactid="783"><code class="hljs js" data-reactid="784"><span class="hljs-keyword">var</span> knex = <span class="hljs-built_in">require</span>(<span class="hljs-string">'knex'</span>)({
   <span class="hljs-attr">log</span>: {
    warn(message) {
    },
    error(message) {
    },
    deprecate(message) {
    },
    debug(message) {
    },
  }
});</code></pre></div><div id="Builder" data-reactid="785"><h2 id="Builder" data-reactid="786">Knex Query Builder</h2><p data-reactid="787">The heart of the library, the knex query builder is the interface used for building and executing standard SQL queries, such as <code>select</code>, <code>insert</code>, <code>update</code>, <code>delete</code>.</p><h3 id="Builder-identifier-syntax" data-reactid="788">Identifier Syntax</h3><div data-reactid="789"><p data-reactid="790">In many places in APIs identifiers like table name or column name can be passed to methods.</p><p data-reactid="791">Most commonly one needs just plain <code>tableName.columnName</code>, <code>tableName</code> or <code>columnName</code>, but in many cases one also needs to pass an alias how that identifier is referred later on in the query.</p><p data-reactid="792">There are two ways to declare an alias for identifier. One can directly give <code>as aliasName</code> prefix for the identifier or one can pass an object <code>{ aliasName: &#39;identifierName&#39; }</code>.</p><p data-reactid="793">If the object has multiple aliases <code>{ alias1: &#39;identifier1&#39;, alias2: &#39;identifier2&#39; }</code>, then all the aliased identifiers are expanded to comma separated list.</p><p data-reactid="794">NOTE: identifier syntax has no place for selecting schema, so if you are doing <code>schemaName.tableName</code>, query might be rendered wrong. Use <code>.withSchema(&#39;schemaName&#39;)</code> instead.</p></div><pre class="display" data-reactid="795"><code class="js hljs" data-reactid="796">knex({ <span class="hljs-attr">a</span>: <span class="hljs-string">'table'</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">'table'</span> })
  .select({
    <span class="hljs-attr">aTitle</span>: <span class="hljs-string">'a.title'</span>,
    <span class="hljs-attr">bTitle</span>: <span class="hljs-string">'b.title'</span>
  })
  .whereRaw(<span class="hljs-string">'?? = ??'</span>, [<span class="hljs-string">'a.column_1'</span>, <span class="hljs-string">'b.column_2'</span>])</code><br data-reactid="797"/><!-- react-text: 798 -->Outputs:<!-- /react-text --><br data-reactid="799"/><code class="sql hljs" data-reactid="800"><span class="hljs-keyword">select</span> <span class="hljs-string">`a`</span>.<span class="hljs-string">`title`</span> <span class="hljs-keyword">as</span> <span class="hljs-string">`aTitle`</span>, <span class="hljs-string">`b`</span>.<span class="hljs-string">`title`</span> <span class="hljs-keyword">as</span> <span class="hljs-string">`bTitle`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`table`</span> <span class="hljs-keyword">as</span> <span class="hljs-string">`a`</span>, <span class="hljs-string">`table`</span> <span class="hljs-keyword">as</span> <span class="hljs-string">`b`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`a`</span>.<span class="hljs-string">`column_1`</span> = <span class="hljs-string">`b`</span>.<span class="hljs-string">`column_2`</span></code></pre><div id="Builder-knex" data-reactid="801"><b data-reactid="802">knex</b><!-- react-text: 803 --> — <!-- /react-text --><code data-reactid="804">knex(tableName, options={only: boolean}) / knex.[methodName]</code><p data-reactid="805">The query builder starts off either by specifying a tableName you wish to query against, or by calling any method directly on the knex object. This kicks off a jQuery-like chain, with which you can call additional query builder methods as needed to construct the query, eventually calling any of the interface methods, to either convert toString, or execute the query with a promise, callback, or stream. Optional second argument for passing options:*   <strong>only</strong>: if <code>true</code>, the ONLY keyword is used before the <code>tableName</code> to discard inheriting tables&#39; data. <strong>NOTE:</strong> only supported in PostgreSQL for now.</p></div><div id="Builder-timeout" data-reactid="806"><b data-reactid="807">timeout</b><!-- react-text: 808 --> — <!-- /react-text --><code data-reactid="809">.timeout(ms, options={cancel: boolean})</code><p data-reactid="810">Sets a timeout for the query and will throw a TimeoutError if the timeout is exceeded. The error contains information about the query, bindings, and the timeout that was set. Useful for complex queries that you want to make sure are not taking too long to execute. Optional second argument for passing options:*   <strong>cancel</strong>: if <code>true</code>, cancel query if timeout is reached. <strong>NOTE:</strong> only supported in MySQL and PostgreSQL for now.</p><pre class="display" data-reactid="811"><code class="js hljs" data-reactid="812">knex.select().from(<span class="hljs-string">'books'</span>).timeout(<span class="hljs-number">1000</span>)</code><br data-reactid="813"/><!-- react-text: 814 -->Outputs:<!-- /react-text --><br data-reactid="815"/><code class="sql hljs" data-reactid="816"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`books`</span></code></pre><pre class="display" data-reactid="817"><code class="js hljs" data-reactid="818">knex.select().from(<span class="hljs-string">'books'</span>).timeout(<span class="hljs-number">1000</span>, {<span class="hljs-attr">cancel</span>: <span class="hljs-literal">true</span>}) <span class="hljs-comment">// MySQL and PostgreSQL only</span></code><br data-reactid="819"/><!-- react-text: 820 -->Outputs:<!-- /react-text --><br data-reactid="821"/><code class="sql hljs" data-reactid="822"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`books`</span></code></pre></div><div id="Builder-select" data-reactid="823"><b data-reactid="824">select</b><!-- react-text: 825 --> — <!-- /react-text --><code data-reactid="826">.select([*columns])</code><p data-reactid="827">Creates a select query, taking an optional array of columns for the query, eventually defaulting to * if none are specified when the query is built. The response of a select call will resolve with an array of objects selected from the database.</p><pre class="display" data-reactid="828"><code class="js hljs" data-reactid="829">knex.select(<span class="hljs-string">'title'</span>, <span class="hljs-string">'author'</span>, <span class="hljs-string">'year'</span>).from(<span class="hljs-string">'books'</span>)</code><br data-reactid="830"/><!-- react-text: 831 -->Outputs:<!-- /react-text --><br data-reactid="832"/><code class="sql hljs" data-reactid="833"><span class="hljs-keyword">select</span> <span class="hljs-string">`title`</span>, <span class="hljs-string">`author`</span>, <span class="hljs-string">`year`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`books`</span></code></pre><pre class="display" data-reactid="834"><code class="js hljs" data-reactid="835">knex.select().table(<span class="hljs-string">'books'</span>)</code><br data-reactid="836"/><!-- react-text: 837 -->Outputs:<!-- /react-text --><br data-reactid="838"/><code class="sql hljs" data-reactid="839"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`books`</span></code></pre></div><div id="Builder-as" data-reactid="840"><b data-reactid="841">as</b><!-- react-text: 842 --> — <!-- /react-text --><code data-reactid="843">.as(name)</code><p data-reactid="844">Allows for aliasing a subquery, taking the string you wish to name the current query. If the query is not a sub-query, it will be ignored.</p><pre class="display" data-reactid="845"><code class="js hljs" data-reactid="846">knex.avg(<span class="hljs-string">'sum_column1'</span>).from(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.sum(<span class="hljs-string">'column1 as sum_column1'</span>).from(<span class="hljs-string">'t1'</span>).groupBy(<span class="hljs-string">'column1'</span>).as(<span class="hljs-string">'t1'</span>)
}).as(<span class="hljs-string">'ignored_alias'</span>)</code><br data-reactid="847"/><!-- react-text: 848 -->Outputs:<!-- /react-text --><br data-reactid="849"/><code class="sql hljs" data-reactid="850"><span class="hljs-keyword">select</span> <span class="hljs-keyword">avg</span>(<span class="hljs-string">`sum_column1`</span>) <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-keyword">sum</span>(<span class="hljs-string">`column1`</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">`sum_column1`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`t1`</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-string">`column1`</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">`t1`</span></code></pre></div><div id="Builder-column" data-reactid="851"><b data-reactid="852">column</b><!-- react-text: 853 --> — <!-- /react-text --><code data-reactid="854">.column(columns)</code><p data-reactid="855">Specifically set the columns to be selected on a select query, taking an array, an object or a list of column names. Passing an object will automatically alias the columns with the given keys.</p><pre class="display" data-reactid="856"><code class="js hljs" data-reactid="857">knex.column(<span class="hljs-string">'title'</span>, <span class="hljs-string">'author'</span>, <span class="hljs-string">'year'</span>).select().from(<span class="hljs-string">'books'</span>)</code><br data-reactid="858"/><!-- react-text: 859 -->Outputs:<!-- /react-text --><br data-reactid="860"/><code class="sql hljs" data-reactid="861"><span class="hljs-keyword">select</span> <span class="hljs-string">`title`</span>, <span class="hljs-string">`author`</span>, <span class="hljs-string">`year`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`books`</span></code></pre><pre class="display" data-reactid="862"><code class="js hljs" data-reactid="863">knex.column([<span class="hljs-string">'title'</span>, <span class="hljs-string">'author'</span>, <span class="hljs-string">'year'</span>]).select().from(<span class="hljs-string">'books'</span>)</code><br data-reactid="864"/><!-- react-text: 865 -->Outputs:<!-- /react-text --><br data-reactid="866"/><code class="sql hljs" data-reactid="867"><span class="hljs-keyword">select</span> <span class="hljs-string">`title`</span>, <span class="hljs-string">`author`</span>, <span class="hljs-string">`year`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`books`</span></code></pre><pre class="display" data-reactid="868"><code class="js hljs" data-reactid="869">knex.column(<span class="hljs-string">'title'</span>, {<span class="hljs-attr">by</span>: <span class="hljs-string">'author'</span>}, <span class="hljs-string">'year'</span>).select().from(<span class="hljs-string">'books'</span>)</code><br data-reactid="870"/><!-- react-text: 871 -->Outputs:<!-- /react-text --><br data-reactid="872"/><code class="sql hljs" data-reactid="873"><span class="hljs-keyword">select</span> <span class="hljs-string">`title`</span>, <span class="hljs-string">`author`</span> <span class="hljs-keyword">as</span> <span class="hljs-string">`by`</span>, <span class="hljs-string">`year`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`books`</span></code></pre></div><div id="Builder-from" data-reactid="874"><b data-reactid="875">from</b><!-- react-text: 876 --> — <!-- /react-text --><code data-reactid="877">.from([tableName], options={only: boolean})</code><p data-reactid="878">Specifies the table used in the current query, replacing the current table name if one has already been specified. This is typically used in the sub-queries performed in the advanced where or union methods. Optional second argument for passing options:*   <strong>only</strong>: if <code>true</code>, the ONLY keyword is used before the <code>tableName</code> to discard inheriting tables&#39; data. <strong>NOTE:</strong> only supported in PostgreSQL for now.</p><pre class="display" data-reactid="879"><code class="js hljs" data-reactid="880">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>)</code><br data-reactid="881"/><!-- react-text: 882 -->Outputs:<!-- /react-text --><br data-reactid="883"/><code class="sql hljs" data-reactid="884"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre></div><div id="Builder-with" data-reactid="885"><b data-reactid="886">with</b><!-- react-text: 887 --> — <!-- /react-text --><code data-reactid="888">.with(alias, function|raw)</code><p data-reactid="889">Add a &quot;with&quot; clause to the query. &quot;With&quot; clauses are supported by PostgreSQL, Oracle, SQLite3 and MSSQL.</p><pre class="display" data-reactid="890"><code class="js hljs" data-reactid="891">knex.with(<span class="hljs-string">'with_alias'</span>, knex.raw(<span class="hljs-string">'select * from "books" where "author" = ?'</span>, <span class="hljs-string">'Test'</span>)).select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'with_alias'</span>)</code><br data-reactid="892"/><!-- react-text: 893 -->Outputs:<!-- /react-text --><br data-reactid="894"/><code class="sql hljs" data-reactid="895"><span class="hljs-keyword">with</span> <span class="hljs-string">`with_alias`</span> <span class="hljs-keyword">as</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">"books"</span> <span class="hljs-keyword">where</span> <span class="hljs-string">"author"</span> = <span class="hljs-string">'Test'</span>) <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`with_alias`</span></code></pre><pre class="display" data-reactid="896"><code class="js hljs" data-reactid="897">knex.with(<span class="hljs-string">'with_alias'</span>, (qb) =&gt; {
  qb.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'books'</span>).where(<span class="hljs-string">'author'</span>, <span class="hljs-string">'Test'</span>)
}).select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'with_alias'</span>)</code><br data-reactid="898"/><!-- react-text: 899 -->Outputs:<!-- /react-text --><br data-reactid="900"/><code class="sql hljs" data-reactid="901"><span class="hljs-keyword">with</span> <span class="hljs-string">`with_alias`</span> <span class="hljs-keyword">as</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`books`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`author`</span> = <span class="hljs-string">'Test'</span>) <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`with_alias`</span></code></pre></div><div id="Builder-withRecursive" data-reactid="902"><b data-reactid="903">withRecursive</b><!-- react-text: 904 --> — <!-- /react-text --><code data-reactid="905">.withRecursive(alias, function|raw)</code><p data-reactid="906">Indentical to the <code>with</code> method except &quot;recursive&quot; is appended to &quot;with&quot; to make self-referential CTEs possible.</p><pre class="display" data-reactid="907"><code class="js hljs" data-reactid="908">knex.withRecursive(<span class="hljs-string">'ancestors'</span>, (qb) =&gt; {
  qb.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'people'</span>).where(<span class="hljs-string">'people.id'</span>, <span class="hljs-number">1</span>).union(<span class="hljs-function">(<span class="hljs-params">qb</span>) =&gt;</span> {
    qb.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'people'</span>).join(<span class="hljs-string">'ancestors'</span>, <span class="hljs-string">'ancestors.parentId'</span>, <span class="hljs-string">'people.id'</span>)
  })
}).select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'ancestors'</span>)</code><br data-reactid="909"/><!-- react-text: 910 -->Outputs:<!-- /react-text --><br data-reactid="911"/><code class="sql hljs" data-reactid="912"><span class="hljs-keyword">with</span> <span class="hljs-keyword">recursive</span> <span class="hljs-string">`ancestors`</span> <span class="hljs-keyword">as</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`people`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`people`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`people`</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`ancestors`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`ancestors`</span>.<span class="hljs-string">`parentId`</span> = <span class="hljs-string">`people`</span>.<span class="hljs-string">`id`</span>) <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`ancestors`</span></code></pre></div><div id="Builder-withSchema" data-reactid="913"><b data-reactid="914">withSchema</b><!-- react-text: 915 --> — <!-- /react-text --><code data-reactid="916">.withSchema([schemaName])</code><p data-reactid="917">Specifies the schema to be used as prefix of table name.</p><pre class="display" data-reactid="918"><code class="js hljs" data-reactid="919">knex.withSchema(<span class="hljs-string">'public'</span>).select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>)</code><br data-reactid="920"/><!-- react-text: 921 -->Outputs:<!-- /react-text --><br data-reactid="922"/><code class="sql hljs" data-reactid="923"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`public`</span>.<span class="hljs-string">`users`</span></code></pre></div><h3 id="Builder-wheres" data-reactid="924">Where Clauses</h3><div data-reactid="925"><p data-reactid="926">Several methods exist to assist in dynamic where clauses. In many places functions may be used in place of values, constructing subqueries. In most places existing knex queries may be used to compose sub-queries, etc. Take a look at a few of the examples for each method for instruction on use:</p><p data-reactid="927"><strong>Important:</strong> Supplying knex with an <code>undefined</code> value to any of the <code>where</code> functions will cause knex to throw an error during sql compilation. This is both for yours and our sake. Knex cannot know what to do with undefined values in a where clause, and generally it would be a programmatic error to supply one to begin with. The error will throw a message containing the type of query and the compiled query-string. Example:</p></div><pre class="display" data-reactid="928"><code class="js hljs" data-reactid="929">knex(<span class="hljs-string">'accounts'</span>)
  .where(<span class="hljs-string">'login'</span>, <span class="hljs-literal">undefined</span>)
  .select()
  .toSQL()</code><br data-reactid="930"/><!-- react-text: 931 -->Error:<!-- /react-text --><br data-reactid="932"/><code class="sql hljs" data-reactid="933">Undefined binding(s) detected when compiling SELECT query: select * from `accounts` where `login` = ?</code></pre><div id="Builder-where" data-reactid="934"><b data-reactid="935">where</b><!-- react-text: 936 --> — <!-- /react-text --><code data-reactid="937">.where(~mixed~)</code></div><p data-reactid="938">Object Syntax:</p><pre class="display" data-reactid="939"><code class="js hljs" data-reactid="940">knex(<span class="hljs-string">'users'</span>).where({
  <span class="hljs-attr">first_name</span>: <span class="hljs-string">'Test'</span>,
  <span class="hljs-attr">last_name</span>:  <span class="hljs-string">'User'</span>
}).select(<span class="hljs-string">'id'</span>)</code><br data-reactid="941"/><!-- react-text: 942 -->Outputs:<!-- /react-text --><br data-reactid="943"/><code class="sql hljs" data-reactid="944"><span class="hljs-keyword">select</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`first_name`</span> = <span class="hljs-string">'Test'</span> <span class="hljs-keyword">and</span> <span class="hljs-string">`last_name`</span> = <span class="hljs-string">'User'</span></code></pre><p data-reactid="945">Key, Value:</p><pre class="display" data-reactid="946"><code class="js hljs" data-reactid="947">knex(<span class="hljs-string">'users'</span>).where(<span class="hljs-string">'id'</span>, <span class="hljs-number">1</span>)</code><br data-reactid="948"/><!-- react-text: 949 -->Outputs:<!-- /react-text --><br data-reactid="950"/><code class="sql hljs" data-reactid="951"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`id`</span> = <span class="hljs-number">1</span></code></pre><p data-reactid="952">Functions:</p><pre class="display" data-reactid="953"><code class="js hljs" data-reactid="954">knex(<span class="hljs-string">'users'</span>)
.where(<span class="hljs-function">(<span class="hljs-params">builder</span>) =&gt;</span>
  builder.whereIn(<span class="hljs-string">'id'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>]).whereNotIn(<span class="hljs-string">'id'</span>, [<span class="hljs-number">17</span>, <span class="hljs-number">19</span>])
)
.andWhere(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.where(<span class="hljs-string">'id'</span>, <span class="hljs-string">'&gt;'</span>, <span class="hljs-number">10</span>)
})</code><br data-reactid="955"/><!-- react-text: 956 -->Outputs:<!-- /react-text --><br data-reactid="957"/><code class="sql hljs" data-reactid="958"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> (<span class="hljs-string">`id`</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>) <span class="hljs-keyword">and</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">17</span>, <span class="hljs-number">19</span>)) <span class="hljs-keyword">and</span> (<span class="hljs-string">`id`</span> &gt; <span class="hljs-number">10</span>)</code></pre><p data-reactid="959">Grouped Chain:</p><pre class="display" data-reactid="960"><code class="js hljs" data-reactid="961">knex(<span class="hljs-string">'users'</span>).where(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.where(<span class="hljs-string">'id'</span>, <span class="hljs-number">1</span>).orWhere(<span class="hljs-string">'id'</span>, <span class="hljs-string">'&gt;'</span>, <span class="hljs-number">10</span>)
}).orWhere({<span class="hljs-attr">name</span>: <span class="hljs-string">'Tester'</span>})</code><br data-reactid="962"/><!-- react-text: 963 -->Outputs:<!-- /react-text --><br data-reactid="964"/><code class="sql hljs" data-reactid="965"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> (<span class="hljs-string">`id`</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-string">`id`</span> &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">or</span> (<span class="hljs-string">`name`</span> = <span class="hljs-string">'Tester'</span>)</code></pre><p data-reactid="966">Operator:</p><pre class="display" data-reactid="967"><code class="js hljs" data-reactid="968">knex(<span class="hljs-string">'users'</span>).where(<span class="hljs-string">'columnName'</span>, <span class="hljs-string">'like'</span>, <span class="hljs-string">'%rowlikeme%'</span>)</code><br data-reactid="969"/><!-- react-text: 970 -->Outputs:<!-- /react-text --><br data-reactid="971"/><code class="sql hljs" data-reactid="972"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`columnName`</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'%rowlikeme%'</span></code></pre><p data-reactid="973">The above query demonstrates the common use case of returning all users for which a specific pattern appears within a designated column.</p><pre class="display" data-reactid="974"><code class="js hljs" data-reactid="975">knex(<span class="hljs-string">'users'</span>).where(<span class="hljs-string">'votes'</span>, <span class="hljs-string">'&gt;'</span>, <span class="hljs-number">100</span>)</code><br data-reactid="976"/><!-- react-text: 977 -->Outputs:<!-- /react-text --><br data-reactid="978"/><code class="sql hljs" data-reactid="979"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`votes`</span> &gt; <span class="hljs-number">100</span></code></pre><pre class="display" data-reactid="980"><code class="js hljs" data-reactid="981"><span class="hljs-keyword">var</span> subquery = knex(<span class="hljs-string">'users'</span>).where(<span class="hljs-string">'votes'</span>, <span class="hljs-string">'&gt;'</span>, <span class="hljs-number">100</span>).andWhere(<span class="hljs-string">'status'</span>, <span class="hljs-string">'active'</span>).orWhere(<span class="hljs-string">'name'</span>, <span class="hljs-string">'John'</span>).select(<span class="hljs-string">'id'</span>);

knex(<span class="hljs-string">'accounts'</span>).where(<span class="hljs-string">'id'</span>, <span class="hljs-string">'in'</span>, subquery)</code><br data-reactid="982"/><!-- react-text: 983 -->Outputs:<!-- /react-text --><br data-reactid="984"/><code class="sql hljs" data-reactid="985"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`votes`</span> &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">and</span> <span class="hljs-string">`status`</span> = <span class="hljs-string">'active'</span> <span class="hljs-keyword">or</span> <span class="hljs-string">`name`</span> = <span class="hljs-string">'John'</span>)</code></pre><p data-reactid="986">.orWhere with an object automatically wraps the statement and creates an <code>or (and - and - and)</code> clause</p><pre class="display" data-reactid="987"><code class="js hljs" data-reactid="988">knex(<span class="hljs-string">'users'</span>).where(<span class="hljs-string">'id'</span>, <span class="hljs-number">1</span>).orWhere({<span class="hljs-attr">votes</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">user</span>: <span class="hljs-string">'knex'</span>})</code><br data-reactid="989"/><!-- react-text: 990 -->Outputs:<!-- /react-text --><br data-reactid="991"/><code class="sql hljs" data-reactid="992"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`id`</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> (<span class="hljs-string">`votes`</span> = <span class="hljs-number">100</span> <span class="hljs-keyword">and</span> <span class="hljs-string">`user`</span> = <span class="hljs-string">'knex'</span>)</code></pre><div id="Builder-whereNot" data-reactid="993"><b data-reactid="994">whereNot</b><!-- react-text: 995 --> — <!-- /react-text --><code data-reactid="996">.whereNot(~mixed~)</code></div><p data-reactid="997">Object Syntax:</p><pre class="display" data-reactid="998"><code class="js hljs" data-reactid="999">knex(<span class="hljs-string">'users'</span>).whereNot({
  <span class="hljs-attr">first_name</span>: <span class="hljs-string">'Test'</span>,
  <span class="hljs-attr">last_name</span>:  <span class="hljs-string">'User'</span>
}).select(<span class="hljs-string">'id'</span>)</code><br data-reactid="1000"/><!-- react-text: 1001 -->Outputs:<!-- /react-text --><br data-reactid="1002"/><code class="sql hljs" data-reactid="1003"><span class="hljs-keyword">select</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> <span class="hljs-string">`first_name`</span> = <span class="hljs-string">'Test'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-string">`last_name`</span> = <span class="hljs-string">'User'</span></code></pre><p data-reactid="1004">Key, Value:</p><pre class="display" data-reactid="1005"><code class="js hljs" data-reactid="1006">knex(<span class="hljs-string">'users'</span>).whereNot(<span class="hljs-string">'id'</span>, <span class="hljs-number">1</span>)</code><br data-reactid="1007"/><!-- react-text: 1008 -->Outputs:<!-- /react-text --><br data-reactid="1009"/><code class="sql hljs" data-reactid="1010"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> <span class="hljs-string">`id`</span> = <span class="hljs-number">1</span></code></pre><p data-reactid="1011">Grouped Chain:</p><pre class="display" data-reactid="1012"><code class="js hljs" data-reactid="1013">knex(<span class="hljs-string">'users'</span>).whereNot(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.where(<span class="hljs-string">'id'</span>, <span class="hljs-number">1</span>).orWhereNot(<span class="hljs-string">'id'</span>, <span class="hljs-string">'&gt;'</span>, <span class="hljs-number">10</span>)
}).orWhereNot({<span class="hljs-attr">name</span>: <span class="hljs-string">'Tester'</span>})</code><br data-reactid="1014"/><!-- react-text: 1015 -->Outputs:<!-- /react-text --><br data-reactid="1016"/><code class="sql hljs" data-reactid="1017"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> (<span class="hljs-string">`id`</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> <span class="hljs-string">`id`</span> &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> <span class="hljs-string">`name`</span> = <span class="hljs-string">'Tester'</span></code></pre><p data-reactid="1018">Operator:</p><pre class="display" data-reactid="1019"><code class="js hljs" data-reactid="1020">knex(<span class="hljs-string">'users'</span>).whereNot(<span class="hljs-string">'votes'</span>, <span class="hljs-string">'&gt;'</span>, <span class="hljs-number">100</span>)</code><br data-reactid="1021"/><!-- react-text: 1022 -->Outputs:<!-- /react-text --><br data-reactid="1023"/><code class="sql hljs" data-reactid="1024"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> <span class="hljs-string">`votes`</span> &gt; <span class="hljs-number">100</span></code></pre><p data-reactid="1025">CAVEAT: WhereNot is not suitable for &quot;in&quot; and &quot;between&quot; type subqueries. You should use &quot;not in&quot; and &quot;not between&quot; instead.</p><pre class="display" data-reactid="1026"><code class="js hljs" data-reactid="1027"><span class="hljs-keyword">var</span> subquery = knex(<span class="hljs-string">'users'</span>)
  .whereNot(<span class="hljs-string">'votes'</span>, <span class="hljs-string">'&gt;'</span>, <span class="hljs-number">100</span>)
  .andWhere(<span class="hljs-string">'status'</span>, <span class="hljs-string">'active'</span>)
  .orWhere(<span class="hljs-string">'name'</span>, <span class="hljs-string">'John'</span>)
  .select(<span class="hljs-string">'id'</span>);

knex(<span class="hljs-string">'accounts'</span>).where(<span class="hljs-string">'id'</span>, <span class="hljs-string">'not in'</span>, subquery)</code><br data-reactid="1028"/><!-- react-text: 1029 -->Outputs:<!-- /react-text --><br data-reactid="1030"/><code class="sql hljs" data-reactid="1031"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> <span class="hljs-string">`votes`</span> &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">and</span> <span class="hljs-string">`status`</span> = <span class="hljs-string">'active'</span> <span class="hljs-keyword">or</span> <span class="hljs-string">`name`</span> = <span class="hljs-string">'John'</span>)</code></pre><div id="Builder-whereIn" data-reactid="1032"><b data-reactid="1033">whereIn</b><!-- react-text: 1034 --> — <!-- /react-text --><code data-reactid="1035">.whereIn(column|columns, array|callback|builder) / .orWhereIn</code><p data-reactid="1036">Shorthand for .where(&#39;id&#39;, &#39;in&#39;, obj), the .whereIn and .orWhereIn methods add a &quot;where in&quot; clause to the query. Note that passing empty array as the value results in a query that never returns any rows (<code>WHERE 1 = 0</code>)</p><pre class="display" data-reactid="1037"><code class="js hljs" data-reactid="1038">knex.select(<span class="hljs-string">'name'</span>).from(<span class="hljs-string">'users'</span>)
  .whereIn(<span class="hljs-string">'id'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
  .orWhereIn(<span class="hljs-string">'id'</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])</code><br data-reactid="1039"/><!-- react-text: 1040 -->Outputs:<!-- /react-text --><br data-reactid="1041"/><code class="sql hljs" data-reactid="1042"><span class="hljs-keyword">select</span> <span class="hljs-string">`name`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">or</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)</code></pre><pre class="display" data-reactid="1043"><code class="js hljs" data-reactid="1044">knex.select(<span class="hljs-string">'name'</span>).from(<span class="hljs-string">'users'</span>)
  .whereIn(<span class="hljs-string">'account_id'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.select(<span class="hljs-string">'id'</span>).from(<span class="hljs-string">'accounts'</span>);
  })</code><br data-reactid="1045"/><!-- react-text: 1046 -->Outputs:<!-- /react-text --><br data-reactid="1047"/><code class="sql hljs" data-reactid="1048"><span class="hljs-keyword">select</span> <span class="hljs-string">`name`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`account_id`</span> <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`accounts`</span>)</code></pre><pre class="display" data-reactid="1049"><code class="js hljs" data-reactid="1050"><span class="hljs-keyword">var</span> subquery = knex.select(<span class="hljs-string">'id'</span>).from(<span class="hljs-string">'accounts'</span>);

knex.select(<span class="hljs-string">'name'</span>).from(<span class="hljs-string">'users'</span>)
  .whereIn(<span class="hljs-string">'account_id'</span>, subquery)</code><br data-reactid="1051"/><!-- react-text: 1052 -->Outputs:<!-- /react-text --><br data-reactid="1053"/><code class="sql hljs" data-reactid="1054"><span class="hljs-keyword">select</span> <span class="hljs-string">`name`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`account_id`</span> <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`accounts`</span>)</code></pre><pre class="display" data-reactid="1055"><code class="js hljs" data-reactid="1056">knex.select(<span class="hljs-string">'name'</span>).from(<span class="hljs-string">'users'</span>)
  .whereIn([<span class="hljs-string">'account_id'</span>, <span class="hljs-string">'email'</span>], [[<span class="hljs-number">3</span>, <span class="hljs-string">'test3@example.com'</span>], [<span class="hljs-number">4</span>, <span class="hljs-string">'test4@example.com'</span>]])</code><br data-reactid="1057"/><!-- react-text: 1058 -->Outputs:<!-- /react-text --><br data-reactid="1059"/><code class="sql hljs" data-reactid="1060"><span class="hljs-keyword">select</span> <span class="hljs-string">`name`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> (<span class="hljs-string">`account_id`</span>, <span class="hljs-string">`email`</span>) <span class="hljs-keyword">in</span> ((<span class="hljs-number">3</span>, <span class="hljs-string">'test3@example.com'</span>), (<span class="hljs-number">4</span>, <span class="hljs-string">'test4@example.com'</span>))</code></pre><pre class="display" data-reactid="1061"><code class="js hljs" data-reactid="1062">knex.select(<span class="hljs-string">'name'</span>).from(<span class="hljs-string">'users'</span>)
  .whereIn([<span class="hljs-string">'account_id'</span>, <span class="hljs-string">'email'</span>], knex.select(<span class="hljs-string">'id'</span>, <span class="hljs-string">'email'</span>).from(<span class="hljs-string">'accounts'</span>))</code><br data-reactid="1063"/><!-- react-text: 1064 -->Outputs:<!-- /react-text --><br data-reactid="1065"/><code class="sql hljs" data-reactid="1066"><span class="hljs-keyword">select</span> <span class="hljs-string">`name`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> (<span class="hljs-string">`account_id`</span>, <span class="hljs-string">`email`</span>) <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> <span class="hljs-string">`id`</span>, <span class="hljs-string">`email`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`accounts`</span>)</code></pre></div><div id="Builder-whereNotIn" data-reactid="1067"><b data-reactid="1068">whereNotIn</b><!-- react-text: 1069 --> — <!-- /react-text --><code data-reactid="1070">.whereNotIn(column, array|callback|builder) / .orWhereNotIn</code><pre class="display" data-reactid="1071"><code class="js hljs" data-reactid="1072">knex(<span class="hljs-string">'users'</span>).whereNotIn(<span class="hljs-string">'id'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])</code><br data-reactid="1073"/><!-- react-text: 1074 -->Outputs:<!-- /react-text --><br data-reactid="1075"/><code class="sql hljs" data-reactid="1076"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</code></pre><pre class="display" data-reactid="1077"><code class="js hljs" data-reactid="1078">knex(<span class="hljs-string">'users'</span>).where(<span class="hljs-string">'name'</span>, <span class="hljs-string">'like'</span>, <span class="hljs-string">'%Test%'</span>).orWhereNotIn(<span class="hljs-string">'id'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])</code><br data-reactid="1079"/><!-- react-text: 1080 -->Outputs:<!-- /react-text --><br data-reactid="1081"/><code class="sql hljs" data-reactid="1082"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`name`</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'%Test%'</span> <span class="hljs-keyword">or</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</code></pre></div><div id="Builder-whereNull" data-reactid="1083"><b data-reactid="1084">whereNull</b><!-- react-text: 1085 --> — <!-- /react-text --><code data-reactid="1086">.whereNull(column) / .orWhereNull</code><pre class="display" data-reactid="1087"><code class="js hljs" data-reactid="1088">knex(<span class="hljs-string">'users'</span>).whereNull(<span class="hljs-string">'updated_at'</span>)</code><br data-reactid="1089"/><!-- react-text: 1090 -->Outputs:<!-- /react-text --><br data-reactid="1091"/><code class="sql hljs" data-reactid="1092"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`updated_at`</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span></code></pre></div><div id="Builder-whereNotNull" data-reactid="1093"><b data-reactid="1094">whereNotNull</b><!-- react-text: 1095 --> — <!-- /react-text --><code data-reactid="1096">.whereNotNull(column) / .orWhereNotNull</code><pre class="display" data-reactid="1097"><code class="js hljs" data-reactid="1098">knex(<span class="hljs-string">'users'</span>).whereNotNull(<span class="hljs-string">'created_at'</span>)</code><br data-reactid="1099"/><!-- react-text: 1100 -->Outputs:<!-- /react-text --><br data-reactid="1101"/><code class="sql hljs" data-reactid="1102"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`created_at`</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span></code></pre></div><div id="Builder-whereExists" data-reactid="1103"><b data-reactid="1104">whereExists</b><!-- react-text: 1105 --> — <!-- /react-text --><code data-reactid="1106">.whereExists(builder | callback) / .orWhereExists</code><pre class="display" data-reactid="1107"><code class="js hljs" data-reactid="1108">knex(<span class="hljs-string">'users'</span>).whereExists(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'accounts'</span>).whereRaw(<span class="hljs-string">'users.account_id = accounts.id'</span>);
})</code><br data-reactid="1109"/><!-- react-text: 1110 -->Outputs:<!-- /react-text --><br data-reactid="1111"/><code class="sql hljs" data-reactid="1112"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">where</span> users.account_id = accounts.id)</code></pre><pre class="display" data-reactid="1113"><code class="js hljs" data-reactid="1114">knex(<span class="hljs-string">'users'</span>).whereExists(knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'accounts'</span>).whereRaw(<span class="hljs-string">'users.account_id = accounts.id'</span>))</code><br data-reactid="1115"/><!-- react-text: 1116 -->Outputs:<!-- /react-text --><br data-reactid="1117"/><code class="sql hljs" data-reactid="1118"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">where</span> users.account_id = accounts.id)</code></pre></div><div id="Builder-whereNotExists" data-reactid="1119"><b data-reactid="1120">whereNotExists</b><!-- react-text: 1121 --> — <!-- /react-text --><code data-reactid="1122">.whereNotExists(builder | callback) / .orWhereNotExists</code><pre class="display" data-reactid="1123"><code class="js hljs" data-reactid="1124">knex(<span class="hljs-string">'users'</span>).whereNotExists(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'accounts'</span>).whereRaw(<span class="hljs-string">'users.account_id = accounts.id'</span>);
})</code><br data-reactid="1125"/><!-- react-text: 1126 -->Outputs:<!-- /react-text --><br data-reactid="1127"/><code class="sql hljs" data-reactid="1128"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">where</span> users.account_id = accounts.id)</code></pre><pre class="display" data-reactid="1129"><code class="js hljs" data-reactid="1130">knex(<span class="hljs-string">'users'</span>).whereNotExists(knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'accounts'</span>).whereRaw(<span class="hljs-string">'users.account_id = accounts.id'</span>))</code><br data-reactid="1131"/><!-- react-text: 1132 -->Outputs:<!-- /react-text --><br data-reactid="1133"/><code class="sql hljs" data-reactid="1134"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">where</span> users.account_id = accounts.id)</code></pre></div><div id="Builder-whereBetween" data-reactid="1135"><b data-reactid="1136">whereBetween</b><!-- react-text: 1137 --> — <!-- /react-text --><code data-reactid="1138">.whereBetween(column, range) / .orWhereBetween</code><pre class="display" data-reactid="1139"><code class="js hljs" data-reactid="1140">knex(<span class="hljs-string">'users'</span>).whereBetween(<span class="hljs-string">'votes'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">100</span>])</code><br data-reactid="1141"/><!-- react-text: 1142 -->Outputs:<!-- /react-text --><br data-reactid="1143"/><code class="sql hljs" data-reactid="1144"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`votes`</span> <span class="hljs-keyword">between</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-number">100</span></code></pre></div><div id="Builder-whereNotBetween" data-reactid="1145"><b data-reactid="1146">whereNotBetween</b><!-- react-text: 1147 --> — <!-- /react-text --><code data-reactid="1148">.whereNotBetween(column, range) / .orWhereNotBetween</code><pre class="display" data-reactid="1149"><code class="js hljs" data-reactid="1150">knex(<span class="hljs-string">'users'</span>).whereNotBetween(<span class="hljs-string">'votes'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">100</span>])</code><br data-reactid="1151"/><!-- react-text: 1152 -->Outputs:<!-- /react-text --><br data-reactid="1153"/><code class="sql hljs" data-reactid="1154"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`votes`</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">between</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-number">100</span></code></pre></div><div id="Builder-whereRaw" data-reactid="1155"><b data-reactid="1156">whereRaw</b><!-- react-text: 1157 --> — <!-- /react-text --><code data-reactid="1158">.whereRaw(query, [bindings])</code><p data-reactid="1159">Convenience helper for .where(knex.raw(query)).</p><pre class="display" data-reactid="1160"><code class="js hljs" data-reactid="1161">knex(<span class="hljs-string">'users'</span>).whereRaw(<span class="hljs-string">'id = ?'</span>, [<span class="hljs-number">1</span>])</code><br data-reactid="1162"/><!-- react-text: 1163 -->Outputs:<!-- /react-text --><br data-reactid="1164"/><code class="sql hljs" data-reactid="1165"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span></code></pre></div><h3 data-reactid="1166">Join Methods</h3><p data-reactid="1167">Several methods are provided which assist in building joins.</p><div id="Builder-join" data-reactid="1168"><b data-reactid="1169">join</b><!-- react-text: 1170 --> — <!-- /react-text --><code data-reactid="1171">.join(table, first, [operator], second)</code><p data-reactid="1172">The join builder can be used to specify joins between tables, with the first argument being the joining table, the next three arguments being the first join column, the join operator and the second join column, respectively.</p><pre class="display" data-reactid="1173"><code class="js hljs" data-reactid="1174">knex(<span class="hljs-string">'users'</span>)
  .join(<span class="hljs-string">'contacts'</span>, <span class="hljs-string">'users.id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'contacts.user_id'</span>)
  .select(<span class="hljs-string">'users.id'</span>, <span class="hljs-string">'contacts.phone'</span>)</code><br data-reactid="1175"/><!-- react-text: 1176 -->Outputs:<!-- /react-text --><br data-reactid="1177"/><code class="sql hljs" data-reactid="1178"><span class="hljs-keyword">select</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span>, <span class="hljs-string">`contacts`</span>.<span class="hljs-string">`phone`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`contacts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`contacts`</span>.<span class="hljs-string">`user_id`</span></code></pre><pre class="display" data-reactid="1179"><code class="js hljs" data-reactid="1180">knex(<span class="hljs-string">'users'</span>)
  .join(<span class="hljs-string">'contacts'</span>, <span class="hljs-string">'users.id'</span>, <span class="hljs-string">'contacts.user_id'</span>)
  .select(<span class="hljs-string">'users.id'</span>, <span class="hljs-string">'contacts.phone'</span>)</code><br data-reactid="1181"/><!-- react-text: 1182 -->Outputs:<!-- /react-text --><br data-reactid="1183"/><code class="sql hljs" data-reactid="1184"><span class="hljs-keyword">select</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span>, <span class="hljs-string">`contacts`</span>.<span class="hljs-string">`phone`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`contacts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`contacts`</span>.<span class="hljs-string">`user_id`</span></code></pre></div><p data-reactid="1185">For grouped joins, specify a function as the second argument for the join query, and use <code>on</code> with <code>orOn</code> or <code>andOn</code> to create joins that are grouped with parentheses.</p><pre class="display" data-reactid="1186"><code class="js hljs" data-reactid="1187">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).join(<span class="hljs-string">'accounts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'accounts.id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'users.account_id'</span>).orOn(<span class="hljs-string">'accounts.owner_id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'users.id'</span>)
})</code><br data-reactid="1188"/><!-- react-text: 1189 -->Outputs:<!-- /react-text --><br data-reactid="1190"/><code class="sql hljs" data-reactid="1191"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`users`</span>.<span class="hljs-string">`account_id`</span> <span class="hljs-keyword">or</span> <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`owner_id`</span> = <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span></code></pre><p data-reactid="1192">For nested join statements, specify a function as first argument of <code>on</code>, <code>orOn</code> or <code>andOn</code></p><pre class="display" data-reactid="1193"><code class="js hljs" data-reactid="1194">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).join(<span class="hljs-string">'accounts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.on(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'accounts.id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'users.account_id'</span>)
    <span class="hljs-keyword">this</span>.orOn(<span class="hljs-string">'accounts.owner_id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'users.id'</span>)
  })
})</code><br data-reactid="1195"/><!-- react-text: 1196 -->Outputs:<!-- /react-text --><br data-reactid="1197"/><code class="sql hljs" data-reactid="1198"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">on</span> (<span class="hljs-string">`accounts`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`users`</span>.<span class="hljs-string">`account_id`</span> <span class="hljs-keyword">or</span> <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`owner_id`</span> = <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span>)</code></pre><p data-reactid="1199">It is also possible to use an object to represent the join syntax.</p><pre class="display" data-reactid="1200"><code class="js hljs" data-reactid="1201">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).join(<span class="hljs-string">'accounts'</span>, {<span class="hljs-string">'accounts.id'</span>: <span class="hljs-string">'users.account_id'</span>})</code><br data-reactid="1202"/><!-- react-text: 1203 -->Outputs:<!-- /react-text --><br data-reactid="1204"/><code class="sql hljs" data-reactid="1205"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`users`</span>.<span class="hljs-string">`account_id`</span></code></pre><p data-reactid="1206">If you need to use a literal value (string, number, or boolean) in a join instead of a column, use <code>knex.raw</code>.</p><pre class="display" data-reactid="1207"><code class="js hljs" data-reactid="1208">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).join(<span class="hljs-string">'accounts'</span>, <span class="hljs-string">'accounts.type'</span>, knex.raw(<span class="hljs-string">'?'</span>, [<span class="hljs-string">'admin'</span>]))</code><br data-reactid="1209"/><!-- react-text: 1210 -->Outputs:<!-- /react-text --><br data-reactid="1211"/><code class="sql hljs" data-reactid="1212"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`type`</span> = <span class="hljs-string">'admin'</span></code></pre><div id="Builder-innerJoin" data-reactid="1213"><b data-reactid="1214">innerJoin</b><!-- react-text: 1215 --> — <!-- /react-text --><code data-reactid="1216">.innerJoin(table, ~mixed~)</code><pre class="display" data-reactid="1217"><code class="js hljs" data-reactid="1218">knex.from(<span class="hljs-string">'users'</span>).innerJoin(<span class="hljs-string">'accounts'</span>, <span class="hljs-string">'users.id'</span>, <span class="hljs-string">'accounts.user_id'</span>)</code><br data-reactid="1219"/><!-- react-text: 1220 -->Outputs:<!-- /react-text --><br data-reactid="1221"/><code class="sql hljs" data-reactid="1222"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`user_id`</span></code></pre><pre class="display" data-reactid="1223"><code class="js hljs" data-reactid="1224">knex.table(<span class="hljs-string">'users'</span>).innerJoin(<span class="hljs-string">'accounts'</span>, <span class="hljs-string">'users.id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'accounts.user_id'</span>)</code><br data-reactid="1225"/><!-- react-text: 1226 -->Outputs:<!-- /react-text --><br data-reactid="1227"/><code class="sql hljs" data-reactid="1228"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`user_id`</span></code></pre><pre class="display" data-reactid="1229"><code class="js hljs" data-reactid="1230">knex(<span class="hljs-string">'users'</span>).innerJoin(<span class="hljs-string">'accounts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'accounts.id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'users.account_id'</span>).orOn(<span class="hljs-string">'accounts.owner_id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'users.id'</span>)
})</code><br data-reactid="1231"/><!-- react-text: 1232 -->Outputs:<!-- /react-text --><br data-reactid="1233"/><code class="sql hljs" data-reactid="1234"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`users`</span>.<span class="hljs-string">`account_id`</span> <span class="hljs-keyword">or</span> <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`owner_id`</span> = <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span></code></pre></div><div id="Builder-leftJoin" data-reactid="1235"><b data-reactid="1236">leftJoin</b><!-- react-text: 1237 --> — <!-- /react-text --><code data-reactid="1238">.leftJoin(table, ~mixed~)</code><pre class="display" data-reactid="1239"><code class="js hljs" data-reactid="1240">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).leftJoin(<span class="hljs-string">'accounts'</span>, <span class="hljs-string">'users.id'</span>, <span class="hljs-string">'accounts.user_id'</span>)</code><br data-reactid="1241"/><!-- react-text: 1242 -->Outputs:<!-- /react-text --><br data-reactid="1243"/><code class="sql hljs" data-reactid="1244"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`user_id`</span></code></pre><pre class="display" data-reactid="1245"><code class="js hljs" data-reactid="1246">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).leftJoin(<span class="hljs-string">'accounts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'accounts.id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'users.account_id'</span>).orOn(<span class="hljs-string">'accounts.owner_id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'users.id'</span>)
})</code><br data-reactid="1247"/><!-- react-text: 1248 -->Outputs:<!-- /react-text --><br data-reactid="1249"/><code class="sql hljs" data-reactid="1250"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`users`</span>.<span class="hljs-string">`account_id`</span> <span class="hljs-keyword">or</span> <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`owner_id`</span> = <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span></code></pre></div><div id="Builder-leftOuterJoin" data-reactid="1251"><b data-reactid="1252">leftOuterJoin</b><!-- react-text: 1253 --> — <!-- /react-text --><code data-reactid="1254">.leftOuterJoin(table, ~mixed~)</code><pre class="display" data-reactid="1255"><code class="js hljs" data-reactid="1256">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).leftOuterJoin(<span class="hljs-string">'accounts'</span>, <span class="hljs-string">'users.id'</span>, <span class="hljs-string">'accounts.user_id'</span>)</code><br data-reactid="1257"/><!-- react-text: 1258 -->Outputs:<!-- /react-text --><br data-reactid="1259"/><code class="sql hljs" data-reactid="1260"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`user_id`</span></code></pre><pre class="display" data-reactid="1261"><code class="js hljs" data-reactid="1262">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).leftOuterJoin(<span class="hljs-string">'accounts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'accounts.id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'users.account_id'</span>).orOn(<span class="hljs-string">'accounts.owner_id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'users.id'</span>)
})</code><br data-reactid="1263"/><!-- react-text: 1264 -->Outputs:<!-- /react-text --><br data-reactid="1265"/><code class="sql hljs" data-reactid="1266"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`users`</span>.<span class="hljs-string">`account_id`</span> <span class="hljs-keyword">or</span> <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`owner_id`</span> = <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span></code></pre></div><div id="Builder-rightJoin" data-reactid="1267"><b data-reactid="1268">rightJoin</b><!-- react-text: 1269 --> — <!-- /react-text --><code data-reactid="1270">.rightJoin(table, ~mixed~)</code><pre class="display" data-reactid="1271"><code class="js hljs" data-reactid="1272">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).rightJoin(<span class="hljs-string">'accounts'</span>, <span class="hljs-string">'users.id'</span>, <span class="hljs-string">'accounts.user_id'</span>)</code><br data-reactid="1273"/><!-- react-text: 1274 -->Outputs:<!-- /react-text --><br data-reactid="1275"/><code class="sql hljs" data-reactid="1276"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`user_id`</span></code></pre><pre class="display" data-reactid="1277"><code class="js hljs" data-reactid="1278">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).rightJoin(<span class="hljs-string">'accounts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'accounts.id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'users.account_id'</span>).orOn(<span class="hljs-string">'accounts.owner_id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'users.id'</span>)
})</code><br data-reactid="1279"/><!-- react-text: 1280 -->Outputs:<!-- /react-text --><br data-reactid="1281"/><code class="sql hljs" data-reactid="1282"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`users`</span>.<span class="hljs-string">`account_id`</span> <span class="hljs-keyword">or</span> <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`owner_id`</span> = <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span></code></pre></div><div id="Builder-rightOuterJoin" data-reactid="1283"><b data-reactid="1284">rightOuterJoin</b><!-- react-text: 1285 --> — <!-- /react-text --><code data-reactid="1286">.rightOuterJoin(table, ~mixed~)</code><pre class="display" data-reactid="1287"><code class="js hljs" data-reactid="1288">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).rightOuterJoin(<span class="hljs-string">'accounts'</span>, <span class="hljs-string">'users.id'</span>, <span class="hljs-string">'accounts.user_id'</span>)</code><br data-reactid="1289"/><!-- react-text: 1290 -->Outputs:<!-- /react-text --><br data-reactid="1291"/><code class="sql hljs" data-reactid="1292"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">right</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`user_id`</span></code></pre><pre class="display" data-reactid="1293"><code class="js hljs" data-reactid="1294">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).rightOuterJoin(<span class="hljs-string">'accounts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'accounts.id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'users.account_id'</span>).orOn(<span class="hljs-string">'accounts.owner_id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'users.id'</span>)
})</code><br data-reactid="1295"/><!-- react-text: 1296 -->Outputs:<!-- /react-text --><br data-reactid="1297"/><code class="sql hljs" data-reactid="1298"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">right</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`users`</span>.<span class="hljs-string">`account_id`</span> <span class="hljs-keyword">or</span> <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`owner_id`</span> = <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span></code></pre></div><div id="Builder-fullOuterJoin" data-reactid="1299"><b data-reactid="1300">fullOuterJoin</b><!-- react-text: 1301 --> — <!-- /react-text --><code data-reactid="1302">.fullOuterJoin(table, ~mixed~)</code><pre class="display" data-reactid="1303"><code class="js hljs" data-reactid="1304">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).fullOuterJoin(<span class="hljs-string">'accounts'</span>, <span class="hljs-string">'users.id'</span>, <span class="hljs-string">'accounts.user_id'</span>)</code><br data-reactid="1305"/><!-- react-text: 1306 -->Outputs:<!-- /react-text --><br data-reactid="1307"/><code class="sql hljs" data-reactid="1308"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">full</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`user_id`</span></code></pre><pre class="display" data-reactid="1309"><code class="js hljs" data-reactid="1310">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).fullOuterJoin(<span class="hljs-string">'accounts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'accounts.id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'users.account_id'</span>).orOn(<span class="hljs-string">'accounts.owner_id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'users.id'</span>)
})</code><br data-reactid="1311"/><!-- react-text: 1312 -->Outputs:<!-- /react-text --><br data-reactid="1313"/><code class="sql hljs" data-reactid="1314"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">full</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`users`</span>.<span class="hljs-string">`account_id`</span> <span class="hljs-keyword">or</span> <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`owner_id`</span> = <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span></code></pre></div><div id="Builder-crossJoin" data-reactid="1315"><b data-reactid="1316">crossJoin</b><!-- react-text: 1317 --> — <!-- /react-text --><code data-reactid="1318">.crossJoin(table, ~mixed~)</code><p data-reactid="1319">Cross join conditions are only supported in MySQL and SQLite3. For join conditions rather use innerJoin.</p><pre class="display" data-reactid="1320"><code class="js hljs" data-reactid="1321">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).crossJoin(<span class="hljs-string">'accounts'</span>)</code><br data-reactid="1322"/><!-- react-text: 1323 -->Outputs:<!-- /react-text --><br data-reactid="1324"/><code class="sql hljs" data-reactid="1325"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">cross</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span></code></pre><pre class="display" data-reactid="1326"><code class="js hljs" data-reactid="1327">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).crossJoin(<span class="hljs-string">'accounts'</span>, <span class="hljs-string">'users.id'</span>, <span class="hljs-string">'accounts.user_id'</span>)</code><br data-reactid="1328"/><!-- react-text: 1329 -->Outputs:<!-- /react-text --><br data-reactid="1330"/><code class="sql hljs" data-reactid="1331"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">cross</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`user_id`</span></code></pre><pre class="display" data-reactid="1332"><code class="js hljs" data-reactid="1333">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).crossJoin(<span class="hljs-string">'accounts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'accounts.id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'users.account_id'</span>).orOn(<span class="hljs-string">'accounts.owner_id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'users.id'</span>)
})</code><br data-reactid="1334"/><!-- react-text: 1335 -->Outputs:<!-- /react-text --><br data-reactid="1336"/><code class="sql hljs" data-reactid="1337"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">cross</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`users`</span>.<span class="hljs-string">`account_id`</span> <span class="hljs-keyword">or</span> <span class="hljs-string">`accounts`</span>.<span class="hljs-string">`owner_id`</span> = <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span></code></pre></div><div id="Builder-joinRaw" data-reactid="1338"><b data-reactid="1339">joinRaw</b><!-- react-text: 1340 --> — <!-- /react-text --><code data-reactid="1341">.joinRaw(sql, [bindings])</code><pre class="display" data-reactid="1342"><code class="js hljs" data-reactid="1343">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'accounts'</span>).joinRaw(<span class="hljs-string">'natural full join table1'</span>).where(<span class="hljs-string">'id'</span>, <span class="hljs-number">1</span>)</code><br data-reactid="1344"/><!-- react-text: 1345 -->Outputs:<!-- /react-text --><br data-reactid="1346"/><code class="sql hljs" data-reactid="1347"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">natural</span> <span class="hljs-keyword">full</span> <span class="hljs-keyword">join</span> table1 <span class="hljs-keyword">where</span> <span class="hljs-string">`id`</span> = <span class="hljs-number">1</span></code></pre><pre class="display" data-reactid="1348"><code class="js hljs" data-reactid="1349">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'accounts'</span>).join(knex.raw(<span class="hljs-string">'natural full join table1'</span>)).where(<span class="hljs-string">'id'</span>, <span class="hljs-number">1</span>)</code><br data-reactid="1350"/><!-- react-text: 1351 -->Outputs:<!-- /react-text --><br data-reactid="1352"/><code class="sql hljs" data-reactid="1353"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-keyword">natural</span> <span class="hljs-keyword">full</span> <span class="hljs-keyword">join</span> table1 <span class="hljs-keyword">where</span> <span class="hljs-string">`id`</span> = <span class="hljs-number">1</span></code></pre></div><h3 id="Builder-on" data-reactid="1354">OnClauses</h3><div id="Builder-onIn" data-reactid="1355"><b data-reactid="1356">onIn</b><!-- react-text: 1357 --> — <!-- /react-text --><code data-reactid="1358">.onIn(column, values)</code><p data-reactid="1359">Adds a onIn clause to the query.</p><pre class="display" data-reactid="1360"><code class="js hljs" data-reactid="1361">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).join(<span class="hljs-string">'contacts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'users.id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'contacts.id'</span>).onIn(<span class="hljs-string">'contacts.id'</span>, [<span class="hljs-number">7</span>, <span class="hljs-number">15</span>, <span class="hljs-number">23</span>, <span class="hljs-number">41</span>])
})</code><br data-reactid="1362"/><!-- react-text: 1363 -->Outputs:<!-- /react-text --><br data-reactid="1364"/><code class="sql hljs" data-reactid="1365"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`contacts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`contacts`</span>.<span class="hljs-string">`id`</span> <span class="hljs-keyword">and</span> <span class="hljs-string">`contacts`</span>.<span class="hljs-string">`id`</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">7</span>, <span class="hljs-number">15</span>, <span class="hljs-number">23</span>, <span class="hljs-number">41</span>)</code></pre></div><div id="Builder-onNotIn" data-reactid="1366"><b data-reactid="1367">onNotIn</b><!-- react-text: 1368 --> — <!-- /react-text --><code data-reactid="1369">.onNotIn(column, values)</code><p data-reactid="1370">Adds a onNotIn clause to the query.</p><pre class="display" data-reactid="1371"><code class="js hljs" data-reactid="1372">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).join(<span class="hljs-string">'contacts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'users.id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'contacts.id'</span>).onNotIn(<span class="hljs-string">'contacts.id'</span>, [<span class="hljs-number">7</span>, <span class="hljs-number">15</span>, <span class="hljs-number">23</span>, <span class="hljs-number">41</span>])
})</code><br data-reactid="1373"/><!-- react-text: 1374 -->Outputs:<!-- /react-text --><br data-reactid="1375"/><code class="sql hljs" data-reactid="1376"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`contacts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`contacts`</span>.<span class="hljs-string">`id`</span> <span class="hljs-keyword">and</span> <span class="hljs-string">`contacts`</span>.<span class="hljs-string">`id`</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">7</span>, <span class="hljs-number">15</span>, <span class="hljs-number">23</span>, <span class="hljs-number">41</span>)</code></pre></div><div id="Builder-onNull" data-reactid="1377"><b data-reactid="1378">onNull</b><!-- react-text: 1379 --> — <!-- /react-text --><code data-reactid="1380">.onNull(column)</code><p data-reactid="1381">Adds a onNull clause to the query.</p><pre class="display" data-reactid="1382"><code class="js hljs" data-reactid="1383">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).join(<span class="hljs-string">'contacts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'users.id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'contacts.id'</span>).onNull(<span class="hljs-string">'contacts.email'</span>)
})</code><br data-reactid="1384"/><!-- react-text: 1385 -->Outputs:<!-- /react-text --><br data-reactid="1386"/><code class="sql hljs" data-reactid="1387"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`contacts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`contacts`</span>.<span class="hljs-string">`id`</span> <span class="hljs-keyword">and</span> <span class="hljs-string">`contacts`</span>.<span class="hljs-string">`email`</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span></code></pre></div><div id="Builder-onNotNull" data-reactid="1388"><b data-reactid="1389">onNotNull</b><!-- react-text: 1390 --> — <!-- /react-text --><code data-reactid="1391">.onNotNull(column)</code><p data-reactid="1392">Adds a onNotNull clause to the query.</p><pre class="display" data-reactid="1393"><code class="js hljs" data-reactid="1394">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).join(<span class="hljs-string">'contacts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'users.id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'contacts.id'</span>).onNotNull(<span class="hljs-string">'contacts.email'</span>)
})</code><br data-reactid="1395"/><!-- react-text: 1396 -->Outputs:<!-- /react-text --><br data-reactid="1397"/><code class="sql hljs" data-reactid="1398"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`contacts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`contacts`</span>.<span class="hljs-string">`id`</span> <span class="hljs-keyword">and</span> <span class="hljs-string">`contacts`</span>.<span class="hljs-string">`email`</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span></code></pre></div><div id="Builder-onExists" data-reactid="1399"><b data-reactid="1400">onExists</b><!-- react-text: 1401 --> — <!-- /react-text --><code data-reactid="1402">.onExists(builder | callback)</code><p data-reactid="1403">Adds a onExists clause to the query.</p><pre class="display" data-reactid="1404"><code class="js hljs" data-reactid="1405">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).join(<span class="hljs-string">'contacts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'users.id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'contacts.id'</span>).onExists(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'accounts'</span>).whereRaw(<span class="hljs-string">'users.account_id = accounts.id'</span>);
  })
})</code><br data-reactid="1406"/><!-- react-text: 1407 -->Outputs:<!-- /react-text --><br data-reactid="1408"/><code class="sql hljs" data-reactid="1409"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`contacts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`contacts`</span>.<span class="hljs-string">`id`</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">where</span> users.account_id = accounts.id)</code></pre></div><div id="Builder-onNotExists" data-reactid="1410"><b data-reactid="1411">onNotExists</b><!-- react-text: 1412 --> — <!-- /react-text --><code data-reactid="1413">.onNotExists(builder | callback)</code><p data-reactid="1414">Adds a onNotExists clause to the query.</p><pre class="display" data-reactid="1415"><code class="js hljs" data-reactid="1416">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).join(<span class="hljs-string">'contacts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'users.id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'contacts.id'</span>).onNotExists(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'accounts'</span>).whereRaw(<span class="hljs-string">'users.account_id = accounts.id'</span>);
  })
})</code><br data-reactid="1417"/><!-- react-text: 1418 -->Outputs:<!-- /react-text --><br data-reactid="1419"/><code class="sql hljs" data-reactid="1420"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`contacts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`contacts`</span>.<span class="hljs-string">`id`</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">where</span> users.account_id = accounts.id)</code></pre></div><div id="Builder-onBetween" data-reactid="1421"><b data-reactid="1422">onBetween</b><!-- react-text: 1423 --> — <!-- /react-text --><code data-reactid="1424">.onBetween(column, range)</code><p data-reactid="1425">Adds a onBetween clause to the query.</p><pre class="display" data-reactid="1426"><code class="js hljs" data-reactid="1427">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).join(<span class="hljs-string">'contacts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'users.id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'contacts.id'</span>).onBetween(<span class="hljs-string">'contacts.id'</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">30</span>])
})</code><br data-reactid="1428"/><!-- react-text: 1429 -->Outputs:<!-- /react-text --><br data-reactid="1430"/><code class="sql hljs" data-reactid="1431"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`contacts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`contacts`</span>.<span class="hljs-string">`id`</span> <span class="hljs-keyword">and</span> <span class="hljs-string">`contacts`</span>.<span class="hljs-string">`id`</span> <span class="hljs-keyword">between</span> <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> <span class="hljs-number">30</span></code></pre></div><div id="Builder-onNotBetween" data-reactid="1432"><b data-reactid="1433">onNotBetween</b><!-- react-text: 1434 --> — <!-- /react-text --><code data-reactid="1435">.onNotBetween(column, range)</code><p data-reactid="1436">Adds a onNotBetween clause to the query.</p><pre class="display" data-reactid="1437"><code class="js hljs" data-reactid="1438">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).join(<span class="hljs-string">'contacts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'users.id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'contacts.id'</span>).onNotBetween(<span class="hljs-string">'contacts.id'</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">30</span>])
})</code><br data-reactid="1439"/><!-- react-text: 1440 -->Outputs:<!-- /react-text --><br data-reactid="1441"/><code class="sql hljs" data-reactid="1442"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> <span class="hljs-string">`contacts`</span> <span class="hljs-keyword">on</span> <span class="hljs-string">`users`</span>.<span class="hljs-string">`id`</span> = <span class="hljs-string">`contacts`</span>.<span class="hljs-string">`id`</span> <span class="hljs-keyword">and</span> <span class="hljs-string">`contacts`</span>.<span class="hljs-string">`id`</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">between</span> <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> <span class="hljs-number">30</span></code></pre></div><h3 id="Builder-clear" data-reactid="1443">ClearClauses</h3><div id="Builder-clearSelect" data-reactid="1444"><b data-reactid="1445">clearSelect</b><!-- react-text: 1446 --> — <!-- /react-text --><code data-reactid="1447">.clearSelect()</code><p data-reactid="1448">Clears all select clauses from the query, excluding subqueries.</p><pre class="display" data-reactid="1449"><code class="js hljs" data-reactid="1450">knex.select(<span class="hljs-string">'email'</span>, <span class="hljs-string">'name'</span>).from(<span class="hljs-string">'users'</span>).clearSelect()</code><br data-reactid="1451"/><!-- react-text: 1452 -->Outputs:<!-- /react-text --><br data-reactid="1453"/><code class="sql hljs" data-reactid="1454"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre></div><div id="Builder-clearWhere" data-reactid="1455"><b data-reactid="1456">clearWhere</b><!-- react-text: 1457 --> — <!-- /react-text --><code data-reactid="1458">.clearWhere()</code><p data-reactid="1459">Clears all where clauses from the query, excluding subqueries.</p><pre class="display" data-reactid="1460"><code class="js hljs" data-reactid="1461">knex.select(<span class="hljs-string">'email'</span>, <span class="hljs-string">'name'</span>).from(<span class="hljs-string">'users'</span>).where(<span class="hljs-string">'id'</span>, <span class="hljs-number">1</span>).clearWhere()</code><br data-reactid="1462"/><!-- react-text: 1463 -->Outputs:<!-- /react-text --><br data-reactid="1464"/><code class="sql hljs" data-reactid="1465"><span class="hljs-keyword">select</span> <span class="hljs-string">`email`</span>, <span class="hljs-string">`name`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre></div><div id="Builder-clearOrder" data-reactid="1466"><b data-reactid="1467">clearOrder</b><!-- react-text: 1468 --> — <!-- /react-text --><code data-reactid="1469">.clearOrder()</code><p data-reactid="1470">Clears all order clauses from the query, excluding subqueries.</p><pre class="display" data-reactid="1471"><code class="js hljs" data-reactid="1472">knex.select().from(<span class="hljs-string">'users'</span>).orderBy(<span class="hljs-string">'name'</span>, <span class="hljs-string">'desc'</span>).clearOrder()</code><br data-reactid="1473"/><!-- react-text: 1474 -->Outputs:<!-- /react-text --><br data-reactid="1475"/><code class="sql hljs" data-reactid="1476"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre></div><div id="Builder-distinct" data-reactid="1477"><b data-reactid="1478">distinct</b><!-- react-text: 1479 --> — <!-- /react-text --><code data-reactid="1480">.distinct()</code><p data-reactid="1481">Sets a distinct clause on the query.</p><pre class="display" data-reactid="1482"><code class="js hljs" data-reactid="1483"><span class="hljs-comment">// select distinct 'first_name' from customers</span>
knex(<span class="hljs-string">'customers'</span>)
  .distinct(<span class="hljs-string">'first_name'</span>, <span class="hljs-string">'last_name'</span>)
  .select()</code><br data-reactid="1484"/><!-- react-text: 1485 -->Outputs:<!-- /react-text --><br data-reactid="1486"/><code class="sql hljs" data-reactid="1487"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> <span class="hljs-string">`first_name`</span>, <span class="hljs-string">`last_name`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`customers`</span></code></pre></div><div id="Builder-groupBy" data-reactid="1488"><b data-reactid="1489">groupBy</b><!-- react-text: 1490 --> — <!-- /react-text --><code data-reactid="1491">.groupBy(*names)</code><p data-reactid="1492">Adds a group by clause to the query.</p><pre class="display" data-reactid="1493"><code class="js hljs" data-reactid="1494">knex(<span class="hljs-string">'users'</span>).groupBy(<span class="hljs-string">'count'</span>)</code><br data-reactid="1495"/><!-- react-text: 1496 -->Outputs:<!-- /react-text --><br data-reactid="1497"/><code class="sql hljs" data-reactid="1498"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-string">`count`</span></code></pre></div><div id="Builder-groupByRaw" data-reactid="1499"><b data-reactid="1500">groupByRaw</b><!-- react-text: 1501 --> — <!-- /react-text --><code data-reactid="1502">.groupByRaw(sql)</code><p data-reactid="1503">Adds a raw group by clause to the query.</p><pre class="display" data-reactid="1504"><code class="js hljs" data-reactid="1505">knex.select(<span class="hljs-string">'year'</span>, knex.raw(<span class="hljs-string">'SUM(profit)'</span>)).from(<span class="hljs-string">'sales'</span>).groupByRaw(<span class="hljs-string">'year WITH ROLLUP'</span>)</code><br data-reactid="1506"/><!-- react-text: 1507 -->Outputs:<!-- /react-text --><br data-reactid="1508"/><code class="sql hljs" data-reactid="1509"><span class="hljs-keyword">select</span> <span class="hljs-string">`year`</span>, <span class="hljs-keyword">SUM</span>(profit) <span class="hljs-keyword">from</span> <span class="hljs-string">`sales`</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">year</span> <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span></code></pre></div><div id="Builder-orderBy" data-reactid="1510"><b data-reactid="1511">orderBy</b><!-- react-text: 1512 --> — <!-- /react-text --><code data-reactid="1513">.orderBy(column, [direction])</code><p data-reactid="1514">Adds an order by clause to the query. column can be string, or list mixed with string and object.</p><p data-reactid="1515">Single Column:</p><pre class="display" data-reactid="1516"><code class="js hljs" data-reactid="1517">knex(<span class="hljs-string">'users'</span>).orderBy(<span class="hljs-string">'email'</span>)</code><br data-reactid="1518"/><!-- react-text: 1519 -->Outputs:<!-- /react-text --><br data-reactid="1520"/><code class="sql hljs" data-reactid="1521"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-string">`email`</span> <span class="hljs-keyword">asc</span></code></pre><pre class="display" data-reactid="1522"><code class="js hljs" data-reactid="1523">knex(<span class="hljs-string">'users'</span>).orderBy(<span class="hljs-string">'name'</span>, <span class="hljs-string">'desc'</span>)</code><br data-reactid="1524"/><!-- react-text: 1525 -->Outputs:<!-- /react-text --><br data-reactid="1526"/><code class="sql hljs" data-reactid="1527"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-string">`name`</span> <span class="hljs-keyword">desc</span></code></pre><p data-reactid="1528">Multiple Columns:</p><pre class="display" data-reactid="1529"><code class="js hljs" data-reactid="1530">knex(<span class="hljs-string">'users'</span>).orderBy([<span class="hljs-string">'email'</span>, { <span class="hljs-attr">column</span>: <span class="hljs-string">'age'</span>, <span class="hljs-attr">order</span>: <span class="hljs-string">'desc'</span> }])</code><br data-reactid="1531"/><!-- react-text: 1532 -->Outputs:<!-- /react-text --><br data-reactid="1533"/><code class="sql hljs" data-reactid="1534"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-string">`email`</span> <span class="hljs-keyword">asc</span>, <span class="hljs-string">`age`</span> <span class="hljs-keyword">desc</span></code></pre><pre class="display" data-reactid="1535"><code class="js hljs" data-reactid="1536">knex(<span class="hljs-string">'users'</span>).orderBy([{ <span class="hljs-attr">column</span>: <span class="hljs-string">'email'</span> }, { <span class="hljs-attr">column</span>: <span class="hljs-string">'age'</span>, <span class="hljs-attr">order</span>: <span class="hljs-string">'desc'</span> }])</code><br data-reactid="1537"/><!-- react-text: 1538 -->Outputs:<!-- /react-text --><br data-reactid="1539"/><code class="sql hljs" data-reactid="1540"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-string">`email`</span> <span class="hljs-keyword">asc</span>, <span class="hljs-string">`age`</span> <span class="hljs-keyword">desc</span></code></pre></div><div id="Builder-orderByRaw" data-reactid="1541"><b data-reactid="1542">orderByRaw</b><!-- react-text: 1543 --> — <!-- /react-text --><code data-reactid="1544">.orderByRaw(sql)</code><p data-reactid="1545">Adds an order by raw clause to the query.</p><pre class="display" data-reactid="1546"><code class="js hljs" data-reactid="1547">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'table'</span>).orderByRaw(<span class="hljs-string">'col DESC NULLS LAST'</span>)</code><br data-reactid="1548"/><!-- react-text: 1549 -->Outputs:<!-- /react-text --><br data-reactid="1550"/><code class="sql hljs" data-reactid="1551"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`table`</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">col</span> <span class="hljs-keyword">DESC</span> <span class="hljs-keyword">NULLS</span> <span class="hljs-keyword">LAST</span></code></pre></div><h3 id="Builder-havings" data-reactid="1552">Having Clauses</h3><div id="Builder-having" data-reactid="1553"><b data-reactid="1554">having</b><!-- react-text: 1555 --> — <!-- /react-text --><code data-reactid="1556">.having(column, operator, value)</code><p data-reactid="1557">Adds a having clause to the query.</p><pre class="display" data-reactid="1558"><code class="js hljs" data-reactid="1559">knex(<span class="hljs-string">'users'</span>)
  .groupBy(<span class="hljs-string">'count'</span>)
  .orderBy(<span class="hljs-string">'name'</span>, <span class="hljs-string">'desc'</span>)
  .having(<span class="hljs-string">'count'</span>, <span class="hljs-string">'&gt;'</span>, <span class="hljs-number">100</span>)</code><br data-reactid="1560"/><!-- react-text: 1561 -->Outputs:<!-- /react-text --><br data-reactid="1562"/><code class="sql hljs" data-reactid="1563"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-string">`count`</span> <span class="hljs-keyword">having</span> <span class="hljs-string">`count`</span> &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-string">`name`</span> <span class="hljs-keyword">desc</span></code></pre></div><div id="Builder-havingIn" data-reactid="1564"><b data-reactid="1565">havingIn</b><!-- react-text: 1566 --> — <!-- /react-text --><code data-reactid="1567">.havingIn(column, values)</code><p data-reactid="1568">Adds a havingIn clause to the query.</p><pre class="display" data-reactid="1569"><code class="js hljs" data-reactid="1570">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).havingIn(<span class="hljs-string">'id'</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">17</span>])</code><br data-reactid="1571"/><!-- react-text: 1572 -->Outputs:<!-- /react-text --><br data-reactid="1573"/><code class="sql hljs" data-reactid="1574"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">having</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">17</span>)</code></pre></div><div id="Builder-havingNotIn" data-reactid="1575"><b data-reactid="1576">havingNotIn</b><!-- react-text: 1577 --> — <!-- /react-text --><code data-reactid="1578">.havingNotIn(column, values)</code><p data-reactid="1579">Adds a havingNotIn clause to the query.</p><pre class="display" data-reactid="1580"><code class="js hljs" data-reactid="1581">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).havingNotIn(<span class="hljs-string">'id'</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">17</span>])</code><br data-reactid="1582"/><!-- react-text: 1583 -->Outputs:<!-- /react-text --><br data-reactid="1584"/><code class="sql hljs" data-reactid="1585"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">having</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">17</span>)</code></pre></div><div id="Builder-havingNull" data-reactid="1586"><b data-reactid="1587">havingNull</b><!-- react-text: 1588 --> — <!-- /react-text --><code data-reactid="1589">.havingNull(column)</code><p data-reactid="1590">Adds a havingNull clause to the query.</p><pre class="display" data-reactid="1591"><code class="js hljs" data-reactid="1592">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).havingNull(<span class="hljs-string">'email'</span>)</code><br data-reactid="1593"/><!-- react-text: 1594 -->Outputs:<!-- /react-text --><br data-reactid="1595"/><code class="sql hljs" data-reactid="1596"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">having</span> <span class="hljs-string">`email`</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span></code></pre></div><div id="Builder-havingNotNull" data-reactid="1597"><b data-reactid="1598">havingNotNull</b><!-- react-text: 1599 --> — <!-- /react-text --><code data-reactid="1600">.havingNotNull(column)</code><p data-reactid="1601">Adds a havingNotNull clause to the query.</p><pre class="display" data-reactid="1602"><code class="js hljs" data-reactid="1603">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).havingNotNull(<span class="hljs-string">'email'</span>)</code><br data-reactid="1604"/><!-- react-text: 1605 -->Outputs:<!-- /react-text --><br data-reactid="1606"/><code class="sql hljs" data-reactid="1607"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">having</span> <span class="hljs-string">`email`</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span></code></pre></div><div id="Builder-havingExists" data-reactid="1608"><b data-reactid="1609">havingExists</b><!-- react-text: 1610 --> — <!-- /react-text --><code data-reactid="1611">.havingExists(builder | callback)</code><p data-reactid="1612">Adds a havingExists clause to the query.</p><pre class="display" data-reactid="1613"><code class="js hljs" data-reactid="1614">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).havingExists(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'accounts'</span>).whereRaw(<span class="hljs-string">'users.account_id = accounts.id'</span>);
})</code><br data-reactid="1615"/><!-- react-text: 1616 -->Outputs:<!-- /react-text --><br data-reactid="1617"/><code class="sql hljs" data-reactid="1618"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">having</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">where</span> users.account_id = accounts.id)</code></pre></div><div id="Builder-havingNotExists" data-reactid="1619"><b data-reactid="1620">havingNotExists</b><!-- react-text: 1621 --> — <!-- /react-text --><code data-reactid="1622">.havingNotExists(builder | callback)</code><p data-reactid="1623">Adds a havingNotExists clause to the query.</p><pre class="display" data-reactid="1624"><code class="js hljs" data-reactid="1625">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).havingNotExists(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'accounts'</span>).whereRaw(<span class="hljs-string">'users.account_id = accounts.id'</span>);
})</code><br data-reactid="1626"/><!-- react-text: 1627 -->Outputs:<!-- /react-text --><br data-reactid="1628"/><code class="sql hljs" data-reactid="1629"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">having</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">where</span> users.account_id = accounts.id)</code></pre></div><div id="Builder-havingBetween" data-reactid="1630"><b data-reactid="1631">havingBetween</b><!-- react-text: 1632 --> — <!-- /react-text --><code data-reactid="1633">.havingBetween(column, range)</code><p data-reactid="1634">Adds a havingBetween clause to the query.</p><pre class="display" data-reactid="1635"><code class="js hljs" data-reactid="1636">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).havingBetween(<span class="hljs-string">'id'</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>])</code><br data-reactid="1637"/><!-- react-text: 1638 -->Outputs:<!-- /react-text --><br data-reactid="1639"/><code class="sql hljs" data-reactid="1640"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">having</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">between</span> <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> <span class="hljs-number">10</span></code></pre></div><div id="Builder-havingNotBetween" data-reactid="1641"><b data-reactid="1642">havingNotBetween</b><!-- react-text: 1643 --> — <!-- /react-text --><code data-reactid="1644">.havingNotBetween(column, range)</code><p data-reactid="1645">Adds a havingNotBetween clause to the query.</p><pre class="display" data-reactid="1646"><code class="js hljs" data-reactid="1647">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).havingNotBetween(<span class="hljs-string">'id'</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>])</code><br data-reactid="1648"/><!-- react-text: 1649 -->Outputs:<!-- /react-text --><br data-reactid="1650"/><code class="sql hljs" data-reactid="1651"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">having</span> <span class="hljs-string">`id`</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">between</span> <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> <span class="hljs-number">10</span></code></pre></div><div id="Builder-havingRaw" data-reactid="1652"><b data-reactid="1653">havingRaw</b><!-- react-text: 1654 --> — <!-- /react-text --><code data-reactid="1655">.havingRaw(column, operator, value)</code><p data-reactid="1656">Adds a havingRaw clause to the query.</p><pre class="display" data-reactid="1657"><code class="js hljs" data-reactid="1658">knex(<span class="hljs-string">'users'</span>)
  .groupBy(<span class="hljs-string">'count'</span>)
  .orderBy(<span class="hljs-string">'name'</span>, <span class="hljs-string">'desc'</span>)
  .havingRaw(<span class="hljs-string">'count &gt; ?'</span>, [<span class="hljs-number">100</span>])</code><br data-reactid="1659"/><!-- react-text: 1660 -->Outputs:<!-- /react-text --><br data-reactid="1661"/><code class="sql hljs" data-reactid="1662"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-string">`count`</span> <span class="hljs-keyword">having</span> <span class="hljs-keyword">count</span> &gt; <span class="hljs-number">100</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-string">`name`</span> <span class="hljs-keyword">desc</span></code></pre></div><div id="Builder-offset" data-reactid="1663"><b data-reactid="1664">offset</b><!-- react-text: 1665 --> — <!-- /react-text --><code data-reactid="1666">.offset(value)</code><p data-reactid="1667">Adds an offset clause to the query.</p><pre class="display" data-reactid="1668"><code class="js hljs" data-reactid="1669">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).offset(<span class="hljs-number">10</span>)</code><br data-reactid="1670"/><!-- react-text: 1671 -->Outputs:<!-- /react-text --><br data-reactid="1672"/><code class="sql hljs" data-reactid="1673"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">18446744073709551615</span> <span class="hljs-keyword">offset</span> <span class="hljs-number">10</span></code></pre></div><div id="Builder-limit" data-reactid="1674"><b data-reactid="1675">limit</b><!-- react-text: 1676 --> — <!-- /react-text --><code data-reactid="1677">.limit(value)</code><p data-reactid="1678">Adds a limit clause to the query.</p><pre class="display" data-reactid="1679"><code class="js hljs" data-reactid="1680">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).limit(<span class="hljs-number">10</span>).offset(<span class="hljs-number">30</span>)</code><br data-reactid="1681"/><!-- react-text: 1682 -->Outputs:<!-- /react-text --><br data-reactid="1683"/><code class="sql hljs" data-reactid="1684"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">10</span> <span class="hljs-keyword">offset</span> <span class="hljs-number">30</span></code></pre></div><div id="Builder-union" data-reactid="1685"><b data-reactid="1686">union</b><!-- react-text: 1687 --> — <!-- /react-text --><code data-reactid="1688">.union([*queries], [wrap])</code><p data-reactid="1689">Creates a union query, taking an array or a list of callbacks, builders, or raw statements to build the union statement, with optional boolean wrap. If the <code>wrap</code> parameter is <code>true</code>, the queries will be individually wrapped in parentheses.</p><pre class="display" data-reactid="1690"><code class="js hljs" data-reactid="1691">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).whereNull(<span class="hljs-string">'last_name'</span>).union(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).whereNull(<span class="hljs-string">'first_name'</span>)
})</code><br data-reactid="1692"/><!-- react-text: 1693 -->Outputs:<!-- /react-text --><br data-reactid="1694"/><code class="sql hljs" data-reactid="1695"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`last_name`</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`first_name`</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span></code></pre><pre class="display" data-reactid="1696"><code class="js hljs" data-reactid="1697">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).whereNull(<span class="hljs-string">'last_name'</span>).union([
  knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).whereNull(<span class="hljs-string">'first_name'</span>)
])</code><br data-reactid="1698"/><!-- react-text: 1699 -->Outputs:<!-- /react-text --><br data-reactid="1700"/><code class="sql hljs" data-reactid="1701"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`last_name`</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`first_name`</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span></code></pre><pre class="display" data-reactid="1702"><code class="js hljs" data-reactid="1703">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).whereNull(<span class="hljs-string">'last_name'</span>).union(
  knex.raw(<span class="hljs-string">'select * from users where first_name is null'</span>),
  knex.raw(<span class="hljs-string">'select * from users where email is null'</span>)
)</code><br data-reactid="1704"/><!-- react-text: 1705 -->Outputs:<!-- /react-text --><br data-reactid="1706"/><code class="sql hljs" data-reactid="1707"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`last_name`</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">where</span> first_name <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">users</span> <span class="hljs-keyword">where</span> email <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span></code></pre></div><div id="Builder-unionAll" data-reactid="1708"><b data-reactid="1709">unionAll</b><!-- react-text: 1710 --> — <!-- /react-text --><code data-reactid="1711">.unionAll(query)</code><p data-reactid="1712">Creates a union all query, with the same method signature as the union method.</p><pre class="display" data-reactid="1713"><code class="js hljs" data-reactid="1714">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).whereNull(<span class="hljs-string">'last_name'</span>).unionAll(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).whereNull(<span class="hljs-string">'first_name'</span>);
})</code><br data-reactid="1715"/><!-- react-text: 1716 -->Outputs:<!-- /react-text --><br data-reactid="1717"/><code class="sql hljs" data-reactid="1718"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`last_name`</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">union</span> all <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`first_name`</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span></code></pre></div><div id="Builder-insert" data-reactid="1719"><b data-reactid="1720">insert</b><!-- react-text: 1721 --> — <!-- /react-text --><code data-reactid="1722">.insert(data, [returning])</code><p data-reactid="1723">Creates an insert query, taking either a hash of properties to be inserted into the row, or an array of inserts, to be executed as a single insert command. If returning array is passed e.g. [&#39;id&#39;, &#39;title&#39;], it resolves the promise / fulfills the callback with an array of all the added rows with specified columns. It&#39;s a shortcut for <a href="##Builder-returning">returning method</a></p><pre class="display" data-reactid="1724"><code class="js hljs" data-reactid="1725"><span class="hljs-comment">// Returns [1] in "mysql", "sqlite", "oracle"; [] in "postgresql" unless the 'returning' parameter is set.</span>
knex(<span class="hljs-string">'books'</span>).insert({<span class="hljs-attr">title</span>: <span class="hljs-string">'Slaughterhouse Five'</span>})</code><br data-reactid="1726"/><!-- react-text: 1727 -->Outputs:<!-- /react-text --><br data-reactid="1728"/><code class="sql hljs" data-reactid="1729"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">`books`</span> (<span class="hljs-string">`title`</span>) <span class="hljs-keyword">values</span> (<span class="hljs-string">'Slaughterhouse Five'</span>)</code></pre><pre class="display" data-reactid="1730"><code class="js hljs" data-reactid="1731"><span class="hljs-comment">// Normalizes for empty keys on multi-row insert:</span>
knex(<span class="hljs-string">'coords'</span>).insert([{<span class="hljs-attr">x</span>: <span class="hljs-number">20</span>}, {<span class="hljs-attr">y</span>: <span class="hljs-number">30</span>},  {<span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">20</span>}])</code><br data-reactid="1732"/><!-- react-text: 1733 -->Outputs:<!-- /react-text --><br data-reactid="1734"/><code class="sql hljs" data-reactid="1735"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">`coords`</span> (<span class="hljs-string">`x`</span>, <span class="hljs-string">`y`</span>) <span class="hljs-keyword">values</span> (<span class="hljs-number">20</span>, <span class="hljs-keyword">DEFAULT</span>), (<span class="hljs-keyword">DEFAULT</span>, <span class="hljs-number">30</span>), (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</code></pre><pre class="display" data-reactid="1736"><code class="js hljs" data-reactid="1737"><span class="hljs-comment">// Returns [2] in "mysql", "sqlite"; [2, 3] in "postgresql"</span>
knex.insert([{<span class="hljs-attr">title</span>: <span class="hljs-string">'Great Gatsby'</span>}, {<span class="hljs-attr">title</span>: <span class="hljs-string">'Fahrenheit 451'</span>}], [<span class="hljs-string">'id'</span>]).into(<span class="hljs-string">'books'</span>)</code><br data-reactid="1738"/><!-- react-text: 1739 -->Outputs:<!-- /react-text --><br data-reactid="1740"/><code class="sql hljs" data-reactid="1741"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">`books`</span> (<span class="hljs-string">`title`</span>) <span class="hljs-keyword">values</span> (<span class="hljs-string">'Great Gatsby'</span>), (<span class="hljs-string">'Fahrenheit 451'</span>)</code></pre></div><p data-reactid="1742">If one prefers that undefined keys are replaced with <code>NULL</code> instead of <code>DEFAULT</code> one may give <code>useNullAsDefault</code> configuration parameter in knex config.</p><pre data-reactid="1743"><code class="hljs js" data-reactid="1744"><span class="hljs-keyword">var</span> knex = <span class="hljs-built_in">require</span>(<span class="hljs-string">'knex'</span>)({
  <span class="hljs-attr">client</span>: <span class="hljs-string">'mysql'</span>,
  <span class="hljs-attr">connection</span>: {
    <span class="hljs-attr">host</span> : <span class="hljs-string">'127.0.0.1'</span>,
    <span class="hljs-attr">user</span> : <span class="hljs-string">'your_database_user'</span>,
    <span class="hljs-attr">password</span> : <span class="hljs-string">'your_database_password'</span>,
    <span class="hljs-attr">database</span> : <span class="hljs-string">'myapp_test'</span>
  },
  <span class="hljs-attr">useNullAsDefault</span>: <span class="hljs-literal">true</span>
});

knex(<span class="hljs-string">'coords'</span>).insert([{<span class="hljs-attr">x</span>: <span class="hljs-number">20</span>}, {<span class="hljs-attr">y</span>: <span class="hljs-number">30</span>}, {<span class="hljs-attr">x</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">20</span>}])
<span class="hljs-comment">// insert into `coords` (`x`, `y`) values (20, NULL), (NULL, 30), (10, 20)"</span></code></pre><div id="Builder-returning" data-reactid="1745"><b data-reactid="1746">returning</b><!-- react-text: 1747 --> — <!-- /react-text --><code data-reactid="1748">.returning(column) / .returning([column1, column2, ...])</code><p data-reactid="1749">Utilized by PostgreSQL, MSSQL, and Oracle databases, the &quot;returning&quot; method specifies which column should be returned by the insert and update methods. Passed column parameter may be a string or an array of strings. When an array of string is passed in, makes the SQL result to be reported as an array of values from the specified column. When passed in an array of strings, makes the SQL result be reported as an array of objects, each containing a single property for each of the specified columns. The returning method is is entirely unsupported on Amazon Redshift and has no support for multiple inserts on MySQL and SQLite.</p><pre class="display" data-reactid="1750"><code class="js hljs" data-reactid="1751"><span class="hljs-comment">// Returns [1]</span>
knex(<span class="hljs-string">'books'</span>)
  .returning(<span class="hljs-string">'id'</span>)
  .insert({<span class="hljs-attr">title</span>: <span class="hljs-string">'Slaughterhouse Five'</span>})</code><br data-reactid="1752"/><!-- react-text: 1753 -->Outputs:<!-- /react-text --><br data-reactid="1754"/><code class="sql hljs" data-reactid="1755"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">`books`</span> (<span class="hljs-string">`title`</span>) <span class="hljs-keyword">values</span> (<span class="hljs-string">'Slaughterhouse Five'</span>)</code></pre><pre class="display" data-reactid="1756"><code class="js hljs" data-reactid="1757"><span class="hljs-comment">// Returns [2] in "mysql", "sqlite"; [2, 3] in "postgresql"</span>
knex(<span class="hljs-string">'books'</span>)
  .returning(<span class="hljs-string">'id'</span>)
  .insert([{<span class="hljs-attr">title</span>: <span class="hljs-string">'Great Gatsby'</span>}, {<span class="hljs-attr">title</span>: <span class="hljs-string">'Fahrenheit 451'</span>}])</code><br data-reactid="1758"/><!-- react-text: 1759 -->Outputs:<!-- /react-text --><br data-reactid="1760"/><code class="sql hljs" data-reactid="1761"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">`books`</span> (<span class="hljs-string">`title`</span>) <span class="hljs-keyword">values</span> (<span class="hljs-string">'Great Gatsby'</span>), (<span class="hljs-string">'Fahrenheit 451'</span>)</code></pre><pre class="display" data-reactid="1762"><code class="js hljs" data-reactid="1763"><span class="hljs-comment">// Returns [ { id: 1, title: 'Slaughterhouse Five' } ]</span>
knex(<span class="hljs-string">'books'</span>)
  .returning([<span class="hljs-string">'id'</span>,<span class="hljs-string">'title'</span>])
  .insert({<span class="hljs-attr">title</span>: <span class="hljs-string">'Slaughterhouse Five'</span>})</code><br data-reactid="1764"/><!-- react-text: 1765 -->Outputs:<!-- /react-text --><br data-reactid="1766"/><code class="sql hljs" data-reactid="1767"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-string">`books`</span> (<span class="hljs-string">`title`</span>) <span class="hljs-keyword">values</span> (<span class="hljs-string">'Slaughterhouse Five'</span>)</code></pre></div><div id="Builder-update" data-reactid="1768"><b data-reactid="1769">update</b><!-- react-text: 1770 --> — <!-- /react-text --><code data-reactid="1771">.update(data, [returning]) / .update(key, value, [returning])</code><p data-reactid="1772">Creates an update query, taking a hash of properties or a key/value pair to be updated based on the other query constraints. If returning array is passed e.g. [&#39;id&#39;, &#39;title&#39;], it resolves the promise / fulfills the callback with an array of all the updated rows with specified columns. It&#39;s a shortcut for <a href="##Builder-returning">returning method</a></p><pre class="display" data-reactid="1773"><code class="js hljs" data-reactid="1774">knex(<span class="hljs-string">'books'</span>)
  .where(<span class="hljs-string">'published_date'</span>, <span class="hljs-string">'&lt;'</span>, <span class="hljs-number">2000</span>)
  .update({
    <span class="hljs-attr">status</span>: <span class="hljs-string">'archived'</span>,
    <span class="hljs-attr">thisKeyIsSkipped</span>: <span class="hljs-literal">undefined</span>
  })</code><br data-reactid="1775"/><!-- react-text: 1776 -->Outputs:<!-- /react-text --><br data-reactid="1777"/><code class="sql hljs" data-reactid="1778"><span class="hljs-keyword">update</span> <span class="hljs-string">`books`</span> <span class="hljs-keyword">set</span> <span class="hljs-string">`status`</span> = <span class="hljs-string">'archived'</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`published_date`</span> &lt; <span class="hljs-number">2000</span></code></pre><pre class="display" data-reactid="1779"><code class="js hljs" data-reactid="1780"><span class="hljs-comment">// Returns [1] in "mysql", "sqlite", "oracle"; [] in "postgresql" unless the 'returning' parameter is set.</span>
knex(<span class="hljs-string">'books'</span>).update(<span class="hljs-string">'title'</span>, <span class="hljs-string">'Slaughterhouse Five'</span>)</code><br data-reactid="1781"/><!-- react-text: 1782 -->Outputs:<!-- /react-text --><br data-reactid="1783"/><code class="sql hljs" data-reactid="1784"><span class="hljs-keyword">update</span> <span class="hljs-string">`books`</span> <span class="hljs-keyword">set</span> <span class="hljs-string">`title`</span> = <span class="hljs-string">'Slaughterhouse Five'</span></code></pre><pre class="display" data-reactid="1785"><code class="js hljs" data-reactid="1786"><span class="hljs-comment">// Returns [2] in "mysql", "sqlite"; [2, 3] in "postgresql"</span>
knex(<span class="hljs-string">'books'</span>)
  .where({ <span class="hljs-attr">id</span>: <span class="hljs-number">42</span> })
  .update({ <span class="hljs-attr">title</span>: <span class="hljs-string">'The Hitchhiker'</span>s Guide to the Galaxy<span class="hljs-string">' }, ['</span>id<span class="hljs-string">', '</span>title<span class="hljs-string">'])
  .then((updatedRows) =&gt; {
    // updatedRows === [{id: 42, title: '</span>The Hitchhiker<span class="hljs-string">'s Guide to the Galaxy'</span>}]
  })</code><br data-reactid="1787"/><!-- react-text: 1788 -->Error:<!-- /react-text --><br data-reactid="1789"/><code class="sql hljs" data-reactid="1790">Unexpected identifier</code></pre></div><div id="Builder-del / delete" data-reactid="1791"><b data-reactid="1792">del / delete</b><!-- react-text: 1793 --> — <!-- /react-text --><code data-reactid="1794">.del()</code><p data-reactid="1795">Aliased to del as delete is a reserved word in JavaScript, this method deletes one or more rows, based on other conditions specified in the query. Resolves the promise / fulfills the callback with the number of affected rows for the query.</p><pre class="display" data-reactid="1796"><code class="js hljs" data-reactid="1797">knex(<span class="hljs-string">'accounts'</span>)
  .where(<span class="hljs-string">'activated'</span>, <span class="hljs-literal">false</span>)
  .del()</code><br data-reactid="1798"/><!-- react-text: 1799 -->Outputs:<!-- /react-text --><br data-reactid="1800"/><code class="sql hljs" data-reactid="1801"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`activated`</span> = <span class="hljs-literal">false</span></code></pre></div><div id="Builder-transacting" data-reactid="1802"><b data-reactid="1803">transacting</b><!-- react-text: 1804 --> — <!-- /react-text --><code data-reactid="1805">.transacting(transactionObj)</code><p data-reactid="1806">Used by knex.transaction, the transacting method may be chained to any query and passed the object you wish to join the query as part of the transaction for.</p><pre data-reactid="1807"><code class="hljs js" data-reactid="1808"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Promise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bluebird'</span>);
knex.transaction(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">trx</span>) </span>{
  knex(<span class="hljs-string">'books'</span>).transacting(trx).insert({<span class="hljs-attr">name</span>: <span class="hljs-string">'Old Books'</span>})
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resp</span>) </span>{
      <span class="hljs-keyword">var</span> id = resp[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">return</span> someExternalMethod(id, trx);
    })
    .then(trx.commit)
    .catch(trx.rollback);
})
.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resp</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Transaction complete.'</span>);
})
.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
  <span class="hljs-built_in">console</span>.error(err);
});</code></pre></div><div id="Builder-forUpdate" data-reactid="1809"><b data-reactid="1810">forUpdate</b><!-- react-text: 1811 --> — <!-- /react-text --><code data-reactid="1812">.transacting(t).forUpdate()</code><p data-reactid="1813">Dynamically added after a transaction is specified, the forUpdate adds a FOR UPDATE in PostgreSQL and MySQL during a select statement. Not supported on Amazon Redshift due to lack of table locks.</p><pre class="display" data-reactid="1814"><code class="js hljs" data-reactid="1815">knex(<span class="hljs-string">'tableName'</span>)
  .transacting(trx)
  .forUpdate()
  .select(<span class="hljs-string">'*'</span>)</code><br data-reactid="1816"/><!-- react-text: 1817 -->Outputs:<!-- /react-text --><br data-reactid="1818"/><code class="sql hljs" data-reactid="1819"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`tableName`</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span></code></pre></div><div id="Builder-forShare" data-reactid="1820"><b data-reactid="1821">forShare</b><!-- react-text: 1822 --> — <!-- /react-text --><code data-reactid="1823">.transacting(t).forShare()</code><p data-reactid="1824">Dynamically added after a transaction is specified, the forShare adds a FOR SHARE in PostgreSQL and a LOCK IN SHARE MODE for MySQL during a select statement. Not supported on Amazon Redshift due to lack of table locks.</p><pre class="display" data-reactid="1825"><code class="js hljs" data-reactid="1826">knex(<span class="hljs-string">'tableName'</span>)
  .transacting(trx)
  .forShare()
  .select(<span class="hljs-string">'*'</span>)</code><br data-reactid="1827"/><!-- react-text: 1828 -->Outputs:<!-- /react-text --><br data-reactid="1829"/><code class="sql hljs" data-reactid="1830"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`tableName`</span> <span class="hljs-keyword">lock</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">share</span> <span class="hljs-keyword">mode</span></code></pre></div><div id="Builder-count" data-reactid="1831"><b data-reactid="1832">count</b><!-- react-text: 1833 --> — <!-- /react-text --><code data-reactid="1834">.count(column|columns|raw)</code><p data-reactid="1835">Performs a count on the specified column or array of columns (note that some drivers do not support multiple columns). Also accepts raw expressions. Note that in Postgres, count returns a bigint type which will be a String and not a Number (more info).</p><pre class="display" data-reactid="1836"><code class="js hljs" data-reactid="1837">knex(<span class="hljs-string">'users'</span>).count(<span class="hljs-string">'active'</span>)</code><br data-reactid="1838"/><!-- react-text: 1839 -->Outputs:<!-- /react-text --><br data-reactid="1840"/><code class="sql hljs" data-reactid="1841"><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(<span class="hljs-string">`active`</span>) <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1842"><code class="js hljs" data-reactid="1843">knex(<span class="hljs-string">'users'</span>).count(<span class="hljs-string">'active as a'</span>)</code><br data-reactid="1844"/><!-- react-text: 1845 -->Outputs:<!-- /react-text --><br data-reactid="1846"/><code class="sql hljs" data-reactid="1847"><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(<span class="hljs-string">`active`</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">`a`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1848"><code class="js hljs" data-reactid="1849">knex(<span class="hljs-string">'users'</span>).count({ <span class="hljs-attr">a</span>: <span class="hljs-string">'active'</span> })</code><br data-reactid="1850"/><!-- react-text: 1851 -->Outputs:<!-- /react-text --><br data-reactid="1852"/><code class="sql hljs" data-reactid="1853"><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(<span class="hljs-string">`active`</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">`a`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1854"><code class="js hljs" data-reactid="1855">knex(<span class="hljs-string">'users'</span>).count(<span class="hljs-string">'id'</span>, <span class="hljs-string">'active'</span>)</code><br data-reactid="1856"/><!-- react-text: 1857 -->Outputs:<!-- /react-text --><br data-reactid="1858"/><code class="sql hljs" data-reactid="1859"><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(<span class="hljs-string">`id`</span>) <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1860"><code class="js hljs" data-reactid="1861">knex(<span class="hljs-string">'users'</span>).count({ <span class="hljs-attr">count</span>: [<span class="hljs-string">'id'</span>, <span class="hljs-string">'active'</span>] })</code><br data-reactid="1862"/><!-- react-text: 1863 -->Outputs:<!-- /react-text --><br data-reactid="1864"/><code class="sql hljs" data-reactid="1865"><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(<span class="hljs-string">`id`</span>, <span class="hljs-string">`active`</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">`count`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1866"><code class="js hljs" data-reactid="1867">knex(<span class="hljs-string">'users'</span>).count(knex.raw(<span class="hljs-string">'??'</span>, [<span class="hljs-string">'active'</span>]))</code><br data-reactid="1868"/><!-- react-text: 1869 -->Outputs:<!-- /react-text --><br data-reactid="1870"/><code class="sql hljs" data-reactid="1871"><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(<span class="hljs-string">`active`</span>) <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre></div><p data-reactid="1872">Use <strong>countDistinct</strong> to add a distinct expression inside the aggregate function.</p><pre class="display" data-reactid="1873"><code class="js hljs" data-reactid="1874">knex(<span class="hljs-string">'users'</span>).countDistinct(<span class="hljs-string">'active'</span>)</code><br data-reactid="1875"/><!-- react-text: 1876 -->Outputs:<!-- /react-text --><br data-reactid="1877"/><code class="sql hljs" data-reactid="1878"><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-string">`active`</span>) <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><div id="Builder-min" data-reactid="1879"><b data-reactid="1880">min</b><!-- react-text: 1881 --> — <!-- /react-text --><code data-reactid="1882">.min(column|columns|raw)</code><p data-reactid="1883">Gets the minimum value for the specified column or array of columns (note that some drivers do not support multiple columns). Also accepts raw expressions.</p><pre class="display" data-reactid="1884"><code class="js hljs" data-reactid="1885">knex(<span class="hljs-string">'users'</span>).min(<span class="hljs-string">'age'</span>)</code><br data-reactid="1886"/><!-- react-text: 1887 -->Outputs:<!-- /react-text --><br data-reactid="1888"/><code class="sql hljs" data-reactid="1889"><span class="hljs-keyword">select</span> <span class="hljs-keyword">min</span>(<span class="hljs-string">`age`</span>) <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1890"><code class="js hljs" data-reactid="1891">knex(<span class="hljs-string">'users'</span>).min(<span class="hljs-string">'age as a'</span>)</code><br data-reactid="1892"/><!-- react-text: 1893 -->Outputs:<!-- /react-text --><br data-reactid="1894"/><code class="sql hljs" data-reactid="1895"><span class="hljs-keyword">select</span> <span class="hljs-keyword">min</span>(<span class="hljs-string">`age`</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">`a`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1896"><code class="js hljs" data-reactid="1897">knex(<span class="hljs-string">'users'</span>).min({ <span class="hljs-attr">a</span>: <span class="hljs-string">'age'</span> })</code><br data-reactid="1898"/><!-- react-text: 1899 -->Outputs:<!-- /react-text --><br data-reactid="1900"/><code class="sql hljs" data-reactid="1901"><span class="hljs-keyword">select</span> <span class="hljs-keyword">min</span>(<span class="hljs-string">`age`</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">`a`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1902"><code class="js hljs" data-reactid="1903">knex(<span class="hljs-string">'users'</span>).min(<span class="hljs-string">'age'</span>, <span class="hljs-string">'logins'</span>)</code><br data-reactid="1904"/><!-- react-text: 1905 -->Outputs:<!-- /react-text --><br data-reactid="1906"/><code class="sql hljs" data-reactid="1907"><span class="hljs-keyword">select</span> <span class="hljs-keyword">min</span>(<span class="hljs-string">`age`</span>) <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1908"><code class="js hljs" data-reactid="1909">knex(<span class="hljs-string">'users'</span>).min({ <span class="hljs-attr">min</span>: [<span class="hljs-string">'age'</span>, <span class="hljs-string">'logins'</span>] })</code><br data-reactid="1910"/><!-- react-text: 1911 -->Outputs:<!-- /react-text --><br data-reactid="1912"/><code class="sql hljs" data-reactid="1913"><span class="hljs-keyword">select</span> <span class="hljs-keyword">min</span>(<span class="hljs-string">`age`</span>, <span class="hljs-string">`logins`</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">`min`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1914"><code class="js hljs" data-reactid="1915">knex(<span class="hljs-string">'users'</span>).min(knex.raw(<span class="hljs-string">'??'</span>, [<span class="hljs-string">'age'</span>]))</code><br data-reactid="1916"/><!-- react-text: 1917 -->Outputs:<!-- /react-text --><br data-reactid="1918"/><code class="sql hljs" data-reactid="1919"><span class="hljs-keyword">select</span> <span class="hljs-keyword">min</span>(<span class="hljs-string">`age`</span>) <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre></div><div id="Builder-max" data-reactid="1920"><b data-reactid="1921">max</b><!-- react-text: 1922 --> — <!-- /react-text --><code data-reactid="1923">.max(column|columns|raw)</code><p data-reactid="1924">Gets the maximum value for the specified column or array of columns (note that some drivers do not support multiple columns). Also accepts raw expressions.</p><pre class="display" data-reactid="1925"><code class="js hljs" data-reactid="1926">knex(<span class="hljs-string">'users'</span>).max(<span class="hljs-string">'age'</span>)</code><br data-reactid="1927"/><!-- react-text: 1928 -->Outputs:<!-- /react-text --><br data-reactid="1929"/><code class="sql hljs" data-reactid="1930"><span class="hljs-keyword">select</span> <span class="hljs-keyword">max</span>(<span class="hljs-string">`age`</span>) <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1931"><code class="js hljs" data-reactid="1932">knex(<span class="hljs-string">'users'</span>).max(<span class="hljs-string">'age as a'</span>)</code><br data-reactid="1933"/><!-- react-text: 1934 -->Outputs:<!-- /react-text --><br data-reactid="1935"/><code class="sql hljs" data-reactid="1936"><span class="hljs-keyword">select</span> <span class="hljs-keyword">max</span>(<span class="hljs-string">`age`</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">`a`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1937"><code class="js hljs" data-reactid="1938">knex(<span class="hljs-string">'users'</span>).max({ <span class="hljs-attr">a</span>: <span class="hljs-string">'age'</span> })</code><br data-reactid="1939"/><!-- react-text: 1940 -->Outputs:<!-- /react-text --><br data-reactid="1941"/><code class="sql hljs" data-reactid="1942"><span class="hljs-keyword">select</span> <span class="hljs-keyword">max</span>(<span class="hljs-string">`age`</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">`a`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1943"><code class="js hljs" data-reactid="1944">knex(<span class="hljs-string">'users'</span>).max(<span class="hljs-string">'age'</span>, <span class="hljs-string">'logins'</span>)</code><br data-reactid="1945"/><!-- react-text: 1946 -->Outputs:<!-- /react-text --><br data-reactid="1947"/><code class="sql hljs" data-reactid="1948"><span class="hljs-keyword">select</span> <span class="hljs-keyword">max</span>(<span class="hljs-string">`age`</span>) <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1949"><code class="js hljs" data-reactid="1950">knex(<span class="hljs-string">'users'</span>).max({ <span class="hljs-attr">max</span>: [<span class="hljs-string">'age'</span>, <span class="hljs-string">'logins'</span>] })</code><br data-reactid="1951"/><!-- react-text: 1952 -->Outputs:<!-- /react-text --><br data-reactid="1953"/><code class="sql hljs" data-reactid="1954"><span class="hljs-keyword">select</span> <span class="hljs-keyword">max</span>(<span class="hljs-string">`age`</span>, <span class="hljs-string">`logins`</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">`max`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1955"><code class="js hljs" data-reactid="1956">knex(<span class="hljs-string">'users'</span>).max(knex.raw(<span class="hljs-string">'??'</span>, [<span class="hljs-string">'age'</span>]))</code><br data-reactid="1957"/><!-- react-text: 1958 -->Outputs:<!-- /react-text --><br data-reactid="1959"/><code class="sql hljs" data-reactid="1960"><span class="hljs-keyword">select</span> <span class="hljs-keyword">max</span>(<span class="hljs-string">`age`</span>) <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre></div><div id="Builder-sum" data-reactid="1961"><b data-reactid="1962">sum</b><!-- react-text: 1963 --> — <!-- /react-text --><code data-reactid="1964">.sum(column|columns|raw)</code><p data-reactid="1965">Retrieve the sum of the values of a given column or array of columns (note that some drivers do not support multiple columns). Also accepts raw expressions.</p><pre class="display" data-reactid="1966"><code class="js hljs" data-reactid="1967">knex(<span class="hljs-string">'users'</span>).sum(<span class="hljs-string">'products'</span>)</code><br data-reactid="1968"/><!-- react-text: 1969 -->Outputs:<!-- /react-text --><br data-reactid="1970"/><code class="sql hljs" data-reactid="1971"><span class="hljs-keyword">select</span> <span class="hljs-keyword">sum</span>(<span class="hljs-string">`products`</span>) <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1972"><code class="js hljs" data-reactid="1973">knex(<span class="hljs-string">'users'</span>).sum(<span class="hljs-string">'products as p'</span>)</code><br data-reactid="1974"/><!-- react-text: 1975 -->Outputs:<!-- /react-text --><br data-reactid="1976"/><code class="sql hljs" data-reactid="1977"><span class="hljs-keyword">select</span> <span class="hljs-keyword">sum</span>(<span class="hljs-string">`products`</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">`p`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1978"><code class="js hljs" data-reactid="1979">knex(<span class="hljs-string">'users'</span>).sum({ <span class="hljs-attr">p</span>: <span class="hljs-string">'products'</span> })</code><br data-reactid="1980"/><!-- react-text: 1981 -->Outputs:<!-- /react-text --><br data-reactid="1982"/><code class="sql hljs" data-reactid="1983"><span class="hljs-keyword">select</span> <span class="hljs-keyword">sum</span>(<span class="hljs-string">`products`</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">`p`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1984"><code class="js hljs" data-reactid="1985">knex(<span class="hljs-string">'users'</span>).sum(<span class="hljs-string">'products'</span>, <span class="hljs-string">'orders'</span>)</code><br data-reactid="1986"/><!-- react-text: 1987 -->Outputs:<!-- /react-text --><br data-reactid="1988"/><code class="sql hljs" data-reactid="1989"><span class="hljs-keyword">select</span> <span class="hljs-keyword">sum</span>(<span class="hljs-string">`products`</span>) <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1990"><code class="js hljs" data-reactid="1991">knex(<span class="hljs-string">'users'</span>).sum({ <span class="hljs-attr">sum</span>: [<span class="hljs-string">'products'</span>, <span class="hljs-string">'orders'</span>] })</code><br data-reactid="1992"/><!-- react-text: 1993 -->Outputs:<!-- /react-text --><br data-reactid="1994"/><code class="sql hljs" data-reactid="1995"><span class="hljs-keyword">select</span> <span class="hljs-keyword">sum</span>(<span class="hljs-string">`products`</span>, <span class="hljs-string">`orders`</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">`sum`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="1996"><code class="js hljs" data-reactid="1997">knex(<span class="hljs-string">'users'</span>).sum(knex.raw(<span class="hljs-string">'??'</span>, [<span class="hljs-string">'products'</span>]))</code><br data-reactid="1998"/><!-- react-text: 1999 -->Outputs:<!-- /react-text --><br data-reactid="2000"/><code class="sql hljs" data-reactid="2001"><span class="hljs-keyword">select</span> <span class="hljs-keyword">sum</span>(<span class="hljs-string">`products`</span>) <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre></div><p data-reactid="2002">Use <strong>sumDistinct</strong> to add a distinct expression inside the aggregate function.</p><pre class="display" data-reactid="2003"><code class="js hljs" data-reactid="2004">knex(<span class="hljs-string">'users'</span>).sumDistinct(<span class="hljs-string">'products'</span>)</code><br data-reactid="2005"/><!-- react-text: 2006 -->Outputs:<!-- /react-text --><br data-reactid="2007"/><code class="sql hljs" data-reactid="2008"><span class="hljs-keyword">select</span> <span class="hljs-keyword">sum</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-string">`products`</span>) <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><div id="Builder-avg" data-reactid="2009"><b data-reactid="2010">avg</b><!-- react-text: 2011 --> — <!-- /react-text --><code data-reactid="2012">.avg(column|columns|raw)</code><p data-reactid="2013">Retrieve the average of the values of a given column or array of columns (note that some drivers do not support multiple columns). Also accepts raw expressions.</p><pre class="display" data-reactid="2014"><code class="js hljs" data-reactid="2015">knex(<span class="hljs-string">'users'</span>).avg(<span class="hljs-string">'age'</span>)</code><br data-reactid="2016"/><!-- react-text: 2017 -->Outputs:<!-- /react-text --><br data-reactid="2018"/><code class="sql hljs" data-reactid="2019"><span class="hljs-keyword">select</span> <span class="hljs-keyword">avg</span>(<span class="hljs-string">`age`</span>) <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="2020"><code class="js hljs" data-reactid="2021">knex(<span class="hljs-string">'users'</span>).avg(<span class="hljs-string">'age as a'</span>)</code><br data-reactid="2022"/><!-- react-text: 2023 -->Outputs:<!-- /react-text --><br data-reactid="2024"/><code class="sql hljs" data-reactid="2025"><span class="hljs-keyword">select</span> <span class="hljs-keyword">avg</span>(<span class="hljs-string">`age`</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">`a`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="2026"><code class="js hljs" data-reactid="2027">knex(<span class="hljs-string">'users'</span>).avg({ <span class="hljs-attr">a</span>: <span class="hljs-string">'age'</span> })</code><br data-reactid="2028"/><!-- react-text: 2029 -->Outputs:<!-- /react-text --><br data-reactid="2030"/><code class="sql hljs" data-reactid="2031"><span class="hljs-keyword">select</span> <span class="hljs-keyword">avg</span>(<span class="hljs-string">`age`</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">`a`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="2032"><code class="js hljs" data-reactid="2033">knex(<span class="hljs-string">'users'</span>).avg(<span class="hljs-string">'age'</span>, <span class="hljs-string">'logins'</span>)</code><br data-reactid="2034"/><!-- react-text: 2035 -->Outputs:<!-- /react-text --><br data-reactid="2036"/><code class="sql hljs" data-reactid="2037"><span class="hljs-keyword">select</span> <span class="hljs-keyword">avg</span>(<span class="hljs-string">`age`</span>) <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="2038"><code class="js hljs" data-reactid="2039">knex(<span class="hljs-string">'users'</span>).avg({ <span class="hljs-attr">avg</span>: [<span class="hljs-string">'age'</span>, <span class="hljs-string">'logins'</span>] })</code><br data-reactid="2040"/><!-- react-text: 2041 -->Outputs:<!-- /react-text --><br data-reactid="2042"/><code class="sql hljs" data-reactid="2043"><span class="hljs-keyword">select</span> <span class="hljs-keyword">avg</span>(<span class="hljs-string">`age`</span>, <span class="hljs-string">`logins`</span>) <span class="hljs-keyword">as</span> <span class="hljs-string">`avg`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><pre class="display" data-reactid="2044"><code class="js hljs" data-reactid="2045">knex(<span class="hljs-string">'users'</span>).avg(knex.raw(<span class="hljs-string">'??'</span>, [<span class="hljs-string">'age'</span>]))</code><br data-reactid="2046"/><!-- react-text: 2047 -->Outputs:<!-- /react-text --><br data-reactid="2048"/><code class="sql hljs" data-reactid="2049"><span class="hljs-keyword">select</span> <span class="hljs-keyword">avg</span>(<span class="hljs-string">`age`</span>) <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre></div><p data-reactid="2050">Use <strong>avgDistinct</strong> to add a distinct expression inside the aggregate function.</p><pre class="display" data-reactid="2051"><code class="js hljs" data-reactid="2052">knex(<span class="hljs-string">'users'</span>).avgDistinct(<span class="hljs-string">'age'</span>)</code><br data-reactid="2053"/><!-- react-text: 2054 -->Outputs:<!-- /react-text --><br data-reactid="2055"/><code class="sql hljs" data-reactid="2056"><span class="hljs-keyword">select</span> <span class="hljs-keyword">avg</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-string">`age`</span>) <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre><div id="Builder-increment" data-reactid="2057"><b data-reactid="2058">increment</b><!-- react-text: 2059 --> — <!-- /react-text --><code data-reactid="2060">.increment(column, amount)</code><p data-reactid="2061">Increments a column value by the specified amount. Object syntax is supported for <code>column</code>.</p><pre class="display" data-reactid="2062"><code class="js hljs" data-reactid="2063">knex(<span class="hljs-string">'accounts'</span>)
  .where(<span class="hljs-string">'userid'</span>, <span class="hljs-string">'='</span>, <span class="hljs-number">1</span>)
  .increment(<span class="hljs-string">'balance'</span>, <span class="hljs-number">10</span>)</code><br data-reactid="2064"/><!-- react-text: 2065 -->Outputs:<!-- /react-text --><br data-reactid="2066"/><code class="sql hljs" data-reactid="2067"><span class="hljs-keyword">update</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">set</span> <span class="hljs-string">`balance`</span> = <span class="hljs-string">`balance`</span> + <span class="hljs-number">10</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`userid`</span> = <span class="hljs-number">1</span></code></pre><pre class="display" data-reactid="2068"><code class="js hljs" data-reactid="2069">knex(<span class="hljs-string">'accounts'</span>)
  .where(<span class="hljs-string">'id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-number">1</span>)
  .increment({
    <span class="hljs-attr">balance</span>: <span class="hljs-number">10</span>,
    <span class="hljs-attr">times</span>: <span class="hljs-number">1</span>,
  })</code><br data-reactid="2070"/><!-- react-text: 2071 -->Outputs:<!-- /react-text --><br data-reactid="2072"/><code class="sql hljs" data-reactid="2073"><span class="hljs-keyword">update</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">set</span> <span class="hljs-string">`balance`</span> = <span class="hljs-string">`balance`</span> + <span class="hljs-number">10</span>, <span class="hljs-string">`times`</span> = <span class="hljs-string">`times`</span> + <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`id`</span> = <span class="hljs-number">1</span></code></pre></div><div id="Builder-decrement" data-reactid="2074"><b data-reactid="2075">decrement</b><!-- react-text: 2076 --> — <!-- /react-text --><code data-reactid="2077">.decrement(column, amount)</code><p data-reactid="2078">Decrements a column value by the specified amount. Object syntax is supported for <code>column</code>.</p><pre class="display" data-reactid="2079"><code class="js hljs" data-reactid="2080">knex(<span class="hljs-string">'accounts'</span>).where(<span class="hljs-string">'userid'</span>, <span class="hljs-string">'='</span>, <span class="hljs-number">1</span>).decrement(<span class="hljs-string">'balance'</span>, <span class="hljs-number">5</span>)</code><br data-reactid="2081"/><!-- react-text: 2082 -->Outputs:<!-- /react-text --><br data-reactid="2083"/><code class="sql hljs" data-reactid="2084"><span class="hljs-keyword">update</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">set</span> <span class="hljs-string">`balance`</span> = <span class="hljs-string">`balance`</span> - <span class="hljs-number">5</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`userid`</span> = <span class="hljs-number">1</span></code></pre><pre class="display" data-reactid="2085"><code class="js hljs" data-reactid="2086">knex(<span class="hljs-string">'accounts'</span>)
  .where(<span class="hljs-string">'id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-number">1</span>)
  .decrement({
    <span class="hljs-attr">balance</span>: <span class="hljs-number">50</span>,
  })</code><br data-reactid="2087"/><!-- react-text: 2088 -->Outputs:<!-- /react-text --><br data-reactid="2089"/><code class="sql hljs" data-reactid="2090"><span class="hljs-keyword">update</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">set</span> <span class="hljs-string">`balance`</span> = <span class="hljs-string">`balance`</span> - <span class="hljs-number">50</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`id`</span> = <span class="hljs-number">1</span></code></pre></div><div id="Builder-clearCounters" data-reactid="2091"><b data-reactid="2092">clearCounters</b><!-- react-text: 2093 --> — <!-- /react-text --><code data-reactid="2094">.clearCounters()</code><p data-reactid="2095">Clears all increments/decrements clauses from the query.</p><pre class="display" data-reactid="2096"><code class="js hljs" data-reactid="2097">knex(<span class="hljs-string">'accounts'</span>)
  .where(<span class="hljs-string">'id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-number">1</span>)
  .update({ <span class="hljs-attr">email</span>: <span class="hljs-string">'foo@bar.com'</span> })
  .decrement({
    <span class="hljs-attr">balance</span>: <span class="hljs-number">50</span>,
  })
  .clearCounters()</code><br data-reactid="2098"/><!-- react-text: 2099 -->Outputs:<!-- /react-text --><br data-reactid="2100"/><code class="sql hljs" data-reactid="2101"><span class="hljs-keyword">update</span> <span class="hljs-string">`accounts`</span> <span class="hljs-keyword">set</span> <span class="hljs-string">`email`</span> = <span class="hljs-string">'foo@bar.com'</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`id`</span> = <span class="hljs-number">1</span></code></pre></div><div id="Builder-truncate" data-reactid="2102"><b data-reactid="2103">truncate</b><!-- react-text: 2104 --> — <!-- /react-text --><code data-reactid="2105">.truncate()</code><p data-reactid="2106">Truncates the current table.</p><pre class="display" data-reactid="2107"><code class="js hljs" data-reactid="2108">knex(<span class="hljs-string">'accounts'</span>).truncate()</code><br data-reactid="2109"/><!-- react-text: 2110 -->Outputs:<!-- /react-text --><br data-reactid="2111"/><code class="sql hljs" data-reactid="2112"><span class="hljs-keyword">truncate</span> <span class="hljs-string">`accounts`</span></code></pre></div><div id="Builder-pluck" data-reactid="2113"><b data-reactid="2114">pluck</b><!-- react-text: 2115 --> — <!-- /react-text --><code data-reactid="2116">.pluck(id)</code><p data-reactid="2117">This will pluck the specified column from each row in your results, yielding a promise which resolves to the array of values selected.</p><pre data-reactid="2118"><code class="hljs js" data-reactid="2119">knex.table(<span class="hljs-string">'users'</span>).pluck(<span class="hljs-string">'id'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ids</span>) </span>{ <span class="hljs-built_in">console</span>.log(ids); });</code></pre></div><div id="Builder-first" data-reactid="2120"><b data-reactid="2121">first</b><!-- react-text: 2122 --> — <!-- /react-text --><code data-reactid="2123">.first([columns])</code><p data-reactid="2124">Similar to select, but only retrieves &amp; resolves with the first record from the query.</p><pre data-reactid="2125"><code class="hljs js" data-reactid="2126">knex.table(<span class="hljs-string">'users'</span>).first(<span class="hljs-string">'id'</span>, <span class="hljs-string">'name'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">row</span>) </span>{ <span class="hljs-built_in">console</span>.log(row); });</code></pre></div><div id="Builder-clone" data-reactid="2127"><b data-reactid="2128">clone</b><!-- react-text: 2129 --> — <!-- /react-text --><code data-reactid="2130">.clone()</code><p data-reactid="2131">Clones the current query chain, useful for re-using partial query snippets in other queries without mutating the original.</p></div><div id="Builder-modify" data-reactid="2132"><b data-reactid="2133">modify</b><!-- react-text: 2134 --> — <!-- /react-text --><code data-reactid="2135">.modify(fn, *arguments)</code><p data-reactid="2136">Allows encapsulating and re-using query snippets and common behaviors as functions. The callback function should receive the query builder as its first argument, followed by the rest of the (optional) parameters passed to modify.</p><pre data-reactid="2137"><code class="hljs js" data-reactid="2138"><span class="hljs-keyword">var</span> withUserName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">queryBuilder, foreignKey</span>) </span>{
  queryBuilder.leftJoin(<span class="hljs-string">'users'</span>, foreignKey, <span class="hljs-string">'users.id'</span>).select(<span class="hljs-string">'users.user_name'</span>);
};
knex.table(<span class="hljs-string">'articles'</span>).select(<span class="hljs-string">'title'</span>, <span class="hljs-string">'body'</span>).modify(withUserName, <span class="hljs-string">'articles_user.id'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">article</span>) </span>{
  <span class="hljs-built_in">console</span>.log(article.user_name);
});</code></pre></div><div id="Builder-columnInfo" data-reactid="2139"><b data-reactid="2140">columnInfo</b><!-- react-text: 2141 --> — <!-- /react-text --><code data-reactid="2142">.columnInfo([columnName])</code><p data-reactid="2143">Returns an object with the column info about the current table, or an individual column if one is passed, returning an object with the following keys:*   <strong>defaultValue</strong>: the default value for the column*   <strong>type</strong>: the column type*   <strong>maxLength</strong>: the max length set for the column*   <strong>nullable</strong>: whether the column may be null</p><pre data-reactid="2144"><code class="hljs js" data-reactid="2145">knex(<span class="hljs-string">'users'</span>).columnInfo().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">info</span>) </span>{ <span class="hljs-comment">// ... });</span></code></pre></div><div id="Builder-debug" data-reactid="2146"><b data-reactid="2147">debug</b><!-- react-text: 2148 --> — <!-- /react-text --><code data-reactid="2149">.debug([enabled])</code><p data-reactid="2150">Overrides the global debug setting for the current query chain. If enabled is omitted, query debugging will be turned on.</p></div><div id="Builder-connection" data-reactid="2151"><b data-reactid="2152">connection</b><!-- react-text: 2153 --> — <!-- /react-text --><code data-reactid="2154">.connection(dbConnection)</code><p data-reactid="2155">The method sets the db connection to use for the query without using the connection pool. You should pass to it the same object that acquireConnection() for the corresponding driver returns</p><pre data-reactid="2156"><code class="hljs js" data-reactid="2157"><span class="hljs-keyword">const</span> Pool = <span class="hljs-built_in">require</span>(<span class="hljs-string">'pg-pool'</span>)
<span class="hljs-keyword">const</span> pool = <span class="hljs-keyword">new</span> Pool({ ... })
<span class="hljs-keyword">const</span> connection = <span class="hljs-keyword">await</span> pool.connect();
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> knex.connection(connection); <span class="hljs-comment">// knex here is a query builder with query already built</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// Process error</span>
  } <span class="hljs-keyword">finally</span> {
    connection.release();
  }</code></pre></div><div id="Builder-options" data-reactid="2158"><b data-reactid="2159">options</b><!-- react-text: 2160 --> — <!-- /react-text --><code data-reactid="2161">.options()</code><p data-reactid="2162">Allows for mixing in additional options as defined by database client specific libraries:</p><pre data-reactid="2163"><code class="hljs js" data-reactid="2164">knex(<span class="hljs-string">'accounts as a1'</span>)
  .leftJoin(<span class="hljs-string">'accounts as a2'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'a1.email'</span>, <span class="hljs-string">'&lt;&gt;'</span>, <span class="hljs-string">'a2.email'</span>);
  })
  .select([<span class="hljs-string">'a1.email'</span>, <span class="hljs-string">'a2.email'</span>])
  .where(knex.raw(<span class="hljs-string">'a1.id = 1'</span>))
  .options({ <span class="hljs-attr">nestTables</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">rowMode</span>: <span class="hljs-string">'array'</span> })
  .limit(<span class="hljs-number">2</span>)
  .then(...</code></pre></div><div id="Builder-queryContext" data-reactid="2165"><b data-reactid="2166">queryContext</b><!-- react-text: 2167 --> — <!-- /react-text --><code data-reactid="2168">.queryContext(context)</code><p data-reactid="2169">Allows for configuring a context to be passed to the <a href="#Installation-wrap-identifier">wrapIdentifier</a> and <a href="#Installation-post-process-response">postProcessResponse</a> hooks:</p><pre data-reactid="2170"><code class="hljs js" data-reactid="2171">knex(<span class="hljs-string">'accounts as a1'</span>)
  .queryContext({ <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> })
  .select([<span class="hljs-string">'a1.email'</span>, <span class="hljs-string">'a2.email'</span>])</code></pre><p data-reactid="2172">The context can be any kind of value and will be passed to the hooks without modification. However, note that <strong>objects will be shallow-cloned</strong> when a query builder instance is <a href="#Builder-clone">cloned</a>, which means that they will contain all the properties of the original object but will not be the same object reference. This allows modifying the context for the cloned query builder instance.</p><p data-reactid="2173">Calling <code>queryContext</code> with no arguments will return any context configured for the query builder instance.</p></div></div><div id="Transactions" data-reactid="2174"><h2 id="Transactions" data-reactid="2175">Transactions</h2><div data-reactid="2176"><p data-reactid="2177">Transactions are an important feature of relational databases, as they allow correct recovery from failures and keep a database consistent even in cases of system failure. All queries within a transaction are executed on the same database connection, and run the entire set of queries as a single unit of work. Any failure will mean the database will rollback any queries executed on that connection to the pre-transaction state.</p><p data-reactid="2178">Transactions are handled by passing a handler function into <code>knex.transaction</code>. The handler function accepts a single argument, an object which may be used in two ways:<ol>
<li>As the &quot;promise aware&quot; knex connection</li>
<li>As an object passed into a query with <a href="#Builder-transacting"></a>and eventually call commit or rollback.</li>
</ol>
Consider these two examples:</p></div><pre data-reactid="2179"><code class="hljs js" data-reactid="2180"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Promise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bluebird'</span>);

<span class="hljs-comment">// Using trx as a query builder:</span>
knex.transaction(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">trx</span>) </span>{

  <span class="hljs-keyword">var</span> books = [
    {<span class="hljs-attr">title</span>: <span class="hljs-string">'Canterbury Tales'</span>},
    {<span class="hljs-attr">title</span>: <span class="hljs-string">'Moby Dick'</span>},
    {<span class="hljs-attr">title</span>: <span class="hljs-string">'Hamlet'</span>}
  ];

  <span class="hljs-keyword">return</span> trx
    .insert({<span class="hljs-attr">name</span>: <span class="hljs-string">'Old Books'</span>}, <span class="hljs-string">'id'</span>)
    .into(<span class="hljs-string">'catalogues'</span>)
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ids</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.map(books, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">book</span>) </span>{
        book.catalogue_id = ids[<span class="hljs-number">0</span>];

        <span class="hljs-comment">// Some validation could take place here.</span>

        <span class="hljs-keyword">return</span> trx.insert(book).into(<span class="hljs-string">'books'</span>);
      });
    });
})
.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">inserts</span>) </span>{
  <span class="hljs-built_in">console</span>.log(inserts.length + <span class="hljs-string">' new books saved.'</span>);
})
.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
  <span class="hljs-comment">// If we get here, that means that neither the 'Old Books' catalogues insert,</span>
  <span class="hljs-comment">// nor any of the books inserts will have taken place.</span>
  <span class="hljs-built_in">console</span>.error(error);
});</code></pre><p data-reactid="2181">And then this example:</p><pre data-reactid="2182"><code class="hljs js" data-reactid="2183"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Promise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bluebird'</span>);

<span class="hljs-comment">// Using trx as a transaction object:</span>
knex.transaction(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">trx</span>) </span>{

  <span class="hljs-keyword">var</span> books = [
    {<span class="hljs-attr">title</span>: <span class="hljs-string">'Canterbury Tales'</span>},
    {<span class="hljs-attr">title</span>: <span class="hljs-string">'Moby Dick'</span>},
    {<span class="hljs-attr">title</span>: <span class="hljs-string">'Hamlet'</span>}
  ];

  knex.insert({<span class="hljs-attr">name</span>: <span class="hljs-string">'Old Books'</span>}, <span class="hljs-string">'id'</span>)
    .into(<span class="hljs-string">'catalogues'</span>)
    .transacting(trx)
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ids</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.map(books, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">book</span>) </span>{
        book.catalogue_id = ids[<span class="hljs-number">0</span>];

        <span class="hljs-comment">// Some validation could take place here.</span>

        <span class="hljs-keyword">return</span> knex.insert(book).into(<span class="hljs-string">'books'</span>).transacting(trx);
      });
    })
    .then(trx.commit)
    .catch(trx.rollback);
})
.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">inserts</span>) </span>{
  <span class="hljs-built_in">console</span>.log(inserts.length + <span class="hljs-string">' new books saved.'</span>);
})
.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
  <span class="hljs-comment">// If we get here, that means that neither the 'Old Books' catalogues insert,</span>
  <span class="hljs-comment">// nor any of the books inserts will have taken place.</span>
  <span class="hljs-built_in">console</span>.error(error);
});</code></pre><div data-reactid="2184"><p data-reactid="2185">Throwing an error directly from the transaction handler function automatically rolls back the transaction, same as returning a rejected promise.</p><p data-reactid="2186">Notice that if a promise is not returned within the handler, it is up to you to ensure <code>trx.commit</code>, or <code>trx.rollback</code> are called, otherwise the transaction connection will hang.</p><p data-reactid="2187">Calling <code>trx.rollback</code> will return a rejected Promise. If you don&#39;t pass any argument to <code>trx.rollback</code>, a generic <code>Error</code> object will be created and passed in to ensure the Promise always rejects with something.</p><p data-reactid="2188">Note that Amazon Redshift does not support savepoints in transactions.</p></div></div><div id="Schema" data-reactid="2189"><h2 id="Schema" data-reactid="2190">Schema Builder</h2><p data-reactid="2191">The <code>knex.schema</code> is a <strong>getter function</strong>, which returns a stateful object containing the query. Therefore be sure to obtain a new instance of the <code>knex.schema</code> for every query. These methods return <a href="http://knexjs.org/#Interfaces-Promises">promises</a>.</p><div id="Schema-withSchema" data-reactid="2192"><b data-reactid="2193">withSchema</b><!-- react-text: 2194 --> — <!-- /react-text --><code data-reactid="2195">knex.schema.withSchema([schemaName])</code><p data-reactid="2196">Specifies the schema to be used when using the schema-building commands.</p><pre class="display" data-reactid="2197"><code class="js hljs" data-reactid="2198">knex.schema.withSchema(<span class="hljs-string">'public'</span>).createTable(<span class="hljs-string">'users'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">table</span>) </span>{
  table.increments();
})</code><br data-reactid="2199"/><!-- react-text: 2200 -->Outputs:<!-- /react-text --><br data-reactid="2201"/><code class="sql hljs" data-reactid="2202"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">`public`</span>.<span class="hljs-string">`users`</span> (<span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span> auto_increment primary <span class="hljs-keyword">key</span>)</code></pre></div><div id="Schema-createTable" data-reactid="2203"><b data-reactid="2204">createTable</b><!-- react-text: 2205 --> — <!-- /react-text --><code data-reactid="2206">knex.schema.createTable(tableName, callback)</code><p data-reactid="2207">Creates a new table on the database, with a callback function to modify the table&#39;s structure, using the schema-building commands.</p><pre class="display" data-reactid="2208"><code class="js hljs" data-reactid="2209">knex.schema.createTable(<span class="hljs-string">'users'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">table</span>) </span>{
  table.increments();
  table.string(<span class="hljs-string">'name'</span>);
  table.timestamps();
})</code><br data-reactid="2210"/><!-- react-text: 2211 -->Outputs:<!-- /react-text --><br data-reactid="2212"/><code class="sql hljs" data-reactid="2213"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-string">`users`</span> (<span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span> auto_increment primary <span class="hljs-keyword">key</span>, <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>), <span class="hljs-string">`created_at`</span> datetime, <span class="hljs-string">`updated_at`</span> datetime)</code></pre></div><div id="Schema-renameTable" data-reactid="2214"><b data-reactid="2215">renameTable</b><!-- react-text: 2216 --> — <!-- /react-text --><code data-reactid="2217">knex.schema.renameTable(from, to)</code><p data-reactid="2218">Renames a table from a current tableName to another.</p><pre class="display" data-reactid="2219"><code class="js hljs" data-reactid="2220">knex.schema.renameTable(<span class="hljs-string">'users'</span>, <span class="hljs-string">'old_users'</span>)</code><br data-reactid="2221"/><!-- react-text: 2222 -->Outputs:<!-- /react-text --><br data-reactid="2223"/><code class="sql hljs" data-reactid="2224"><span class="hljs-keyword">rename</span> <span class="hljs-keyword">table</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">to</span> <span class="hljs-string">`old_users`</span></code></pre></div><div id="Schema-dropTable" data-reactid="2225"><b data-reactid="2226">dropTable</b><!-- react-text: 2227 --> — <!-- /react-text --><code data-reactid="2228">knex.schema.dropTable(tableName)</code><p data-reactid="2229">Drops a table, specified by tableName.</p><pre class="display" data-reactid="2230"><code class="js hljs" data-reactid="2231">knex.schema.dropTable(<span class="hljs-string">'users'</span>)</code><br data-reactid="2232"/><!-- react-text: 2233 -->Outputs:<!-- /react-text --><br data-reactid="2234"/><code class="sql hljs" data-reactid="2235"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> <span class="hljs-string">`users`</span></code></pre></div><div id="Schema-hasTable" data-reactid="2236"><b data-reactid="2237">hasTable</b><!-- react-text: 2238 --> — <!-- /react-text --><code data-reactid="2239">knex.schema.hasTable(tableName)</code><p data-reactid="2240">Checks for a table&#39;s existence by tableName, resolving with a boolean to signal if the table exists.</p><pre data-reactid="2241"><code class="hljs js" data-reactid="2242">knex.schema.hasTable(<span class="hljs-string">'users'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">exists</span>) </span>{
  <span class="hljs-keyword">if</span> (!exists) {
    <span class="hljs-keyword">return</span> knex.schema.createTable(<span class="hljs-string">'users'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t</span>) </span>{
      t.increments(<span class="hljs-string">'id'</span>).primary();
      t.string(<span class="hljs-string">'first_name'</span>, <span class="hljs-number">100</span>);
      t.string(<span class="hljs-string">'last_name'</span>, <span class="hljs-number">100</span>);
      t.text(<span class="hljs-string">'bio'</span>);
    });
  }
});</code></pre></div><div id="Schema-hasColumn" data-reactid="2243"><b data-reactid="2244">hasColumn</b><!-- react-text: 2245 --> — <!-- /react-text --><code data-reactid="2246">knex.schema.hasColumn(tableName, columnName)</code><p data-reactid="2247">Checks if a column exists in the current table, resolves the promise with a boolean, true if the column exists, false otherwise.</p></div><div id="Schema-dropTableIfExists" data-reactid="2248"><b data-reactid="2249">dropTableIfExists</b><!-- react-text: 2250 --> — <!-- /react-text --><code data-reactid="2251">knex.schema.dropTableIfExists(tableName)</code><p data-reactid="2252">Drops a table conditionally if the table exists, specified by tableName.</p><pre class="display" data-reactid="2253"><code class="js hljs" data-reactid="2254">knex.schema.dropTableIfExists(<span class="hljs-string">'users'</span>)</code><br data-reactid="2255"/><!-- react-text: 2256 -->Outputs:<!-- /react-text --><br data-reactid="2257"/><code class="sql hljs" data-reactid="2258"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> <span class="hljs-string">`users`</span></code></pre></div><div id="Schema-table" data-reactid="2259"><b data-reactid="2260">table</b><!-- react-text: 2261 --> — <!-- /react-text --><code data-reactid="2262">knex.schema.table(tableName, callback)</code><p data-reactid="2263">Chooses a database table, and then modifies the table, using the Schema Building functions inside of the callback.</p><pre class="display" data-reactid="2264"><code class="js hljs" data-reactid="2265">knex.schema.table(<span class="hljs-string">'users'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">table</span>) </span>{
  table.dropColumn(<span class="hljs-string">'name'</span>);
  table.string(<span class="hljs-string">'first_name'</span>);
  table.string(<span class="hljs-string">'last_name'</span>);
})</code><br data-reactid="2266"/><!-- react-text: 2267 -->Outputs:<!-- /react-text --><br data-reactid="2268"/><code class="sql hljs" data-reactid="2269"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">add</span> <span class="hljs-string">`first_name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>), <span class="hljs-keyword">add</span> <span class="hljs-string">`last_name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>);
<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">drop</span> <span class="hljs-string">`name`</span></code></pre></div><div id="Schema-raw" data-reactid="2270"><b data-reactid="2271">raw</b><!-- react-text: 2272 --> — <!-- /react-text --><code data-reactid="2273">knex.schema.raw(statement)</code><p data-reactid="2274">Run an arbitrary sql query in the schema builder chain.</p><pre class="display" data-reactid="2275"><code class="js hljs" data-reactid="2276">knex.schema.raw(<span class="hljs-string">"SET sql_mode='TRADITIONAL'"</span>)
  .table(<span class="hljs-string">'users'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">table</span>) </span>{
    table.dropColumn(<span class="hljs-string">'name'</span>);
    table.string(<span class="hljs-string">'first_name'</span>);
    table.string(<span class="hljs-string">'last_name'</span>);
  })</code><br data-reactid="2277"/><!-- react-text: 2278 -->Outputs:<!-- /react-text --><br data-reactid="2279"/><code class="sql hljs" data-reactid="2280"><span class="hljs-keyword">SET</span> sql_mode=<span class="hljs-string">'TRADITIONAL'</span>;
<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">add</span> <span class="hljs-string">`first_name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>), <span class="hljs-keyword">add</span> <span class="hljs-string">`last_name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>);
<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">drop</span> <span class="hljs-string">`name`</span></code></pre></div><div id="Schema-queryContext" data-reactid="2281"><b data-reactid="2282">queryContext</b><!-- react-text: 2283 --> — <!-- /react-text --><code data-reactid="2284">knex.schema.queryContext(context)</code><p data-reactid="2285">Allows configuring a context to be passed to the <a href="#Installation-wrap-identifier">wrapIdentifier</a> hook. The context can be any kind of value and will be passed to <code>wrapIdentifier</code> without modification.</p><pre data-reactid="2286"><code class="hljs js" data-reactid="2287">knex.schema.queryContext({ <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> })
  .table(<span class="hljs-string">'users'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">table</span>) </span>{
    table.string(<span class="hljs-string">'first_name'</span>);
    table.string(<span class="hljs-string">'last_name'</span>);
  })</code></pre><p data-reactid="2288">The context configured will be passed to <code>wrapIdentifier</code> for each identifier that needs to be formatted, including the table and column names. However, a different context can be set for the column names via <a href="#Schema-table-queryContext">table.queryContext</a>.</p><p data-reactid="2289">Calling <code>queryContext</code> with no arguments will return any context configured for the schema builder instance.</p></div><h3 id="Schema-Building" data-reactid="2290">Schema Building:</h3><div id="Schema-dropColumn" data-reactid="2291"><b data-reactid="2292">dropColumn</b><!-- react-text: 2293 --> — <!-- /react-text --><code data-reactid="2294">table.dropColumn(name)</code><p data-reactid="2295">Drops a column, specified by the column&#39;s name</p></div><div id="Schema-dropColumns" data-reactid="2296"><b data-reactid="2297">dropColumns</b><!-- react-text: 2298 --> — <!-- /react-text --><code data-reactid="2299">table.dropColumns(*columns)</code><p data-reactid="2300">Drops multiple columns, taking a variable number of column names.</p></div><div id="Schema-renameColumn" data-reactid="2301"><b data-reactid="2302">renameColumn</b><!-- react-text: 2303 --> — <!-- /react-text --><code data-reactid="2304">table.renameColumn(from, to)</code><p data-reactid="2305">Renames a column from one name to another.</p></div><div id="Schema-increments" data-reactid="2306"><b data-reactid="2307">increments</b><!-- react-text: 2308 --> — <!-- /react-text --><code data-reactid="2309">table.increments(name)</code><p data-reactid="2310">Adds an auto incrementing column. In PostgreSQL this is a serial; in Amazon Redshift an integer identity(1,1). This will be used as the primary key for the table. Also available is a bigIncrements if you wish to add a bigint incrementing number (in PostgreSQL bigserial).</p><pre data-reactid="2311"><code class="hljs js" data-reactid="2312"><span class="hljs-comment">// create table 'users' with a primary key using 'increments()'</span>
knex.schema.createTable(<span class="hljs-string">'users'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">table</span>) </span>{
  table.increments(<span class="hljs-string">'userId'</span>);
  table.string(<span class="hljs-string">'name'</span>);
});

<span class="hljs-comment">// reference the 'users' primary key in new table 'posts'</span>
knex.schema.createTable(<span class="hljs-string">'posts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">table</span>) </span>{
  table.integer(<span class="hljs-string">'author'</span>).unsigned().notNullable();
  table.string(<span class="hljs-string">'title'</span>, <span class="hljs-number">30</span>);
  table.string(<span class="hljs-string">'content'</span>);

  table.foreign(<span class="hljs-string">'author'</span>).references(<span class="hljs-string">'userId'</span>).inTable(<span class="hljs-string">'users'</span>);
});</code></pre></div><div id="Schema-integer" data-reactid="2313"><b data-reactid="2314">integer</b><!-- react-text: 2315 --> — <!-- /react-text --><code data-reactid="2316">table.integer(name)</code><p data-reactid="2317">Adds an integer column.</p></div><div id="Schema-bigInteger" data-reactid="2318"><b data-reactid="2319">bigInteger</b><!-- react-text: 2320 --> — <!-- /react-text --><code data-reactid="2321">table.bigInteger(name)</code><p data-reactid="2322">In MySQL or PostgreSQL, adds a bigint column, otherwise adds a normal integer. Note that bigint data is returned as a string in queries because JavaScript may be unable to parse them without loss of precision.</p></div><div id="Schema-text" data-reactid="2323"><b data-reactid="2324">text</b><!-- react-text: 2325 --> — <!-- /react-text --><code data-reactid="2326">table.text(name, [textType])</code><p data-reactid="2327">Adds a text column, with optional textType for MySql text datatype preference. textType may be mediumtext or longtext, otherwise defaults to text.</p></div><div id="Schema-string" data-reactid="2328"><b data-reactid="2329">string</b><!-- react-text: 2330 --> — <!-- /react-text --><code data-reactid="2331">table.string(name, [length])</code><p data-reactid="2332">Adds a string column, with optional length defaulting to 255.</p></div><div id="Schema-float" data-reactid="2333"><b data-reactid="2334">float</b><!-- react-text: 2335 --> — <!-- /react-text --><code data-reactid="2336">table.float(column, [precision], [scale])</code><p data-reactid="2337">Adds a float column, with optional precision (defaults to 8) and scale (defaults to 2).</p></div><div id="Schema-decimal" data-reactid="2338"><b data-reactid="2339">decimal</b><!-- react-text: 2340 --> — <!-- /react-text --><code data-reactid="2341">table.decimal(column, [precision], [scale])</code><p data-reactid="2342">Adds a decimal column, with optional precision (defaults to 8) and scale (defaults to 2). Specifying NULL as precision creates a decimal column that can store numbers of any precision and scale. (Only supported for Oracle, SQLite, Postgres)</p></div><div id="Schema-boolean" data-reactid="2343"><b data-reactid="2344">boolean</b><!-- react-text: 2345 --> — <!-- /react-text --><code data-reactid="2346">table.boolean(name)</code><p data-reactid="2347">Adds a boolean column.</p></div><div id="Schema-date" data-reactid="2348"><b data-reactid="2349">date</b><!-- react-text: 2350 --> — <!-- /react-text --><code data-reactid="2351">table.date(name)</code><p data-reactid="2352">Adds a date column.</p></div><div id="Schema-datetime" data-reactid="2353"><b data-reactid="2354">datetime</b><!-- react-text: 2355 --> — <!-- /react-text --><code data-reactid="2356">table.datetime(name, [precision])</code><p data-reactid="2357">Adds a datetime column, with optional precision for MySQL.</p><p data-reactid="2358">In MySQL a precision argument may be passed as the second argument to specify precision:</p><pre data-reactid="2359"><code class="hljs js" data-reactid="2360">table.datetime(<span class="hljs-string">'some_time'</span>, <span class="hljs-number">6</span>).defaultTo(knex.fn.now(<span class="hljs-number">6</span>))</code></pre></div><div id="Schema-time" data-reactid="2361"><b data-reactid="2362">time</b><!-- react-text: 2363 --> — <!-- /react-text --><code data-reactid="2364">table.time(name, [precision])</code><p data-reactid="2365">Adds a time column, with optional precision for MySQL. Not supported on Amazon Redshift.</p><p data-reactid="2366">In MySQL a precision argument may be passed as the second argument to specify precision:</p><pre data-reactid="2367"><code class="hljs js" data-reactid="2368">table.time(<span class="hljs-string">'some_time'</span>, <span class="hljs-number">6</span>)</code></pre></div><div id="Schema-timestamp" data-reactid="2369"><b data-reactid="2370">timestamp</b><!-- react-text: 2371 --> — <!-- /react-text --><code data-reactid="2372">table.timestamp(name, [useTz], [precision])</code><p data-reactid="2373">Adds a timestamp column, defaulting to timestamptz in PostgreSQL unless true is passed as the second argument.</p><pre data-reactid="2374"><code class="hljs js" data-reactid="2375">table.timestamp(<span class="hljs-string">'created_at'</span>).defaultTo(knex.fn.now());</code></pre><p data-reactid="2376">In MySQL a precision argument may be passed as the second argument to specify precision:</p><pre data-reactid="2377"><code class="hljs js" data-reactid="2378">table.timestamp(<span class="hljs-string">'created_at'</span>, <span class="hljs-number">6</span>).defaultTo(knex.fn.now(<span class="hljs-number">6</span>));</code></pre><p data-reactid="2379">In MSSQL an option argument may be passed as the second argument to specify whether or not use timezone:</p><pre data-reactid="2380"><code class="hljs js" data-reactid="2381">table.timestamp(<span class="hljs-string">'created_at'</span>, { <span class="hljs-attr">useTz</span>: <span class="hljs-literal">true</span> });</code></pre></div><div id="Schema-timestamps" data-reactid="2382"><b data-reactid="2383">timestamps</b><!-- react-text: 2384 --> — <!-- /react-text --><code data-reactid="2385">table.timestamps([useTimestamps], [defaultToNow])</code><p data-reactid="2386">Adds created_at and updated_at columns on the database, setting each to datetime types. When true is passed as the first argument a timestamp type is used instead. Both colums default to being not null and using the current timestamp when true is passed as the second argument. Note that on MySQL the .timestamps() only have seconds precision, to get better precision use the .datetime or .timestamp methods directly with precision.</p></div><div id="Schema-dropTimestamps" data-reactid="2387"><b data-reactid="2388">dropTimestamps</b><!-- react-text: 2389 --> — <!-- /react-text --><code data-reactid="2390">table.dropTimestamps()</code><p data-reactid="2391">Drops the columns created_at and updated_at from the table, which can be created via timestamps.</p></div><div id="Schema-binary" data-reactid="2392"><b data-reactid="2393">binary</b><!-- react-text: 2394 --> — <!-- /react-text --><code data-reactid="2395">table.binary(name, [length])</code><p data-reactid="2396">Adds a binary column, with optional length argument for MySQL.</p></div><div id="Schema-enum" data-reactid="2397"><b data-reactid="2398">enum / enu</b><!-- react-text: 2399 --> — <!-- /react-text --><code data-reactid="2400">table.enu(col, values, [options])</code><p data-reactid="2401">Adds a enum column, (aliased to enu, as enum is a reserved word in JavaScript). Implemented as unchecked varchar(255) on Amazon Redshift. Note that the second argument is an array of values. Example:</p><pre data-reactid="2402"><code class="hljs js" data-reactid="2403">table.enu(<span class="hljs-string">'column'</span>, [<span class="hljs-string">'value1'</span>, <span class="hljs-string">'value2'</span>])</code></pre><p data-reactid="2404">For Postgres, an additional options argument can be provided to specify whether or not to use Postgres&#39;s native TYPE:</p><pre data-reactid="2405"><code class="hljs js" data-reactid="2406">table.enu(<span class="hljs-string">'column'</span>, [<span class="hljs-string">'value1'</span>, <span class="hljs-string">'value2'</span>], { <span class="hljs-attr">useNative</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">enumName</span>: <span class="hljs-string">'foo_type'</span> })</code></pre><p data-reactid="2407">It will use the values provided to generate the appropriate TYPE. Example:</p><pre data-reactid="2408"><code class="hljs sql" data-reactid="2409"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TYPE</span> <span class="hljs-string">"foo_type"</span> <span class="hljs-keyword">AS</span> ENUM (<span class="hljs-string">'value1'</span>, <span class="hljs-string">'value2'</span>);</code></pre><p data-reactid="2410">To use an existing native type across columns, specify &#39;existingType&#39; in the options (this assumes the type has already been created):</p><p class="info" data-reactid="2411">Note: Since the enum values aren&#39;t utilized for a native &amp;&amp; existing type, the type being passed in for values is immaterial.</p><pre data-reactid="2412"><code class="hljs js" data-reactid="2413">table.enu(<span class="hljs-string">'column'</span>, <span class="hljs-literal">null</span>, { <span class="hljs-attr">useNative</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">existingType</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">enumName</span>: <span class="hljs-string">'foo_type'</span> })</code></pre></div><div id="Schema-json" data-reactid="2414"><b data-reactid="2415">json</b><!-- react-text: 2416 --> — <!-- /react-text --><code data-reactid="2417">table.json(name)</code><p data-reactid="2418">Adds a json column, using the built-in json type in PostgreSQL, MySQL and SQLite, defaulting to a text column in older versions or in unsupported databases.</p><p data-reactid="2419">For PostgreSQL, due to incompatibility between native array and json types, when setting an array (or a value that could be an array) as the value of a json or jsonb column, you should use JSON.stringify() to convert your value to a string prior to passing it to the query builder, e.g.</p><pre data-reactid="2420"><code class="hljs js" data-reactid="2421">knex.table(<span class="hljs-string">'users'</span>)
  .where({<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>})
  .update({<span class="hljs-attr">json_data</span>: <span class="hljs-built_in">JSON</span>.stringify(mightBeAnArray)});</code></pre></div><div id="Schema-jsonb" data-reactid="2422"><b data-reactid="2423">jsonb</b><!-- react-text: 2424 --> — <!-- /react-text --><code data-reactid="2425">table.jsonb(name)</code><p data-reactid="2426">Adds a jsonb column. Works similar to table.json(), but uses native jsonb type if possible.</p></div><div id="Schema-uuid" data-reactid="2427"><b data-reactid="2428">uuid</b><!-- react-text: 2429 --> — <!-- /react-text --><code data-reactid="2430">table.uuid(name)</code><p data-reactid="2431">Adds a uuid column - this uses the built-in uuid type in PostgreSQL, and falling back to a char(36) in other databases.</p></div><div id="Schema-comment" data-reactid="2432"><b data-reactid="2433">comment</b><!-- react-text: 2434 --> — <!-- /react-text --><code data-reactid="2435">table.comment(value)</code><p data-reactid="2436">Sets the comment for a table.</p></div><div id="Schema-engine" data-reactid="2437"><b data-reactid="2438">engine</b><!-- react-text: 2439 --> — <!-- /react-text --><code data-reactid="2440">table.engine(val)</code><p data-reactid="2441">Sets the engine for the database table, only available within a createTable call, and only applicable to MySQL.</p></div><div id="Schema-charset" data-reactid="2442"><b data-reactid="2443">charset</b><!-- react-text: 2444 --> — <!-- /react-text --><code data-reactid="2445">table.charset(val)</code><p data-reactid="2446">Sets the charset for the database table, only available within a createTable call, and only applicable to MySQL.</p></div><div id="Schema-collate" data-reactid="2447"><b data-reactid="2448">collate</b><!-- react-text: 2449 --> — <!-- /react-text --><code data-reactid="2450">table.collate(val)</code><p data-reactid="2451">Sets the collation for the database table, only available within a createTable call, and only applicable to MySQL.</p></div><div id="Schema-inherits" data-reactid="2452"><b data-reactid="2453">inherits</b><!-- react-text: 2454 --> — <!-- /react-text --><code data-reactid="2455">table.inherits(val)</code><p data-reactid="2456">Sets the tables that this table inherits, only available within a createTable call, and only applicable to PostgreSQL.</p></div><div id="Schema-specificType" data-reactid="2457"><b data-reactid="2458">specificType</b><!-- react-text: 2459 --> — <!-- /react-text --><code data-reactid="2460">table.specificType(name, type)</code><p data-reactid="2461">Sets a specific type for the column creation, if you&#39;d like to add a column type that isn&#39;t supported here.</p></div><div id="Schema-index" data-reactid="2462"><b data-reactid="2463">index</b><!-- react-text: 2464 --> — <!-- /react-text --><code data-reactid="2465">table.index(columns, [indexName], [indexType])</code><p data-reactid="2466">Adds an index to a table over the given columns. A default index name using the columns is used unless indexName is specified. The indexType can be optionally specified for PostgreSQL and MySQL. Amazon Redshift does not allow creating an index.</p></div><div id="Schema-dropIndex" data-reactid="2467"><b data-reactid="2468">dropIndex</b><!-- react-text: 2469 --> — <!-- /react-text --><code data-reactid="2470">table.dropIndex(columns, [indexName])</code><p data-reactid="2471">Drops an index from a table. A default index name using the columns is used unless indexName is specified (in which case columns is ignored). Amazon Redshift does not allow creating an index.</p></div><div id="Schema-unique" data-reactid="2472"><b data-reactid="2473">unique</b><!-- react-text: 2474 --> — <!-- /react-text --><code data-reactid="2475">table.unique(columns, [indexName])</code><p data-reactid="2476">Adds an unique index to a table over the given <code>columns</code>. A default index name using the columns is used unless indexName is specified.</p><pre data-reactid="2477"><code class="hljs js" data-reactid="2478">knex.schema.alterTable(<span class="hljs-string">'users'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t</span>) </span>{
  t.unique(<span class="hljs-string">'email'</span>)
})
knex.schema.alterTable(<span class="hljs-string">'job'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">t</span>) </span>{
  t.unique([<span class="hljs-string">'account_id'</span>, <span class="hljs-string">'program_id'</span>])
})</code></pre></div><div id="Schema-foreign" data-reactid="2479"><b data-reactid="2480">foreign</b><!-- react-text: 2481 --> — <!-- /react-text --><code data-reactid="2482">table.foreign(columns, [foreignKeyName])[.onDelete(statement).onUpdate(statement).withKeyName(foreignKeyName)]</code><p data-reactid="2483">Adds a foreign key constraint to a table for an existing column using <code>table.foreign(column).references(column)</code> or multiple columns using <code>table.foreign(columns).references(columns).on(table)</code>. A default key name using the columns is used unless foreignKeyName is specified. You can also chain onDelete() and/or onUpdate() to set the reference option (RESTRICT, CASCADE, SET NULL, NO ACTION) for the operation. You can also chain withKeyName() to override default key name that is generated from table and column names (result is identical to specifying second parameter to function foreign()). Note that using foreign() is the same as column.references(column) but it works for existing columns.</p><pre data-reactid="2484"><code class="hljs js" data-reactid="2485">knex.schema.table(<span class="hljs-string">'users'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">table</span>) </span>{
  table.integer(<span class="hljs-string">'user_id'</span>).unsigned()
  table.foreign(<span class="hljs-string">'user_id'</span>).references(<span class="hljs-string">'Items.user_id_in_items'</span>)
})</code></pre></div><div id="Schema-dropForeign" data-reactid="2486"><b data-reactid="2487">dropForeign</b><!-- react-text: 2488 --> — <!-- /react-text --><code data-reactid="2489">table.dropForeign(columns, [foreignKeyName])</code><p data-reactid="2490">Drops a foreign key constraint from a table. A default foreign key name using the columns is used unless foreignKeyName is specified (in which case columns is ignored).</p></div><div id="Schema-dropUnique" data-reactid="2491"><b data-reactid="2492">dropUnique</b><!-- react-text: 2493 --> — <!-- /react-text --><code data-reactid="2494">table.dropUnique(columns, [indexName])</code><p data-reactid="2495">Drops a unique key constraint from a table. A default unique key name using the columns is used unless indexName is specified (in which case columns is ignored).</p></div><div id="Schema-dropPrimary" data-reactid="2496"><b data-reactid="2497">dropPrimary</b><!-- react-text: 2498 --> — <!-- /react-text --><code data-reactid="2499">table.dropPrimary([constraintName])</code><p data-reactid="2500">Drops the primary key constraint on a table. Defaults to tablename_pkey unless constraintName is specified.</p></div><div id="Schema-table-queryContext" data-reactid="2501"><b data-reactid="2502">queryContext</b><!-- react-text: 2503 --> — <!-- /react-text --><code data-reactid="2504">table.queryContext(context)</code><p data-reactid="2505">Allows configuring a context to be passed to the <a href="#Installation-wrap-identifier">wrapIdentifier</a> hook for formatting table builder identifiers. The context can be any kind of value and will be passed to <code>wrapIdentifier</code> without modification.</p><pre data-reactid="2506"><code class="hljs js" data-reactid="2507">knex.schema.table(<span class="hljs-string">'users'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">table</span>) </span>{
  table.queryContext({ <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> });
  table.string(<span class="hljs-string">'first_name'</span>);
  table.string(<span class="hljs-string">'last_name'</span>);
})</code></pre><p data-reactid="2508">This method also enables overwriting the context configured for a schema builder instance via <a href="#Schema-queryContext">schema.queryContext</a>:</p><pre data-reactid="2509"><code class="hljs js" data-reactid="2510">knex.schema.queryContext(<span class="hljs-string">'schema context'</span>)
  .table(<span class="hljs-string">'users'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">table</span>) </span>{
    table.queryContext(<span class="hljs-string">'table context'</span>);
    table.string(<span class="hljs-string">'first_name'</span>);
    table.string(<span class="hljs-string">'last_name'</span>);
})</code></pre><p data-reactid="2511">Note that it&#39;s also possible to overwrite the table builder context for any column in the table definition:</p><pre data-reactid="2512"><code class="hljs js" data-reactid="2513">knex.schema.queryContext(<span class="hljs-string">'schema context'</span>)
  .table(<span class="hljs-string">'users'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">table</span>) </span>{
    table.queryContext(<span class="hljs-string">'table context'</span>);
    table.string(<span class="hljs-string">'first_name'</span>).queryContext(<span class="hljs-string">'first_name context'</span>);
    table.string(<span class="hljs-string">'last_name'</span>).queryContext(<span class="hljs-string">'last_name context'</span>);
})</code></pre><p data-reactid="2514">Calling <code>queryContext</code> with no arguments will return any context configured for the table builder instance.</p></div><h3 id="Chainable" data-reactid="2515">Chainable Methods:</h3><p data-reactid="2516">The following three methods may be chained on the schema building methods, as modifiers to the column.</p><div id="Schema-alter" data-reactid="2517"><b data-reactid="2518">alter</b><!-- react-text: 2519 --> — <!-- /react-text --><code data-reactid="2520">column.alter()</code><p data-reactid="2521">Marks the column as an alter / modify, instead of the default add. Note: This only works in .alterTable() and is not supported by SQlite or Amazon Redshift. Alter is <em>not</em> done incrementally over older column type so if you like to add <code>notNull</code> and keep the old default value, the alter statement must contain both <code>.notNull().defaultTo(1).alter()</code>. If one just tries to add <code>.notNull().alter()</code> the old default value will be dropped.</p></div><pre data-reactid="2522"><code data-reactid="2523">knex.schema.alterTable('user', function(t) {
  t.increments().primary(); // add
  // drops previous default value from column, change type to string and add not nullable constraint
  t.string('username', 35).notNullable().alter();
  // drops both not null contraint and the default value
  t.integer('age').alter();
});</code></pre><div id="Schema-index" data-reactid="2524"><b data-reactid="2525">index</b><!-- react-text: 2526 --> — <!-- /react-text --><code data-reactid="2527">column.index([indexName], [indexType])</code><p data-reactid="2528">Specifies a field as an index. If an indexName is specified, it is used in place of the standard index naming convention of tableName_columnName. The indexType can be optionally specified for PostgreSQL and MySQL. No-op if this is chained off of a field that cannot be indexed.</p></div><div id="Schema-primary" data-reactid="2529"><b data-reactid="2530">primary</b><!-- react-text: 2531 --> — <!-- /react-text --><code data-reactid="2532">column.primary([constraintName]); table.primary(columns, [constraintName])</code><p data-reactid="2533"><pre><code>  When called on a single column it will set that column as the primary key for a table.
  If you need to create a composite primary key, call it on a table with an array of column names instead.
  Constraint name defaults to `tablename_pkey` unless `constraintName` is specified.
  On Amazon Redshift, all columns included in a primary key must be not nullable.</code></pre></p></div><div id="Schema-unique" data-reactid="2534"><b data-reactid="2535">unique</b><!-- react-text: 2536 --> — <!-- /react-text --><code data-reactid="2537">column.unique()</code><p data-reactid="2538">Sets the column as unique. On Amazon Redshift, this constraint is not enforced, but it is used by the query planner.</p></div><div id="Schema-references" data-reactid="2539"><b data-reactid="2540">references</b><!-- react-text: 2541 --> — <!-- /react-text --><code data-reactid="2542">column.references(column)</code><p data-reactid="2543">Sets the &quot;column&quot; that the current column references as a foreign key. &quot;column&quot; can either be &quot;.<column>&quot; syntax, or just the column name followed up with a call to inTable to specify the table.</column><table></table></p></div><div id="Schema-inTable" data-reactid="2544"><b data-reactid="2545">inTable</b><!-- react-text: 2546 --> — <!-- /react-text --><code data-reactid="2547">column.inTable(table)</code><p data-reactid="2548">Sets the &quot;table&quot; where the foreign key column is located after calling column.references.</p></div><div id="Schema-onDelete" data-reactid="2549"><b data-reactid="2550">onDelete</b><!-- react-text: 2551 --> — <!-- /react-text --><code data-reactid="2552">column.onDelete(command)</code><p data-reactid="2553">Sets the SQL command to be run &quot;onDelete&quot;.</p></div><div id="Schema-onUpdate" data-reactid="2554"><b data-reactid="2555">onUpdate</b><!-- react-text: 2556 --> — <!-- /react-text --><code data-reactid="2557">column.onUpdate(command)</code><p data-reactid="2558">Sets the SQL command to be run &quot;onUpdate&quot;.</p></div><div id="Schema-defaultTo" data-reactid="2559"><b data-reactid="2560">defaultTo</b><!-- react-text: 2561 --> — <!-- /react-text --><code data-reactid="2562">column.defaultTo(value)</code><p data-reactid="2563">Sets the default value for the column on an insert.</p></div><div id="Schema-unsigned" data-reactid="2564"><b data-reactid="2565">unsigned</b><!-- react-text: 2566 --> — <!-- /react-text --><code data-reactid="2567">column.unsigned()</code><p data-reactid="2568">Specifies an integer as unsigned. No-op if this is chained off of a non-integer field.</p></div><div id="Schema-notNullable" data-reactid="2569"><b data-reactid="2570">notNullable</b><!-- react-text: 2571 --> — <!-- /react-text --><code data-reactid="2572">column.notNullable()</code><p data-reactid="2573">Adds a not null on the current column being created.</p></div><div id="Schema-nullable" data-reactid="2574"><b data-reactid="2575">nullable</b><!-- react-text: 2576 --> — <!-- /react-text --><code data-reactid="2577">column.nullable()</code><p data-reactid="2578">Default on column creation, this explicitly sets a field to be nullable.</p></div><div id="Schema-first" data-reactid="2579"><b data-reactid="2580">first</b><!-- react-text: 2581 --> — <!-- /react-text --><code data-reactid="2582">column.first()</code><p data-reactid="2583">Sets the column to be inserted on the first position, only used in MySQL alter tables.</p></div><div id="Schema-after" data-reactid="2584"><b data-reactid="2585">after</b><!-- react-text: 2586 --> — <!-- /react-text --><code data-reactid="2587">column.after(field)</code><p data-reactid="2588">Sets the column to be inserted after another, only used in MySQL alter tables.</p></div><div id="Column-comment" data-reactid="2589"><b data-reactid="2590">comment</b><!-- react-text: 2591 --> — <!-- /react-text --><code data-reactid="2592">column.comment(value)</code><p data-reactid="2593">Sets the comment for a column.</p></div><pre data-reactid="2594"><code data-reactid="2595">knex.schema.createTable('accounts', function(t) {
  t.increments().primary();
  t.string('email').unique().comment('This is the email field');
});</code></pre><div id="Column-collate" data-reactid="2596"><b data-reactid="2597">collate</b><!-- react-text: 2598 --> — <!-- /react-text --><code data-reactid="2599">column.collate(collation)</code><p data-reactid="2600">Sets the collation for a column (only works in MySQL). Here is a list of all available collations: <a href="https://dev.mysql.com/doc/refman/5.5/en/charset-charsets.html">https://dev.mysql.com/doc/refman/5.5/en/charset-charsets.html</a></p></div><pre data-reactid="2601"><code data-reactid="2602">knex.schema.createTable('users', function(t) {
  t.increments();
  t.string('email').unique().collate('utf8_unicode_ci');
});</code></pre></div><div id="Raw" data-reactid="2603"><h2 id="Raw" data-reactid="2604">Raw</h2><p data-reactid="2605">Sometimes you may need to use a raw expression in a query. Raw query object may be injected pretty much anywhere you want, and using proper bindings can ensure your values are escaped properly, preventing SQL-injection attacks.</p><h3 id="Raw-Bindings" data-reactid="2606">Raw Parameter Binding:</h3><p data-reactid="2607">One can paramterize sql given to <code>knex.raw(sql, bindings)</code>. Parameters can be positional named. One can also choose if parameter should be treated as value or as sql identifier e.g. in case of <code>&#39;TableName.ColumnName&#39;</code> reference.</p><pre class="display" data-reactid="2608"><code class="js hljs" data-reactid="2609">knex(<span class="hljs-string">'users'</span>)
  .select(knex.raw(<span class="hljs-string">'count(*) as user_count, status'</span>))
  .where(knex.raw(<span class="hljs-number">1</span>))
  .orWhere(knex.raw(<span class="hljs-string">'status &lt;&gt; ?'</span>, [<span class="hljs-number">1</span>]))
  .groupBy(<span class="hljs-string">'status'</span>)</code><br data-reactid="2610"/><!-- react-text: 2611 -->Outputs:<!-- /react-text --><br data-reactid="2612"/><code class="sql hljs" data-reactid="2613"><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">as</span> user_count, <span class="hljs-keyword">status</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">status</span> &lt;&gt; <span class="hljs-number">1</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-string">`status`</span></code></pre><p data-reactid="2614">Positional bindings <code>?</code> are interpreted as values and <code>??</code> are interpreted as identifiers.</p><pre class="display" data-reactid="2615"><code class="js hljs" data-reactid="2616">knex(<span class="hljs-string">'users'</span>).where(knex.raw(<span class="hljs-string">'?? = ?'</span>, [<span class="hljs-string">'user.name'</span>, <span class="hljs-number">1</span>]))</code><br data-reactid="2617"/><!-- react-text: 2618 -->Outputs:<!-- /react-text --><br data-reactid="2619"/><code class="sql hljs" data-reactid="2620"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`user`</span>.<span class="hljs-string">`name`</span> = <span class="hljs-number">1</span></code></pre><p data-reactid="2621">Named bindings such as <code>:name</code> are interpreted as values and <code>:name:</code> interpreted as identifiers. Named bindings are processed so long as the value is anything other than <code>undefined</code>.</p><pre class="display" data-reactid="2622"><code class="js hljs" data-reactid="2623">knex(<span class="hljs-string">'users'</span>)
  .where(knex.raw(<span class="hljs-string">':name: = :thisGuy or :name: = :otherGuy or :name: = :undefinedBinding'</span>, {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'users.name'</span>,
    <span class="hljs-attr">thisGuy</span>: <span class="hljs-string">'Bob'</span>,
    <span class="hljs-attr">otherGuy</span>: <span class="hljs-string">'Jay'</span>,
    <span class="hljs-attr">undefinedBinding</span>: <span class="hljs-literal">undefined</span>
  }))</code><br data-reactid="2624"/><!-- react-text: 2625 -->Error:<!-- /react-text --><br data-reactid="2626"/><code class="sql hljs" data-reactid="2627">Undefined binding(s) detected when compiling RAW query: `users`.`name` = ? or `users`.`name` = ? or `users`.`name` = :undefinedBinding</code></pre><p data-reactid="2628">For simpler queries where one only has a single binding, <code>.raw</code> can accept said binding as its second parameter.</p><pre class="display" data-reactid="2629"><code class="js hljs" data-reactid="2630">knex(<span class="hljs-string">'users'</span>)
  .where(
    knex.raw(<span class="hljs-string">'LOWER("login") = ?'</span>, <span class="hljs-string">'knex'</span>)
  )
  .orWhere(
    knex.raw(<span class="hljs-string">'accesslevel = ?'</span>, <span class="hljs-number">1</span>)
  )
  .orWhere(
    knex.raw(<span class="hljs-string">'updtime = ?'</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>.UTC(<span class="hljs-string">'01-01-2016'</span>))
  )</code><br data-reactid="2631"/><!-- react-text: 2632 -->Error:<!-- /react-text --><br data-reactid="2633"/><code class="sql hljs" data-reactid="2634">Date.UTC is not a constructor</code></pre><p data-reactid="2635">Since there is no unified syntax for array bindings, instead you need to treat them as multiple values by adding <code>?</code> directly in your query.</p><pre class="display" data-reactid="2636"><code class="js hljs" data-reactid="2637"><span class="hljs-keyword">const</span> myArray = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
knex.raw(<span class="hljs-string">'select * from users where id in ('</span> + myArray.map(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-string">'?'</span>).join(<span class="hljs-string">','</span>) + <span class="hljs-string">')'</span>, [...myArray]);
<span class="hljs-comment">// query will become: select * from users where id in (?, ?, ?) with bindings [1,2,3]</span></code><br data-reactid="2638"/><!-- react-text: 2639 -->Error:<!-- /react-text --><br data-reactid="2640"/><code class="sql hljs" data-reactid="2641">Unexpected token const</code></pre><p data-reactid="2642">To prevent replacement of <code>?</code> one can use the escape sequence <code>\\?</code>.</p><pre class="display" data-reactid="2643"><code class="js hljs" data-reactid="2644">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).where(<span class="hljs-string">'id'</span>, <span class="hljs-string">'='</span>, <span class="hljs-number">1</span>).whereRaw(<span class="hljs-string">'?? \\? ?'</span>, [<span class="hljs-string">'jsonColumn'</span>, <span class="hljs-string">'jsonKey'</span>])</code><br data-reactid="2645"/><!-- react-text: 2646 -->Outputs:<!-- /react-text --><br data-reactid="2647"/><code class="sql hljs" data-reactid="2648"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`id`</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-string">`jsonColumn`</span> ? <span class="hljs-string">'jsonKey'</span></code></pre><p data-reactid="2649">To prevent replacement of named bindings one can use the escape sequence <code>\\:</code>.</p><pre class="display" data-reactid="2650"><code class="js hljs" data-reactid="2651">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).whereRaw(<span class="hljs-string">":property: = '\\:value' OR \\:property: = :value"</span>, {
  <span class="hljs-attr">property</span>: <span class="hljs-string">'name'</span>,
  <span class="hljs-attr">value</span>: <span class="hljs-string">'Bob'</span>
})</code><br data-reactid="2652"/><!-- react-text: 2653 -->Outputs:<!-- /react-text --><br data-reactid="2654"/><code class="sql hljs" data-reactid="2655"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`name`</span> = <span class="hljs-string">':value'</span> <span class="hljs-keyword">OR</span> :property: = <span class="hljs-string">'Bob'</span></code></pre><h3 id="Raw-Expressions" data-reactid="2656">Raw Expressions:</h3><p data-reactid="2657">Raw expressions are created by using <code>knex.raw(sql, [bindings])</code> and passing this as a value for any value in the query chain.</p><pre class="display" data-reactid="2658"><code class="js hljs" data-reactid="2659">knex(<span class="hljs-string">'users'</span>)
  .select(knex.raw(<span class="hljs-string">'count(*) as user_count, status'</span>))
  .where(knex.raw(<span class="hljs-number">1</span>))
  .orWhere(knex.raw(<span class="hljs-string">'status &lt;&gt; ?'</span>, [<span class="hljs-number">1</span>]))
  .groupBy(<span class="hljs-string">'status'</span>)</code><br data-reactid="2660"/><!-- react-text: 2661 -->Outputs:<!-- /react-text --><br data-reactid="2662"/><code class="sql hljs" data-reactid="2663"><span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">as</span> user_count, <span class="hljs-keyword">status</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span> <span class="hljs-keyword">where</span> <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">status</span> &lt;&gt; <span class="hljs-number">1</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-string">`status`</span></code></pre><h3 id="Raw-Queries" data-reactid="2664">Raw Queries:</h3><p data-reactid="2665">The <code>knex.raw</code> may also be used to build a full query and execute it, as a standard query builder query would be executed. The benefit of this is that it uses the connection pool and provides a standard interface for the different client libraries.</p><pre data-reactid="2666"><code class="hljs js" data-reactid="2667">knex.raw(<span class="hljs-string">'select * from users where id = ?'</span>, [<span class="hljs-number">1</span>]).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resp</span>) </span>{ ... });</code></pre><p class="info" data-reactid="2668">Note that the response will be whatever the underlying sql library would typically return on a normal query, so you may need to look at the documentation for the base library the queries are executing against to determine how to handle the response.</p><h3 id="Raw-queries-wrapped" data-reactid="2669">Wrapped Queries:</h3><p data-reactid="2670">The raw query builder also comes with a <code>wrap</code> method, which allows wrapping the query in a value:</p><pre class="display" data-reactid="2671"><code class="js hljs" data-reactid="2672"><span class="hljs-keyword">var</span> subcolumn = knex.raw(<span class="hljs-string">'select avg(salary) from employee where dept_no = e.dept_no'</span>)
.wrap(<span class="hljs-string">'('</span>, <span class="hljs-string">') avg_sal_dept'</span>);

knex.select(<span class="hljs-string">'e.lastname'</span>, <span class="hljs-string">'e.salary'</span>, subcolumn)
.from(<span class="hljs-string">'employee as e'</span>)
.whereRaw(<span class="hljs-string">'dept_no = e.dept_no'</span>)</code><br data-reactid="2673"/><!-- react-text: 2674 -->Outputs:<!-- /react-text --><br data-reactid="2675"/><code class="sql hljs" data-reactid="2676"><span class="hljs-keyword">select</span> <span class="hljs-string">`e`</span>.<span class="hljs-string">`lastname`</span>, <span class="hljs-string">`e`</span>.<span class="hljs-string">`salary`</span>, (<span class="hljs-keyword">select</span> <span class="hljs-keyword">avg</span>(salary) <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> dept_no = e.dept_no) avg_sal_dept <span class="hljs-keyword">from</span> <span class="hljs-string">`employee`</span> <span class="hljs-keyword">as</span> <span class="hljs-string">`e`</span> <span class="hljs-keyword">where</span> dept_no = e.dept_no</code></pre><p data-reactid="2677">Note that the example above be achieved more easily using the <a href="#Builder-as">as</a> method.</p><pre class="display" data-reactid="2678"><code class="js hljs" data-reactid="2679"><span class="hljs-keyword">var</span> subcolumn = knex.avg(<span class="hljs-string">'salary'</span>)
.from(<span class="hljs-string">'employee'</span>)
.whereRaw(<span class="hljs-string">'dept_no = e.dept_no'</span>)
.as(<span class="hljs-string">'avg_sal_dept'</span>);

knex.select(<span class="hljs-string">'e.lastname'</span>, <span class="hljs-string">'e.salary'</span>, subcolumn)
.from(<span class="hljs-string">'employee as e'</span>)
.whereRaw(<span class="hljs-string">'dept_no = e.dept_no'</span>)</code><br data-reactid="2680"/><!-- react-text: 2681 -->Outputs:<!-- /react-text --><br data-reactid="2682"/><code class="sql hljs" data-reactid="2683"><span class="hljs-keyword">select</span> <span class="hljs-string">`e`</span>.<span class="hljs-string">`lastname`</span>, <span class="hljs-string">`e`</span>.<span class="hljs-string">`salary`</span>, (<span class="hljs-keyword">select</span> <span class="hljs-keyword">avg</span>(<span class="hljs-string">`salary`</span>) <span class="hljs-keyword">from</span> <span class="hljs-string">`employee`</span> <span class="hljs-keyword">where</span> dept_no = e.dept_no) <span class="hljs-keyword">as</span> <span class="hljs-string">`avg_sal_dept`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`employee`</span> <span class="hljs-keyword">as</span> <span class="hljs-string">`e`</span> <span class="hljs-keyword">where</span> dept_no = e.dept_no</code></pre></div><div id="Ref" data-reactid="2684"><h2 id="Ref" data-reactid="2685">Ref</h2><p data-reactid="2686">Can be used to create references in a query, such as column- or tablenames. This is a good and shorter alternative to using <code>knex.raw(&#39;??&#39;, &#39;tableName.columName&#39;) which essentially does the same thing.</code></p><h3 id="Ref-Usage" data-reactid="2687">Usage:</h3><p data-reactid="2688"><code>knex.ref</code> can be used essentially anywhere in a build-chain. Here is an example:</p><pre class="display" data-reactid="2689"><code class="js hljs" data-reactid="2690">knex(knex.ref(<span class="hljs-string">'Users'</span>).withSchema(<span class="hljs-string">'TenantId'</span>))
  .where(knex.ref(<span class="hljs-string">'Id'</span>), <span class="hljs-number">1</span>)
  .orWhere(knex.ref(<span class="hljs-string">'Name'</span>), <span class="hljs-string">'Admin'</span>)
  .select([<span class="hljs-string">'Id'</span>, knex.ref(<span class="hljs-string">'Name'</span>).as(<span class="hljs-string">'Username'</span>)])</code><br data-reactid="2691"/><!-- react-text: 2692 -->Outputs:<!-- /react-text --><br data-reactid="2693"/><code class="sql hljs" data-reactid="2694"><span class="hljs-keyword">select</span> <span class="hljs-string">`Id`</span>, <span class="hljs-string">`Name`</span> <span class="hljs-keyword">as</span> <span class="hljs-string">`Username`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`TenantId`</span>.<span class="hljs-string">`Users`</span> <span class="hljs-keyword">where</span> <span class="hljs-string">`Id`</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-string">`Name`</span> = <span class="hljs-string">'Admin'</span></code></pre><h3 id="Ref-withSchema" data-reactid="2695">withSchema:</h3><p data-reactid="2696">The Ref function supports schema using <code>.withSchema(string)</code>:</p><pre class="display" data-reactid="2697"><code class="js hljs" data-reactid="2698">knex(knex.ref(<span class="hljs-string">'users'</span>).withSchema(<span class="hljs-string">'TenantId'</span>)).select()</code><br data-reactid="2699"/><!-- react-text: 2700 -->Outputs:<!-- /react-text --><br data-reactid="2701"/><code class="sql hljs" data-reactid="2702"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">`TenantId`</span>.<span class="hljs-string">`users`</span></code></pre><h3 id="Ref-alias" data-reactid="2703">alias:</h3><p data-reactid="2704">Alias is supported using <code>.alias(string)</code></p><pre class="display" data-reactid="2705"><code class="js hljs" data-reactid="2706">knex(<span class="hljs-string">'users'</span>)
  .select(knex.ref(<span class="hljs-string">'Id'</span>).as(<span class="hljs-string">'UserId'</span>))</code><br data-reactid="2707"/><!-- react-text: 2708 -->Outputs:<!-- /react-text --><br data-reactid="2709"/><code class="sql hljs" data-reactid="2710"><span class="hljs-keyword">select</span> <span class="hljs-string">`Id`</span> <span class="hljs-keyword">as</span> <span class="hljs-string">`UserId`</span> <span class="hljs-keyword">from</span> <span class="hljs-string">`users`</span></code></pre></div><div id="Utility" data-reactid="2711"><h2 id="Utility" data-reactid="2712">Utility</h2><p data-reactid="2713">A collection of utilities that the knex library provides for convenience.</p><h3 id="Utility-BatchInsert" data-reactid="2714">Batch Insert</h3><div data-reactid="2715"><p data-reactid="2716">The <code>batchInsert</code> utility will insert a batch of rows wrapped inside a transaction _(which is automatically created unless explicitly given a transaction using <a href="#Builder-transacting">transacting</a>)_, at a given <code>chunkSize</code>.</p><p data-reactid="2717">It&#39;s primarily designed to be used when you have thousands of rows to insert into a table.</p><p data-reactid="2718">By default, the <code>chunkSize</code> is set to 1000.</p><p data-reactid="2719">BatchInsert also allows for <a href="#Builder-returning">returning values</a> and supplying transactions using <a href="#Builder-transacting">transacting</a>.</p></div><pre data-reactid="2720"><code class="hljs js" data-reactid="2721"><span class="hljs-keyword">var</span> rows = [{...}, {...}];
<span class="hljs-keyword">var</span> chunkSize = <span class="hljs-number">30</span>;
knex.batchInsert(<span class="hljs-string">'TableName'</span>, rows, chunkSize)
  .returning(<span class="hljs-string">'id'</span>)
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ids</span>) </span>{ ... })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{ ... });

knex.transaction(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tr</span>) </span>{
  <span class="hljs-keyword">return</span> knex.batchInsert(<span class="hljs-string">'TableName'</span>, rows, chunkSize)
    .transacting(tr)
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ ... })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{ ... });</code></pre></div><div id="Interfaces" data-reactid="2722"><h2 id="Interfaces" data-reactid="2723">Interfaces</h2><p data-reactid="2724">Knex.js provides several options to deal with query output. The following methods are present on the query builder, schema builder, and the raw builder:</p><h3 id="Interfaces-Promises" data-reactid="2725">Promises</h3><p data-reactid="2726"><a href="https://github.com/petkaantonov/bluebird#what-are-promises-and-why-should-i-use-them">Promises</a> are the preferred way of dealing with queries in knex, as they allow you to return values from a fulfillment handler, which in turn become the value of the promise. The main benefit of promises are the ability to catch thrown errors without crashing the node app, making your code behave like a <strong>.try / .catch / .finally</strong> in synchronous code.</p><pre data-reactid="2727"><code class="hljs js" data-reactid="2728">knex.select(<span class="hljs-string">'name'</span>)
  .from(<span class="hljs-string">'users'</span>)
  .where(<span class="hljs-string">'id'</span>, <span class="hljs-string">'&gt;'</span>, <span class="hljs-number">20</span>)
  .andWhere(<span class="hljs-string">'id'</span>, <span class="hljs-string">'&lt;'</span>, <span class="hljs-number">200</span>)
  .limit(<span class="hljs-number">10</span>)
  .offset(x)
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rows</span>) </span>{
    <span class="hljs-keyword">return</span> _.pluck(rows, <span class="hljs-string">'name'</span>);
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">names</span>) </span>{
    <span class="hljs-keyword">return</span> knex.select(<span class="hljs-string">'id'</span>).from(<span class="hljs-string">'nicknames'</span>).whereIn(<span class="hljs-string">'nickname'</span>, names);
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rows</span>) </span>{
    <span class="hljs-built_in">console</span>.log(rows);
  })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
    <span class="hljs-built_in">console</span>.error(error)
  });</code></pre><div id="Interfaces-then" data-reactid="2729"><b data-reactid="2730">then</b><!-- react-text: 2731 --> — <!-- /react-text --><code data-reactid="2732">.then(onFulfilled, [onRejected])</code><p data-reactid="2733">Coerces the current query builder chain into a promise state, accepting the resolve and reject handlers as specified by the Promises/A+ spec. As stated in the spec, more than one call to the then method for the current query chain will resolve with the same value, in the order they were called; the query will not be executed multiple times.</p><pre data-reactid="2734"><code class="hljs js" data-reactid="2735">knex.select(<span class="hljs-string">'*'</span>)
  .from(<span class="hljs-string">'users'</span>)
  .where({<span class="hljs-attr">name</span>: <span class="hljs-string">'Tim'</span>})
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rows</span>) </span>{
    <span class="hljs-keyword">return</span> knex.insert({<span class="hljs-attr">user_id</span>: rows[<span class="hljs-number">0</span>].id, <span class="hljs-attr">name</span>: <span class="hljs-string">'Test'</span>}, <span class="hljs-string">'id'</span>).into(<span class="hljs-string">'accounts'</span>);
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Inserted Account '</span> + id);
  })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{ <span class="hljs-built_in">console</span>.error(error); });</code></pre></div><div id="Interfaces-catch" data-reactid="2736"><b data-reactid="2737">catch</b><!-- react-text: 2738 --> — <!-- /react-text --><code data-reactid="2739">.catch(onRejected)</code><p data-reactid="2740">Coerces the current query builder into a promise state, catching any error thrown by the query, the same as calling .then(null, onRejected).</p><pre data-reactid="2741"><code class="hljs js" data-reactid="2742"><span class="hljs-keyword">return</span> knex.insert({<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Test'</span>}, <span class="hljs-string">'id'</span>)
  .into(<span class="hljs-string">'accounts'</span>)
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
    <span class="hljs-built_in">console</span>.error(error);
  }).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> knex.select(<span class="hljs-string">'*'</span>)
      .from(<span class="hljs-string">'accounts'</span>)
      .where(<span class="hljs-string">'id'</span>, <span class="hljs-number">1</span>);
  }).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rows</span>) </span>{
    <span class="hljs-built_in">console</span>.log(rows[<span class="hljs-number">0</span>]);
  })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
    <span class="hljs-built_in">console</span>.error(error);
  });</code></pre></div><div id="Interfaces-tap" data-reactid="2743"><b data-reactid="2744">tap</b><!-- react-text: 2745 --> — <!-- /react-text --><code data-reactid="2746">.tap(sideEffectHandler)</code><p data-reactid="2747">Executes side effects on the resolved response, ultimately returning a promise that fulfills with the original value. A thrown error or rejected promise will cause the promise to transition into a rejected state.</p><pre data-reactid="2748"><code class="hljs js" data-reactid="2749"><span class="hljs-comment">// Using only .then()</span>
query.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
  doSideEffectsHere(x);
  <span class="hljs-keyword">return</span> x;
});

<span class="hljs-comment">// Using .tap()</span>
promise.tap(doSideEffectsHere);</code></pre></div><div id="Interfaces-map" data-reactid="2750"><b data-reactid="2751">map</b><!-- react-text: 2752 --> — <!-- /react-text --><code data-reactid="2753">.map(mapper)</code><p data-reactid="2754">A passthrough to Bluebird&#39;s map implementation with the result set.</p><pre data-reactid="2755"><code class="hljs js" data-reactid="2756">knex.select(<span class="hljs-string">'name'</span>).from(<span class="hljs-string">'users'</span>).limit(<span class="hljs-number">10</span>).map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">row</span>) </span>{
  <span class="hljs-keyword">return</span> row.name;
})
.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">names</span>) </span>{ <span class="hljs-built_in">console</span>.log(names); })
.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{ <span class="hljs-built_in">console</span>.error(e); });</code></pre></div><div id="Interfaces-reduce" data-reactid="2757"><b data-reactid="2758">reduce</b><!-- react-text: 2759 --> — <!-- /react-text --><code data-reactid="2760">.reduce(reducer, [initialValue])</code><p data-reactid="2761">A passthrough to Bluebird&#39;s reduce implementation with the result set.</p><pre data-reactid="2762"><code class="hljs js" data-reactid="2763">knex.select(<span class="hljs-string">'name'</span>).from(<span class="hljs-string">'users'</span>).limit(<span class="hljs-number">10</span>).reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">memo, row</span>) </span>{
  memo.names.push(row.name);
  memo.count++;
  <span class="hljs-keyword">return</span> memo;
}, {<span class="hljs-attr">count</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">names</span>: []})
.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>{ <span class="hljs-built_in">console</span>.log(obj); })
.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{ <span class="hljs-built_in">console</span>.error(e); });</code></pre></div><div id="Interfaces-bind" data-reactid="2764"><b data-reactid="2765">bind</b><!-- react-text: 2766 --> — <!-- /react-text --><code data-reactid="2767">.bind(context)</code><p data-reactid="2768">A passthrough to Bluebird&#39;s bind method which sets the context value (this) for the returned promise.</p><pre data-reactid="2769"><code class="hljs js" data-reactid="2770">knex.select(<span class="hljs-string">'name'</span>).from(<span class="hljs-string">'users'</span>)
  .limit(<span class="hljs-number">10</span>)
  .bind(<span class="hljs-built_in">console</span>)
  .then(<span class="hljs-built_in">console</span>.log)
  .catch(<span class="hljs-built_in">console</span>.error)</code></pre></div><div id="Interfaces-return" data-reactid="2771"><b data-reactid="2772">return</b><!-- react-text: 2773 --> — <!-- /react-text --><code data-reactid="2774">.return(value)</code><p data-reactid="2775">Shorthand for calling .then(function() { return value }).</p><pre data-reactid="2776"><code class="hljs js" data-reactid="2777"><span class="hljs-comment">// Without return:</span>
knex.insert(values).into(<span class="hljs-string">'users'</span>)
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> {<span class="hljs-attr">inserted</span>: <span class="hljs-literal">true</span>};
  });

knex.insert(values).into(<span class="hljs-string">'users'</span>).return({<span class="hljs-attr">inserted</span>: <span class="hljs-literal">true</span>});</code></pre></div><h3 id="Interfaces-Callbacks" data-reactid="2778">Callbacks</h3><div id="Interfaces-asCallback" data-reactid="2779"><b data-reactid="2780">asCallback</b><!-- react-text: 2781 --> — <!-- /react-text --><code data-reactid="2782">.asCallback(callback)</code><p data-reactid="2783">If you&#39;d prefer a callback interface over promises, the asCallback function accepts a standard node style callback for executing the query chain. Note that as with the then method, subsequent calls to the same query chain will return the same result.</p><pre data-reactid="2784"><code class="hljs js" data-reactid="2785">knex.select(<span class="hljs-string">'name'</span>).from(<span class="hljs-string">'users'</span>)
  .where(<span class="hljs-string">'id'</span>, <span class="hljs-string">'&gt;'</span>, <span class="hljs-number">20</span>)
  .andWhere(<span class="hljs-string">'id'</span>, <span class="hljs-string">'&lt;'</span>, <span class="hljs-number">200</span>)
  .limit(<span class="hljs-number">10</span>)
  .offset(x)
  .asCallback(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, rows</span>) </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.error(err);
    knex.select(<span class="hljs-string">'id'</span>).from(<span class="hljs-string">'nicknames'</span>)
      .whereIn(<span class="hljs-string">'nickname'</span>, _.pluck(rows, <span class="hljs-string">'name'</span>))
      .asCallback(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, rows</span>) </span>{
        <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.error(err);
        <span class="hljs-built_in">console</span>.log(rows);
      });
  });</code></pre></div><h3 id="Interfaces-Streams" data-reactid="2786">Streams</h3><p data-reactid="2787">Streams are a powerful way of piping data through as it comes in, rather than all at once. You can read more about streams <a href="https://github.com/substack/stream-handbook">here at substack&#39;s stream handbook</a>. See the following for example uses of stream &amp; pipe. If you wish to use streams with PostgreSQL, you must also install the <a href="https://github.com/brianc/node-pg-query-stream">pg-query-stream</a> module. On an HTTP server, make sure to <a href="https://github.com/tgriesser/knex/wiki/Manually-Closing-Streams">manually close your streams</a> if a request is aborted.</p><div id="Interfaces-stream" data-reactid="2788"><b data-reactid="2789">stream</b><!-- react-text: 2790 --> — <!-- /react-text --><code data-reactid="2791">.stream([options], [callback])</code><p data-reactid="2792">If called with a callback, the callback is passed the stream and a promise is returned. Otherwise, the readable stream is returned.</p><pre data-reactid="2793"><code class="hljs js" data-reactid="2794"><span class="hljs-comment">// Retrieve the stream:</span>
<span class="hljs-keyword">var</span> stream = knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).stream();
stream.pipe(writableStream);

<span class="hljs-comment">// With options:</span>
<span class="hljs-keyword">var</span> stream = knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).stream({<span class="hljs-attr">highWaterMark</span>: <span class="hljs-number">5</span>});
stream.pipe(writableStream);

<span class="hljs-comment">// Use as a promise:</span>
<span class="hljs-keyword">var</span> stream = knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>)
  .where(knex.raw(<span class="hljs-string">'id = ?'</span>, [<span class="hljs-number">1</span>]))
  .stream(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stream</span>) </span>{
    stream.pipe(writableStream);
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// ... })</span>
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{ <span class="hljs-built_in">console</span>.error(e); });</code></pre></div><div id="Interfaces-pipe" data-reactid="2795"><b data-reactid="2796">pipe</b><!-- react-text: 2797 --> — <!-- /react-text --><code data-reactid="2798">.pipe(writableStream)</code><p data-reactid="2799">Pipe a stream for the current query to a writableStream.</p><pre data-reactid="2800"><code class="hljs js" data-reactid="2801"><span class="hljs-keyword">var</span> stream = knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).pipe(writableStream);</code></pre></div><h3 id="Interfaces-Events" data-reactid="2802">Events</h3><div id="Interfaces-query" data-reactid="2803"><b data-reactid="2804">query</b><p data-reactid="2805">A query event is fired just before a query takes place, providing data about the query, including the connection&#39;s <code>__knexUid</code> / <code>__knexTxId</code> properties and any other information about the query as described in toSQL. Useful for logging all queries throughout your application.</p><pre data-reactid="2806"><code class="hljs js" data-reactid="2807">knex.select(<span class="hljs-string">'*'</span>)
  .from(<span class="hljs-string">'users'</span>)
  .on(<span class="hljs-string">'query'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{
    app.log(data);
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// ...</span>
  });</code></pre></div><div id="Interfaces-query-error" data-reactid="2808"><b data-reactid="2809">query-error</b><p data-reactid="2810">A query-error event is fired when an error occurs when running a query, providing the error object and data about the query, including the connection&#39;s <code>__knexUid</code> / <code>__knexTxId</code> properties and any other information about the query as described in toSQL. Useful for logging all query errors throughout your application.</p><pre data-reactid="2811"><code class="hljs js" data-reactid="2812">knex.select([<span class="hljs-string">'NonExistentColumn'</span>])
  .from(<span class="hljs-string">'users'</span>)
  .on(<span class="hljs-string">'query-error'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, obj</span>) </span>{
    app.log(error);
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-comment">// ... })</span>
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
    <span class="hljs-comment">// Same error object as the query-error event provides.</span>
  });</code></pre></div><div id="Interfaces-query-response" data-reactid="2813"><b data-reactid="2814">query-response</b><p data-reactid="2815">A query-response event is fired when a successful query has been run, providing the response of the query and data about the query, including the connection&#39;s <code>__knexUid</code> / <code>__knexTxId</code> properties and any other information about the query as described in toSQL, and finally the query builder used for the query.</p><pre data-reactid="2816"><code class="hljs js" data-reactid="2817">knex.select(<span class="hljs-string">'*'</span>)
  .from(<span class="hljs-string">'users'</span>)
  .on(<span class="hljs-string">'query-response'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response, obj, builder</span>) </span>{
    <span class="hljs-comment">// ...</span>
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>{
    <span class="hljs-comment">// Same response as the emitted event</span>
  })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{ });</code></pre></div><div id="Interfaces-start" data-reactid="2818"><b data-reactid="2819">start</b><p data-reactid="2820">A <code>start</code> event is fired right before a query-builder is compiled. Note: While this event can be used to alter a builders state prior to compilation it is not to be recommended. Future goals include ways of doing this in a different manner such as hooks.</p><pre data-reactid="2821"><code class="hljs js" data-reactid="2822">knex.select(<span class="hljs-string">'*'</span>)
  .from(<span class="hljs-string">'users'</span>)
  .on(<span class="hljs-string">'start'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">builder</span>) </span>{
    builder
    .where(<span class="hljs-string">'IsPrivate'</span>, <span class="hljs-number">0</span>)
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Rows</span>) </span>{
    <span class="hljs-comment">//Only contains Rows where IsPrivate = 0</span>
  })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{ });</code></pre></div><h3 id="Interfaces-Other" data-reactid="2823">Other</h3><div id="Interfaces-toString" data-reactid="2824"><b data-reactid="2825">toString</b><!-- react-text: 2826 --> — <!-- /react-text --><code data-reactid="2827">.toString()</code><p data-reactid="2828">Returns an array of query strings filled out with the correct values based on bindings, etc. Useful for debugging, but should not be used to create queries for running them against DB.</p><pre data-reactid="2829"><code class="hljs js" data-reactid="2830"><span class="hljs-keyword">var</span> toStringQuery = knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>).where(<span class="hljs-string">'id'</span>, <span class="hljs-number">1</span>).toString();

<span class="hljs-comment">// Outputs: console.log(toStringQuery); </span>
<span class="hljs-comment">// select * from "users" where "id" = 1</span></code></pre></div><div id="Interfaces-toSQL" data-reactid="2831"><b data-reactid="2832">toSQL</b><!-- react-text: 2833 --> — <!-- /react-text --><code data-reactid="2834">.toSQL() and toSQL().toNative()</code><p data-reactid="2835">Returns an array of query strings filled out with the correct values based on bindings, etc. Useful for debugging and building queries for running them manually with DB driver. <code>.toSQL().toNative()</code> outputs object with sql string and bindings in a dialects format in the same way that knex internally sends them to unterlying DB driver.</p><pre data-reactid="2836"><code class="hljs js" data-reactid="2837">knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>)
  .where(knex.raw(<span class="hljs-string">'id = ?'</span>, [<span class="hljs-number">1</span>]))
  .toSQL()
<span class="hljs-comment">// Outputs:</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   bindings: [1],</span>
<span class="hljs-comment">//   method: 'select',</span>
<span class="hljs-comment">//   sql: 'select * from "users" where id = ?',</span>
<span class="hljs-comment">//   options: undefined,</span>
<span class="hljs-comment">//   toNative: function () {}</span>
<span class="hljs-comment">// }</span>

knex.select(<span class="hljs-string">'*'</span>).from(<span class="hljs-string">'users'</span>)
  .where(knex.raw(<span class="hljs-string">'id = ?'</span>, [<span class="hljs-number">1</span>]))
  .toSQL().toNative()
<span class="hljs-comment">// Outputs for postgresql dialect:</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//   bindings: [1],</span>
<span class="hljs-comment">//   sql: 'select * from "users" where id = $1',</span>
<span class="hljs-comment">// }</span></code></pre></div></div><div id="Migrations" data-reactid="2838"><h2 id="Migrations" data-reactid="2839">Migrations</h2><p data-reactid="2840">Migrations allow for you to define sets of schema changes so upgrading a database is a breeze.</p><h3 id="Migrations-CLI" data-reactid="2841">Migration CLI</h3><p data-reactid="2842">The migration CLI is bundled with the knex install, and is driven by the <a href="https://github.com/tkellen/node-liftoff">node-liftoff</a> module. To install globally, run:</p><pre data-reactid="2843"><code data-reactid="2844">$ npm install knex -g</code></pre><p data-reactid="2845">Migrations use a <strong>knexfile</strong>, which specify various configuration settings for the module. To create a new knexfile, run the following:</p><pre data-reactid="2846"><code data-reactid="2847">$ knex init

# or for .coffee

$ knex init -x coffee</code></pre><p data-reactid="2848">will create a sample knexfile.js - the file which contains our various database configurations. Once you have a knexfile.js, you can use the migration tool to create migration files to the specified directory (default migrations). Creating new migration files can be achieved by running:</p><pre data-reactid="2849"><code data-reactid="2850">$ knex migrate:make migration_name</code></pre><p data-reactid="2851">Once you have finished writing the migrations, you can update the database matching your <code>NODE_ENV</code> by running:</p><pre data-reactid="2852"><code data-reactid="2853">$ knex migrate:latest</code></pre><p data-reactid="2854">You can also pass the <code>--env</code> flag or set <code>NODE_ENV</code> to select an alternative environment:</p><pre data-reactid="2855"><code data-reactid="2856">$ knex migrate:latest --env production

# or

$ NODE_ENV=production knex migrate:latest</code></pre><p data-reactid="2857">To rollback the last batch of migrations:</p><pre data-reactid="2858"><code data-reactid="2859">$ knex migrate:rollback</code></pre><h2 id="Seeds" data-reactid="2860">Seed files</h2><p data-reactid="2861">Seed files allow you to populate your database with test or seed data independent of your migration files.</p><h3 id="Seeds-CLI" data-reactid="2862">Seed CLI</h3><p data-reactid="2863">To create a seed file, run:</p><pre data-reactid="2864"><code data-reactid="2865">$ knex seed:make seed_name</code></pre><p data-reactid="2866">Seed files are created in the directory specified in your knexfile.js for the current environment. A sample seed configuration looks like:</p><pre data-reactid="2867"><code data-reactid="2868">development: {
  client: ...,
  connection: { ... },
  seeds: {
      directory: './seeds/dev'
  }
}</code></pre><div data-reactid="2869"><p data-reactid="2870">If no <code>seeds.directory</code> is defined, files are created in <code>./seeds</code>. Note that the seed directory needs to be a relative path. Absolute paths are not supported (nor is it good practice).</p><p data-reactid="2871">To run seed files, execute:</p></div><pre data-reactid="2872"><code data-reactid="2873">$ knex seed:run</code></pre><p data-reactid="2874">Seed files are executed in alphabetical order. Unlike migrations, <em>every</em> seed file will be executed when you run the command. You should design your seed files to reset tables as needed before inserting data.</p><h3 id="knexfile" data-reactid="2875">knexfile.js</h3><p data-reactid="2876">A knexfile.js or knexfile.coffee generally contains all of the configuration for your database. It can optionally provide different configuration for different environments. You may pass a <code>--knexfile</code> option to any of the command line statements to specify an alternate path to your knexfile.</p><h4 data-reactid="2877">Basic configuration:</h4><pre data-reactid="2878"><code class="hljs js" data-reactid="2879"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">client</span>: <span class="hljs-string">'pg'</span>,
  <span class="hljs-attr">connection</span>: process.env.DATABASE_URL || { <span class="hljs-attr">user</span>: <span class="hljs-string">'me'</span>, <span class="hljs-attr">database</span>: <span class="hljs-string">'my_app'</span> }
};</code></pre><h4 data-reactid="2880">Environment configuration:</h4><pre data-reactid="2881"><code class="hljs js" data-reactid="2882"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">development</span>: {
    <span class="hljs-attr">client</span>: <span class="hljs-string">'pg'</span>,
    <span class="hljs-attr">connection</span>: { <span class="hljs-attr">user</span>: <span class="hljs-string">'me'</span>, <span class="hljs-attr">database</span>: <span class="hljs-string">'my_app'</span> }
  },
  <span class="hljs-attr">production</span>: { <span class="hljs-attr">client</span>: <span class="hljs-string">'pg'</span>, <span class="hljs-attr">connection</span>: process.env.DATABASE_URL }
};</code></pre><h4 data-reactid="2883">Custom migration:</h4><p data-reactid="2884">You may provide a custom migration stub to be used in place of the default option.</p><pre data-reactid="2885"><code class="hljs js" data-reactid="2886"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">client</span>: <span class="hljs-string">'pg'</span>,
  <span class="hljs-attr">migrations</span>: {
    <span class="hljs-attr">stub</span>: <span class="hljs-string">'migration.stub'</span>
  }
};</code></pre><h3 id="Migrations-API" data-reactid="2887">Migration API</h3><div data-reactid="2888"><p data-reactid="2889"><code>knex.migrate</code> is the class utilized by the knex migrations cli.</p><p data-reactid="2890">Each method takes an optional <code>config</code> object, which may specify the following properties:</p></div><ul data-reactid="2891"><li data-reactid="2892"><code>directory</code>: a relative path to the directory containing the migration files. Can be an array of paths (default <code>./migrations</code>)</li><li data-reactid="2893"><code>extension</code>: the file extension used for the generated migration files (default <code>js</code>)</li><li data-reactid="2894"><code>tableName</code>: the table name used for storing the migration state (default <code>knex_migrations</code>)</li><li data-reactid="2895"><code>schemaName</code>: the schema name used for storing the table with migration state (optional parameter, only works on DBs that support multiple schemas in a single DB, such as PostgreSQL)</li><li data-reactid="2896"><code>disableTransactions</code>: don&#39;t run migrations inside transactions (default <code>false</code>)</li><li data-reactid="2897"><code>sortDirsSeparately</code>: if true and multiple directories are specified, all migrations from a single directory will be executed before executing migrations in the next folder (default <code>false</code>)</li><li data-reactid="2898"><code>loadExtensions</code>: array of file extensions which knex will treat as migrations. For example, if you have typescript transpiled into javascript in the same folder, you want to execute only javascript migrations. In this case, set <code>loadExtensions</code> to <code>[&#39;.js&#39;]</code> (Notice the dot!) (default <code>[&#39;.co&#39;, &#39;.coffee&#39;, &#39;.eg&#39;, &#39;.iced&#39;, &#39;.js&#39;, &#39;.litcoffee&#39;, &#39;.ls&#39;, &#39;.ts&#39;]</code>)</li><li data-reactid="2899"><code>migrationSource</code>: specify a custom migration source, see <a href="#custom-migration-source">Custom Migration Source</a> for more info (default filesystem)</li></ul><h4 id="Migrations-API-transactions" data-reactid="2900">Transactions in migrations</h4><p data-reactid="2901">By default, each migration is run inside a transaction. Whenever needed, one can disable transactions for all migrations via the common migration config option <code>config.disableTransactions</code> or per-migration, via exposing a boolean property <code>config.transaction</code> from a migration file:</p><pre data-reactid="2902"><code class="hljs js" data-reactid="2903">exports.up = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">knex, Promise</span>) </span>{ <span class="hljs-comment">/* ... */</span> };

exports.down = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">knex, Promise</span>) </span>{ <span class="hljs-comment">/* ... */</span> };

exports.config = { <span class="hljs-attr">transaction</span>: <span class="hljs-literal">false</span> };</code></pre><p data-reactid="2904">The same config property can be used for enabling transaction per-migration in case the common configuration has <code>disableTransactions: true</code>.</p><div id="Migrations-make" data-reactid="2905"><b data-reactid="2906">make</b><!-- react-text: 2907 --> — <!-- /react-text --><code data-reactid="2908">knex.migrate.make(name, [config])</code><p data-reactid="2909">Creates a new migration, with the name of the migration being added.</p></div><div id="Migrations-latest" data-reactid="2910"><b data-reactid="2911">latest</b><!-- react-text: 2912 --> — <!-- /react-text --><code data-reactid="2913">knex.migrate.latest([config])</code><p data-reactid="2914">Runs all migrations that have not yet been run.</p></div><p data-reactid="2915">If you need to run something only after all migrations have finished their execution, you can do something like this:</p><pre data-reactid="2916"><code class="hljs js" data-reactid="2917">knex.migrate.latest()
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> knex.seed.run();
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// migrations are finished</span>
  });</code></pre><div id="Migrations-rollback" data-reactid="2918"><b data-reactid="2919">rollback</b><!-- react-text: 2920 --> — <!-- /react-text --><code data-reactid="2921">knex.migrate.rollback([config])</code><p data-reactid="2922">Rolls back the latest migration group.</p></div><div id="Migrations-currentVersion" data-reactid="2923"><b data-reactid="2924">currentVersion</b><!-- react-text: 2925 --> — <!-- /react-text --><code data-reactid="2926">knex.migrate.currentVersion([config])</code><p data-reactid="2927">Retrieves and returns the current migration version, as a promise. If there aren&#39;t any migrations run yet, returns &quot;none&quot; as the value for the currentVersion.</p></div><h3 id="Notes-about-locks" data-reactid="2928">Notes about locks</h3><p data-reactid="2929">A lock system is there to prevent multiple processes from running the same migration batch in the same time. When a batch of migrations is about to be run, the migration system first tries to get a lock using a <code>SELECT ... FOR UPDATE</code> statement (preventing race conditions from happening). If it can get a lock, the migration batch will run. If it can&#39;t, it will wait until the lock is released.</p><p data-reactid="2930">Please note that if your process unfortunately crashes, the lock will have to be <em>manually</em> removed in order to let migrations run again. The locks are saved in a table called &quot;<code>tableName</code>_lock&quot;; it has a column called <code>is_locked</code> that you need to set to <code>0</code> in order to release the lock. The <code>index</code> column in the lock table exists for compatibility with some database clusters that require a primary key, but is otherwise unused.</p><h3 id="custom-migration-sources" data-reactid="2931">Custom migraiton sources</h3><p data-reactid="2932">Knex supports custom migration sources, allowing you full control of where your migrations come from. This can be useful for custom folder structures, when bundling with webpack/browserify and other scenarios.</p><pre data-reactid="2933"><code class="hljs js" data-reactid="2934"><span class="hljs-comment">// Create a custom migration source class</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMigrationSource</span> </span>{
  <span class="hljs-comment">// Must return a Promise containing a list of migrations. </span>
  <span class="hljs-comment">// Migrations can be whatever you want, they will be passed as</span>
  <span class="hljs-comment">// arguments to getMigrationName and getMigration</span>
  getMigrations() {
    <span class="hljs-comment">// In this example we are just returning migration names</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve([<span class="hljs-string">'migration1'</span>])
  }

  getMigrationName(migration) {
    <span class="hljs-keyword">return</span> migration;
  }

  getMigration(migration) {
    <span class="hljs-keyword">switch</span>(migration) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'migration1'</span>:
        <span class="hljs-keyword">return</span> {
          up(knex)   { <span class="hljs-comment">/* ... * / }
          down(knex) { /* ... * / }
        }
    }
  },
}

// pass an instance of your migration source as knex config
knex.migrations.latest({ migrationSource: new MyMigrationSource() })</span></code></pre><h4 data-reactid="2935">Webpack migration source example</h4><p data-reactid="2936">An example of how to create a migration source where migrations are included in a webpack bundle.</p><pre data-reactid="2937"><code class="hljs js" data-reactid="2938"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebpackMigrationSource</span> </span>{
  <span class="hljs-keyword">constructor</span>(migrationContext) {
    <span class="hljs-keyword">this</span>.migrationContext = migrationContext;
  }

  getMigrations() {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-keyword">this</span>.migrationContext.keys().sort())
  }

  getMigrationName(migration) {
    <span class="hljs-keyword">return</span> migration
  }

  getMigration(migration) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.migrationContext(migration)
  }
}

<span class="hljs-comment">// pass an instance of your migration source as knex config</span>
knex.migrations.latest({
  <span class="hljs-attr">migrationSource</span>: <span class="hljs-keyword">new</span> WebpackMigrationSource(<span class="hljs-built_in">require</span>.context(<span class="hljs-string">'./migrations'</span>, <span class="hljs-literal">false</span>, /.js$/))
})</code></pre></div><div id="Seeds" data-reactid="2939"><h3 id="Seeds-API" data-reactid="2940">Seed API</h3><div data-reactid="2941"><p data-reactid="2942"><code>knex.seed</code> is the class utilized by the knex seed CLI.</p><p data-reactid="2943">Each method takes an optional <code>config</code> object, which may specify the following properties:</p></div><ul data-reactid="2944"><li data-reactid="2945"><code>directory</code>: a relative path to the directory containing the seed files (default <code>./seeds</code>)</li><li data-reactid="2946"><code>loadExtensions</code>: array of file extensions which knex will treat as seeds. For example, if you have typescript transpiled into javascript in the same folder, you want to execute only javascript seeds. In this case, set <code>loadExtensions</code> to <code>[&#39;.js&#39;]</code>  (Notice the dot!)  (default <code>[&#39;.co&#39;, &#39;.coffee&#39;, &#39;.eg&#39;, &#39;.iced&#39;, &#39;.js&#39;, &#39;.litcoffee&#39;, &#39;.ls&#39;, &#39;.ts&#39;]</code>)</li></ul><h4 id="Seeds-API-methods" data-reactid="2947">Methods</h4><div id="Seeds-make" data-reactid="2948"><b data-reactid="2949">make</b><!-- react-text: 2950 --> — <!-- /react-text --><code data-reactid="2951">knex.seed.make(name, [config])</code><p data-reactid="2952">Creates a new seed file, with the name of the seed file being added.</p></div><div id="Seeds-run" data-reactid="2953"><b data-reactid="2954">run</b><!-- react-text: 2955 --> — <!-- /react-text --><code data-reactid="2956">knex.seed.run([config])</code><p data-reactid="2957">Runs all seed files for the current environment.</p></div></div><div id="Support" data-reactid="2958"><h2 id="support" data-reactid="2959">Support</h2><p data-reactid="2960">Have questions about the library? Come join us in the <a href="http://webchat.freenode.net/?channels=bookshelf">#bookshelf freenode IRC</a> channel for support on knex.js and <a href="http://bookshelfjs.org">bookshelf.js</a>, or post an issue on <a href="http://stackoverflow.com/questions/tagged/knex.js">Stack Overflow</a> or in the GitHub <a href="https://github.com/tgriesser/knex/issues">issue tracker</a>.</p></div><div id="Faq" data-reactid="2961"><h2 id="faq" data-reactid="2962">F.A.Q.</h2><div data-reactid="2963"><p data-reactid="2964"><strong>How do I help contribute?</strong><br>Glad you ask! Pull requests, or feature requests, though not always implemented, are a great way to help make Knex even better than it is now. If you&#39;re looking for something specific to help out with, there&#39;s a number of unit tests that aren&#39;t implemented yet, the library could never have too many of those. If you want to submit a fix or feature, take a look at the <a href="https://github.com/tgriesser/knex/blob/master/CONTRIBUTING.md">Contributing</a> readme in the Github and go ahead and open a ticket.</p><p data-reactid="2965"><strong>How do I debug?</strong><br>Knex is beginning to make use of the <a href="https://github.com/visionmedia/debug">debug</a> module internally, so you can set the <code>DEBUG</code> environment variable to <code>knex:*</code> to see all debugging, or select individual namespaces <code>DEBUG=knex:query,knex:tx</code> to constrain a bit.</p><p data-reactid="2966">If you pass <code>{debug: true}</code> as one of the options in your initialize settings, you can see all of the query calls being made. Sometimes you need to dive a bit further into the various calls and see what all is going on behind the scenes. I&#39;d recommend <a href="https://github.com/dannycoates/node-inspector">node-inspector</a>, which allows you to debug code with <code>debugger</code> statements like you would in the browser.</p><p data-reactid="2967">At the start of your application code will catch any errors not otherwise caught in the normal promise chain handlers, which is very helpful in debugging.</p><p data-reactid="2968"><strong>How do I run the test suite?</strong><br>The test suite looks for an environment variable called <code>KNEX_TEST</code> for the path to the database configuration. If you run the following command:</p></div><pre data-reactid="2969"><code data-reactid="2970">$ export KNEX_TEST='/path/to/your/knex_config.js'
$ npm test</code></pre><div data-reactid="2971"><p data-reactid="2972">replacing with the path to your config file, and the config file is valid, the test suite should run properly.</p><p data-reactid="2973"><strong>My tests are failing because slow DB connection and short test timeouts! How to extend test timeouts?</strong><br>Sometimes, e.g. when running CI on travis, test suite&#39;s default timeout of 5 seconds might be too short. In such cases an alternative test timeout value in milliseconds can be specified using the <code>KNEX_TEST_TIMEOUT</code> environment variable.</p></div><pre data-reactid="2974"><code data-reactid="2975">$ export KNEX_TEST_TIMEOUT=30000
$ npm test</code></pre><div data-reactid="2976"><p data-reactid="2977"><strong>Can I use Knex outside of Node.js</strong><br>Yes. While the WebSQL spec is deprecated, there is still an adapter that provides support. You will need to use a build tool like browserify or webpack for a browser build.</p><p data-reactid="2978"><strong>I found something broken with Amazon Redshift! Can you help?</strong><br>Because there is no testing platform available for Amazon Redshift, be aware that it is included as a dialect but is unsupported. With that said, please file an issue if something is found to be broken that is not noted in the documentation, and we will do our best.</p></div></div><div id="changelog" data-reactid="2979"><h2 data-reactid="2980">Change Log</h2></div></div></div></div>
  </body>
  <script type="text/javascript" src="build/bundle.js"></script>
  <script type="text/javascript" src="assets/ga.js"></script>
</html>
