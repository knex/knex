(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("lodash"), require("bluebird"));
	else if(typeof define === 'function' && define.amd)
		define(["lodash", "bluebird"], factory);
	else if(typeof exports === 'object')
		exports["Knex"] = factory(require("lodash"), require("bluebird"));
	else
		root["Knex"] = factory(root["_"], root["Promise"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_44__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	exports.__esModule = true;
	exports['default'] = Knex;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _raw = __webpack_require__(2);

	var _raw2 = _interopRequireDefault(_raw);

	var _helpers = __webpack_require__(4);

	var _client = __webpack_require__(42);

	var _client2 = _interopRequireDefault(_client);

	var _utilMakeClient = __webpack_require__(84);

	var _utilMakeClient2 = _interopRequireDefault(_utilMakeClient);

	var _utilMakeKnex = __webpack_require__(69);

	var _utilMakeKnex2 = _interopRequireDefault(_utilMakeKnex);

	var _utilParseConnection = __webpack_require__(85);

	var _utilParseConnection2 = _interopRequireDefault(_utilParseConnection);

	var _lodash = __webpack_require__(5);

	// The client names we'll allow in the `{name: lib}` pairing.
	var aliases = {
	  'mariadb': 'maria',
	  'mariasql': 'maria',
	  'pg': 'postgres',
	  'postgresql': 'postgres',
	  'sqlite': 'sqlite3'
	};

	function Knex(config) {
	  if (typeof config === 'string') {
	    return new Knex(_lodash.assign(_utilParseConnection2['default'](config), arguments[2]));
	  }
	  var Dialect = undefined;
	  if (arguments.length === 0 || !config.client && !config.dialect) {
	    Dialect = _utilMakeClient2['default'](_client2['default']);
	  } else if (typeof config.client === 'function' && config.client.prototype instanceof _client2['default']) {
	    Dialect = _utilMakeClient2['default'](config.client);
	  } else {
	    var clientName = config.client || config.dialect;
	    Dialect = _utilMakeClient2['default'](__webpack_require__(92)("./" + (aliases[clientName] || clientName) + '/index.js'));
	  }
	  if (typeof config.connection === 'string') {
	    config = _lodash.assign({}, config, { connection: _utilParseConnection2['default'](config.connection).connection });
	  }
	  return _utilMakeKnex2['default'](new Dialect(config));
	}

	// Expose Client on the main Knex namespace.
	Knex.Client = _client2['default'];

	// Expose Knex version on the main Knex namespace.
	Knex.VERSION = __webpack_require__(74).version;

	// Run a "raw" query, though we can't do anything with it other than put
	// it in a query statement.
	Knex.raw = function (sql, bindings) {
	  return new _raw2['default']({}).set(sql, bindings);
	};

	// Create a new "knex" instance with the appropriate configured client.
	Knex.initialize = function (config) {
	  _helpers.warn('knex.initialize is deprecated, pass your config object directly to the knex module');
	  return new Knex(config);
	};

	// Bluebird
	Knex.Promise = __webpack_require__(43);

	// Doing this ensures Browserify works. Still need to figure out
	// the best way to do some of this.
	if (process.browser) {
	  __webpack_require__(142);
	}
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7cUJBb0J3QixJQUFJOzs7O21CQW5CWixPQUFPOzs7O3VCQUNGLFdBQVc7O3NCQUNiLFVBQVU7Ozs7OEJBRU4sb0JBQW9COzs7OzRCQUN0QixrQkFBa0I7Ozs7bUNBQ1gseUJBQXlCOzs7O3NCQUU5QixRQUFROzs7QUFHL0IsSUFBTSxPQUFPLEdBQUc7QUFDZCxXQUFTLEVBQUssT0FBTztBQUNyQixZQUFVLEVBQUksT0FBTztBQUNyQixNQUFJLEVBQVUsVUFBVTtBQUN4QixjQUFZLEVBQUUsVUFBVTtBQUN4QixVQUFRLEVBQU0sU0FBUztDQUN4QixDQUFDOztBQUVhLFNBQVMsSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUNuQyxNQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsRUFBRTtBQUM5QixXQUFPLElBQUksSUFBSSxDQUFDLGVBQU8saUNBQWdCLE1BQU0sQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7R0FDL0Q7QUFDRCxNQUFJLE9BQU8sWUFBQSxDQUFDO0FBQ1osTUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxBQUFDLEVBQUU7QUFDakUsV0FBTyxHQUFHLGdEQUFrQixDQUFBO0dBQzdCLE1BQU0sSUFBSSxPQUFPLE1BQU0sQ0FBQyxNQUFNLEtBQUssVUFBVSxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBUywrQkFBa0IsRUFBRTtBQUMzRixXQUFPLEdBQUcsNEJBQVcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFBO0dBQ3BDLE1BQU07QUFDTCxRQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUE7QUFDbEQsV0FBTyxHQUFHLDRCQUFXLE9BQU8sa0JBQWUsT0FBTyxDQUFDLFVBQVUsQ0FBQyxJQUFJLFVBQVUsQ0FBQSxlQUFZLENBQUMsQ0FBQTtHQUMxRjtBQUNELE1BQUksT0FBTyxNQUFNLENBQUMsVUFBVSxLQUFLLFFBQVEsRUFBRTtBQUN6QyxVQUFNLEdBQUcsZUFBTyxFQUFFLEVBQUUsTUFBTSxFQUFFLEVBQUMsVUFBVSxFQUFFLGlDQUFnQixNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsVUFBVSxFQUFDLENBQUMsQ0FBQTtHQUN6RjtBQUNELFNBQU8sMEJBQVMsSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQTtDQUNyQzs7O0FBR0QsSUFBSSxDQUFDLE1BQU0sc0JBQVMsQ0FBQTs7O0FBR3BCLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUMsT0FBTyxDQUFBOzs7O0FBSWpELElBQUksQ0FBQyxHQUFHLEdBQUcsVUFBQyxHQUFHLEVBQUUsUUFBUTtTQUFLLHFCQUFRLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDO0NBQUEsQ0FBQTs7O0FBRzVELElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBUyxNQUFNLEVBQUU7QUFDakMsZ0JBQUssb0ZBQW9GLENBQUMsQ0FBQTtBQUMxRixTQUFPLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO0NBQ3hCLENBQUE7OztBQUdELElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFBOzs7O0FBSW5DLElBQUksT0FBTyxDQUFDLE9BQU8sRUFBRTtBQUNuQixTQUFPLENBQUMsNEJBQTRCLENBQUMsQ0FBQTtDQUN0QyIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IFJhdyBmcm9tICcuL3Jhdyc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCBDbGllbnQgZnJvbSAnLi9jbGllbnQnO1xuXG5pbXBvcnQgbWFrZUNsaWVudCBmcm9tICcuL3V0aWwvbWFrZS1jbGllbnQnO1xuaW1wb3J0IG1ha2VLbmV4IGZyb20gJy4vdXRpbC9tYWtlLWtuZXgnO1xuaW1wb3J0IHBhcnNlQ29ubmVjdGlvbiBmcm9tICcuL3V0aWwvcGFyc2UtY29ubmVjdGlvbic7XG5cbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJ2xvZGFzaCdcblxuLy8gVGhlIGNsaWVudCBuYW1lcyB3ZSdsbCBhbGxvdyBpbiB0aGUgYHtuYW1lOiBsaWJ9YCBwYWlyaW5nLlxuY29uc3QgYWxpYXNlcyA9IHtcbiAgJ21hcmlhZGInICAgOiAnbWFyaWEnLFxuICAnbWFyaWFzcWwnICA6ICdtYXJpYScsXG4gICdwZycgICAgICAgIDogJ3Bvc3RncmVzJyxcbiAgJ3Bvc3RncmVzcWwnOiAncG9zdGdyZXMnLFxuICAnc3FsaXRlJyAgICA6ICdzcWxpdGUzJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gS25leChjb25maWcpIHtcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG5ldyBLbmV4KGFzc2lnbihwYXJzZUNvbm5lY3Rpb24oY29uZmlnKSwgYXJndW1lbnRzWzJdKSlcbiAgfVxuICBsZXQgRGlhbGVjdDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgKCFjb25maWcuY2xpZW50ICYmICFjb25maWcuZGlhbGVjdCkpIHtcbiAgICBEaWFsZWN0ID0gbWFrZUNsaWVudChDbGllbnQpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvbmZpZy5jbGllbnQgPT09ICdmdW5jdGlvbicgJiYgY29uZmlnLmNsaWVudC5wcm90b3R5cGUgaW5zdGFuY2VvZiBDbGllbnQpIHtcbiAgICBEaWFsZWN0ID0gbWFrZUNsaWVudChjb25maWcuY2xpZW50KVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNsaWVudE5hbWUgPSBjb25maWcuY2xpZW50IHx8IGNvbmZpZy5kaWFsZWN0XG4gICAgRGlhbGVjdCA9IG1ha2VDbGllbnQocmVxdWlyZShgLi9kaWFsZWN0cy8ke2FsaWFzZXNbY2xpZW50TmFtZV0gfHwgY2xpZW50TmFtZX0vaW5kZXguanNgKSlcbiAgfVxuICBpZiAodHlwZW9mIGNvbmZpZy5jb25uZWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IGFzc2lnbih7fSwgY29uZmlnLCB7Y29ubmVjdGlvbjogcGFyc2VDb25uZWN0aW9uKGNvbmZpZy5jb25uZWN0aW9uKS5jb25uZWN0aW9ufSlcbiAgfVxuICByZXR1cm4gbWFrZUtuZXgobmV3IERpYWxlY3QoY29uZmlnKSlcbn1cblxuLy8gRXhwb3NlIENsaWVudCBvbiB0aGUgbWFpbiBLbmV4IG5hbWVzcGFjZS5cbktuZXguQ2xpZW50ID0gQ2xpZW50XG5cbi8vIEV4cG9zZSBLbmV4IHZlcnNpb24gb24gdGhlIG1haW4gS25leCBuYW1lc3BhY2UuXG5LbmV4LlZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbi8vIFJ1biBhIFwicmF3XCIgcXVlcnksIHRob3VnaCB3ZSBjYW4ndCBkbyBhbnl0aGluZyB3aXRoIGl0IG90aGVyIHRoYW4gcHV0XG4vLyBpdCBpbiBhIHF1ZXJ5IHN0YXRlbWVudC5cbktuZXgucmF3ID0gKHNxbCwgYmluZGluZ3MpID0+IG5ldyBSYXcoe30pLnNldChzcWwsIGJpbmRpbmdzKVxuXG4vLyBDcmVhdGUgYSBuZXcgXCJrbmV4XCIgaW5zdGFuY2Ugd2l0aCB0aGUgYXBwcm9wcmlhdGUgY29uZmlndXJlZCBjbGllbnQuXG5LbmV4LmluaXRpYWxpemUgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgd2Fybigna25leC5pbml0aWFsaXplIGlzIGRlcHJlY2F0ZWQsIHBhc3MgeW91ciBjb25maWcgb2JqZWN0IGRpcmVjdGx5IHRvIHRoZSBrbmV4IG1vZHVsZScpXG4gIHJldHVybiBuZXcgS25leChjb25maWcpXG59XG5cbi8vIEJsdWViaXJkXG5LbmV4LlByb21pc2UgPSByZXF1aXJlKCcuL3Byb21pc2UnKVxuXG4vLyBEb2luZyB0aGlzIGVuc3VyZXMgQnJvd3NlcmlmeSB3b3Jrcy4gU3RpbGwgbmVlZCB0byBmaWd1cmUgb3V0XG4vLyB0aGUgYmVzdCB3YXkgdG8gZG8gc29tZSBvZiB0aGlzLlxuaWYgKHByb2Nlc3MuYnJvd3Nlcikge1xuICByZXF1aXJlKCcuL2RpYWxlY3RzL3dlYnNxbC9pbmRleC5qcycpXG59XG4iXX0=
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 1 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	(function () {
	  try {
	    cachedSetTimeout = setTimeout;
	  } catch (e) {
	    cachedSetTimeout = function () {
	      throw new Error('setTimeout is not defined');
	    }
	  }
	  try {
	    cachedClearTimeout = clearTimeout;
	  } catch (e) {
	    cachedClearTimeout = function () {
	      throw new Error('clearTimeout is not defined');
	    }
	  }
	} ())
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = cachedSetTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    cachedClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        cachedSetTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	
	// Raw
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _events = __webpack_require__(18);

	var _lodash = __webpack_require__(5);

	var _nodeUuid = __webpack_require__(19);

	var _nodeUuid2 = _interopRequireDefault(_nodeUuid);

	function Raw(client) {
	  this.client = client;

	  this.sql = '';
	  this.bindings = [];
	  this._cached = undefined;

	  // Todo: Deprecate
	  this._wrappedBefore = undefined;
	  this._wrappedAfter = undefined;
	  this._debug = client && client.config && client.config.debug;
	}
	_inherits2['default'](Raw, _events.EventEmitter);

	_lodash.assign(Raw.prototype, {

	  set: function set(sql, bindings) {
	    this._cached = undefined;
	    this.sql = sql;
	    this.bindings = _lodash.isObject(bindings) && !bindings.toSQL || _lodash.isUndefined(bindings) ? bindings : [bindings];

	    return this;
	  },

	  timeout: function timeout(ms) {
	    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var cancel = _ref.cancel;

	    if (_lodash.isNumber(ms) && ms > 0) {
	      this._timeout = ms;
	      if (cancel) {
	        this.client.assertCanCancelQuery();
	        this._cancelOnTimeout = true;
	      }
	    }
	    return this;
	  },

	  // Wraps the current sql with `before` and `after`.
	  wrap: function wrap(before, after) {
	    this._cached = undefined;
	    this._wrappedBefore = before;
	    this._wrappedAfter = after;
	    return this;
	  },

	  // Calls `toString` on the Knex object.
	  toString: function toString() {
	    return this.toQuery();
	  },

	  // Returns the raw sql for the query.
	  toSQL: function toSQL(method, tz) {
	    if (this._cached) return this._cached;
	    if (Array.isArray(this.bindings)) {
	      this._cached = replaceRawArrBindings(this);
	    } else if (this.bindings && _lodash.isPlainObject(this.bindings)) {
	      this._cached = replaceKeyBindings(this);
	    } else {
	      this._cached = {
	        method: 'raw',
	        sql: this.sql,
	        bindings: _lodash.isUndefined(this.bindings) ? void 0 : [this.bindings]
	      };
	    }
	    if (this._wrappedBefore) {
	      this._cached.sql = this._wrappedBefore + this._cached.sql;
	    }
	    if (this._wrappedAfter) {
	      this._cached.sql = this._cached.sql + this._wrappedAfter;
	    }
	    this._cached.options = _lodash.reduce(this._options, _lodash.assign, {});
	    if (this._timeout) {
	      this._cached.timeout = this._timeout;
	      if (this._cancelOnTimeout) {
	        this._cached.cancelOnTimeout = this._cancelOnTimeout;
	      }
	    }
	    if (this.client && this.client.prepBindings) {
	      this._cached.bindings = this._cached.bindings || [];
	      if (helpers.containsUndefined(this._cached.bindings)) {
	        throw new Error('Undefined binding(s) detected when compiling RAW query: ' + this._cached.sql);
	      }
	      this._cached.bindings = this.client.prepBindings(this._cached.bindings, tz);
	    }
	    this._cached.__knexQueryUid = _nodeUuid2['default'].v4();
	    return this._cached;
	  }

	});

	function replaceRawArrBindings(raw) {
	  var expectedBindings = raw.bindings.length;
	  var values = raw.bindings;
	  var client = raw.client;

	  var index = 0;
	  var bindings = [];

	  var sql = raw.sql.replace(/\\?\?\??/g, function (match) {
	    if (match === '\\?') {
	      return match;
	    }

	    var value = values[index++];

	    if (value && typeof value.toSQL === 'function') {
	      var bindingSQL = value.toSQL();
	      bindings = bindings.concat(bindingSQL.bindings);
	      return bindingSQL.sql;
	    }

	    if (match === '??') {
	      return client.formatter().columnize(value);
	    }
	    bindings.push(value);
	    return '?';
	  });

	  if (expectedBindings !== index) {
	    throw new Error('Expected ' + expectedBindings + ' bindings, saw ' + index);
	  }

	  return {
	    method: 'raw',
	    sql: sql,
	    bindings: bindings
	  };
	}

	function replaceKeyBindings(raw) {
	  var values = raw.bindings;
	  var client = raw.client;
	  var sql = raw.sql;var bindings = [];

	  var regex = new RegExp('(\\:\\w+\\:?)', 'g');
	  sql = raw.sql.replace(regex, function (full) {
	    var key = full.trim();
	    var isIdentifier = key[key.length - 1] === ':';
	    var value = isIdentifier ? values[key.slice(1, -1)] : values[key.slice(1)];
	    if (value === undefined) {
	      bindings.push(value);
	      return full;
	    }
	    if (value && typeof value.toSQL === 'function') {
	      var bindingSQL = value.toSQL();
	      bindings = bindings.concat(bindingSQL.bindings);
	      return full.replace(key, bindingSQL.sql);
	    }
	    if (isIdentifier) {
	      return full.replace(key, client.formatter().columnize(value));
	    }
	    bindings.push(value);
	    return full.replace(key, '?');
	  });

	  return {
	    method: 'raw',
	    sql: sql,
	    bindings: bindings
	  };
	}

	// Allow the `Raw` object to be utilized with full access to the relevant
	// promise API.
	__webpack_require__(41)(Raw);

	exports['default'] = Raw;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,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YUFBTyxJQUFJLENBQUM7S0FDYjtBQUNELFFBQUksS0FBSyxJQUFJLE9BQU8sS0FBSyxDQUFDLEtBQUssS0FBSyxVQUFVLEVBQUU7QUFDOUMsVUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFBO0FBQ2hDLGNBQVEsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQTtBQUMvQyxhQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQTtLQUN6QztBQUNELFFBQUksWUFBWSxFQUFFO0FBQ2hCLGFBQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFBO0tBQzlEO0FBQ0QsWUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQTtBQUNwQixXQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFBO0dBQzlCLENBQUMsQ0FBQTs7QUFFRixTQUFPO0FBQ0wsVUFBTSxFQUFFLEtBQUs7QUFDYixPQUFHLEVBQUgsR0FBRztBQUNILFlBQVEsRUFBUixRQUFRO0dBQ1QsQ0FBQTtDQUNGOzs7O0FBSUQsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFBOztxQkFFWixHQUFHIiwiZmlsZSI6InJhdy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLy8gUmF3XG4vLyAtLS0tLS0tXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcblxuaW1wb3J0IHsgYXNzaWduLCByZWR1Y2UsIGlzUGxhaW5PYmplY3QsIGlzT2JqZWN0LCBpc1VuZGVmaW5lZCwgaXNOdW1iZXIgfSBmcm9tICdsb2Rhc2gnXG5cbmltcG9ydCB1dWlkIGZyb20gJ25vZGUtdXVpZCc7XG5cbmZ1bmN0aW9uIFJhdyhjbGllbnQpIHtcbiAgdGhpcy5jbGllbnQgPSBjbGllbnRcblxuICB0aGlzLnNxbCA9ICcnXG4gIHRoaXMuYmluZGluZ3MgPSBbXVxuICB0aGlzLl9jYWNoZWQgPSB1bmRlZmluZWRcblxuICAvLyBUb2RvOiBEZXByZWNhdGVcbiAgdGhpcy5fd3JhcHBlZEJlZm9yZSA9IHVuZGVmaW5lZFxuICB0aGlzLl93cmFwcGVkQWZ0ZXIgPSB1bmRlZmluZWRcbiAgdGhpcy5fZGVidWcgPSBjbGllbnQgJiYgY2xpZW50LmNvbmZpZyAmJiBjbGllbnQuY29uZmlnLmRlYnVnXG59XG5pbmhlcml0cyhSYXcsIEV2ZW50RW1pdHRlcilcblxuYXNzaWduKFJhdy5wcm90b3R5cGUsIHtcblxuICBzZXQoc3FsLCBiaW5kaW5ncykge1xuICAgIHRoaXMuX2NhY2hlZCA9IHVuZGVmaW5lZFxuICAgIHRoaXMuc3FsID0gc3FsXG4gICAgdGhpcy5iaW5kaW5ncyA9IChcbiAgICAgIChpc09iamVjdChiaW5kaW5ncykgJiYgIWJpbmRpbmdzLnRvU1FMKSB8fFxuICAgICAgaXNVbmRlZmluZWQoYmluZGluZ3MpXG4gICAgKSA/IGJpbmRpbmdzIDogW2JpbmRpbmdzXVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcblxuICB0aW1lb3V0KG1zLCB7Y2FuY2VsfSA9IHt9KSB7XG4gICAgaWYoaXNOdW1iZXIobXMpICYmIG1zID4gMCkge1xuICAgICAgdGhpcy5fdGltZW91dCA9IG1zO1xuICAgICAgaWYgKGNhbmNlbCkge1xuICAgICAgICB0aGlzLmNsaWVudC5hc3NlcnRDYW5DYW5jZWxRdWVyeSgpO1xuICAgICAgICB0aGlzLl9jYW5jZWxPblRpbWVvdXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBXcmFwcyB0aGUgY3VycmVudCBzcWwgd2l0aCBgYmVmb3JlYCBhbmQgYGFmdGVyYC5cbiAgd3JhcChiZWZvcmUsIGFmdGVyKSB7XG4gICAgdGhpcy5fY2FjaGVkID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fd3JhcHBlZEJlZm9yZSA9IGJlZm9yZVxuICAgIHRoaXMuX3dyYXBwZWRBZnRlciA9IGFmdGVyXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcblxuICAvLyBDYWxscyBgdG9TdHJpbmdgIG9uIHRoZSBLbmV4IG9iamVjdC5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9RdWVyeSgpXG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgcmF3IHNxbCBmb3IgdGhlIHF1ZXJ5LlxuICB0b1NRTChtZXRob2QsIHR6KSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZCkgcmV0dXJuIHRoaXMuX2NhY2hlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuYmluZGluZ3MpKSB7XG4gICAgICB0aGlzLl9jYWNoZWQgPSByZXBsYWNlUmF3QXJyQmluZGluZ3ModGhpcylcbiAgICB9IGVsc2UgaWYgKHRoaXMuYmluZGluZ3MgJiYgaXNQbGFpbk9iamVjdCh0aGlzLmJpbmRpbmdzKSkge1xuICAgICAgdGhpcy5fY2FjaGVkID0gcmVwbGFjZUtleUJpbmRpbmdzKHRoaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NhY2hlZCA9IHtcbiAgICAgICAgbWV0aG9kOiAncmF3JyxcbiAgICAgICAgc3FsOiB0aGlzLnNxbCxcbiAgICAgICAgYmluZGluZ3M6IGlzVW5kZWZpbmVkKHRoaXMuYmluZGluZ3MpID8gdm9pZCAwIDogW3RoaXMuYmluZGluZ3NdXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl93cmFwcGVkQmVmb3JlKSB7XG4gICAgICB0aGlzLl9jYWNoZWQuc3FsID0gdGhpcy5fd3JhcHBlZEJlZm9yZSArIHRoaXMuX2NhY2hlZC5zcWxcbiAgICB9XG4gICAgaWYgKHRoaXMuX3dyYXBwZWRBZnRlcikge1xuICAgICAgdGhpcy5fY2FjaGVkLnNxbCA9IHRoaXMuX2NhY2hlZC5zcWwgKyB0aGlzLl93cmFwcGVkQWZ0ZXJcbiAgICB9XG4gICAgdGhpcy5fY2FjaGVkLm9wdGlvbnMgPSByZWR1Y2UodGhpcy5fb3B0aW9ucywgYXNzaWduLCB7fSlcbiAgICBpZih0aGlzLl90aW1lb3V0KSB7XG4gICAgICB0aGlzLl9jYWNoZWQudGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gICAgICBpZiAodGhpcy5fY2FuY2VsT25UaW1lb3V0KSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZC5jYW5jZWxPblRpbWVvdXQgPSB0aGlzLl9jYW5jZWxPblRpbWVvdXQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKHRoaXMuY2xpZW50ICYmIHRoaXMuY2xpZW50LnByZXBCaW5kaW5ncykge1xuICAgICAgdGhpcy5fY2FjaGVkLmJpbmRpbmdzID0gdGhpcy5fY2FjaGVkLmJpbmRpbmdzIHx8IFtdO1xuICAgICAgaWYoaGVscGVycy5jb250YWluc1VuZGVmaW5lZCh0aGlzLl9jYWNoZWQuYmluZGluZ3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVW5kZWZpbmVkIGJpbmRpbmcocykgZGV0ZWN0ZWQgd2hlbiBjb21waWxpbmcgUkFXIHF1ZXJ5OiBgICtcbiAgICAgICAgICB0aGlzLl9jYWNoZWQuc3FsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWNoZWQuYmluZGluZ3MgPSB0aGlzLmNsaWVudC5wcmVwQmluZGluZ3ModGhpcy5fY2FjaGVkLmJpbmRpbmdzLCB0eik7XG4gICAgfVxuICAgIHRoaXMuX2NhY2hlZC5fX2tuZXhRdWVyeVVpZCA9IHV1aWQudjQoKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkXG4gIH1cblxufSlcblxuZnVuY3Rpb24gcmVwbGFjZVJhd0FyckJpbmRpbmdzKHJhdykge1xuICBjb25zdCBleHBlY3RlZEJpbmRpbmdzID0gcmF3LmJpbmRpbmdzLmxlbmd0aFxuICBjb25zdCB2YWx1ZXMgPSByYXcuYmluZGluZ3NcbiAgY29uc3QgeyBjbGllbnQgfSA9IHJhd1xuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgYmluZGluZ3MgPSBbXVxuXG4gIGNvbnN0IHNxbCA9IHJhdy5zcWwucmVwbGFjZSgvXFxcXD9cXD9cXD8/L2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKG1hdGNoID09PSAnXFxcXD8nKSB7XG4gICAgICByZXR1cm4gbWF0Y2hcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpbmRleCsrXVxuXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50b1NRTCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgYmluZGluZ1NRTCA9IHZhbHVlLnRvU1FMKClcbiAgICAgIGJpbmRpbmdzID0gYmluZGluZ3MuY29uY2F0KGJpbmRpbmdTUUwuYmluZGluZ3MpXG4gICAgICByZXR1cm4gYmluZGluZ1NRTC5zcWxcbiAgICB9XG5cbiAgICBpZiAobWF0Y2ggPT09ICc/PycpIHtcbiAgICAgIHJldHVybiBjbGllbnQuZm9ybWF0dGVyKCkuY29sdW1uaXplKHZhbHVlKVxuICAgIH1cbiAgICBiaW5kaW5ncy5wdXNoKHZhbHVlKVxuICAgIHJldHVybiAnPydcbiAgfSlcblxuICBpZiAoZXhwZWN0ZWRCaW5kaW5ncyAhPT0gaW5kZXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7ZXhwZWN0ZWRCaW5kaW5nc30gYmluZGluZ3MsIHNhdyAke2luZGV4fWApXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1ldGhvZDogJ3JhdycsXG4gICAgc3FsLFxuICAgIGJpbmRpbmdzXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZUtleUJpbmRpbmdzKHJhdykge1xuICBjb25zdCB2YWx1ZXMgPSByYXcuYmluZGluZ3NcbiAgY29uc3QgeyBjbGllbnQgfSA9IHJhd1xuICBsZXQgeyBzcWwgfSA9IHJhdywgYmluZGluZ3MgPSBbXVxuXG4gIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cCgnKFxcXFw6XFxcXHcrXFxcXDo/KScsICdnJylcbiAgc3FsID0gcmF3LnNxbC5yZXBsYWNlKHJlZ2V4LCBmdW5jdGlvbihmdWxsKSB7XG4gICAgY29uc3Qga2V5ID0gZnVsbC50cmltKCk7XG4gICAgY29uc3QgaXNJZGVudGlmaWVyID0ga2V5W2tleS5sZW5ndGggLSAxXSA9PT0gJzonXG4gICAgY29uc3QgdmFsdWUgPSBpc0lkZW50aWZpZXIgPyB2YWx1ZXNba2V5LnNsaWNlKDEsIC0xKV0gOiB2YWx1ZXNba2V5LnNsaWNlKDEpXVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBiaW5kaW5ncy5wdXNoKHZhbHVlKTtcbiAgICAgIHJldHVybiBmdWxsO1xuICAgIH1cbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRvU1FMID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBiaW5kaW5nU1FMID0gdmFsdWUudG9TUUwoKVxuICAgICAgYmluZGluZ3MgPSBiaW5kaW5ncy5jb25jYXQoYmluZGluZ1NRTC5iaW5kaW5ncylcbiAgICAgIHJldHVybiBmdWxsLnJlcGxhY2Uoa2V5LCBiaW5kaW5nU1FMLnNxbClcbiAgICB9XG4gICAgaWYgKGlzSWRlbnRpZmllcikge1xuICAgICAgcmV0dXJuIGZ1bGwucmVwbGFjZShrZXksIGNsaWVudC5mb3JtYXR0ZXIoKS5jb2x1bW5pemUodmFsdWUpKVxuICAgIH1cbiAgICBiaW5kaW5ncy5wdXNoKHZhbHVlKVxuICAgIHJldHVybiBmdWxsLnJlcGxhY2Uoa2V5LCAnPycpXG4gIH0pXG5cbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6ICdyYXcnLFxuICAgIHNxbCxcbiAgICBiaW5kaW5nc1xuICB9XG59XG5cbi8vIEFsbG93IHRoZSBgUmF3YCBvYmplY3QgdG8gYmUgdXRpbGl6ZWQgd2l0aCBmdWxsIGFjY2VzcyB0byB0aGUgcmVsZXZhbnRcbi8vIHByb21pc2UgQVBJLlxucmVxdWlyZSgnLi9pbnRlcmZhY2UnKShSYXcpXG5cbmV4cG9ydCBkZWZhdWx0IFJhd1xuIl19

/***/ },
/* 3 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/* eslint no-console:0 */

	'use strict';

	exports.__esModule = true;
	exports.skim = skim;
	exports.normalizeArr = normalizeArr;
	exports.debugLog = debugLog;
	exports.error = error;
	exports.deprecate = deprecate;
	exports.warn = warn;
	exports.exit = exit;
	exports.containsUndefined = containsUndefined;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _lodash = __webpack_require__(5);

	var _chalk = __webpack_require__(6);

	var _chalk2 = _interopRequireDefault(_chalk);

	// Pick off the attributes from only the current layer of the object.

	function skim(data) {
	  return _lodash.map(data, function (obj) {
	    return _lodash.pick(obj, _lodash.keys(obj));
	  });
	}

	// Check if the first argument is an array, otherwise uses all arguments as an
	// array.

	function normalizeArr() {
	  var args = new Array(arguments.length);
	  for (var i = 0; i < args.length; i++) {
	    args[i] = arguments[i];
	  }
	  if (Array.isArray(args[0])) {
	    return args[0];
	  }
	  return args;
	}

	function debugLog(msg) {
	  console.log(msg);
	}

	function error(msg) {
	  console.log(_chalk2['default'].red('Knex:Error ' + msg));
	}

	// Used to signify deprecated functionality.

	function deprecate(method, alternate) {
	  warn(method + ' is deprecated, please use ' + alternate);
	}

	// Used to warn about incorrect use, without error'ing

	function warn(msg) {
	  console.log(_chalk2['default'].yellow('Knex:warning - ' + msg));
	}

	function exit(msg) {
	  console.log(_chalk2['default'].red(msg));
	  process.exit(1);
	}

	function containsUndefined(mixed) {
	  var argContainsUndefined = false;

	  if (mixed && _lodash.isFunction(mixed.toSQL)) {
	    //Any QueryBuilder or Raw will automatically be validated during compile.
	    return argContainsUndefined;
	  }

	  if (_lodash.isArray(mixed)) {
	    for (var i = 0; i < mixed.length; i++) {
	      if (argContainsUndefined) break;
	      argContainsUndefined = this.containsUndefined(mixed[i]);
	    }
	  } else if (_lodash.isObject(mixed)) {
	    for (var key in mixed) {
	      if (argContainsUndefined) break;
	      argContainsUndefined = this.containsUndefined(mixed[key]);
	    }
	  } else {
	    argContainsUndefined = _lodash.isUndefined(mixed);
	  }

	  return argContainsUndefined;
	}
	//# sourceMappingURL=data:application/json;base64,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XG5cbmltcG9ydCB7IG1hcCwgcGljaywga2V5cywgaXNGdW5jdGlvbiwgaXNVbmRlZmluZWQsIGlzT2JqZWN0LCBpc0FycmF5IH0gZnJvbSAnbG9kYXNoJ1xuaW1wb3J0IGNoYWxrIGZyb20gJ2NoYWxrJztcblxuLy8gUGljayBvZmYgdGhlIGF0dHJpYnV0ZXMgZnJvbSBvbmx5IHRoZSBjdXJyZW50IGxheWVyIG9mIHRoZSBvYmplY3QuXG5leHBvcnQgZnVuY3Rpb24gc2tpbShkYXRhKSB7XG4gIHJldHVybiBtYXAoZGF0YSwgKG9iaikgPT4gcGljayhvYmosIGtleXMob2JqKSkpO1xufVxuXG4vLyBDaGVjayBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYW4gYXJyYXksIG90aGVyd2lzZSB1c2VzIGFsbCBhcmd1bWVudHMgYXMgYW5cbi8vIGFycmF5LlxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUFycigpIHtcbiAgY29uc3QgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgIHJldHVybiBhcmdzWzBdO1xuICB9XG4gIHJldHVybiBhcmdzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVidWdMb2cobXNnKSB7XG4gIGNvbnNvbGUubG9nKG1zZyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgY29uc29sZS5sb2coY2hhbGsucmVkKGBLbmV4OkVycm9yICR7bXNnfWApKVxufVxuXG4gIC8vIFVzZWQgdG8gc2lnbmlmeSBkZXByZWNhdGVkIGZ1bmN0aW9uYWxpdHkuXG5leHBvcnQgZnVuY3Rpb24gZGVwcmVjYXRlKG1ldGhvZCwgYWx0ZXJuYXRlKSB7XG4gIHdhcm4oYCR7bWV0aG9kfSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlICR7YWx0ZXJuYXRlfWApO1xufVxuXG4gIC8vIFVzZWQgdG8gd2FybiBhYm91dCBpbmNvcnJlY3QgdXNlLCB3aXRob3V0IGVycm9yJ2luZ1xuZXhwb3J0IGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gIGNvbnNvbGUubG9nKGNoYWxrLnllbGxvdyhgS25leDp3YXJuaW5nIC0gJHttc2d9YCkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleGl0KG1zZykge1xuICBjb25zb2xlLmxvZyhjaGFsay5yZWQobXNnKSlcbiAgcHJvY2Vzcy5leGl0KDEpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc1VuZGVmaW5lZChtaXhlZCkge1xuICBsZXQgYXJnQ29udGFpbnNVbmRlZmluZWQgPSBmYWxzZTtcblxuICBpZihtaXhlZCAmJiBpc0Z1bmN0aW9uKG1peGVkLnRvU1FMKSkge1xuICAgIC8vQW55IFF1ZXJ5QnVpbGRlciBvciBSYXcgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHZhbGlkYXRlZCBkdXJpbmcgY29tcGlsZS5cbiAgICByZXR1cm4gYXJnQ29udGFpbnNVbmRlZmluZWQ7XG4gIH1cblxuICBpZihpc0FycmF5KG1peGVkKSkge1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBtaXhlZC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYoYXJnQ29udGFpbnNVbmRlZmluZWQpIGJyZWFrO1xuICAgICAgYXJnQ29udGFpbnNVbmRlZmluZWQgPSB0aGlzLmNvbnRhaW5zVW5kZWZpbmVkKG1peGVkW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZihpc09iamVjdChtaXhlZCkpIHtcbiAgICBmb3IoY29uc3Qga2V5IGluIG1peGVkKSB7XG4gICAgICBpZihhcmdDb250YWluc1VuZGVmaW5lZCkgYnJlYWs7XG4gICAgICBhcmdDb250YWluc1VuZGVmaW5lZCA9IHRoaXMuY29udGFpbnNVbmRlZmluZWQobWl4ZWRba2V5XSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFyZ0NvbnRhaW5zVW5kZWZpbmVkID0gaXNVbmRlZmluZWQobWl4ZWQpO1xuICB9XG5cbiAgcmV0dXJuIGFyZ0NvbnRhaW5zVW5kZWZpbmVkO1xufSJdfQ==
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_5__;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	var escapeStringRegexp = __webpack_require__(7);
	var ansiStyles = __webpack_require__(8);
	var stripAnsi = __webpack_require__(14);
	var hasAnsi = __webpack_require__(16);
	var supportsColor = __webpack_require__(17);
	var defineProps = Object.defineProperties;
	var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);

	function Chalk(options) {
		// detect mode if not set manually
		this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
	}

	// use bright blue on Windows as the normal blue color is illegible
	if (isSimpleWindowsTerm) {
		ansiStyles.blue.open = '\u001b[94m';
	}

	var styles = (function () {
		var ret = {};

		Object.keys(ansiStyles).forEach(function (key) {
			ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

			ret[key] = {
				get: function () {
					return build.call(this, this._styles.concat(key));
				}
			};
		});

		return ret;
	})();

	var proto = defineProps(function chalk() {}, styles);

	function build(_styles) {
		var builder = function () {
			return applyStyle.apply(builder, arguments);
		};

		builder._styles = _styles;
		builder.enabled = this.enabled;
		// __proto__ is used because we must return a function, but there is
		// no way to create a function with a different prototype.
		/* eslint-disable no-proto */
		builder.__proto__ = proto;

		return builder;
	}

	function applyStyle() {
		// support varags, but simply cast to string in case there's only one arg
		var args = arguments;
		var argsLen = args.length;
		var str = argsLen !== 0 && String(arguments[0]);

		if (argsLen > 1) {
			// don't slice `arguments`, it prevents v8 optimizations
			for (var a = 1; a < argsLen; a++) {
				str += ' ' + args[a];
			}
		}

		if (!this.enabled || !str) {
			return str;
		}

		var nestedStyles = this._styles;
		var i = nestedStyles.length;

		// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
		// see https://github.com/chalk/chalk/issues/58
		// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
		var originalDim = ansiStyles.dim.open;
		if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
			ansiStyles.dim.open = '';
		}

		while (i--) {
			var code = ansiStyles[nestedStyles[i]];

			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			str = code.open + str.replace(code.closeRe, code.open) + code.close;
		}

		// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
		ansiStyles.dim.open = originalDim;

		return str;
	}

	function init() {
		var ret = {};

		Object.keys(styles).forEach(function (name) {
			ret[name] = {
				get: function () {
					return build.call(this, [name]);
				}
			};
		});

		return ret;
	}

	defineProps(Chalk.prototype, init());

	module.exports = new Chalk();
	module.exports.styles = ansiStyles;
	module.exports.hasColor = hasAnsi;
	module.exports.stripColor = stripAnsi;
	module.exports.supportsColor = supportsColor;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 7 */
/***/ function(module, exports) {

	'use strict';

	var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

	module.exports = function (str) {
		if (typeof str !== 'string') {
			throw new TypeError('Expected a string');
		}

		return str.replace(matchOperatorsRe, '\\$&');
	};


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {'use strict';
	var colorConvert = __webpack_require__(10);

	function wrapAnsi16(fn, offset) {
		return function () {
			var code = fn.apply(colorConvert, arguments);
			return '\u001b[' + (code + offset) + 'm';
		};
	}

	function wrapAnsi256(fn, offset) {
		return function () {
			var code = fn.apply(colorConvert, arguments);
			return '\u001b[' + (38 + offset) + ';5;' + code + 'm';
		};
	}

	function wrapAnsi16m(fn, offset) {
		return function () {
			var rgb = fn.apply(colorConvert, arguments);
			return '\u001b[' + (38 + offset) + ';2;' +
				rgb[0] + ';' + rgb[1] + ';' + rgb[2] + 'm';
		};
	}

	function assembleStyles() {
		var styles = {
			modifier: {
				reset: [0, 0],
				// 21 isn't widely supported and 22 does the same thing
				bold: [1, 22],
				dim: [2, 22],
				italic: [3, 23],
				underline: [4, 24],
				inverse: [7, 27],
				hidden: [8, 28],
				strikethrough: [9, 29]
			},
			color: {
				black: [30, 39],
				red: [31, 39],
				green: [32, 39],
				yellow: [33, 39],
				blue: [34, 39],
				magenta: [35, 39],
				cyan: [36, 39],
				white: [37, 39],
				gray: [90, 39]
			},
			bgColor: {
				bgBlack: [40, 49],
				bgRed: [41, 49],
				bgGreen: [42, 49],
				bgYellow: [43, 49],
				bgBlue: [44, 49],
				bgMagenta: [45, 49],
				bgCyan: [46, 49],
				bgWhite: [47, 49]
			}
		};

		// fix humans
		styles.color.grey = styles.color.gray;

		Object.keys(styles).forEach(function (groupName) {
			var group = styles[groupName];

			Object.keys(group).forEach(function (styleName) {
				var style = group[styleName];

				styles[styleName] = group[styleName] = {
					open: '\u001b[' + style[0] + 'm',
					close: '\u001b[' + style[1] + 'm'
				};
			});

			Object.defineProperty(styles, groupName, {
				value: group,
				enumerable: false
			});
		});

		function rgb2rgb(r, g, b) {
			return [r, g, b];
		}

		styles.color.close = '\u001b[39m';
		styles.bgColor.close = '\u001b[49m';

		styles.color.ansi = {};
		styles.color.ansi256 = {};
		styles.color.ansi16m = {
			rgb: wrapAnsi16m(rgb2rgb, 0)
		};

		styles.bgColor.ansi = {};
		styles.bgColor.ansi256 = {};
		styles.bgColor.ansi16m = {
			rgb: wrapAnsi16m(rgb2rgb, 10)
		};

		for (var key in colorConvert) {
			if (!colorConvert.hasOwnProperty(key) || typeof colorConvert[key] !== 'object') {
				continue;
			}

			var suite = colorConvert[key];

			if ('ansi16' in suite) {
				styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
				styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
			}

			if ('ansi256' in suite) {
				styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
				styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
			}

			if ('rgb' in suite) {
				styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
				styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
			}
		}

		return styles;
	}

	Object.defineProperty(module, 'exports', {
		enumerable: true,
		get: assembleStyles
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)(module)))

/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var conversions = __webpack_require__(11);
	var route = __webpack_require__(13);

	var convert = {};

	var models = Object.keys(conversions);

	function wrapRaw(fn) {
		var wrappedFn = function (args) {
			if (args === undefined || args === null) {
				return args;
			}

			if (arguments.length > 1) {
				args = Array.prototype.slice.call(arguments);
			}

			return fn(args);
		};

		// preserve .conversion property if there is one
		if ('conversion' in fn) {
			wrappedFn.conversion = fn.conversion;
		}

		return wrappedFn;
	}

	function wrapRounded(fn) {
		var wrappedFn = function (args) {
			if (args === undefined || args === null) {
				return args;
			}

			if (arguments.length > 1) {
				args = Array.prototype.slice.call(arguments);
			}

			var result = fn(args);

			// we're assuming the result is an array here.
			// see notice in conversions.js; don't use box types
			// in conversion functions.
			if (typeof result === 'object') {
				for (var len = result.length, i = 0; i < len; i++) {
					result[i] = Math.round(result[i]);
				}
			}

			return result;
		};

		// preserve .conversion property if there is one
		if ('conversion' in fn) {
			wrappedFn.conversion = fn.conversion;
		}

		return wrappedFn;
	}

	models.forEach(function (fromModel) {
		convert[fromModel] = {};

		var routes = route(fromModel);
		var routeModels = Object.keys(routes);

		routeModels.forEach(function (toModel) {
			var fn = routes[toModel];

			convert[fromModel][toModel] = wrapRounded(fn);
			convert[fromModel][toModel].raw = wrapRaw(fn);
		});
	});

	module.exports = convert;


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* MIT license */
	var cssKeywords = __webpack_require__(12);

	// NOTE: conversions should only return primitive values (i.e. arrays, or
	//       values that give correct `typeof` results).
	//       do not use box values types (i.e. Number(), String(), etc.)

	var reverseKeywords = {};
	for (var key in cssKeywords) {
		if (cssKeywords.hasOwnProperty(key)) {
			reverseKeywords[cssKeywords[key].join()] = key;
		}
	}

	var convert = module.exports = {
		rgb: {},
		hsl: {},
		hsv: {},
		hwb: {},
		cmyk: {},
		xyz: {},
		lab: {},
		lch: {},
		hex: {},
		keyword: {},
		ansi16: {},
		ansi256: {}
	};

	convert.rgb.hsl = function (rgb) {
		var r = rgb[0] / 255;
		var g = rgb[1] / 255;
		var b = rgb[2] / 255;
		var min = Math.min(r, g, b);
		var max = Math.max(r, g, b);
		var delta = max - min;
		var h;
		var s;
		var l;

		if (max === min) {
			h = 0;
		} else if (r === max) {
			h = (g - b) / delta;
		} else if (g === max) {
			h = 2 + (b - r) / delta;
		} else if (b === max) {
			h = 4 + (r - g) / delta;
		}

		h = Math.min(h * 60, 360);

		if (h < 0) {
			h += 360;
		}

		l = (min + max) / 2;

		if (max === min) {
			s = 0;
		} else if (l <= 0.5) {
			s = delta / (max + min);
		} else {
			s = delta / (2 - max - min);
		}

		return [h, s * 100, l * 100];
	};

	convert.rgb.hsv = function (rgb) {
		var r = rgb[0];
		var g = rgb[1];
		var b = rgb[2];
		var min = Math.min(r, g, b);
		var max = Math.max(r, g, b);
		var delta = max - min;
		var h;
		var s;
		var v;

		if (max === 0) {
			s = 0;
		} else {
			s = (delta / max * 1000) / 10;
		}

		if (max === min) {
			h = 0;
		} else if (r === max) {
			h = (g - b) / delta;
		} else if (g === max) {
			h = 2 + (b - r) / delta;
		} else if (b === max) {
			h = 4 + (r - g) / delta;
		}

		h = Math.min(h * 60, 360);

		if (h < 0) {
			h += 360;
		}

		v = ((max / 255) * 1000) / 10;

		return [h, s, v];
	};

	convert.rgb.hwb = function (rgb) {
		var r = rgb[0];
		var g = rgb[1];
		var b = rgb[2];
		var h = convert.rgb.hsl(rgb)[0];
		var w = 1 / 255 * Math.min(r, Math.min(g, b));

		b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

		return [h, w * 100, b * 100];
	};

	convert.rgb.cmyk = function (rgb) {
		var r = rgb[0] / 255;
		var g = rgb[1] / 255;
		var b = rgb[2] / 255;
		var c;
		var m;
		var y;
		var k;

		k = Math.min(1 - r, 1 - g, 1 - b);
		c = (1 - r - k) / (1 - k) || 0;
		m = (1 - g - k) / (1 - k) || 0;
		y = (1 - b - k) / (1 - k) || 0;

		return [c * 100, m * 100, y * 100, k * 100];
	};

	convert.rgb.keyword = function (rgb) {
		return reverseKeywords[rgb.join()];
	};

	convert.keyword.rgb = function (keyword) {
		return cssKeywords[keyword];
	};

	convert.rgb.xyz = function (rgb) {
		var r = rgb[0] / 255;
		var g = rgb[1] / 255;
		var b = rgb[2] / 255;

		// assume sRGB
		r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
		g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
		b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

		var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
		var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
		var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

		return [x * 100, y * 100, z * 100];
	};

	convert.rgb.lab = function (rgb) {
		var xyz = convert.rgb.xyz(rgb);
		var x = xyz[0];
		var y = xyz[1];
		var z = xyz[2];
		var l;
		var a;
		var b;

		x /= 95.047;
		y /= 100;
		z /= 108.883;

		x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
		y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
		z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

		l = (116 * y) - 16;
		a = 500 * (x - y);
		b = 200 * (y - z);

		return [l, a, b];
	};

	convert.hsl.rgb = function (hsl) {
		var h = hsl[0] / 360;
		var s = hsl[1] / 100;
		var l = hsl[2] / 100;
		var t1;
		var t2;
		var t3;
		var rgb;
		var val;

		if (s === 0) {
			val = l * 255;
			return [val, val, val];
		}

		if (l < 0.5) {
			t2 = l * (1 + s);
		} else {
			t2 = l + s - l * s;
		}

		t1 = 2 * l - t2;

		rgb = [0, 0, 0];
		for (var i = 0; i < 3; i++) {
			t3 = h + 1 / 3 * -(i - 1);
			if (t3 < 0) {
				t3++;
			}
			if (t3 > 1) {
				t3--;
			}

			if (6 * t3 < 1) {
				val = t1 + (t2 - t1) * 6 * t3;
			} else if (2 * t3 < 1) {
				val = t2;
			} else if (3 * t3 < 2) {
				val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
			} else {
				val = t1;
			}

			rgb[i] = val * 255;
		}

		return rgb;
	};

	convert.hsl.hsv = function (hsl) {
		var h = hsl[0];
		var s = hsl[1] / 100;
		var l = hsl[2] / 100;
		var sv;
		var v;

		if (l === 0) {
			// no need to do calc on black
			// also avoids divide by 0 error
			return [0, 0, 0];
		}

		l *= 2;
		s *= (l <= 1) ? l : 2 - l;
		v = (l + s) / 2;
		sv = (2 * s) / (l + s);

		return [h, sv * 100, v * 100];
	};

	convert.hsv.rgb = function (hsv) {
		var h = hsv[0] / 60;
		var s = hsv[1] / 100;
		var v = hsv[2] / 100;
		var hi = Math.floor(h) % 6;

		var f = h - Math.floor(h);
		var p = 255 * v * (1 - s);
		var q = 255 * v * (1 - (s * f));
		var t = 255 * v * (1 - (s * (1 - f)));
		v *= 255;

		switch (hi) {
			case 0:
				return [v, t, p];
			case 1:
				return [q, v, p];
			case 2:
				return [p, v, t];
			case 3:
				return [p, q, v];
			case 4:
				return [t, p, v];
			case 5:
				return [v, p, q];
		}
	};

	convert.hsv.hsl = function (hsv) {
		var h = hsv[0];
		var s = hsv[1] / 100;
		var v = hsv[2] / 100;
		var sl;
		var l;

		l = (2 - s) * v;
		sl = s * v;
		sl /= (l <= 1) ? l : 2 - l;
		sl = sl || 0;
		l /= 2;

		return [h, sl * 100, l * 100];
	};

	// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
	convert.hwb.rgb = function (hwb) {
		var h = hwb[0] / 360;
		var wh = hwb[1] / 100;
		var bl = hwb[2] / 100;
		var ratio = wh + bl;
		var i;
		var v;
		var f;
		var n;

		// wh + bl cant be > 1
		if (ratio > 1) {
			wh /= ratio;
			bl /= ratio;
		}

		i = Math.floor(6 * h);
		v = 1 - bl;
		f = 6 * h - i;

		if ((i & 0x01) !== 0) {
			f = 1 - f;
		}

		n = wh + f * (v - wh); // linear interpolation

		var r;
		var g;
		var b;
		switch (i) {
			default:
			case 6:
			case 0: r = v; g = n; b = wh; break;
			case 1: r = n; g = v; b = wh; break;
			case 2: r = wh; g = v; b = n; break;
			case 3: r = wh; g = n; b = v; break;
			case 4: r = n; g = wh; b = v; break;
			case 5: r = v; g = wh; b = n; break;
		}

		return [r * 255, g * 255, b * 255];
	};

	convert.cmyk.rgb = function (cmyk) {
		var c = cmyk[0] / 100;
		var m = cmyk[1] / 100;
		var y = cmyk[2] / 100;
		var k = cmyk[3] / 100;
		var r;
		var g;
		var b;

		r = 1 - Math.min(1, c * (1 - k) + k);
		g = 1 - Math.min(1, m * (1 - k) + k);
		b = 1 - Math.min(1, y * (1 - k) + k);

		return [r * 255, g * 255, b * 255];
	};

	convert.xyz.rgb = function (xyz) {
		var x = xyz[0] / 100;
		var y = xyz[1] / 100;
		var z = xyz[2] / 100;
		var r;
		var g;
		var b;

		r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
		g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
		b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

		// assume sRGB
		r = r > 0.0031308
			? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
			: r *= 12.92;

		g = g > 0.0031308
			? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
			: g *= 12.92;

		b = b > 0.0031308
			? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
			: b *= 12.92;

		r = Math.min(Math.max(0, r), 1);
		g = Math.min(Math.max(0, g), 1);
		b = Math.min(Math.max(0, b), 1);

		return [r * 255, g * 255, b * 255];
	};

	convert.xyz.lab = function (xyz) {
		var x = xyz[0];
		var y = xyz[1];
		var z = xyz[2];
		var l;
		var a;
		var b;

		x /= 95.047;
		y /= 100;
		z /= 108.883;

		x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
		y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
		z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

		l = (116 * y) - 16;
		a = 500 * (x - y);
		b = 200 * (y - z);

		return [l, a, b];
	};

	convert.lab.xyz = function (lab) {
		var l = lab[0];
		var a = lab[1];
		var b = lab[2];
		var x;
		var y;
		var z;
		var y2;

		if (l <= 8) {
			y = (l * 100) / 903.3;
			y2 = (7.787 * (y / 100)) + (16 / 116);
		} else {
			y = 100 * Math.pow((l + 16) / 116, 3);
			y2 = Math.pow(y / 100, 1 / 3);
		}

		x = x / 95.047 <= 0.008856
			? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787
			: 95.047 * Math.pow((a / 500) + y2, 3);
		z = z / 108.883 <= 0.008859
			? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787
			: 108.883 * Math.pow(y2 - (b / 200), 3);

		return [x, y, z];
	};

	convert.lab.lch = function (lab) {
		var l = lab[0];
		var a = lab[1];
		var b = lab[2];
		var hr;
		var h;
		var c;

		hr = Math.atan2(b, a);
		h = hr * 360 / 2 / Math.PI;

		if (h < 0) {
			h += 360;
		}

		c = Math.sqrt(a * a + b * b);

		return [l, c, h];
	};

	convert.lch.lab = function (lch) {
		var l = lch[0];
		var c = lch[1];
		var h = lch[2];
		var a;
		var b;
		var hr;

		hr = h / 360 * 2 * Math.PI;
		a = c * Math.cos(hr);
		b = c * Math.sin(hr);

		return [l, a, b];
	};

	convert.rgb.ansi16 = function (args) {
		var r = args[0];
		var g = args[1];
		var b = args[2];
		var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

		value = Math.round(value / 50);

		if (value === 0) {
			return 30;
		}

		var ansi = 30
			+ ((Math.round(b / 255) << 2)
			| (Math.round(g / 255) << 1)
			| Math.round(r / 255));

		if (value === 2) {
			ansi += 60;
		}

		return ansi;
	};

	convert.hsv.ansi16 = function (args) {
		// optimization here; we already know the value and don't need to get
		// it converted for us.
		return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
	};

	convert.rgb.ansi256 = function (args) {
		var r = args[0];
		var g = args[1];
		var b = args[2];

		// we use the extended greyscale palette here, with the exception of
		// black and white. normal palette only has 4 greyscale shades.
		if (r === g && g === b) {
			if (r < 8) {
				return 16;
			}

			if (r > 248) {
				return 231;
			}

			return Math.round(((r - 8) / 247) * 24) + 232;
		}

		var ansi = 16
			+ (36 * Math.round(r / 255 * 5))
			+ (6 * Math.round(g / 255 * 5))
			+ Math.round(b / 255 * 5);

		return ansi;
	};

	convert.ansi16.rgb = function (args) {
		var color = args % 10;

		// handle greyscale
		if (color === 0 || color === 7) {
			if (args > 50) {
				color += 3.5;
			}

			color = color / 10.5 * 255;

			return [color, color, color];
		}

		var mult = (~~(args > 50) + 1) * 0.5;
		var r = ((color & 1) * mult) * 255;
		var g = (((color >> 1) & 1) * mult) * 255;
		var b = (((color >> 2) & 1) * mult) * 255;

		return [r, g, b];
	};

	convert.ansi256.rgb = function (args) {
		// handle greyscale
		if (args >= 232) {
			var c = (args - 232) * 10 + 8;
			return [c, c, c];
		}

		args -= 16;

		var rem;
		var r = Math.floor(args / 36) / 5 * 255;
		var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
		var b = (rem % 6) / 5 * 255;

		return [r, g, b];
	};

	convert.rgb.hex = function (args) {
		var integer = ((Math.round(args[0]) & 0xFF) << 16)
			+ ((Math.round(args[1]) & 0xFF) << 8)
			+ (Math.round(args[2]) & 0xFF);

		var string = integer.toString(16).toUpperCase();
		return '000000'.substring(string.length) + string;
	};

	convert.hex.rgb = function (args) {
		var match = args.toString(16).match(/[a-f0-9]{6}/i);
		if (!match) {
			return [0, 0, 0];
		}

		var integer = parseInt(match[0], 16);
		var r = (integer >> 16) & 0xFF;
		var g = (integer >> 8) & 0xFF;
		var b = integer & 0xFF;

		return [r, g, b];
	};


/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = {
		aliceblue: [240, 248, 255],
		antiquewhite: [250, 235, 215],
		aqua: [0, 255, 255],
		aquamarine: [127, 255, 212],
		azure: [240, 255, 255],
		beige: [245, 245, 220],
		bisque: [255, 228, 196],
		black: [0, 0, 0],
		blanchedalmond: [255, 235, 205],
		blue: [0, 0, 255],
		blueviolet: [138, 43, 226],
		brown: [165, 42, 42],
		burlywood: [222, 184, 135],
		cadetblue: [95, 158, 160],
		chartreuse: [127, 255, 0],
		chocolate: [210, 105, 30],
		coral: [255, 127, 80],
		cornflowerblue: [100, 149, 237],
		cornsilk: [255, 248, 220],
		crimson: [220, 20, 60],
		cyan: [0, 255, 255],
		darkblue: [0, 0, 139],
		darkcyan: [0, 139, 139],
		darkgoldenrod: [184, 134, 11],
		darkgray: [169, 169, 169],
		darkgreen: [0, 100, 0],
		darkgrey: [169, 169, 169],
		darkkhaki: [189, 183, 107],
		darkmagenta: [139, 0, 139],
		darkolivegreen: [85, 107, 47],
		darkorange: [255, 140, 0],
		darkorchid: [153, 50, 204],
		darkred: [139, 0, 0],
		darksalmon: [233, 150, 122],
		darkseagreen: [143, 188, 143],
		darkslateblue: [72, 61, 139],
		darkslategray: [47, 79, 79],
		darkslategrey: [47, 79, 79],
		darkturquoise: [0, 206, 209],
		darkviolet: [148, 0, 211],
		deeppink: [255, 20, 147],
		deepskyblue: [0, 191, 255],
		dimgray: [105, 105, 105],
		dimgrey: [105, 105, 105],
		dodgerblue: [30, 144, 255],
		firebrick: [178, 34, 34],
		floralwhite: [255, 250, 240],
		forestgreen: [34, 139, 34],
		fuchsia: [255, 0, 255],
		gainsboro: [220, 220, 220],
		ghostwhite: [248, 248, 255],
		gold: [255, 215, 0],
		goldenrod: [218, 165, 32],
		gray: [128, 128, 128],
		green: [0, 128, 0],
		greenyellow: [173, 255, 47],
		grey: [128, 128, 128],
		honeydew: [240, 255, 240],
		hotpink: [255, 105, 180],
		indianred: [205, 92, 92],
		indigo: [75, 0, 130],
		ivory: [255, 255, 240],
		khaki: [240, 230, 140],
		lavender: [230, 230, 250],
		lavenderblush: [255, 240, 245],
		lawngreen: [124, 252, 0],
		lemonchiffon: [255, 250, 205],
		lightblue: [173, 216, 230],
		lightcoral: [240, 128, 128],
		lightcyan: [224, 255, 255],
		lightgoldenrodyellow: [250, 250, 210],
		lightgray: [211, 211, 211],
		lightgreen: [144, 238, 144],
		lightgrey: [211, 211, 211],
		lightpink: [255, 182, 193],
		lightsalmon: [255, 160, 122],
		lightseagreen: [32, 178, 170],
		lightskyblue: [135, 206, 250],
		lightslategray: [119, 136, 153],
		lightslategrey: [119, 136, 153],
		lightsteelblue: [176, 196, 222],
		lightyellow: [255, 255, 224],
		lime: [0, 255, 0],
		limegreen: [50, 205, 50],
		linen: [250, 240, 230],
		magenta: [255, 0, 255],
		maroon: [128, 0, 0],
		mediumaquamarine: [102, 205, 170],
		mediumblue: [0, 0, 205],
		mediumorchid: [186, 85, 211],
		mediumpurple: [147, 112, 219],
		mediumseagreen: [60, 179, 113],
		mediumslateblue: [123, 104, 238],
		mediumspringgreen: [0, 250, 154],
		mediumturquoise: [72, 209, 204],
		mediumvioletred: [199, 21, 133],
		midnightblue: [25, 25, 112],
		mintcream: [245, 255, 250],
		mistyrose: [255, 228, 225],
		moccasin: [255, 228, 181],
		navajowhite: [255, 222, 173],
		navy: [0, 0, 128],
		oldlace: [253, 245, 230],
		olive: [128, 128, 0],
		olivedrab: [107, 142, 35],
		orange: [255, 165, 0],
		orangered: [255, 69, 0],
		orchid: [218, 112, 214],
		palegoldenrod: [238, 232, 170],
		palegreen: [152, 251, 152],
		paleturquoise: [175, 238, 238],
		palevioletred: [219, 112, 147],
		papayawhip: [255, 239, 213],
		peachpuff: [255, 218, 185],
		peru: [205, 133, 63],
		pink: [255, 192, 203],
		plum: [221, 160, 221],
		powderblue: [176, 224, 230],
		purple: [128, 0, 128],
		rebeccapurple: [102, 51, 153],
		red: [255, 0, 0],
		rosybrown: [188, 143, 143],
		royalblue: [65, 105, 225],
		saddlebrown: [139, 69, 19],
		salmon: [250, 128, 114],
		sandybrown: [244, 164, 96],
		seagreen: [46, 139, 87],
		seashell: [255, 245, 238],
		sienna: [160, 82, 45],
		silver: [192, 192, 192],
		skyblue: [135, 206, 235],
		slateblue: [106, 90, 205],
		slategray: [112, 128, 144],
		slategrey: [112, 128, 144],
		snow: [255, 250, 250],
		springgreen: [0, 255, 127],
		steelblue: [70, 130, 180],
		tan: [210, 180, 140],
		teal: [0, 128, 128],
		thistle: [216, 191, 216],
		tomato: [255, 99, 71],
		turquoise: [64, 224, 208],
		violet: [238, 130, 238],
		wheat: [245, 222, 179],
		white: [255, 255, 255],
		whitesmoke: [245, 245, 245],
		yellow: [255, 255, 0],
		yellowgreen: [154, 205, 50]
	};



/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var conversions = __webpack_require__(11);

	/*
		this function routes a model to all other models.

		all functions that are routed have a property `.conversion` attached
		to the returned synthetic function. This property is an array
		of strings, each with the steps in between the 'from' and 'to'
		color models (inclusive).

		conversions that are not possible simply are not included.
	*/

	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	var models = Object.keys(conversions);

	function buildGraph() {
		var graph = {};

		for (var len = models.length, i = 0; i < len; i++) {
			graph[models[i]] = {
				// http://jsperf.com/1-vs-infinity
				// micro-opt, but this is simple.
				distance: -1,
				parent: null
			};
		}

		return graph;
	}

	// https://en.wikipedia.org/wiki/Breadth-first_search
	function deriveBFS(fromModel) {
		var graph = buildGraph();
		var queue = [fromModel]; // unshift -> queue -> pop

		graph[fromModel].distance = 0;

		while (queue.length) {
			var current = queue.pop();
			var adjacents = Object.keys(conversions[current]);

			for (var len = adjacents.length, i = 0; i < len; i++) {
				var adjacent = adjacents[i];
				var node = graph[adjacent];

				if (node.distance === -1) {
					node.distance = graph[current].distance + 1;
					node.parent = current;
					queue.unshift(adjacent);
				}
			}
		}

		return graph;
	}

	function link(from, to) {
		return function (args) {
			return to(from(args));
		};
	}

	function wrapConversion(toModel, graph) {
		var path = [graph[toModel].parent, toModel];
		var fn = conversions[graph[toModel].parent][toModel];

		var cur = graph[toModel].parent;
		while (graph[cur].parent) {
			path.unshift(graph[cur].parent);
			fn = link(conversions[graph[cur].parent][cur], fn);
			cur = graph[cur].parent;
		}

		fn.conversion = path;
		return fn;
	}

	module.exports = function (fromModel) {
		var graph = deriveBFS(fromModel);
		var conversion = {};

		var models = Object.keys(graph);
		for (var len = models.length, i = 0; i < len; i++) {
			var toModel = models[i];
			var node = graph[toModel];

			if (node.parent === null) {
				// no possible conversion, or this node is the source model.
				continue;
			}

			conversion[toModel] = wrapConversion(toModel, graph);
		}

		return conversion;
	};



/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ansiRegex = __webpack_require__(15)();

	module.exports = function (str) {
		return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
	};


/***/ },
/* 15 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function () {
		return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
	};


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ansiRegex = __webpack_require__(15);
	var re = new RegExp(ansiRegex().source); // remove the `g` flag
	module.exports = re.test.bind(re);


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	var argv = process.argv;

	var terminator = argv.indexOf('--');
	var hasFlag = function (flag) {
		flag = '--' + flag;
		var pos = argv.indexOf(flag);
		return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
	};

	module.exports = (function () {
		if ('FORCE_COLOR' in process.env) {
			return true;
		}

		if (hasFlag('no-color') ||
			hasFlag('no-colors') ||
			hasFlag('color=false')) {
			return false;
		}

		if (hasFlag('color') ||
			hasFlag('colors') ||
			hasFlag('color=true') ||
			hasFlag('color=always')) {
			return true;
		}

		if (process.stdout && !process.stdout.isTTY) {
			return false;
		}

		if (process.platform === 'win32') {
			return true;
		}

		if ('COLORTERM' in process.env) {
			return true;
		}

		if (process.env.TERM === 'dumb') {
			return false;
		}

		if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
			return true;
		}

		return false;
	})();

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 18 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(Buffer) {//     uuid.js
	//
	//     Copyright (c) 2010-2012 Robert Kieffer
	//     MIT License - http://opensource.org/licenses/mit-license.php

	/*global window, require, define */
	(function(_window) {
	  'use strict';

	  // Unique ID creation requires a high quality random # generator.  We feature
	  // detect to determine the best RNG source, normalizing to a function that
	  // returns 128-bits of randomness, since that's what's usually required
	  var _rng, _mathRNG, _nodeRNG, _whatwgRNG, _previousRoot;

	  function setupBrowser() {
	    // Allow for MSIE11 msCrypto
	    var _crypto = _window.crypto || _window.msCrypto;

	    if (!_rng && _crypto && _crypto.getRandomValues) {
	      // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
	      //
	      // Moderately fast, high quality
	      try {
	        var _rnds8 = new Uint8Array(16);
	        _whatwgRNG = _rng = function whatwgRNG() {
	          _crypto.getRandomValues(_rnds8);
	          return _rnds8;
	        };
	        _rng();
	      } catch(e) {}
	    }

	    if (!_rng) {
	      // Math.random()-based (RNG)
	      //
	      // If all else fails, use Math.random().  It's fast, but is of unspecified
	      // quality.
	      var  _rnds = new Array(16);
	      _mathRNG = _rng = function() {
	        for (var i = 0, r; i < 16; i++) {
	          if ((i & 0x03) === 0) { r = Math.random() * 0x100000000; }
	          _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
	        }

	        return _rnds;
	      };
	      if ('undefined' !== typeof console && console.warn) {
	        console.warn("[SECURITY] node-uuid: crypto not usable, falling back to insecure Math.random()");
	      }
	    }
	  }

	  function setupNode() {
	    // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
	    //
	    // Moderately fast, high quality
	    if (true) {
	      try {
	        var _rb = __webpack_require__(24).randomBytes;
	        _nodeRNG = _rng = _rb && function() {return _rb(16);};
	        _rng();
	      } catch(e) {}
	    }
	  }

	  if (_window) {
	    setupBrowser();
	  } else {
	    setupNode();
	  }

	  // Buffer class to use
	  var BufferClass = ('function' === typeof Buffer) ? Buffer : Array;

	  // Maps for number <-> hex string conversion
	  var _byteToHex = [];
	  var _hexToByte = {};
	  for (var i = 0; i < 256; i++) {
	    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
	    _hexToByte[_byteToHex[i]] = i;
	  }

	  // **`parse()` - Parse a UUID into it's component bytes**
	  function parse(s, buf, offset) {
	    var i = (buf && offset) || 0, ii = 0;

	    buf = buf || [];
	    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
	      if (ii < 16) { // Don't overflow!
	        buf[i + ii++] = _hexToByte[oct];
	      }
	    });

	    // Zero out remaining bytes if string was short
	    while (ii < 16) {
	      buf[i + ii++] = 0;
	    }

	    return buf;
	  }

	  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
	  function unparse(buf, offset) {
	    var i = offset || 0, bth = _byteToHex;
	    return  bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]];
	  }

	  // **`v1()` - Generate time-based UUID**
	  //
	  // Inspired by https://github.com/LiosK/UUID.js
	  // and http://docs.python.org/library/uuid.html

	  // random #'s we need to init node and clockseq
	  var _seedBytes = _rng();

	  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
	  var _nodeId = [
	    _seedBytes[0] | 0x01,
	    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
	  ];

	  // Per 4.2.2, randomize (14 bit) clockseq
	  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

	  // Previous uuid creation time
	  var _lastMSecs = 0, _lastNSecs = 0;

	  // See https://github.com/broofa/node-uuid for API details
	  function v1(options, buf, offset) {
	    var i = buf && offset || 0;
	    var b = buf || [];

	    options = options || {};

	    var clockseq = (options.clockseq != null) ? options.clockseq : _clockseq;

	    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
	    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
	    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
	    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
	    var msecs = (options.msecs != null) ? options.msecs : new Date().getTime();

	    // Per 4.2.1.2, use count of uuid's generated during the current clock
	    // cycle to simulate higher resolution clock
	    var nsecs = (options.nsecs != null) ? options.nsecs : _lastNSecs + 1;

	    // Time since last uuid creation (in msecs)
	    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

	    // Per 4.2.1.2, Bump clockseq on clock regression
	    if (dt < 0 && options.clockseq == null) {
	      clockseq = clockseq + 1 & 0x3fff;
	    }

	    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
	    // time interval
	    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
	      nsecs = 0;
	    }

	    // Per 4.2.1.2 Throw error if too many uuids are requested
	    if (nsecs >= 10000) {
	      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
	    }

	    _lastMSecs = msecs;
	    _lastNSecs = nsecs;
	    _clockseq = clockseq;

	    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
	    msecs += 12219292800000;

	    // `time_low`
	    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
	    b[i++] = tl >>> 24 & 0xff;
	    b[i++] = tl >>> 16 & 0xff;
	    b[i++] = tl >>> 8 & 0xff;
	    b[i++] = tl & 0xff;

	    // `time_mid`
	    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
	    b[i++] = tmh >>> 8 & 0xff;
	    b[i++] = tmh & 0xff;

	    // `time_high_and_version`
	    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
	    b[i++] = tmh >>> 16 & 0xff;

	    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
	    b[i++] = clockseq >>> 8 | 0x80;

	    // `clock_seq_low`
	    b[i++] = clockseq & 0xff;

	    // `node`
	    var node = options.node || _nodeId;
	    for (var n = 0; n < 6; n++) {
	      b[i + n] = node[n];
	    }

	    return buf ? buf : unparse(b);
	  }

	  // **`v4()` - Generate random UUID**

	  // See https://github.com/broofa/node-uuid for API details
	  function v4(options, buf, offset) {
	    // Deprecated - 'format' argument, as supported in v1.2
	    var i = buf && offset || 0;

	    if (typeof(options) === 'string') {
	      buf = (options === 'binary') ? new BufferClass(16) : null;
	      options = null;
	    }
	    options = options || {};

	    var rnds = options.random || (options.rng || _rng)();

	    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
	    rnds[6] = (rnds[6] & 0x0f) | 0x40;
	    rnds[8] = (rnds[8] & 0x3f) | 0x80;

	    // Copy bytes to buffer, if provided
	    if (buf) {
	      for (var ii = 0; ii < 16; ii++) {
	        buf[i + ii] = rnds[ii];
	      }
	    }

	    return buf || unparse(rnds);
	  }

	  // Export public API
	  var uuid = v4;
	  uuid.v1 = v1;
	  uuid.v4 = v4;
	  uuid.parse = parse;
	  uuid.unparse = unparse;
	  uuid.BufferClass = BufferClass;
	  uuid._rng = _rng;
	  uuid._mathRNG = _mathRNG;
	  uuid._nodeRNG = _nodeRNG;
	  uuid._whatwgRNG = _whatwgRNG;

	  if (('undefined' !== typeof module) && module.exports) {
	    // Publish as node.js module
	    module.exports = uuid;
	  } else if (true) {
	    // Publish as AMD module
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {return uuid;}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


	  } else {
	    // Publish as global (in browsers)
	    _previousRoot = _window.uuid;

	    // **`noConflict()` - (browser only) to reset global 'uuid' var**
	    uuid.noConflict = function() {
	      _window.uuid = _previousRoot;
	      return uuid;
	    };

	    _window.uuid = uuid;
	  }
	})('undefined' !== typeof window ? window : null);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20).Buffer))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	'use strict'

	var base64 = __webpack_require__(21)
	var ieee754 = __webpack_require__(22)
	var isArray = __webpack_require__(23)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation

	var rootParent = {}

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }

	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }

	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }

	  // Unusual.
	  return fromObject(this, arg)
	}

	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)

	  that.write(string, encoding)
	  return that
	}

	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

	  if (isArray(object)) return fromArray(that, object)

	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }

	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }

	  if (object.length) return fromArrayLike(that, object)

	  return fromJsonObject(that, object)
	}

	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}

	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}

	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0

	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)

	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}

	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }

	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent

	  return that
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break

	    ++i
	  }

	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

	  if (list.length === 0) {
	    return new Buffer(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }

	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}

	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0

	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'binary':
	        return binarySlice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0

	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1

	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }

	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}

	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'binary':
	        return binaryWrite(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  if (newBuf.length) newBuf.parent = this.parent || this

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }

	  return len
	}

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length

	  if (end < start) throw new RangeError('end < start')

	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return

	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }

	  return this
	}

	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}

	// HELPER FUNCTIONS
	// ================

	var BP = Buffer.prototype

	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true

	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set

	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set

	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer

	  return arr
	}

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20).Buffer, (function() { return this; }())))

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array

		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)

		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}

		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length

			var L = 0

			function push (v) {
				arr[L++] = v
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}

			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}

			return arr
		}

		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length

			function encode (num) {
				return lookup.charAt(num)
			}

			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}

			return output
		}

		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 22 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 23 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var rng = __webpack_require__(25)

	function error () {
	  var m = [].slice.call(arguments).join(' ')
	  throw new Error([
	    m,
	    'we accept pull requests',
	    'http://github.com/dominictarr/crypto-browserify'
	    ].join('\n'))
	}

	exports.createHash = __webpack_require__(27)

	exports.createHmac = __webpack_require__(38)

	exports.randomBytes = function(size, callback) {
	  if (callback && callback.call) {
	    try {
	      callback.call(this, undefined, new Buffer(rng(size)))
	    } catch (err) { callback(err) }
	  } else {
	    return new Buffer(rng(size))
	  }
	}

	function each(a, f) {
	  for(var i in a)
	    f(a[i], i)
	}

	exports.getHashes = function () {
	  return ['sha1', 'sha256', 'sha512', 'md5', 'rmd160']
	}

	var p = __webpack_require__(39)(exports)
	exports.pbkdf2 = p.pbkdf2
	exports.pbkdf2Sync = p.pbkdf2Sync


	// the least I can do is make error messages for the rest of the node.js/crypto api.
	each(['createCredentials'
	, 'createCipher'
	, 'createCipheriv'
	, 'createDecipher'
	, 'createDecipheriv'
	, 'createSign'
	, 'createVerify'
	, 'createDiffieHellman'
	], function (name) {
	  exports[name] = function () {
	    error('sorry,', name, 'is not implemented yet')
	  }
	})

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20).Buffer))

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer) {(function() {
	  var g = ('undefined' === typeof window ? global : window) || {}
	  _crypto = (
	    g.crypto || g.msCrypto || __webpack_require__(26)
	  )
	  module.exports = function(size) {
	    // Modern Browsers
	    if(_crypto.getRandomValues) {
	      var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
	      /* This will not work in older browsers.
	       * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	       */
	    
	      _crypto.getRandomValues(bytes);
	      return bytes;
	    }
	    else if (_crypto.randomBytes) {
	      return _crypto.randomBytes(size)
	    }
	    else
	      throw new Error(
	        'secure random number generation not supported by this browser\n'+
	        'use chrome, FireFox or Internet Explorer 11'
	      )
	  }
	}())

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(20).Buffer))

/***/ },
/* 26 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(28)

	var md5 = toConstructor(__webpack_require__(35))
	var rmd160 = toConstructor(__webpack_require__(37))

	function toConstructor (fn) {
	  return function () {
	    var buffers = []
	    var m= {
	      update: function (data, enc) {
	        if(!Buffer.isBuffer(data)) data = new Buffer(data, enc)
	        buffers.push(data)
	        return this
	      },
	      digest: function (enc) {
	        var buf = Buffer.concat(buffers)
	        var r = fn(buf)
	        buffers = null
	        return enc ? r.toString(enc) : r
	      }
	    }
	    return m
	  }
	}

	module.exports = function (alg) {
	  if('md5' === alg) return new md5()
	  if('rmd160' === alg) return new rmd160()
	  return createHash(alg)
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20).Buffer))

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var exports = module.exports = function (alg) {
	  var Alg = exports[alg]
	  if(!Alg) throw new Error(alg + ' is not supported (we accept pull requests)')
	  return new Alg()
	}

	var Buffer = __webpack_require__(20).Buffer
	var Hash   = __webpack_require__(29)(Buffer)

	exports.sha1 = __webpack_require__(30)(Buffer, Hash)
	exports.sha256 = __webpack_require__(33)(Buffer, Hash)
	exports.sha512 = __webpack_require__(34)(Buffer, Hash)


/***/ },
/* 29 */
/***/ function(module, exports) {

	module.exports = function (Buffer) {

	  //prototype class for hash functions
	  function Hash (blockSize, finalSize) {
	    this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)
	    this._finalSize = finalSize
	    this._blockSize = blockSize
	    this._len = 0
	    this._s = 0
	  }

	  Hash.prototype.init = function () {
	    this._s = 0
	    this._len = 0
	  }

	  Hash.prototype.update = function (data, enc) {
	    if ("string" === typeof data) {
	      enc = enc || "utf8"
	      data = new Buffer(data, enc)
	    }

	    var l = this._len += data.length
	    var s = this._s = (this._s || 0)
	    var f = 0
	    var buffer = this._block

	    while (s < l) {
	      var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
	      var ch = (t - f)

	      for (var i = 0; i < ch; i++) {
	        buffer[(s % this._blockSize) + i] = data[i + f]
	      }

	      s += ch
	      f += ch

	      if ((s % this._blockSize) === 0) {
	        this._update(buffer)
	      }
	    }
	    this._s = s

	    return this
	  }

	  Hash.prototype.digest = function (enc) {
	    // Suppose the length of the message M, in bits, is l
	    var l = this._len * 8

	    // Append the bit 1 to the end of the message
	    this._block[this._len % this._blockSize] = 0x80

	    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
	    this._block.fill(0, this._len % this._blockSize + 1)

	    if (l % (this._blockSize * 8) >= this._finalSize * 8) {
	      this._update(this._block)
	      this._block.fill(0)
	    }

	    // to this append the block which is equal to the number l written in binary
	    // TODO: handle case where l is > Math.pow(2, 29)
	    this._block.writeInt32BE(l, this._blockSize - 4)

	    var hash = this._update(this._block) || this._hash()

	    return enc ? hash.toString(enc) : hash
	  }

	  Hash.prototype._update = function () {
	    throw new Error('_update must be implemented by subclass')
	  }

	  return Hash
	}


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */

	var inherits = __webpack_require__(31).inherits

	module.exports = function (Buffer, Hash) {

	  var A = 0|0
	  var B = 4|0
	  var C = 8|0
	  var D = 12|0
	  var E = 16|0

	  var W = new (typeof Int32Array === 'undefined' ? Array : Int32Array)(80)

	  var POOL = []

	  function Sha1 () {
	    if(POOL.length)
	      return POOL.pop().init()

	    if(!(this instanceof Sha1)) return new Sha1()
	    this._w = W
	    Hash.call(this, 16*4, 14*4)

	    this._h = null
	    this.init()
	  }

	  inherits(Sha1, Hash)

	  Sha1.prototype.init = function () {
	    this._a = 0x67452301
	    this._b = 0xefcdab89
	    this._c = 0x98badcfe
	    this._d = 0x10325476
	    this._e = 0xc3d2e1f0

	    Hash.prototype.init.call(this)
	    return this
	  }

	  Sha1.prototype._POOL = POOL
	  Sha1.prototype._update = function (X) {

	    var a, b, c, d, e, _a, _b, _c, _d, _e

	    a = _a = this._a
	    b = _b = this._b
	    c = _c = this._c
	    d = _d = this._d
	    e = _e = this._e

	    var w = this._w

	    for(var j = 0; j < 80; j++) {
	      var W = w[j] = j < 16 ? X.readInt32BE(j*4)
	        : rol(w[j - 3] ^ w[j -  8] ^ w[j - 14] ^ w[j - 16], 1)

	      var t = add(
	        add(rol(a, 5), sha1_ft(j, b, c, d)),
	        add(add(e, W), sha1_kt(j))
	      )

	      e = d
	      d = c
	      c = rol(b, 30)
	      b = a
	      a = t
	    }

	    this._a = add(a, _a)
	    this._b = add(b, _b)
	    this._c = add(c, _c)
	    this._d = add(d, _d)
	    this._e = add(e, _e)
	  }

	  Sha1.prototype._hash = function () {
	    if(POOL.length < 100) POOL.push(this)
	    var H = new Buffer(20)
	    //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)
	    H.writeInt32BE(this._a|0, A)
	    H.writeInt32BE(this._b|0, B)
	    H.writeInt32BE(this._c|0, C)
	    H.writeInt32BE(this._d|0, D)
	    H.writeInt32BE(this._e|0, E)
	    return H
	  }

	  /*
	   * Perform the appropriate triplet combination function for the current
	   * iteration
	   */
	  function sha1_ft(t, b, c, d) {
	    if(t < 20) return (b & c) | ((~b) & d);
	    if(t < 40) return b ^ c ^ d;
	    if(t < 60) return (b & c) | (b & d) | (c & d);
	    return b ^ c ^ d;
	  }

	  /*
	   * Determine the appropriate additive constant for the current iteration
	   */
	  function sha1_kt(t) {
	    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
	           (t < 60) ? -1894007588 : -899497514;
	  }

	  /*
	   * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	   * to work around bugs in some JS interpreters.
	   * //dominictarr: this is 10 years old, so maybe this can be dropped?)
	   *
	   */
	  function add(x, y) {
	    return (x + y ) | 0
	  //lets see how this goes on testling.
	  //  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  //  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  //  return (msw << 16) | (lsw & 0xFFFF);
	  }

	  /*
	   * Bitwise rotate a 32-bit number to the left.
	   */
	  function rol(num, cnt) {
	    return (num << cnt) | (num >>> (32 - cnt));
	  }

	  return Sha1
	}


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(32);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(3);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(1)))

/***/ },
/* 32 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */

	var inherits = __webpack_require__(31).inherits

	module.exports = function (Buffer, Hash) {

	  var K = [
	      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	    ]

	  var W = new Array(64)

	  function Sha256() {
	    this.init()

	    this._w = W //new Array(64)

	    Hash.call(this, 16*4, 14*4)
	  }

	  inherits(Sha256, Hash)

	  Sha256.prototype.init = function () {

	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0

	    this._len = this._s = 0

	    return this
	  }

	  function S (X, n) {
	    return (X >>> n) | (X << (32 - n));
	  }

	  function R (X, n) {
	    return (X >>> n);
	  }

	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }

	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }

	  function Sigma0256 (x) {
	    return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
	  }

	  function Sigma1256 (x) {
	    return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
	  }

	  function Gamma0256 (x) {
	    return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
	  }

	  function Gamma1256 (x) {
	    return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
	  }

	  Sha256.prototype._update = function(M) {

	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var T1, T2

	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0

	    for (var j = 0; j < 64; j++) {
	      var w = W[j] = j < 16
	        ? M.readInt32BE(j * 4)
	        : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16]

	      T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w

	      T2 = Sigma0256(a) + Maj(a, b, c);
	      h = g; g = f; f = e; e = d + T1; d = c; c = b; b = a; a = T1 + T2;
	    }

	    this._a = (a + this._a) | 0
	    this._b = (b + this._b) | 0
	    this._c = (c + this._c) | 0
	    this._d = (d + this._d) | 0
	    this._e = (e + this._e) | 0
	    this._f = (f + this._f) | 0
	    this._g = (g + this._g) | 0
	    this._h = (h + this._h) | 0

	  };

	  Sha256.prototype._hash = function () {
	    var H = new Buffer(32)

	    H.writeInt32BE(this._a,  0)
	    H.writeInt32BE(this._b,  4)
	    H.writeInt32BE(this._c,  8)
	    H.writeInt32BE(this._d, 12)
	    H.writeInt32BE(this._e, 16)
	    H.writeInt32BE(this._f, 20)
	    H.writeInt32BE(this._g, 24)
	    H.writeInt32BE(this._h, 28)

	    return H
	  }

	  return Sha256

	}


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(31).inherits

	module.exports = function (Buffer, Hash) {
	  var K = [
	    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	  ]

	  var W = new Array(160)

	  function Sha512() {
	    this.init()
	    this._w = W

	    Hash.call(this, 128, 112)
	  }

	  inherits(Sha512, Hash)

	  Sha512.prototype.init = function () {

	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0

	    this._al = 0xf3bcc908|0
	    this._bl = 0x84caa73b|0
	    this._cl = 0xfe94f82b|0
	    this._dl = 0x5f1d36f1|0
	    this._el = 0xade682d1|0
	    this._fl = 0x2b3e6c1f|0
	    this._gl = 0xfb41bd6b|0
	    this._hl = 0x137e2179|0

	    this._len = this._s = 0

	    return this
	  }

	  function S (X, Xl, n) {
	    return (X >>> n) | (Xl << (32 - n))
	  }

	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }

	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }

	  Sha512.prototype._update = function(M) {

	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var al, bl, cl, dl, el, fl, gl, hl

	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0

	    al = this._al | 0
	    bl = this._bl | 0
	    cl = this._cl | 0
	    dl = this._dl | 0
	    el = this._el | 0
	    fl = this._fl | 0
	    gl = this._gl | 0
	    hl = this._hl | 0

	    for (var i = 0; i < 80; i++) {
	      var j = i * 2

	      var Wi, Wil

	      if (i < 16) {
	        Wi = W[j] = M.readInt32BE(j * 4)
	        Wil = W[j + 1] = M.readInt32BE(j * 4 + 4)

	      } else {
	        var x  = W[j - 15*2]
	        var xl = W[j - 15*2 + 1]
	        var gamma0  = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
	        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)

	        x  = W[j - 2*2]
	        xl = W[j - 2*2 + 1]
	        var gamma1  = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
	        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)

	        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	        var Wi7  = W[j - 7*2]
	        var Wi7l = W[j - 7*2 + 1]

	        var Wi16  = W[j - 16*2]
	        var Wi16l = W[j - 16*2 + 1]

	        Wil = gamma0l + Wi7l
	        Wi  = gamma0  + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
	        Wil = Wil + gamma1l
	        Wi  = Wi  + gamma1  + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
	        Wil = Wil + Wi16l
	        Wi  = Wi  + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)

	        W[j] = Wi
	        W[j + 1] = Wil
	      }

	      var maj = Maj(a, b, c)
	      var majl = Maj(al, bl, cl)

	      var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
	      var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
	      var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
	      var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)

	      // t1 = h + sigma1 + ch + K[i] + W[i]
	      var Ki = K[j]
	      var Kil = K[j + 1]

	      var ch = Ch(e, f, g)
	      var chl = Ch(el, fl, gl)

	      var t1l = hl + sigma1l
	      var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
	      t1l = t1l + chl
	      t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
	      t1l = t1l + Kil
	      t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
	      t1l = t1l + Wil
	      t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)

	      // t2 = sigma0 + maj
	      var t2l = sigma0l + majl
	      var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)

	      h  = g
	      hl = gl
	      g  = f
	      gl = fl
	      f  = e
	      fl = el
	      el = (dl + t1l) | 0
	      e  = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	      d  = c
	      dl = cl
	      c  = b
	      cl = bl
	      b  = a
	      bl = al
	      al = (t1l + t2l) | 0
	      a  = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0
	    }

	    this._al = (this._al + al) | 0
	    this._bl = (this._bl + bl) | 0
	    this._cl = (this._cl + cl) | 0
	    this._dl = (this._dl + dl) | 0
	    this._el = (this._el + el) | 0
	    this._fl = (this._fl + fl) | 0
	    this._gl = (this._gl + gl) | 0
	    this._hl = (this._hl + hl) | 0

	    this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
	    this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
	    this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
	    this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	    this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
	    this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
	    this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
	    this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
	  }

	  Sha512.prototype._hash = function () {
	    var H = new Buffer(64)

	    function writeInt64BE(h, l, offset) {
	      H.writeInt32BE(h, offset)
	      H.writeInt32BE(l, offset + 4)
	    }

	    writeInt64BE(this._a, this._al, 0)
	    writeInt64BE(this._b, this._bl, 8)
	    writeInt64BE(this._c, this._cl, 16)
	    writeInt64BE(this._d, this._dl, 24)
	    writeInt64BE(this._e, this._el, 32)
	    writeInt64BE(this._f, this._fl, 40)
	    writeInt64BE(this._g, this._gl, 48)
	    writeInt64BE(this._h, this._hl, 56)

	    return H
	  }

	  return Sha512

	}


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */

	var helpers = __webpack_require__(36);

	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length
	 */
	function core_md5(x, len)
	{
	  /* append padding */
	  x[len >> 5] |= 0x80 << ((len) % 32);
	  x[(((len + 64) >>> 9) << 4) + 14] = len;

	  var a =  1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d =  271733878;

	  for(var i = 0; i < x.length; i += 16)
	  {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;

	    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
	    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
	    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
	    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
	    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
	    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
	    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
	    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
	    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
	    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
	    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
	    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
	    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
	    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
	    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
	    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

	    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
	    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
	    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
	    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
	    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
	    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
	    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
	    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
	    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
	    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
	    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
	    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
	    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
	    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
	    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
	    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

	    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
	    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
	    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
	    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
	    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
	    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
	    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
	    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
	    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
	    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
	    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
	    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
	    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
	    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
	    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
	    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

	    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
	    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
	    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
	    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
	    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
	    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
	    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
	    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
	    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
	    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
	    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
	    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
	    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
	    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
	    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
	    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	  }
	  return Array(a, b, c, d);

	}

	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t)
	{
	  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
	}
	function md5_ff(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t)
	{
	  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t)
	{
	  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	}

	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return (msw << 16) | (lsw & 0xFFFF);
	}

	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt)
	{
	  return (num << cnt) | (num >>> (32 - cnt));
	}

	module.exports = function md5(buf) {
	  return helpers.hash(buf, core_md5, 16);
	};


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var intSize = 4;
	var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
	var chrsz = 8;

	function toArray(buf, bigEndian) {
	  if ((buf.length % intSize) !== 0) {
	    var len = buf.length + (intSize - (buf.length % intSize));
	    buf = Buffer.concat([buf, zeroBuffer], len);
	  }

	  var arr = [];
	  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
	  for (var i = 0; i < buf.length; i += intSize) {
	    arr.push(fn.call(buf, i));
	  }
	  return arr;
	}

	function toBuffer(arr, size, bigEndian) {
	  var buf = new Buffer(size);
	  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
	  for (var i = 0; i < arr.length; i++) {
	    fn.call(buf, arr[i], i * 4, true);
	  }
	  return buf;
	}

	function hash(buf, fn, hashSize, bigEndian) {
	  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
	  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
	  return toBuffer(arr, hashSize, bigEndian);
	}

	module.exports = { hash: hash };

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20).Buffer))

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	module.exports = ripemd160



	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/** @preserve
	(c) 2012 by Cdric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	// Constants table
	var zl = [
	    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13];
	var zr = [
	    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11];
	var sl = [
	     11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	    7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	      11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ];
	var sr = [
	    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ];

	var hl =  [ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
	var hr =  [ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];

	var bytesToWords = function (bytes) {
	  var words = [];
	  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
	    words[b >>> 5] |= bytes[i] << (24 - b % 32);
	  }
	  return words;
	};

	var wordsToBytes = function (words) {
	  var bytes = [];
	  for (var b = 0; b < words.length * 32; b += 8) {
	    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	  }
	  return bytes;
	};

	var processBlock = function (H, M, offset) {

	  // Swap endian
	  for (var i = 0; i < 16; i++) {
	    var offset_i = offset + i;
	    var M_offset_i = M[offset_i];

	    // Swap
	    M[offset_i] = (
	        (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	        (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	    );
	  }

	  // Working variables
	  var al, bl, cl, dl, el;
	  var ar, br, cr, dr, er;

	  ar = al = H[0];
	  br = bl = H[1];
	  cr = cl = H[2];
	  dr = dl = H[3];
	  er = el = H[4];
	  // Computation
	  var t;
	  for (var i = 0; i < 80; i += 1) {
	    t = (al +  M[offset+zl[i]])|0;
	    if (i<16){
	        t +=  f1(bl,cl,dl) + hl[0];
	    } else if (i<32) {
	        t +=  f2(bl,cl,dl) + hl[1];
	    } else if (i<48) {
	        t +=  f3(bl,cl,dl) + hl[2];
	    } else if (i<64) {
	        t +=  f4(bl,cl,dl) + hl[3];
	    } else {// if (i<80) {
	        t +=  f5(bl,cl,dl) + hl[4];
	    }
	    t = t|0;
	    t =  rotl(t,sl[i]);
	    t = (t+el)|0;
	    al = el;
	    el = dl;
	    dl = rotl(cl, 10);
	    cl = bl;
	    bl = t;

	    t = (ar + M[offset+zr[i]])|0;
	    if (i<16){
	        t +=  f5(br,cr,dr) + hr[0];
	    } else if (i<32) {
	        t +=  f4(br,cr,dr) + hr[1];
	    } else if (i<48) {
	        t +=  f3(br,cr,dr) + hr[2];
	    } else if (i<64) {
	        t +=  f2(br,cr,dr) + hr[3];
	    } else {// if (i<80) {
	        t +=  f1(br,cr,dr) + hr[4];
	    }
	    t = t|0;
	    t =  rotl(t,sr[i]) ;
	    t = (t+er)|0;
	    ar = er;
	    er = dr;
	    dr = rotl(cr, 10);
	    cr = br;
	    br = t;
	  }
	  // Intermediate hash value
	  t    = (H[1] + cl + dr)|0;
	  H[1] = (H[2] + dl + er)|0;
	  H[2] = (H[3] + el + ar)|0;
	  H[3] = (H[4] + al + br)|0;
	  H[4] = (H[0] + bl + cr)|0;
	  H[0] =  t;
	};

	function f1(x, y, z) {
	  return ((x) ^ (y) ^ (z));
	}

	function f2(x, y, z) {
	  return (((x)&(y)) | ((~x)&(z)));
	}

	function f3(x, y, z) {
	  return (((x) | (~(y))) ^ (z));
	}

	function f4(x, y, z) {
	  return (((x) & (z)) | ((y)&(~(z))));
	}

	function f5(x, y, z) {
	  return ((x) ^ ((y) |(~(z))));
	}

	function rotl(x,n) {
	  return (x<<n) | (x>>>(32-n));
	}

	function ripemd160(message) {
	  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];

	  if (typeof message == 'string')
	    message = new Buffer(message, 'utf8');

	  var m = bytesToWords(message);

	  var nBitsLeft = message.length * 8;
	  var nBitsTotal = message.length * 8;

	  // Add padding
	  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	  );

	  for (var i=0 ; i<m.length; i += 16) {
	    processBlock(H, m, i);
	  }

	  // Swap endian
	  for (var i = 0; i < 5; i++) {
	      // Shortcut
	    var H_i = H[i];

	    // Swap
	    H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	          (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	  }

	  var digestbytes = wordsToBytes(H);
	  return new Buffer(digestbytes);
	}



	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20).Buffer))

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(27)

	var zeroBuffer = new Buffer(128)
	zeroBuffer.fill(0)

	module.exports = Hmac

	function Hmac (alg, key) {
	  if(!(this instanceof Hmac)) return new Hmac(alg, key)
	  this._opad = opad
	  this._alg = alg

	  var blocksize = (alg === 'sha512') ? 128 : 64

	  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key

	  if(key.length > blocksize) {
	    key = createHash(alg).update(key).digest()
	  } else if(key.length < blocksize) {
	    key = Buffer.concat([key, zeroBuffer], blocksize)
	  }

	  var ipad = this._ipad = new Buffer(blocksize)
	  var opad = this._opad = new Buffer(blocksize)

	  for(var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36
	    opad[i] = key[i] ^ 0x5C
	  }

	  this._hash = createHash(alg).update(ipad)
	}

	Hmac.prototype.update = function (data, enc) {
	  this._hash.update(data, enc)
	  return this
	}

	Hmac.prototype.digest = function (enc) {
	  var h = this._hash.digest()
	  return createHash(this._alg).update(this._opad).update(h).digest(enc)
	}


	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20).Buffer))

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var pbkdf2Export = __webpack_require__(40)

	module.exports = function (crypto, exports) {
	  exports = exports || {}

	  var exported = pbkdf2Export(crypto)

	  exports.pbkdf2 = exported.pbkdf2
	  exports.pbkdf2Sync = exported.pbkdf2Sync

	  return exports
	}


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function(crypto) {
	  function pbkdf2(password, salt, iterations, keylen, digest, callback) {
	    if ('function' === typeof digest) {
	      callback = digest
	      digest = undefined
	    }

	    if ('function' !== typeof callback)
	      throw new Error('No callback provided to pbkdf2')

	    setTimeout(function() {
	      var result

	      try {
	        result = pbkdf2Sync(password, salt, iterations, keylen, digest)
	      } catch (e) {
	        return callback(e)
	      }

	      callback(undefined, result)
	    })
	  }

	  function pbkdf2Sync(password, salt, iterations, keylen, digest) {
	    if ('number' !== typeof iterations)
	      throw new TypeError('Iterations not a number')

	    if (iterations < 0)
	      throw new TypeError('Bad iterations')

	    if ('number' !== typeof keylen)
	      throw new TypeError('Key length not a number')

	    if (keylen < 0)
	      throw new TypeError('Bad key length')

	    digest = digest || 'sha1'

	    if (!Buffer.isBuffer(password)) password = new Buffer(password)
	    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt)

	    var hLen, l = 1, r, T
	    var DK = new Buffer(keylen)
	    var block1 = new Buffer(salt.length + 4)
	    salt.copy(block1, 0, 0, salt.length)

	    for (var i = 1; i <= l; i++) {
	      block1.writeUInt32BE(i, salt.length)

	      var U = crypto.createHmac(digest, password).update(block1).digest()

	      if (!hLen) {
	        hLen = U.length
	        T = new Buffer(hLen)
	        l = Math.ceil(keylen / hLen)
	        r = keylen - (l - 1) * hLen

	        if (keylen > (Math.pow(2, 32) - 1) * hLen)
	          throw new TypeError('keylen exceeds maximum length')
	      }

	      U.copy(T, 0, 0, hLen)

	      for (var j = 1; j < iterations; j++) {
	        U = crypto.createHmac(digest, password).update(U).digest()

	        for (var k = 0; k < hLen; k++) {
	          T[k] ^= U[k]
	        }
	      }

	      var destPos = (i - 1) * hLen
	      var len = (i == l ? r : hLen)
	      T.copy(DK, destPos, 0, len)
	    }

	    return DK
	  }

	  return {
	    pbkdf2: pbkdf2,
	    pbkdf2Sync: pbkdf2Sync
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20).Buffer))

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _lodash = __webpack_require__(5);

	exports['default'] = function (Target) {

	  Target.prototype.toQuery = function (tz) {
	    var _this = this;

	    var data = this.toSQL(this._method, tz);
	    if (!_lodash.isArray(data)) data = [data];
	    return _lodash.map(data, function (statement) {
	      return _this._formatQuery(statement.sql, statement.bindings, tz);
	    }).join(';\n');
	  };

	  // Format the query as sql, prepping bindings as necessary.
	  Target.prototype._formatQuery = function (sql, bindings, tz) {
	    return this.client.SqlString.format(sql, bindings, tz);
	  };

	  // Create a new instance of the `Runner`, passing in the current object.
	  Target.prototype.then = function () /* onFulfilled, onRejected */{
	    var result = this.client.runner(this).run();
	    return result.then.apply(result, arguments);
	  };

	  // Add additional "options" to the builder. Typically used for client specific
	  // items, like the `mysql` and `sqlite3` drivers.
	  Target.prototype.options = function (opts) {
	    this._options = this._options || [];
	    this._options.push(_lodash.clone(opts) || {});
	    this._cached = undefined;
	    return this;
	  };

	  // Sets an explicit "connnection" we wish to use for this query.
	  Target.prototype.connection = function (connection) {
	    this._connection = connection;
	    return this;
	  };

	  // Set a debug flag for the current schema query stack.
	  Target.prototype.debug = function (enabled) {
	    this._debug = arguments.length ? enabled : true;
	    return this;
	  };

	  // Set the transaction object for this query.
	  Target.prototype.transacting = function (t) {
	    if (t && t.client) {
	      if (!t.client.transacting) {
	        helpers.warn('Invalid transaction value: ' + t.client);
	      } else {
	        this.client = t.client;
	      }
	    }
	    return this;
	  };

	  // Initializes a stream.
	  Target.prototype.stream = function (options) {
	    return this.client.runner(this).stream(options);
	  };

	  // Initialize a stream & pipe automatically.
	  Target.prototype.pipe = function (writable, options) {
	    return this.client.runner(this).pipe(writable, options);
	  };

	  // Creates a method which "coerces" to a promise, by calling a
	  // "then" method on the current `Target`
	  _lodash.each(['bind', 'catch', 'finally', 'asCallback', 'spread', 'map', 'reduce', 'tap', 'thenReturn', 'return', 'yield', 'ensure', 'exec', 'reflect'], function (method) {
	    Target.prototype[method] = function () {
	      var then = this.then();
	      then = then[method].apply(then, arguments);
	      return then;
	    };
	  });
	};

	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,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T0FBTyxDQUFDLENBQUM7R0FDakQsQ0FBQzs7O0FBR0YsUUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsVUFBUyxRQUFRLEVBQUUsT0FBTyxFQUFFO0FBQ2xELFdBQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztHQUN6RCxDQUFDOzs7O0FBSUYsZUFBSyxDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFDNUMsUUFBUSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFDOUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLFNBQVMsQ0FBQyxFQUFFLFVBQVMsTUFBTSxFQUFFO0FBQ2xFLFVBQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEdBQUcsWUFBVztBQUNwQyxVQUFJLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDdkIsVUFBSSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQzNDLGFBQU8sSUFBSSxDQUFDO0tBQ2IsQ0FBQztHQUNILENBQUMsQ0FBQztDQUVKIiwiZmlsZSI6ImludGVyZmFjZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHsgaXNBcnJheSwgbWFwLCBjbG9uZSwgZWFjaCB9IGZyb20gJ2xvZGFzaCdcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oVGFyZ2V0KSB7XG5cbiAgVGFyZ2V0LnByb3RvdHlwZS50b1F1ZXJ5ID0gZnVuY3Rpb24odHopIHtcbiAgICBsZXQgZGF0YSA9IHRoaXMudG9TUUwodGhpcy5fbWV0aG9kLCB0eik7XG4gICAgaWYgKCFpc0FycmF5KGRhdGEpKSBkYXRhID0gW2RhdGFdO1xuICAgIHJldHVybiBtYXAoZGF0YSwgKHN0YXRlbWVudCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdFF1ZXJ5KHN0YXRlbWVudC5zcWwsIHN0YXRlbWVudC5iaW5kaW5ncywgdHopO1xuICAgIH0pLmpvaW4oJztcXG4nKTtcbiAgfTtcblxuICAvLyBGb3JtYXQgdGhlIHF1ZXJ5IGFzIHNxbCwgcHJlcHBpbmcgYmluZGluZ3MgYXMgbmVjZXNzYXJ5LlxuICBUYXJnZXQucHJvdG90eXBlLl9mb3JtYXRRdWVyeSA9IGZ1bmN0aW9uKHNxbCwgYmluZGluZ3MsIHR6KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LlNxbFN0cmluZy5mb3JtYXQoc3FsLCBiaW5kaW5ncywgdHopO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFJ1bm5lcmAsIHBhc3NpbmcgaW4gdGhlIGN1cnJlbnQgb2JqZWN0LlxuICBUYXJnZXQucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbigvKiBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCAqLykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY2xpZW50LnJ1bm5lcih0aGlzKS5ydW4oKVxuICAgIHJldHVybiByZXN1bHQudGhlbi5hcHBseShyZXN1bHQsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQWRkIGFkZGl0aW9uYWwgXCJvcHRpb25zXCIgdG8gdGhlIGJ1aWxkZXIuIFR5cGljYWxseSB1c2VkIGZvciBjbGllbnQgc3BlY2lmaWNcbiAgLy8gaXRlbXMsIGxpa2UgdGhlIGBteXNxbGAgYW5kIGBzcWxpdGUzYCBkcml2ZXJzLlxuICBUYXJnZXQucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX29wdGlvbnMgfHwgW107XG4gICAgdGhpcy5fb3B0aW9ucy5wdXNoKGNsb25lKG9wdHMpIHx8IHt9KTtcbiAgICB0aGlzLl9jYWNoZWQgPSB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBTZXRzIGFuIGV4cGxpY2l0IFwiY29ubm5lY3Rpb25cIiB3ZSB3aXNoIHRvIHVzZSBmb3IgdGhpcyBxdWVyeS5cbiAgVGFyZ2V0LnByb3RvdHlwZS5jb25uZWN0aW9uID0gZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFNldCBhIGRlYnVnIGZsYWcgZm9yIHRoZSBjdXJyZW50IHNjaGVtYSBxdWVyeSBzdGFjay5cbiAgVGFyZ2V0LnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICB0aGlzLl9kZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPyBlbmFibGVkIDogdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBTZXQgdGhlIHRyYW5zYWN0aW9uIG9iamVjdCBmb3IgdGhpcyBxdWVyeS5cbiAgVGFyZ2V0LnByb3RvdHlwZS50cmFuc2FjdGluZyA9IGZ1bmN0aW9uKHQpIHtcbiAgICBpZiAodCAmJiB0LmNsaWVudCkge1xuICAgICAgaWYgKCF0LmNsaWVudC50cmFuc2FjdGluZykge1xuICAgICAgICBoZWxwZXJzLndhcm4oYEludmFsaWQgdHJhbnNhY3Rpb24gdmFsdWU6ICR7dC5jbGllbnR9YClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gdC5jbGllbnRcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gSW5pdGlhbGl6ZXMgYSBzdHJlYW0uXG4gIFRhcmdldC5wcm90b3R5cGUuc3RyZWFtID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5ydW5uZXIodGhpcykuc3RyZWFtKG9wdGlvbnMpO1xuICB9O1xuXG4gIC8vIEluaXRpYWxpemUgYSBzdHJlYW0gJiBwaXBlIGF1dG9tYXRpY2FsbHkuXG4gIFRhcmdldC5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKHdyaXRhYmxlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LnJ1bm5lcih0aGlzKS5waXBlKHdyaXRhYmxlLCBvcHRpb25zKTtcbiAgfTtcblxuICAvLyBDcmVhdGVzIGEgbWV0aG9kIHdoaWNoIFwiY29lcmNlc1wiIHRvIGEgcHJvbWlzZSwgYnkgY2FsbGluZyBhXG4gIC8vIFwidGhlblwiIG1ldGhvZCBvbiB0aGUgY3VycmVudCBgVGFyZ2V0YFxuICBlYWNoKFsnYmluZCcsICdjYXRjaCcsICdmaW5hbGx5JywgJ2FzQ2FsbGJhY2snLFxuICAgICdzcHJlYWQnLCAnbWFwJywgJ3JlZHVjZScsICd0YXAnLCAndGhlblJldHVybicsXG4gICAgJ3JldHVybicsICd5aWVsZCcsICdlbnN1cmUnLCAnZXhlYycsICdyZWZsZWN0J10sIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIFRhcmdldC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IHRoZW4gPSB0aGlzLnRoZW4oKTtcbiAgICAgIHRoZW4gPSB0aGVuW21ldGhvZF0uYXBwbHkodGhlbiwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGVuO1xuICAgIH07XG4gIH0pO1xuXG59XG4iXX0=

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _promise = __webpack_require__(43);

	var _promise2 = _interopRequireDefault(_promise);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _raw = __webpack_require__(2);

	var _raw2 = _interopRequireDefault(_raw);

	var _runner = __webpack_require__(45);

	var _runner2 = _interopRequireDefault(_runner);

	var _formatter = __webpack_require__(61);

	var _formatter2 = _interopRequireDefault(_formatter);

	var _transaction = __webpack_require__(65);

	var _transaction2 = _interopRequireDefault(_transaction);

	var _queryBuilder = __webpack_require__(62);

	var _queryBuilder2 = _interopRequireDefault(_queryBuilder);

	var _queryCompiler = __webpack_require__(75);

	var _queryCompiler2 = _interopRequireDefault(_queryCompiler);

	var _schemaBuilder = __webpack_require__(76);

	var _schemaBuilder2 = _interopRequireDefault(_schemaBuilder);

	var _schemaCompiler = __webpack_require__(77);

	var _schemaCompiler2 = _interopRequireDefault(_schemaCompiler);

	var _schemaTablebuilder = __webpack_require__(79);

	var _schemaTablebuilder2 = _interopRequireDefault(_schemaTablebuilder);

	var _schemaTablecompiler = __webpack_require__(80);

	var _schemaTablecompiler2 = _interopRequireDefault(_schemaTablecompiler);

	var _schemaColumnbuilder = __webpack_require__(81);

	var _schemaColumnbuilder2 = _interopRequireDefault(_schemaColumnbuilder);

	var _schemaColumncompiler = __webpack_require__(82);

	var _schemaColumncompiler2 = _interopRequireDefault(_schemaColumncompiler);

	var _pool2 = __webpack_require__(70);

	var _pool22 = _interopRequireDefault(_pool2);

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _events = __webpack_require__(18);

	var _queryString = __webpack_require__(83);

	var _queryString2 = _interopRequireDefault(_queryString);

	var _lodash = __webpack_require__(5);

	var debug = __webpack_require__(66)('knex:client');
	var debugQuery = __webpack_require__(66)('knex:query');

	// The base client provides the general structure
	// for a dialect specific client object.
	function Client() {
	  var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	  this.config = config;
	  this.connectionSettings = _lodash.cloneDeep(config.connection || {});
	  if (this.driverName && config.connection) {
	    this.initializeDriver();
	    if (!config.pool || config.pool && config.pool.max !== 0) {
	      this.initializePool(config);
	    }
	  }
	  this.valueForUndefined = this.raw('DEFAULT');
	  if (config.useNullAsDefault) {
	    this.valueForUndefined = null;
	  }
	}
	_inherits2['default'](Client, _events.EventEmitter);

	_lodash.assign(Client.prototype, {

	  Formatter: _formatter2['default'],

	  formatter: function formatter() {
	    return new this.Formatter(this);
	  },

	  QueryBuilder: _queryBuilder2['default'],

	  queryBuilder: function queryBuilder() {
	    return new this.QueryBuilder(this);
	  },

	  QueryCompiler: _queryCompiler2['default'],

	  queryCompiler: function queryCompiler(builder) {
	    return new this.QueryCompiler(this, builder);
	  },

	  SchemaBuilder: _schemaBuilder2['default'],

	  schemaBuilder: function schemaBuilder() {
	    return new this.SchemaBuilder(this);
	  },

	  SchemaCompiler: _schemaCompiler2['default'],

	  schemaCompiler: function schemaCompiler(builder) {
	    return new this.SchemaCompiler(this, builder);
	  },

	  TableBuilder: _schemaTablebuilder2['default'],

	  tableBuilder: function tableBuilder(type, tableName, fn) {
	    return new this.TableBuilder(this, type, tableName, fn);
	  },

	  TableCompiler: _schemaTablecompiler2['default'],

	  tableCompiler: function tableCompiler(tableBuilder) {
	    return new this.TableCompiler(this, tableBuilder);
	  },

	  ColumnBuilder: _schemaColumnbuilder2['default'],

	  columnBuilder: function columnBuilder(tableBuilder, type, args) {
	    return new this.ColumnBuilder(this, tableBuilder, type, args);
	  },

	  ColumnCompiler: _schemaColumncompiler2['default'],

	  columnCompiler: function columnCompiler(tableBuilder, columnBuilder) {
	    return new this.ColumnCompiler(this, tableBuilder, columnBuilder);
	  },

	  Runner: _runner2['default'],

	  runner: function runner(connection) {
	    return new this.Runner(this, connection);
	  },

	  SqlString: _queryString2['default'],

	  Transaction: _transaction2['default'],

	  transaction: function transaction(container, config, outerTx) {
	    return new this.Transaction(this, container, config, outerTx);
	  },

	  Raw: _raw2['default'],

	  raw: function raw() {
	    var raw = new this.Raw(this);
	    return raw.set.apply(raw, arguments);
	  },

	  query: function query(connection, obj) {
	    var _this = this;

	    if (typeof obj === 'string') obj = { sql: obj };
	    this.emit('query', _lodash.assign({ __knexUid: connection.__knexUid }, obj));
	    debugQuery(obj.sql);
	    return this._query.call(this, connection, obj)['catch'](function (err) {
	      err.message = _queryString2['default'].format(obj.sql, obj.bindings) + ' - ' + err.message;
	      _this.emit('query-error', err, _lodash.assign({ __knexUid: connection.__knexUid }, obj));
	      throw err;
	    });
	  },

	  stream: function stream(connection, obj, _stream, options) {
	    if (typeof obj === 'string') obj = { sql: obj };
	    this.emit('query', _lodash.assign({ __knexUid: connection.__knexUid }, obj));
	    debugQuery(obj.sql);
	    return this._stream.call(this, connection, obj, _stream, options);
	  },

	  prepBindings: function prepBindings(bindings) {
	    return bindings;
	  },

	  wrapIdentifier: function wrapIdentifier(value) {
	    return value !== '*' ? '"' + value.replace(/"/g, '""') + '"' : '*';
	  },

	  initializeDriver: function initializeDriver() {
	    try {
	      this.driver = this._driver();
	    } catch (e) {
	      helpers.exit('Knex: run\n$ npm install ' + this.driverName + ' --save\n' + e.stack);
	    }
	  },

	  Pool: _pool22['default'],

	  initializePool: function initializePool(config) {
	    if (this.pool) this.destroy();
	    this.pool = new this.Pool(_lodash.assign(this.poolDefaults(config.pool || {}), config.pool));
	    this.pool.on('error', function (err) {
	      helpers.error('Pool2 - ' + err);
	    });
	    this.pool.on('warn', function (msg) {
	      helpers.warn('Pool2 - ' + msg);
	    });
	  },

	  poolDefaults: function poolDefaults(poolConfig) {
	    var client = this;
	    return {
	      min: 2,
	      max: 10,
	      acquire: function acquire(callback) {
	        client.acquireRawConnection().tap(function (connection) {
	          connection.__knexUid = _lodash.uniqueId('__knexUid');
	          if (poolConfig.afterCreate) {
	            return _promise2['default'].promisify(poolConfig.afterCreate)(connection);
	          }
	        }).asCallback(callback);
	      },
	      dispose: function dispose(connection, callback) {
	        if (poolConfig.beforeDestroy) {
	          poolConfig.beforeDestroy(connection, function () {
	            if (connection !== undefined) {
	              client.destroyRawConnection(connection, callback);
	            }
	          });
	        } else if (connection !== void 0) {
	          client.destroyRawConnection(connection, callback);
	        }
	      },
	      ping: function ping(resource, callback) {
	        return client.ping(resource, callback);
	      }
	    };
	  },

	  // Acquire a connection from the pool.
	  acquireConnection: function acquireConnection() {
	    var client = this;
	    var request = null;
	    var completed = new _promise2['default'](function (resolver, rejecter) {
	      if (!client.pool) {
	        return rejecter(new Error('There is no pool defined on the current client'));
	      }
	      request = client.pool.acquire(function (err, connection) {
	        if (err) return rejecter(err);
	        debug('acquired connection from pool: %s', connection.__knexUid);
	        resolver(connection);
	      });
	    });
	    var abort = function abort(reason) {
	      if (request && !request.fulfilled) {
	        request.abort(reason);
	      }
	    };
	    return {
	      completed: completed,
	      abort: abort
	    };
	  },

	  // Releases a connection back to the connection pool,
	  // returning a promise resolved when the connection is released.
	  releaseConnection: function releaseConnection(connection) {
	    var pool = this.pool;

	    return new _promise2['default'](function (resolver) {
	      debug('releasing connection to pool: %s', connection.__knexUid);
	      pool.release(connection);
	      resolver();
	    });
	  },

	  // Destroy the current connection pool for the client.
	  destroy: function destroy(callback) {
	    var client = this;
	    var promise = new _promise2['default'](function (resolver) {
	      if (!client.pool) return resolver();
	      client.pool.end(function () {
	        client.pool = undefined;
	        resolver();
	      });
	    });
	    // Allow either a callback or promise interface for destruction.
	    if (typeof callback === 'function') {
	      promise.asCallback(callback);
	    } else {
	      return promise;
	    }
	  },

	  // Return the database being used by this client.
	  database: function database() {
	    return this.connectionSettings.database;
	  },

	  toString: function toString() {
	    return '[object KnexClient]';
	  },

	  canCancelQuery: false,

	  assertCanCancelQuery: function assertCanCancelQuery() {
	    if (!this.canCancelQuery) {
	      throw new Error("Query cancelling not supported for this dialect");
	    }
	  },

	  cancelQuery: function cancelQuery() {
	    throw new Error("Query cancelling not supported for this dialect");
	  }

	});

	exports['default'] = Client;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,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QUFFO0FBQ2hCLFFBQU0sTUFBTSxHQUFHLElBQUksQ0FBQTtBQUNuQixRQUFNLE9BQU8sR0FBRyx5QkFBWSxVQUFTLFFBQVEsRUFBRTtBQUM3QyxVQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxPQUFPLFFBQVEsRUFBRSxDQUFBO0FBQ25DLFlBQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVc7QUFDekIsY0FBTSxDQUFDLElBQUksR0FBRyxTQUFTLENBQUE7QUFDdkIsZ0JBQVEsRUFBRSxDQUFBO09BQ1gsQ0FBQyxDQUFBO0tBQ0gsQ0FBQyxDQUFBOztBQUVGLFFBQUksT0FBTyxRQUFRLEtBQUssVUFBVSxFQUFFO0FBQ2xDLGFBQU8sQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUE7S0FDN0IsTUFBTTtBQUNMLGFBQU8sT0FBTyxDQUFBO0tBQ2Y7R0FDRjs7O0FBR0QsVUFBUSxFQUFBLG9CQUFHO0FBQ1QsV0FBTyxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFBO0dBQ3hDOztBQUVELFVBQVEsRUFBQSxvQkFBRztBQUNULFdBQU8scUJBQXFCLENBQUE7R0FDN0I7O0FBRUQsZ0JBQWMsRUFBRSxLQUFLOztBQUVyQixzQkFBb0IsRUFBQSxnQ0FBRztBQUNyQixRQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRTtBQUN4QixZQUFNLElBQUksS0FBSyxDQUFDLGlEQUFpRCxDQUFDLENBQUM7S0FDcEU7R0FDRjs7QUFFRCxhQUFXLEVBQUEsdUJBQUc7QUFDWixVQUFNLElBQUksS0FBSyxDQUFDLGlEQUFpRCxDQUFDLENBQUE7R0FDbkU7O0NBRUYsQ0FBQyxDQUFBOztxQkFFYSxNQUFNIiwiZmlsZSI6ImNsaWVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IFByb21pc2UgZnJvbSAnLi9wcm9taXNlJztcbmltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSAnLi9oZWxwZXJzJztcblxuaW1wb3J0IFJhdyBmcm9tICcuL3Jhdyc7XG5pbXBvcnQgUnVubmVyIGZyb20gJy4vcnVubmVyJztcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSAnLi9mb3JtYXR0ZXInO1xuaW1wb3J0IFRyYW5zYWN0aW9uIGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuXG5pbXBvcnQgUXVlcnlCdWlsZGVyIGZyb20gJy4vcXVlcnkvYnVpbGRlcic7XG5pbXBvcnQgUXVlcnlDb21waWxlciBmcm9tICcuL3F1ZXJ5L2NvbXBpbGVyJztcblxuaW1wb3J0IFNjaGVtYUJ1aWxkZXIgZnJvbSAnLi9zY2hlbWEvYnVpbGRlcic7XG5pbXBvcnQgU2NoZW1hQ29tcGlsZXIgZnJvbSAnLi9zY2hlbWEvY29tcGlsZXInO1xuaW1wb3J0IFRhYmxlQnVpbGRlciBmcm9tICcuL3NjaGVtYS90YWJsZWJ1aWxkZXInO1xuaW1wb3J0IFRhYmxlQ29tcGlsZXIgZnJvbSAnLi9zY2hlbWEvdGFibGVjb21waWxlcic7XG5pbXBvcnQgQ29sdW1uQnVpbGRlciBmcm9tICcuL3NjaGVtYS9jb2x1bW5idWlsZGVyJztcbmltcG9ydCBDb2x1bW5Db21waWxlciBmcm9tICcuL3NjaGVtYS9jb2x1bW5jb21waWxlcic7XG5cbmltcG9ydCBQb29sMiBmcm9tICdwb29sMic7XG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCBTcWxTdHJpbmcgZnJvbSAnLi9xdWVyeS9zdHJpbmcnO1xuXG5pbXBvcnQgeyBhc3NpZ24sIHVuaXF1ZUlkLCBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnXG5cbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgna25leDpjbGllbnQnKVxuY29uc3QgZGVidWdRdWVyeSA9IHJlcXVpcmUoJ2RlYnVnJykoJ2tuZXg6cXVlcnknKVxuXG4vLyBUaGUgYmFzZSBjbGllbnQgcHJvdmlkZXMgdGhlIGdlbmVyYWwgc3RydWN0dXJlXG4vLyBmb3IgYSBkaWFsZWN0IHNwZWNpZmljIGNsaWVudCBvYmplY3QuXG5mdW5jdGlvbiBDbGllbnQoY29uZmlnID0ge30pIHtcbiAgdGhpcy5jb25maWcgPSBjb25maWdcbiAgdGhpcy5jb25uZWN0aW9uU2V0dGluZ3MgPSBjbG9uZURlZXAoY29uZmlnLmNvbm5lY3Rpb24gfHwge30pXG4gIGlmICh0aGlzLmRyaXZlck5hbWUgJiYgY29uZmlnLmNvbm5lY3Rpb24pIHtcbiAgICB0aGlzLmluaXRpYWxpemVEcml2ZXIoKVxuICAgIGlmICghY29uZmlnLnBvb2wgfHwgKGNvbmZpZy5wb29sICYmIGNvbmZpZy5wb29sLm1heCAhPT0gMCkpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZVBvb2woY29uZmlnKVxuICAgIH1cbiAgfVxuICB0aGlzLnZhbHVlRm9yVW5kZWZpbmVkID0gdGhpcy5yYXcoJ0RFRkFVTFQnKTtcbiAgaWYgKGNvbmZpZy51c2VOdWxsQXNEZWZhdWx0KSB7XG4gICAgdGhpcy52YWx1ZUZvclVuZGVmaW5lZCA9IG51bGxcbiAgfVxufVxuaW5oZXJpdHMoQ2xpZW50LCBFdmVudEVtaXR0ZXIpXG5cbmFzc2lnbihDbGllbnQucHJvdG90eXBlLCB7XG5cbiAgRm9ybWF0dGVyLFxuXG4gIGZvcm1hdHRlcigpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuRm9ybWF0dGVyKHRoaXMpXG4gIH0sXG5cbiAgUXVlcnlCdWlsZGVyLFxuXG4gIHF1ZXJ5QnVpbGRlcigpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuUXVlcnlCdWlsZGVyKHRoaXMpXG4gIH0sXG5cbiAgUXVlcnlDb21waWxlcixcblxuICBxdWVyeUNvbXBpbGVyKGJ1aWxkZXIpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuUXVlcnlDb21waWxlcih0aGlzLCBidWlsZGVyKVxuICB9LFxuXG4gIFNjaGVtYUJ1aWxkZXIsXG5cbiAgc2NoZW1hQnVpbGRlcigpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuU2NoZW1hQnVpbGRlcih0aGlzKVxuICB9LFxuXG4gIFNjaGVtYUNvbXBpbGVyLFxuXG4gIHNjaGVtYUNvbXBpbGVyKGJ1aWxkZXIpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuU2NoZW1hQ29tcGlsZXIodGhpcywgYnVpbGRlcilcbiAgfSxcblxuICBUYWJsZUJ1aWxkZXIsXG5cbiAgdGFibGVCdWlsZGVyKHR5cGUsIHRhYmxlTmFtZSwgZm4pIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuVGFibGVCdWlsZGVyKHRoaXMsIHR5cGUsIHRhYmxlTmFtZSwgZm4pXG4gIH0sXG5cbiAgVGFibGVDb21waWxlcixcblxuICB0YWJsZUNvbXBpbGVyKHRhYmxlQnVpbGRlcikge1xuICAgIHJldHVybiBuZXcgdGhpcy5UYWJsZUNvbXBpbGVyKHRoaXMsIHRhYmxlQnVpbGRlcilcbiAgfSxcblxuICBDb2x1bW5CdWlsZGVyLFxuXG4gIGNvbHVtbkJ1aWxkZXIodGFibGVCdWlsZGVyLCB0eXBlLCBhcmdzKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLkNvbHVtbkJ1aWxkZXIodGhpcywgdGFibGVCdWlsZGVyLCB0eXBlLCBhcmdzKVxuICB9LFxuXG4gIENvbHVtbkNvbXBpbGVyLFxuXG4gIGNvbHVtbkNvbXBpbGVyKHRhYmxlQnVpbGRlciwgY29sdW1uQnVpbGRlcikge1xuICAgIHJldHVybiBuZXcgdGhpcy5Db2x1bW5Db21waWxlcih0aGlzLCB0YWJsZUJ1aWxkZXIsIGNvbHVtbkJ1aWxkZXIpXG4gIH0sXG5cbiAgUnVubmVyLFxuXG4gIHJ1bm5lcihjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLlJ1bm5lcih0aGlzLCBjb25uZWN0aW9uKVxuICB9LFxuXG4gIFNxbFN0cmluZyxcblxuICBUcmFuc2FjdGlvbixcblxuICB0cmFuc2FjdGlvbihjb250YWluZXIsIGNvbmZpZywgb3V0ZXJUeCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5UcmFuc2FjdGlvbih0aGlzLCBjb250YWluZXIsIGNvbmZpZywgb3V0ZXJUeClcbiAgfSxcblxuICBSYXcsXG5cbiAgcmF3KCkge1xuICAgIGNvbnN0IHJhdyA9IG5ldyB0aGlzLlJhdyh0aGlzKVxuICAgIHJldHVybiByYXcuc2V0LmFwcGx5KHJhdywgYXJndW1lbnRzKVxuICB9LFxuXG4gIHF1ZXJ5KGNvbm5lY3Rpb24sIG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykgb2JqID0ge3NxbDogb2JqfVxuICAgIHRoaXMuZW1pdCgncXVlcnknLCBhc3NpZ24oe19fa25leFVpZDogY29ubmVjdGlvbi5fX2tuZXhVaWR9LCBvYmopKVxuICAgIGRlYnVnUXVlcnkob2JqLnNxbClcbiAgICByZXR1cm4gdGhpcy5fcXVlcnkuY2FsbCh0aGlzLCBjb25uZWN0aW9uLCBvYmopLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGVyci5tZXNzYWdlID0gU3FsU3RyaW5nLmZvcm1hdChvYmouc3FsLCBvYmouYmluZGluZ3MpICsgJyAtICcgKyBlcnIubWVzc2FnZVxuICAgICAgdGhpcy5lbWl0KCdxdWVyeS1lcnJvcicsIGVyciwgYXNzaWduKHtfX2tuZXhVaWQ6IGNvbm5lY3Rpb24uX19rbmV4VWlkfSwgb2JqKSlcbiAgICAgIHRocm93IGVyclxuICAgIH0pXG4gIH0sXG5cbiAgc3RyZWFtKGNvbm5lY3Rpb24sIG9iaiwgc3RyZWFtLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSBvYmogPSB7c3FsOiBvYmp9XG4gICAgdGhpcy5lbWl0KCdxdWVyeScsIGFzc2lnbih7X19rbmV4VWlkOiBjb25uZWN0aW9uLl9fa25leFVpZH0sIG9iaikpXG4gICAgZGVidWdRdWVyeShvYmouc3FsKVxuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uY2FsbCh0aGlzLCBjb25uZWN0aW9uLCBvYmosIHN0cmVhbSwgb3B0aW9ucylcbiAgfSxcblxuICBwcmVwQmluZGluZ3MoYmluZGluZ3MpIHtcbiAgICByZXR1cm4gYmluZGluZ3M7XG4gIH0sXG5cbiAgd3JhcElkZW50aWZpZXIodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICE9PSAnKicgPyBgXCIke3ZhbHVlLnJlcGxhY2UoL1wiL2csICdcIlwiJyl9XCJgIDogJyonKVxuICB9LFxuXG4gIGluaXRpYWxpemVEcml2ZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZHJpdmVyID0gdGhpcy5fZHJpdmVyKClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoZWxwZXJzLmV4aXQoYEtuZXg6IHJ1blxcbiQgbnBtIGluc3RhbGwgJHt0aGlzLmRyaXZlck5hbWV9IC0tc2F2ZVxcbiR7ZS5zdGFja31gKVxuICAgIH1cbiAgfSxcblxuICBQb29sOiBQb29sMixcblxuICBpbml0aWFsaXplUG9vbChjb25maWcpIHtcbiAgICBpZiAodGhpcy5wb29sKSB0aGlzLmRlc3Ryb3koKVxuICAgIHRoaXMucG9vbCA9IG5ldyB0aGlzLlBvb2woYXNzaWduKHRoaXMucG9vbERlZmF1bHRzKGNvbmZpZy5wb29sIHx8IHt9KSwgY29uZmlnLnBvb2wpKVxuICAgIHRoaXMucG9vbC5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGhlbHBlcnMuZXJyb3IoYFBvb2wyIC0gJHtlcnJ9YClcbiAgICB9KVxuICAgIHRoaXMucG9vbC5vbignd2FybicsIGZ1bmN0aW9uKG1zZykge1xuICAgICAgaGVscGVycy53YXJuKGBQb29sMiAtICR7bXNnfWApXG4gICAgfSlcbiAgfSxcblxuICBwb29sRGVmYXVsdHMocG9vbENvbmZpZykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXNcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiAyLFxuICAgICAgbWF4OiAxMCxcbiAgICAgIGFjcXVpcmUoY2FsbGJhY2spIHtcbiAgICAgICAgY2xpZW50LmFjcXVpcmVSYXdDb25uZWN0aW9uKClcbiAgICAgICAgICAudGFwKGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uX19rbmV4VWlkID0gdW5pcXVlSWQoJ19fa25leFVpZCcpXG4gICAgICAgICAgICBpZiAocG9vbENvbmZpZy5hZnRlckNyZWF0ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5wcm9taXNpZnkocG9vbENvbmZpZy5hZnRlckNyZWF0ZSkoY29ubmVjdGlvbilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKVxuICAgICAgfSxcbiAgICAgIGRpc3Bvc2UoY29ubmVjdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHBvb2xDb25maWcuYmVmb3JlRGVzdHJveSkge1xuICAgICAgICAgIHBvb2xDb25maWcuYmVmb3JlRGVzdHJveShjb25uZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY2xpZW50LmRlc3Ryb3lSYXdDb25uZWN0aW9uKGNvbm5lY3Rpb24sIGNhbGxiYWNrKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgY2xpZW50LmRlc3Ryb3lSYXdDb25uZWN0aW9uKGNvbm5lY3Rpb24sIGNhbGxiYWNrKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGluZyhyZXNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5waW5nKHJlc291cmNlLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8vIEFjcXVpcmUgYSBjb25uZWN0aW9uIGZyb20gdGhlIHBvb2wuXG4gIGFjcXVpcmVDb25uZWN0aW9uKCkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXNcbiAgICBsZXQgcmVxdWVzdCA9IG51bGxcbiAgICBjb25zdCBjb21wbGV0ZWQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlciwgcmVqZWN0ZXIpIHtcbiAgICAgIGlmICghY2xpZW50LnBvb2wpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGVyKG5ldyBFcnJvcignVGhlcmUgaXMgbm8gcG9vbCBkZWZpbmVkIG9uIHRoZSBjdXJyZW50IGNsaWVudCcpKVxuICAgICAgfVxuICAgICAgcmVxdWVzdCA9IGNsaWVudC5wb29sLmFjcXVpcmUoZnVuY3Rpb24oZXJyLCBjb25uZWN0aW9uKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3RlcihlcnIpXG4gICAgICAgIGRlYnVnKCdhY3F1aXJlZCBjb25uZWN0aW9uIGZyb20gcG9vbDogJXMnLCBjb25uZWN0aW9uLl9fa25leFVpZClcbiAgICAgICAgcmVzb2x2ZXIoY29ubmVjdGlvbilcbiAgICAgIH0pXG4gICAgfSlcbiAgICBjb25zdCBhYm9ydCA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgaWYgKHJlcXVlc3QgJiYgIXJlcXVlc3QuZnVsZmlsbGVkKSB7XG4gICAgICAgIHJlcXVlc3QuYWJvcnQocmVhc29uKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGxldGVkOiBjb21wbGV0ZWQsXG4gICAgICBhYm9ydDogYWJvcnRcbiAgICB9XG4gIH0sXG5cbiAgLy8gUmVsZWFzZXMgYSBjb25uZWN0aW9uIGJhY2sgdG8gdGhlIGNvbm5lY3Rpb24gcG9vbCxcbiAgLy8gcmV0dXJuaW5nIGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIHJlbGVhc2VkLlxuICByZWxlYXNlQ29ubmVjdGlvbihjb25uZWN0aW9uKSB7XG4gICAgY29uc3QgeyBwb29sIH0gPSB0aGlzXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmVyKSB7XG4gICAgICBkZWJ1ZygncmVsZWFzaW5nIGNvbm5lY3Rpb24gdG8gcG9vbDogJXMnLCBjb25uZWN0aW9uLl9fa25leFVpZClcbiAgICAgIHBvb2wucmVsZWFzZShjb25uZWN0aW9uKVxuICAgICAgcmVzb2x2ZXIoKVxuICAgIH0pXG4gIH0sXG5cbiAgLy8gRGVzdHJveSB0aGUgY3VycmVudCBjb25uZWN0aW9uIHBvb2wgZm9yIHRoZSBjbGllbnQuXG4gIGRlc3Ryb3koY2FsbGJhY2spIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzXG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmVyKSB7XG4gICAgICBpZiAoIWNsaWVudC5wb29sKSByZXR1cm4gcmVzb2x2ZXIoKVxuICAgICAgY2xpZW50LnBvb2wuZW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGllbnQucG9vbCA9IHVuZGVmaW5lZFxuICAgICAgICByZXNvbHZlcigpXG4gICAgICB9KVxuICAgIH0pXG4gICAgLy8gQWxsb3cgZWl0aGVyIGEgY2FsbGJhY2sgb3IgcHJvbWlzZSBpbnRlcmZhY2UgZm9yIGRlc3RydWN0aW9uLlxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb21pc2UuYXNDYWxsYmFjayhjYWxsYmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByb21pc2VcbiAgICB9XG4gIH0sXG5cbiAgLy8gUmV0dXJuIHRoZSBkYXRhYmFzZSBiZWluZyB1c2VkIGJ5IHRoaXMgY2xpZW50LlxuICBkYXRhYmFzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uU2V0dGluZ3MuZGF0YWJhc2VcbiAgfSxcblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1tvYmplY3QgS25leENsaWVudF0nXG4gIH0sXG5cbiAgY2FuQ2FuY2VsUXVlcnk6IGZhbHNlLFxuXG4gIGFzc2VydENhbkNhbmNlbFF1ZXJ5KCkge1xuICAgIGlmICghdGhpcy5jYW5DYW5jZWxRdWVyeSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVlcnkgY2FuY2VsbGluZyBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIGRpYWxlY3RcIik7XG4gICAgfVxuICB9LFxuXG4gIGNhbmNlbFF1ZXJ5KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXJ5IGNhbmNlbGxpbmcgbm90IHN1cHBvcnRlZCBmb3IgdGhpcyBkaWFsZWN0XCIpXG4gIH1cblxufSlcblxuZXhwb3J0IGRlZmF1bHQgQ2xpZW50XG4iXX0=

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _bluebird = __webpack_require__(44);

	var _bluebird2 = _interopRequireDefault(_bluebird);

	var _helpers = __webpack_require__(4);

	_bluebird2['default'].prototype.exec = function (cb) {
	  _helpers.deprecate('.exec', '.asCallback');
	  return this.asCallback(cb);
	};

	exports['default'] = _bluebird2['default'];
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wcm9taXNlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozt3QkFDb0IsVUFBVTs7Ozt1QkFDSixXQUFXOztBQUVyQyxzQkFBUSxTQUFTLENBQUMsSUFBSSxHQUFHLFVBQVMsRUFBRSxFQUFFO0FBQ3BDLHFCQUFVLE9BQU8sRUFBRSxhQUFhLENBQUMsQ0FBQTtBQUNqQyxTQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUE7Q0FDM0IsQ0FBQyIsImZpbGUiOiJwcm9taXNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgUHJvbWlzZSBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBkZXByZWNhdGUgfSBmcm9tICcuL2hlbHBlcnMnO1xuXG5Qcm9taXNlLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY2IpIHtcbiAgZGVwcmVjYXRlKCcuZXhlYycsICcuYXNDYWxsYmFjaycpXG4gIHJldHVybiB0aGlzLmFzQ2FsbGJhY2soY2IpXG59O1xuXG5leHBvcnQgZGVmYXVsdCBQcm9taXNlO1xuIl19

/***/ },
/* 44 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_44__;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _lodash = __webpack_require__(5);

	var _promise = __webpack_require__(43);

	var _promise2 = _interopRequireDefault(_promise);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var PassThrough = undefined;

	// The "Runner" constructor takes a "builder" (query, schema, or raw)
	// and runs through each of the query statements, calling any additional
	// "output" method provided alongside the query and bindings.
	function Runner(client, builder) {
	  this.client = client;
	  this.builder = builder;
	  this.queries = [];

	  // The "connection" object is set on the runner when
	  // "run" is called.
	  this.connection = void 0;
	}

	_lodash.assign(Runner.prototype, {

	  // "Run" the target, calling "toSQL" on the builder, returning
	  // an object or array of queries to run, each of which are run on
	  // a single connection.
	  run: function run() {
	    var runner = this;
	    return _promise2['default'].using(this.ensureConnection(), function (connection) {
	      runner.connection = connection;

	      runner.client.emit('start', runner.builder);
	      runner.builder.emit('start', runner.builder);
	      var sql = runner.builder.toSQL();

	      if (runner.builder._debug) {
	        helpers.debugLog(sql);
	      }

	      if (_lodash.isArray(sql)) {
	        return runner.queryArray(sql);
	      }
	      return runner.query(sql);
	    })

	    // If there are any "error" listeners, we fire an error event
	    // and then re-throw the error to be eventually handled by
	    // the promise chain. Useful if you're wrapping in a custom `Promise`.
	    ['catch'](function (err) {
	      if (runner.builder._events && runner.builder._events.error) {
	        runner.builder.emit('error', err);
	      }
	      throw err;
	    })

	    // Fire a single "end" event on the builder when
	    // all queries have successfully completed.
	    .tap(function () {
	      runner.builder.emit('end');
	    });
	  },

	  // Stream the result set, by passing through to the dialect's streaming
	  // capabilities. If the options are
	  stream: function stream(options, handler) {

	    // If we specify stream(handler).then(...
	    if (arguments.length === 1) {
	      if (typeof options === 'function') {
	        handler = options;
	        options = {};
	      }
	    }

	    // Determines whether we emit an error or throw here.
	    var hasHandler = typeof handler === 'function';

	    // Lazy-load the "PassThrough" dependency.
	    PassThrough = PassThrough || __webpack_require__(46).PassThrough;

	    var runner = this;
	    var stream = new PassThrough({ objectMode: true });
	    var promise = _promise2['default'].using(this.ensureConnection(), function (connection) {
	      runner.connection = connection;
	      var sql = runner.builder.toSQL();
	      var err = new Error('The stream may only be used with a single query statement.');
	      if (_lodash.isArray(sql)) {
	        if (hasHandler) throw err;
	        stream.emit('error', err);
	      }
	      return runner.client.stream(runner.connection, sql, stream, options);
	    });

	    // If a function is passed to handle the stream, send the stream
	    // there and return the promise, otherwise just return the stream
	    // and the promise will take care of itsself.
	    if (hasHandler) {
	      handler(stream);
	      return promise;
	    }
	    return stream;
	  },

	  // Allow you to pipe the stream to a writable stream.
	  pipe: function pipe(writable, options) {
	    return this.stream(options).pipe(writable);
	  },

	  // "Runs" a query, returning a promise. All queries specified by the builder are guaranteed
	  // to run in sequence, and on the same connection, especially helpful when schema building
	  // and dealing with foreign key constraints, etc.
	  query: _promise2['default'].method(function (obj) {
	    var _this = this;

	    this.builder.emit('query', _lodash.assign({ __knexUid: this.connection.__knexUid }, obj));
	    var runner = this;
	    var queryPromise = this.client.query(this.connection, obj);

	    if (obj.timeout) {
	      queryPromise = queryPromise.timeout(obj.timeout);
	    }

	    return queryPromise.then(function (resp) {
	      var processedResponse = _this.client.processResponse(resp, runner);
	      _this.builder.emit('query-response', processedResponse, _lodash.assign({ __knexUid: _this.connection.__knexUid }, obj), _this.builder);
	      _this.client.emit('query-response', processedResponse, _lodash.assign({ __knexUid: _this.connection.__knexUid }, obj), _this.builder);
	      return processedResponse;
	    })['catch'](_promise2['default'].TimeoutError, function (error) {
	      var timeout = obj.timeout;
	      var sql = obj.sql;
	      var bindings = obj.bindings;

	      var cancelQuery = undefined;
	      if (obj.cancelOnTimeout) {
	        cancelQuery = _this.client.cancelQuery(_this.connection);
	      } else {
	        cancelQuery = _promise2['default'].resolve();
	      }

	      return cancelQuery['catch'](function (cancelError) {
	        // cancellation failed
	        throw _lodash.assign(cancelError, {
	          message: 'After query timeout of ' + timeout + 'ms exceeded, cancelling of query failed.',
	          sql: sql, bindings: bindings, timeout: timeout
	        });
	      }).then(function () {
	        // cancellation succeeded, rethrow timeout error
	        throw _lodash.assign(error, {
	          message: 'Defined query timeout of ' + timeout + 'ms exceeded when running query.',
	          sql: sql, bindings: bindings, timeout: timeout
	        });
	      });
	    })['catch'](function (error) {
	      _this.builder.emit('query-error', error, _lodash.assign({ __knexUid: _this.connection.__knexUid }, obj));
	      throw error;
	    });
	  }),

	  // In the case of the "schema builder" we call `queryArray`, which runs each
	  // of the queries in sequence.
	  queryArray: function queryArray(queries) {
	    return queries.length === 1 ? this.query(queries[0]) : _promise2['default'].bind(this)['return'](queries).reduce(function (memo, query) {
	      return this.query(query).then(function (resp) {
	        memo.push(resp);
	        return memo;
	      });
	    }, []);
	  },

	  // Check whether there's a transaction flag, and that it has a connection.
	  ensureConnection: function ensureConnection() {
	    var runner = this;
	    var acquireConnectionTimeout = runner.client.config.acquireConnectionTimeout || 60000;
	    return _promise2['default']['try'](function () {
	      return runner.connection || new _promise2['default'](function (resolver, rejecter) {
	        var acquireConnection = runner.client.acquireConnection();

	        acquireConnection.completed.timeout(acquireConnectionTimeout).then(resolver)['catch'](_promise2['default'].TimeoutError, function (error) {
	          var timeoutError = new Error('Knex: Timeout acquiring a connection. The pool is probably full. ' + 'Are you missing a .transacting(trx) call?');
	          var additionalErrorInformation = {
	            timeoutStack: error.stack
	          };

	          if (runner.builder) {
	            additionalErrorInformation.sql = runner.builder.sql;
	            additionalErrorInformation.bindings = runner.builder.bindings;
	          }

	          _lodash.assign(timeoutError, additionalErrorInformation);

	          // Let the pool know that this request for a connection timed out
	          acquireConnection.abort('Knex: Timeout acquiring a connection.');

	          rejecter(timeoutError);
	        })['catch'](rejecter);
	      });
	    }).disposer(function () {
	      if (runner.connection.__knex__disposed) return;
	      runner.client.releaseConnection(runner.connection);
	    });
	  }

	});

	exports['default'] = Runner;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,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QUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFBO0tBQ25ELENBQUMsQ0FBQTtHQUNIOztDQUVGLENBQUMsQ0FBQTs7cUJBRWEsTUFBTSIsImZpbGUiOiJydW5uZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NpZ24sIGlzQXJyYXkgfSBmcm9tICdsb2Rhc2gnXG5pbXBvcnQgUHJvbWlzZSBmcm9tICcuL3Byb21pc2UnO1xuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuL2hlbHBlcnMnO1xuXG5sZXQgUGFzc1Rocm91Z2g7XG5cbi8vIFRoZSBcIlJ1bm5lclwiIGNvbnN0cnVjdG9yIHRha2VzIGEgXCJidWlsZGVyXCIgKHF1ZXJ5LCBzY2hlbWEsIG9yIHJhdylcbi8vIGFuZCBydW5zIHRocm91Z2ggZWFjaCBvZiB0aGUgcXVlcnkgc3RhdGVtZW50cywgY2FsbGluZyBhbnkgYWRkaXRpb25hbFxuLy8gXCJvdXRwdXRcIiBtZXRob2QgcHJvdmlkZWQgYWxvbmdzaWRlIHRoZSBxdWVyeSBhbmQgYmluZGluZ3MuXG5mdW5jdGlvbiBSdW5uZXIoY2xpZW50LCBidWlsZGVyKSB7XG4gIHRoaXMuY2xpZW50ID0gY2xpZW50XG4gIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXJcbiAgdGhpcy5xdWVyaWVzID0gW11cblxuICAvLyBUaGUgXCJjb25uZWN0aW9uXCIgb2JqZWN0IGlzIHNldCBvbiB0aGUgcnVubmVyIHdoZW5cbiAgLy8gXCJydW5cIiBpcyBjYWxsZWQuXG4gIHRoaXMuY29ubmVjdGlvbiA9IHZvaWQgMFxufVxuXG5hc3NpZ24oUnVubmVyLnByb3RvdHlwZSwge1xuXG4gIC8vIFwiUnVuXCIgdGhlIHRhcmdldCwgY2FsbGluZyBcInRvU1FMXCIgb24gdGhlIGJ1aWxkZXIsIHJldHVybmluZ1xuICAvLyBhbiBvYmplY3Qgb3IgYXJyYXkgb2YgcXVlcmllcyB0byBydW4sIGVhY2ggb2Ygd2hpY2ggYXJlIHJ1biBvblxuICAvLyBhIHNpbmdsZSBjb25uZWN0aW9uLlxuICBydW4oKSB7XG4gICAgY29uc3QgcnVubmVyID0gdGhpc1xuICAgIHJldHVybiBQcm9taXNlLnVzaW5nKHRoaXMuZW5zdXJlQ29ubmVjdGlvbigpLCBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICBydW5uZXIuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG5cbiAgICAgIHJ1bm5lci5jbGllbnQuZW1pdCgnc3RhcnQnLCBydW5uZXIuYnVpbGRlcilcbiAgICAgIHJ1bm5lci5idWlsZGVyLmVtaXQoJ3N0YXJ0JywgcnVubmVyLmJ1aWxkZXIpXG4gICAgICBjb25zdCBzcWwgPSBydW5uZXIuYnVpbGRlci50b1NRTCgpO1xuXG4gICAgICBpZiAocnVubmVyLmJ1aWxkZXIuX2RlYnVnKSB7XG4gICAgICAgIGhlbHBlcnMuZGVidWdMb2coc3FsKVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheShzcWwpKSB7XG4gICAgICAgIHJldHVybiBydW5uZXIucXVlcnlBcnJheShzcWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ1bm5lci5xdWVyeShzcWwpO1xuXG4gICAgfSlcblxuICAgIC8vIElmIHRoZXJlIGFyZSBhbnkgXCJlcnJvclwiIGxpc3RlbmVycywgd2UgZmlyZSBhbiBlcnJvciBldmVudFxuICAgIC8vIGFuZCB0aGVuIHJlLXRocm93IHRoZSBlcnJvciB0byBiZSBldmVudHVhbGx5IGhhbmRsZWQgYnlcbiAgICAvLyB0aGUgcHJvbWlzZSBjaGFpbi4gVXNlZnVsIGlmIHlvdSdyZSB3cmFwcGluZyBpbiBhIGN1c3RvbSBgUHJvbWlzZWAuXG4gICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKHJ1bm5lci5idWlsZGVyLl9ldmVudHMgJiYgcnVubmVyLmJ1aWxkZXIuX2V2ZW50cy5lcnJvcikge1xuICAgICAgICBydW5uZXIuYnVpbGRlci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSlcblxuICAgIC8vIEZpcmUgYSBzaW5nbGUgXCJlbmRcIiBldmVudCBvbiB0aGUgYnVpbGRlciB3aGVuXG4gICAgLy8gYWxsIHF1ZXJpZXMgaGF2ZSBzdWNjZXNzZnVsbHkgY29tcGxldGVkLlxuICAgIC50YXAoZnVuY3Rpb24oKSB7XG4gICAgICBydW5uZXIuYnVpbGRlci5lbWl0KCdlbmQnKTtcbiAgICB9KVxuXG4gIH0sXG5cbiAgLy8gU3RyZWFtIHRoZSByZXN1bHQgc2V0LCBieSBwYXNzaW5nIHRocm91Z2ggdG8gdGhlIGRpYWxlY3QncyBzdHJlYW1pbmdcbiAgLy8gY2FwYWJpbGl0aWVzLiBJZiB0aGUgb3B0aW9ucyBhcmVcbiAgc3RyZWFtKG9wdGlvbnMsIGhhbmRsZXIpIHtcblxuICAgIC8vIElmIHdlIHNwZWNpZnkgc3RyZWFtKGhhbmRsZXIpLnRoZW4oLi4uXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBoYW5kbGVyID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERldGVybWluZXMgd2hldGhlciB3ZSBlbWl0IGFuIGVycm9yIG9yIHRocm93IGhlcmUuXG4gICAgY29uc3QgaGFzSGFuZGxlciA9IHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nO1xuXG4gICAgLy8gTGF6eS1sb2FkIHRoZSBcIlBhc3NUaHJvdWdoXCIgZGVwZW5kZW5jeS5cbiAgICBQYXNzVGhyb3VnaCA9IFBhc3NUaHJvdWdoIHx8IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlBhc3NUaHJvdWdoO1xuXG4gICAgY29uc3QgcnVubmVyID0gdGhpcztcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2goe29iamVjdE1vZGU6IHRydWV9KTtcbiAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS51c2luZyh0aGlzLmVuc3VyZUNvbm5lY3Rpb24oKSwgZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgcnVubmVyLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgY29uc3Qgc3FsID0gcnVubmVyLmJ1aWxkZXIudG9TUUwoKVxuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdUaGUgc3RyZWFtIG1heSBvbmx5IGJlIHVzZWQgd2l0aCBhIHNpbmdsZSBxdWVyeSBzdGF0ZW1lbnQuJyk7XG4gICAgICBpZiAoaXNBcnJheShzcWwpKSB7XG4gICAgICAgIGlmIChoYXNIYW5kbGVyKSB0aHJvdyBlcnI7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnVubmVyLmNsaWVudC5zdHJlYW0ocnVubmVyLmNvbm5lY3Rpb24sIHNxbCwgc3RyZWFtLCBvcHRpb25zKTtcbiAgICB9KVxuXG4gICAgLy8gSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQgdG8gaGFuZGxlIHRoZSBzdHJlYW0sIHNlbmQgdGhlIHN0cmVhbVxuICAgIC8vIHRoZXJlIGFuZCByZXR1cm4gdGhlIHByb21pc2UsIG90aGVyd2lzZSBqdXN0IHJldHVybiB0aGUgc3RyZWFtXG4gICAgLy8gYW5kIHRoZSBwcm9taXNlIHdpbGwgdGFrZSBjYXJlIG9mIGl0c3NlbGYuXG4gICAgaWYgKGhhc0hhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXIoc3RyZWFtKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICByZXR1cm4gc3RyZWFtO1xuICB9LFxuXG4gIC8vIEFsbG93IHlvdSB0byBwaXBlIHRoZSBzdHJlYW0gdG8gYSB3cml0YWJsZSBzdHJlYW0uXG4gIHBpcGUod3JpdGFibGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW0ob3B0aW9ucykucGlwZSh3cml0YWJsZSk7XG4gIH0sXG5cbiAgLy8gXCJSdW5zXCIgYSBxdWVyeSwgcmV0dXJuaW5nIGEgcHJvbWlzZS4gQWxsIHF1ZXJpZXMgc3BlY2lmaWVkIGJ5IHRoZSBidWlsZGVyIGFyZSBndWFyYW50ZWVkXG4gIC8vIHRvIHJ1biBpbiBzZXF1ZW5jZSwgYW5kIG9uIHRoZSBzYW1lIGNvbm5lY3Rpb24sIGVzcGVjaWFsbHkgaGVscGZ1bCB3aGVuIHNjaGVtYSBidWlsZGluZ1xuICAvLyBhbmQgZGVhbGluZyB3aXRoIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnRzLCBldGMuXG4gIHF1ZXJ5OiBQcm9taXNlLm1ldGhvZChmdW5jdGlvbihvYmopIHtcbiAgICB0aGlzLmJ1aWxkZXIuZW1pdCgncXVlcnknLCBhc3NpZ24oe19fa25leFVpZDogdGhpcy5jb25uZWN0aW9uLl9fa25leFVpZH0sIG9iaikpXG4gICAgY29uc3QgcnVubmVyID0gdGhpc1xuICAgIGxldCBxdWVyeVByb21pc2UgPSB0aGlzLmNsaWVudC5xdWVyeSh0aGlzLmNvbm5lY3Rpb24sIG9iailcblxuICAgIGlmKG9iai50aW1lb3V0KSB7XG4gICAgICBxdWVyeVByb21pc2UgPSBxdWVyeVByb21pc2UudGltZW91dChvYmoudGltZW91dClcbiAgICB9XG5cbiAgICByZXR1cm4gcXVlcnlQcm9taXNlXG4gICAgICAudGhlbigocmVzcCkgPT4ge1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRSZXNwb25zZSA9IHRoaXMuY2xpZW50LnByb2Nlc3NSZXNwb25zZShyZXNwLCBydW5uZXIpO1xuICAgICAgICB0aGlzLmJ1aWxkZXIuZW1pdChcbiAgICAgICAgICAncXVlcnktcmVzcG9uc2UnLFxuICAgICAgICAgIHByb2Nlc3NlZFJlc3BvbnNlLFxuICAgICAgICAgIGFzc2lnbih7X19rbmV4VWlkOiB0aGlzLmNvbm5lY3Rpb24uX19rbmV4VWlkfSwgb2JqKSxcbiAgICAgICAgICB0aGlzLmJ1aWxkZXJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jbGllbnQuZW1pdChcbiAgICAgICAgICAncXVlcnktcmVzcG9uc2UnLFxuICAgICAgICAgIHByb2Nlc3NlZFJlc3BvbnNlLFxuICAgICAgICAgIGFzc2lnbih7X19rbmV4VWlkOiB0aGlzLmNvbm5lY3Rpb24uX19rbmV4VWlkfSwgb2JqKSxcbiAgICAgICAgICB0aGlzLmJ1aWxkZXJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZFJlc3BvbnNlO1xuICAgICAgfSkuY2F0Y2goUHJvbWlzZS5UaW1lb3V0RXJyb3IsIGVycm9yID0+IHtcbiAgICAgICAgY29uc3QgeyB0aW1lb3V0LCBzcWwsIGJpbmRpbmdzIH0gPSBvYmo7XG5cbiAgICAgICAgbGV0IGNhbmNlbFF1ZXJ5O1xuICAgICAgICBpZiAob2JqLmNhbmNlbE9uVGltZW91dCkge1xuICAgICAgICAgIGNhbmNlbFF1ZXJ5ID0gdGhpcy5jbGllbnQuY2FuY2VsUXVlcnkodGhpcy5jb25uZWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYW5jZWxRdWVyeSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbmNlbFF1ZXJ5XG4gICAgICAgICAgLmNhdGNoKChjYW5jZWxFcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gY2FuY2VsbGF0aW9uIGZhaWxlZFxuICAgICAgICAgICAgdGhyb3cgYXNzaWduKGNhbmNlbEVycm9yLCB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGBBZnRlciBxdWVyeSB0aW1lb3V0IG9mICR7dGltZW91dH1tcyBleGNlZWRlZCwgY2FuY2VsbGluZyBvZiBxdWVyeSBmYWlsZWQuYCxcbiAgICAgICAgICAgICAgc3FsLCBiaW5kaW5ncywgdGltZW91dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBjYW5jZWxsYXRpb24gc3VjY2VlZGVkLCByZXRocm93IHRpbWVvdXQgZXJyb3JcbiAgICAgICAgICAgIHRocm93IGFzc2lnbihlcnJvciwge1xuICAgICAgICAgICAgICBtZXNzYWdlOiBgRGVmaW5lZCBxdWVyeSB0aW1lb3V0IG9mICR7dGltZW91dH1tcyBleGNlZWRlZCB3aGVuIHJ1bm5pbmcgcXVlcnkuYCxcbiAgICAgICAgICAgICAgc3FsLCBiaW5kaW5ncywgdGltZW91dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICB0aGlzLmJ1aWxkZXIuZW1pdCgncXVlcnktZXJyb3InLCBlcnJvciwgYXNzaWduKHtfX2tuZXhVaWQ6IHRoaXMuY29ubmVjdGlvbi5fX2tuZXhVaWR9LCBvYmopKVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pO1xuICB9KSxcblxuICAvLyBJbiB0aGUgY2FzZSBvZiB0aGUgXCJzY2hlbWEgYnVpbGRlclwiIHdlIGNhbGwgYHF1ZXJ5QXJyYXlgLCB3aGljaCBydW5zIGVhY2hcbiAgLy8gb2YgdGhlIHF1ZXJpZXMgaW4gc2VxdWVuY2UuXG4gIHF1ZXJ5QXJyYXkocXVlcmllcykge1xuICAgIHJldHVybiBxdWVyaWVzLmxlbmd0aCA9PT0gMSA/IHRoaXMucXVlcnkocXVlcmllc1swXSkgOiBQcm9taXNlLmJpbmQodGhpcylcbiAgICAgIC5yZXR1cm4ocXVlcmllcylcbiAgICAgIC5yZWR1Y2UoZnVuY3Rpb24obWVtbywgcXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnkocXVlcnkpLnRoZW4oZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAgIG1lbW8ucHVzaChyZXNwKVxuICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9KTtcbiAgICAgIH0sIFtdKVxuICB9LFxuXG4gIC8vIENoZWNrIHdoZXRoZXIgdGhlcmUncyBhIHRyYW5zYWN0aW9uIGZsYWcsIGFuZCB0aGF0IGl0IGhhcyBhIGNvbm5lY3Rpb24uXG4gIGVuc3VyZUNvbm5lY3Rpb24oKSB7XG4gICAgY29uc3QgcnVubmVyID0gdGhpc1xuICAgIGNvbnN0IGFjcXVpcmVDb25uZWN0aW9uVGltZW91dCA9IHJ1bm5lci5jbGllbnQuY29uZmlnLmFjcXVpcmVDb25uZWN0aW9uVGltZW91dCB8fCA2MDAwMDtcbiAgICByZXR1cm4gUHJvbWlzZS50cnkoKCkgPT4ge1xuICAgICAgcmV0dXJuIHJ1bm5lci5jb25uZWN0aW9uIHx8IG5ldyBQcm9taXNlKChyZXNvbHZlciwgcmVqZWN0ZXIpID0+IHtcbiAgICAgICAgY29uc3QgYWNxdWlyZUNvbm5lY3Rpb24gPSBydW5uZXIuY2xpZW50LmFjcXVpcmVDb25uZWN0aW9uKCk7XG5cbiAgICAgICAgYWNxdWlyZUNvbm5lY3Rpb24uY29tcGxldGVkXG4gICAgICAgICAgLnRpbWVvdXQoYWNxdWlyZUNvbm5lY3Rpb25UaW1lb3V0KVxuICAgICAgICAgIC50aGVuKHJlc29sdmVyKVxuICAgICAgICAgIC5jYXRjaChQcm9taXNlLlRpbWVvdXRFcnJvciwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0RXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdLbmV4OiBUaW1lb3V0IGFjcXVpcmluZyBhIGNvbm5lY3Rpb24uIFRoZSBwb29sIGlzIHByb2JhYmx5IGZ1bGwuICcgK1xuICAgICAgICAgICAgICAnQXJlIHlvdSBtaXNzaW5nIGEgLnRyYW5zYWN0aW5nKHRyeCkgY2FsbD8nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgYWRkaXRpb25hbEVycm9ySW5mb3JtYXRpb24gPSB7XG4gICAgICAgICAgICAgIHRpbWVvdXRTdGFjazogZXJyb3Iuc3RhY2tcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYocnVubmVyLmJ1aWxkZXIpIHtcbiAgICAgICAgICAgICAgYWRkaXRpb25hbEVycm9ySW5mb3JtYXRpb24uc3FsID0gcnVubmVyLmJ1aWxkZXIuc3FsO1xuICAgICAgICAgICAgICBhZGRpdGlvbmFsRXJyb3JJbmZvcm1hdGlvbi5iaW5kaW5ncyA9IHJ1bm5lci5idWlsZGVyLmJpbmRpbmdzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhc3NpZ24odGltZW91dEVycm9yLCBhZGRpdGlvbmFsRXJyb3JJbmZvcm1hdGlvbilcblxuICAgICAgICAgICAgLy8gTGV0IHRoZSBwb29sIGtub3cgdGhhdCB0aGlzIHJlcXVlc3QgZm9yIGEgY29ubmVjdGlvbiB0aW1lZCBvdXRcbiAgICAgICAgICAgIGFjcXVpcmVDb25uZWN0aW9uLmFib3J0KCdLbmV4OiBUaW1lb3V0IGFjcXVpcmluZyBhIGNvbm5lY3Rpb24uJylcblxuICAgICAgICAgICAgcmVqZWN0ZXIodGltZW91dEVycm9yKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKHJlamVjdGVyKVxuICAgICAgfSlcbiAgICB9KS5kaXNwb3NlcihmdW5jdGlvbigpIHtcbiAgICAgIGlmIChydW5uZXIuY29ubmVjdGlvbi5fX2tuZXhfX2Rpc3Bvc2VkKSByZXR1cm5cbiAgICAgIHJ1bm5lci5jbGllbnQucmVsZWFzZUNvbm5lY3Rpb24ocnVubmVyLmNvbm5lY3Rpb24pXG4gICAgfSlcbiAgfVxuXG59KVxuXG5leHBvcnQgZGVmYXVsdCBSdW5uZXI7XG4iXX0=

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(47);
	exports.Stream = __webpack_require__(49);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(51);
	exports.Duplex = __webpack_require__(53);
	exports.Transform = __webpack_require__(56);
	exports.PassThrough = __webpack_require__(58);


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Readable;

	/*<replacement>*/
	var isArray = __webpack_require__(48);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(20).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(18).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	var Stream = __webpack_require__(49);

	/*<replacement>*/
	var util = __webpack_require__(52);
	util.inherits = __webpack_require__(3);
	/*</replacement>*/

	var StringDecoder;


	/*<replacement>*/
	var debug = __webpack_require__(59);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/


	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(53);

	  options = options || {};

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;


	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(60).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  var Duplex = __webpack_require__(53);

	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      if (!addToFront)
	        state.reading = false;

	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);

	        if (state.needReadable)
	          emitReadable(stream);
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(60).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;

	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }

	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);

	  if (!util.isNull(ret))
	    this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }

	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}

	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}

	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 48 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Stream;

	var EE = __webpack_require__(18).EventEmitter;
	var inherits = __webpack_require__(3);

	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(46);
	Stream.Writable = __webpack_require__(50);
	Stream.Duplex = __webpack_require__(54);
	Stream.Transform = __webpack_require__(55);
	Stream.PassThrough = __webpack_require__(57);

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;



	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.

	function Stream() {
	  EE.call(this);
	}

	Stream.prototype.pipe = function(dest, options) {
	  var source = this;

	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }

	  source.on('data', ondata);

	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }

	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }

	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    dest.end();
	  }


	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }

	  source.on('error', onerror);
	  dest.on('error', onerror);

	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);

	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);

	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);

	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);

	    dest.removeListener('close', cleanup);
	  }

	  source.on('end', cleanup);
	  source.on('close', cleanup);

	  dest.on('close', cleanup);

	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(51)


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	module.exports = Writable;

	/*<replacement>*/
	var Buffer = __webpack_require__(20).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(52);
	util.inherits = __webpack_require__(3);
	/*</replacement>*/

	var Stream = __webpack_require__(49);

	util.inherits(Writable, Stream);

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}

	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(53);

	  options = options || {};

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.buffer = [];

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	function Writable(options) {
	  var Duplex = __webpack_require__(53);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (!util.isFunction(cb))
	    cb = function() {};

	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function() {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function() {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);

	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;

	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);

	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });

	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);

	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }

	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }

	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));

	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.

	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = Buffer.isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20).Buffer))

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	module.exports = Duplex;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	/*<replacement>*/
	var util = __webpack_require__(52);
	util.inherits = __webpack_require__(3);
	/*</replacement>*/

	var Readable = __webpack_require__(47);
	var Writable = __webpack_require__(51);

	util.inherits(Duplex, Readable);

	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(53)


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(56)


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.


	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	module.exports = Transform;

	var Duplex = __webpack_require__(53);

	/*<replacement>*/
	var util = __webpack_require__(52);
	util.inherits = __webpack_require__(3);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (!util.isNullOrUndefined(data))
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(options, this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(58)


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	module.exports = PassThrough;

	var Transform = __webpack_require__(56);

	/*<replacement>*/
	var util = __webpack_require__(52);
	util.inherits = __webpack_require__(3);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 59 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(20).Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _queryBuilder = __webpack_require__(62);

	var _queryBuilder2 = _interopRequireDefault(_queryBuilder);

	var _raw = __webpack_require__(2);

	var _raw2 = _interopRequireDefault(_raw);

	var _lodash = __webpack_require__(5);

	// Valid values for the `order by` clause generation.
	var orderBys = ['asc', 'desc'];

	// Turn this into a lookup map
	var operators = _lodash.transform(['=', '<', '>', '<=', '>=', '<>', '!=', 'like', 'not like', 'between', 'ilike', '&', '|', '^', '<<', '>>', 'rlike', 'regexp', 'not regexp', '~', '~*', '!~', '!~*', '#', '&&', '@>', '<@', '||'], function (result, key) {
	  result[key] = true;
	}, {});

	function Formatter(client) {
	  this.client = client;
	  this.bindings = [];
	}

	_lodash.assign(Formatter.prototype, {

	  // Accepts a string or array of columns to wrap as appropriate.
	  columnize: function columnize(target) {
	    var columns = typeof target === 'string' ? [target] : target;
	    var str = '',
	        i = -1;
	    while (++i < columns.length) {
	      if (i > 0) str += ', ';
	      str += this.wrap(columns[i]);
	    }
	    return str;
	  },

	  // Turns a list of values into a list of ?'s, joining them with commas unless
	  // a "joining" value is specified (e.g. ' and ')
	  parameterize: function parameterize(values, notSetValue) {
	    if (typeof values === 'function') return this.parameter(values);
	    values = Array.isArray(values) ? values : [values];
	    var str = '',
	        i = -1;
	    while (++i < values.length) {
	      if (i > 0) str += ', ';
	      str += this.parameter(values[i] === undefined ? notSetValue : values[i]);
	    }
	    return str;
	  },

	  // Checks whether a value is a function... if it is, we compile it
	  // otherwise we check whether it's a raw
	  parameter: function parameter(value) {
	    if (typeof value === 'function') {
	      return this.outputQuery(this.compileCallback(value), true);
	    }
	    return this.unwrapRaw(value, true) || '?';
	  },

	  unwrapRaw: function unwrapRaw(value, isParameter) {
	    var query = undefined;
	    if (value instanceof _queryBuilder2['default']) {
	      query = this.client.queryCompiler(value).toSQL();
	      if (query.bindings) {
	        this.bindings = this.bindings.concat(query.bindings);
	      }
	      return this.outputQuery(query, isParameter);
	    }
	    if (value instanceof _raw2['default']) {
	      value.client = this.client;
	      query = value.toSQL();
	      if (query.bindings) {
	        this.bindings = this.bindings.concat(query.bindings);
	      }
	      return query.sql;
	    }
	    if (isParameter) {
	      this.bindings.push(value);
	    }
	  },

	  rawOrFn: function rawOrFn(value, method) {
	    if (typeof value === 'function') {
	      return this.outputQuery(this.compileCallback(value, method));
	    }
	    return this.unwrapRaw(value) || '';
	  },

	  // Puts the appropriate wrapper around a value depending on the database
	  // engine, unless it's a knex.raw value, in which case it's left alone.
	  wrap: function wrap(value) {
	    if (typeof value === 'function') {
	      return this.outputQuery(this.compileCallback(value), true);
	    }
	    var raw = this.unwrapRaw(value);
	    if (raw) return raw;
	    if (typeof value === 'number') return value;
	    return this._wrapString(value + '');
	  },

	  wrapAsIdentifier: function wrapAsIdentifier(value) {
	    return this.client.wrapIdentifier((value || '').trim());
	  },

	  alias: function alias(first, second) {
	    return first + ' as ' + second;
	  },

	  // The operator method takes a value and returns something or other.
	  operator: function operator(value) {
	    var raw = this.unwrapRaw(value);
	    if (raw) return raw;
	    if (operators[(value || '').toLowerCase()] !== true) {
	      throw new TypeError('The operator "' + value + '" is not permitted');
	    }
	    return value;
	  },

	  // Specify the direction of the ordering.
	  direction: function direction(value) {
	    var raw = this.unwrapRaw(value);
	    if (raw) return raw;
	    return orderBys.indexOf((value || '').toLowerCase()) !== -1 ? value : 'asc';
	  },

	  // Compiles a callback using the query builder.
	  compileCallback: function compileCallback(callback, method) {
	    var client = this.client;

	    // Build the callback
	    var builder = client.queryBuilder();
	    callback.call(builder, builder);

	    // Compile the callback, using the current formatter (to track all bindings).
	    var compiler = client.queryCompiler(builder);
	    compiler.formatter = this;

	    // Return the compiled & parameterized sql.
	    return compiler.toSQL(method || 'select');
	  },

	  // Ensures the query is aliased if necessary.
	  outputQuery: function outputQuery(compiled, isParameter) {
	    var sql = compiled.sql || '';
	    if (sql) {
	      if (compiled.method === 'select' && (isParameter || compiled.as)) {
	        sql = '(' + sql + ')';
	        if (compiled.as) return this.alias(sql, this.wrap(compiled.as));
	      }
	    }
	    return sql;
	  },

	  // Coerce to string to prevent strange errors when it's not a string.
	  _wrapString: function _wrapString(value) {
	    var asIndex = value.toLowerCase().indexOf(' as ');
	    if (asIndex !== -1) {
	      var first = value.slice(0, asIndex);
	      var second = value.slice(asIndex + 4);
	      return this.alias(this.wrap(first), this.wrapAsIdentifier(second));
	    }
	    var wrapped = [];
	    var i = -1;
	    var segments = value.split('.');
	    while (++i < segments.length) {
	      value = segments[i];
	      if (i === 0 && segments.length > 1) {
	        wrapped.push(this.wrap((value || '').trim()));
	      } else {
	        wrapped.push(this.client.wrapIdentifier((value || '').trim()));
	      }
	    }
	    return wrapped.join('.');
	  }

	});

	exports['default'] = Formatter;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,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LElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztPQUNoRTtLQUNGO0FBQ0QsV0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0dBQzFCOztDQUVGLENBQUMsQ0FBQzs7cUJBRVksU0FBUyIsImZpbGUiOiJmb3JtYXR0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBRdWVyeUJ1aWxkZXIgZnJvbSAnLi9xdWVyeS9idWlsZGVyJztcbmltcG9ydCBSYXcgZnJvbSAnLi9yYXcnO1xuXG5pbXBvcnQgeyBhc3NpZ24sIHRyYW5zZm9ybSB9IGZyb20gJ2xvZGFzaCdcblxuLy8gVmFsaWQgdmFsdWVzIGZvciB0aGUgYG9yZGVyIGJ5YCBjbGF1c2UgZ2VuZXJhdGlvbi5cbmNvbnN0IG9yZGVyQnlzID0gWydhc2MnLCAnZGVzYyddO1xuXG4vLyBUdXJuIHRoaXMgaW50byBhIGxvb2t1cCBtYXBcbmNvbnN0IG9wZXJhdG9ycyA9IHRyYW5zZm9ybShbXG4gICc9JywgJzwnLCAnPicsICc8PScsICc+PScsICc8PicsICchPScsICdsaWtlJyxcbiAgJ25vdCBsaWtlJywgJ2JldHdlZW4nLCAnaWxpa2UnLCAnJicsICd8JywgJ14nLCAnPDwnLCAnPj4nLFxuICAncmxpa2UnLCAncmVnZXhwJywgJ25vdCByZWdleHAnLCAnficsICd+KicsICchficsICchfionLFxuICAnIycsICcmJicsICdAPicsICc8QCcsICd8fCdcbl0sIChyZXN1bHQsIGtleSkgPT4ge1xuICByZXN1bHRba2V5XSA9IHRydWVcbn0sIHt9KTtcblxuZnVuY3Rpb24gRm9ybWF0dGVyKGNsaWVudCkge1xuICB0aGlzLmNsaWVudCA9IGNsaWVudFxuICB0aGlzLmJpbmRpbmdzID0gW11cbn1cblxuYXNzaWduKEZvcm1hdHRlci5wcm90b3R5cGUsIHtcblxuICAvLyBBY2NlcHRzIGEgc3RyaW5nIG9yIGFycmF5IG9mIGNvbHVtbnMgdG8gd3JhcCBhcyBhcHByb3ByaWF0ZS5cbiAgY29sdW1uaXplKHRhcmdldCkge1xuICAgIGNvbnN0IGNvbHVtbnMgPSB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IFt0YXJnZXRdIDogdGFyZ2V0XG4gICAgbGV0IHN0ciA9ICcnLCBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IGNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICBpZiAoaSA+IDApIHN0ciArPSAnLCAnXG4gICAgICBzdHIgKz0gdGhpcy53cmFwKGNvbHVtbnNbaV0pXG4gICAgfVxuICAgIHJldHVybiBzdHJcbiAgfSxcblxuICAvLyBUdXJucyBhIGxpc3Qgb2YgdmFsdWVzIGludG8gYSBsaXN0IG9mID8ncywgam9pbmluZyB0aGVtIHdpdGggY29tbWFzIHVubGVzc1xuICAvLyBhIFwiam9pbmluZ1wiIHZhbHVlIGlzIHNwZWNpZmllZCAoZS5nLiAnIGFuZCAnKVxuICBwYXJhbWV0ZXJpemUodmFsdWVzLCBub3RTZXRWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWVzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5wYXJhbWV0ZXIodmFsdWVzKTtcbiAgICB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMgOiBbdmFsdWVzXTtcbiAgICBsZXQgc3RyID0gJycsIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgaWYgKGkgPiAwKSBzdHIgKz0gJywgJ1xuICAgICAgc3RyICs9IHRoaXMucGFyYW1ldGVyKHZhbHVlc1tpXSA9PT0gdW5kZWZpbmVkID8gbm90U2V0VmFsdWUgOiB2YWx1ZXNbaV0pXG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH0sXG5cbiAgLy8gQ2hlY2tzIHdoZXRoZXIgYSB2YWx1ZSBpcyBhIGZ1bmN0aW9uLi4uIGlmIGl0IGlzLCB3ZSBjb21waWxlIGl0XG4gIC8vIG90aGVyd2lzZSB3ZSBjaGVjayB3aGV0aGVyIGl0J3MgYSByYXdcbiAgcGFyYW1ldGVyKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMub3V0cHV0UXVlcnkodGhpcy5jb21waWxlQ2FsbGJhY2sodmFsdWUpLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudW53cmFwUmF3KHZhbHVlLCB0cnVlKSB8fCAnPyc7XG4gIH0sXG5cbiAgdW53cmFwUmF3KHZhbHVlLCBpc1BhcmFtZXRlcikge1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBRdWVyeUJ1aWxkZXIpIHtcbiAgICAgIHF1ZXJ5ID0gdGhpcy5jbGllbnQucXVlcnlDb21waWxlcih2YWx1ZSkudG9TUUwoKVxuICAgICAgaWYgKHF1ZXJ5LmJpbmRpbmdzKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmNvbmNhdChxdWVyeS5iaW5kaW5ncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5vdXRwdXRRdWVyeShxdWVyeSwgaXNQYXJhbWV0ZXIpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBSYXcpIHtcbiAgICAgIHZhbHVlLmNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgICAgcXVlcnkgPSB2YWx1ZS50b1NRTCgpXG4gICAgICBpZiAocXVlcnkuYmluZGluZ3MpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuY29uY2F0KHF1ZXJ5LmJpbmRpbmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBxdWVyeS5zcWxcbiAgICB9XG4gICAgaWYgKGlzUGFyYW1ldGVyKSB7XG4gICAgICB0aGlzLmJpbmRpbmdzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICByYXdPckZuKHZhbHVlLCBtZXRob2QpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5vdXRwdXRRdWVyeSh0aGlzLmNvbXBpbGVDYWxsYmFjayh2YWx1ZSwgbWV0aG9kKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVud3JhcFJhdyh2YWx1ZSkgfHwgJyc7XG4gIH0sXG5cbiAgLy8gUHV0cyB0aGUgYXBwcm9wcmlhdGUgd3JhcHBlciBhcm91bmQgYSB2YWx1ZSBkZXBlbmRpbmcgb24gdGhlIGRhdGFiYXNlXG4gIC8vIGVuZ2luZSwgdW5sZXNzIGl0J3MgYSBrbmV4LnJhdyB2YWx1ZSwgaW4gd2hpY2ggY2FzZSBpdCdzIGxlZnQgYWxvbmUuXG4gIHdyYXAodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5vdXRwdXRRdWVyeSh0aGlzLmNvbXBpbGVDYWxsYmFjayh2YWx1ZSksIHRydWUpO1xuICAgIH1cbiAgICBjb25zdCByYXcgPSB0aGlzLnVud3JhcFJhdyh2YWx1ZSk7XG4gICAgaWYgKHJhdykgcmV0dXJuIHJhdztcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgcmV0dXJuIHZhbHVlO1xuICAgIHJldHVybiB0aGlzLl93cmFwU3RyaW5nKHZhbHVlICsgJycpO1xuICB9LFxuXG4gIHdyYXBBc0lkZW50aWZpZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQud3JhcElkZW50aWZpZXIoKHZhbHVlIHx8ICcnKS50cmltKCkpO1xuICB9LFxuXG4gIGFsaWFzKGZpcnN0LCBzZWNvbmQpIHtcbiAgICByZXR1cm4gZmlyc3QgKyAnIGFzICcgKyBzZWNvbmQ7XG4gIH0sXG5cbiAgLy8gVGhlIG9wZXJhdG9yIG1ldGhvZCB0YWtlcyBhIHZhbHVlIGFuZCByZXR1cm5zIHNvbWV0aGluZyBvciBvdGhlci5cbiAgb3BlcmF0b3IodmFsdWUpIHtcbiAgICBjb25zdCByYXcgPSB0aGlzLnVud3JhcFJhdyh2YWx1ZSk7XG4gICAgaWYgKHJhdykgcmV0dXJuIHJhdztcbiAgICBpZiAob3BlcmF0b3JzWyh2YWx1ZSB8fCAnJykudG9Mb3dlckNhc2UoKV0gIT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBvcGVyYXRvciBcIiR7dmFsdWV9XCIgaXMgbm90IHBlcm1pdHRlZGApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG5cbiAgLy8gU3BlY2lmeSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBvcmRlcmluZy5cbiAgZGlyZWN0aW9uKHZhbHVlKSB7XG4gICAgY29uc3QgcmF3ID0gdGhpcy51bndyYXBSYXcodmFsdWUpO1xuICAgIGlmIChyYXcpIHJldHVybiByYXc7XG4gICAgcmV0dXJuIG9yZGVyQnlzLmluZGV4T2YoKHZhbHVlIHx8ICcnKS50b0xvd2VyQ2FzZSgpKSAhPT0gLTEgPyB2YWx1ZSA6ICdhc2MnO1xuICB9LFxuXG4gIC8vIENvbXBpbGVzIGEgY2FsbGJhY2sgdXNpbmcgdGhlIHF1ZXJ5IGJ1aWxkZXIuXG4gIGNvbXBpbGVDYWxsYmFjayhjYWxsYmFjaywgbWV0aG9kKSB7XG4gICAgY29uc3QgeyBjbGllbnQgfSA9IHRoaXM7XG5cbiAgICAvLyBCdWlsZCB0aGUgY2FsbGJhY2tcbiAgICBjb25zdCBidWlsZGVyID0gY2xpZW50LnF1ZXJ5QnVpbGRlcigpO1xuICAgIGNhbGxiYWNrLmNhbGwoYnVpbGRlciwgYnVpbGRlcik7XG5cbiAgICAvLyBDb21waWxlIHRoZSBjYWxsYmFjaywgdXNpbmcgdGhlIGN1cnJlbnQgZm9ybWF0dGVyICh0byB0cmFjayBhbGwgYmluZGluZ3MpLlxuICAgIGNvbnN0IGNvbXBpbGVyID0gY2xpZW50LnF1ZXJ5Q29tcGlsZXIoYnVpbGRlcik7XG4gICAgY29tcGlsZXIuZm9ybWF0dGVyID0gdGhpcztcblxuICAgIC8vIFJldHVybiB0aGUgY29tcGlsZWQgJiBwYXJhbWV0ZXJpemVkIHNxbC5cbiAgICByZXR1cm4gY29tcGlsZXIudG9TUUwobWV0aG9kIHx8ICdzZWxlY3QnKTtcbiAgfSxcblxuICAvLyBFbnN1cmVzIHRoZSBxdWVyeSBpcyBhbGlhc2VkIGlmIG5lY2Vzc2FyeS5cbiAgb3V0cHV0UXVlcnkoY29tcGlsZWQsIGlzUGFyYW1ldGVyKSB7XG4gICAgbGV0IHNxbCA9IGNvbXBpbGVkLnNxbCB8fCAnJztcbiAgICBpZiAoc3FsKSB7XG4gICAgICBpZiAoY29tcGlsZWQubWV0aG9kID09PSAnc2VsZWN0JyAmJiAoaXNQYXJhbWV0ZXIgfHwgY29tcGlsZWQuYXMpKSB7XG4gICAgICAgIHNxbCA9IGAoJHtzcWx9KWA7XG4gICAgICAgIGlmIChjb21waWxlZC5hcykgcmV0dXJuIHRoaXMuYWxpYXMoc3FsLCB0aGlzLndyYXAoY29tcGlsZWQuYXMpKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3FsO1xuICB9LFxuXG4gIC8vIENvZXJjZSB0byBzdHJpbmcgdG8gcHJldmVudCBzdHJhbmdlIGVycm9ycyB3aGVuIGl0J3Mgbm90IGEgc3RyaW5nLlxuICBfd3JhcFN0cmluZyh2YWx1ZSkge1xuICAgIGNvbnN0IGFzSW5kZXggPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJyBhcyAnKTtcbiAgICBpZiAoYXNJbmRleCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gdmFsdWUuc2xpY2UoMCwgYXNJbmRleClcbiAgICAgIGNvbnN0IHNlY29uZCA9IHZhbHVlLnNsaWNlKGFzSW5kZXggKyA0KVxuICAgICAgcmV0dXJuIHRoaXMuYWxpYXModGhpcy53cmFwKGZpcnN0KSwgdGhpcy53cmFwQXNJZGVudGlmaWVyKHNlY29uZCkpXG4gICAgfVxuICAgIGNvbnN0IHdyYXBwZWQgPSBbXTtcbiAgICBsZXQgaSA9IC0xO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdmFsdWUuc3BsaXQoJy4nKTtcbiAgICB3aGlsZSAoKytpIDwgc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICB2YWx1ZSA9IHNlZ21lbnRzW2ldO1xuICAgICAgaWYgKGkgPT09IDAgJiYgc2VnbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICB3cmFwcGVkLnB1c2godGhpcy53cmFwKCh2YWx1ZSB8fCAnJykudHJpbSgpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cmFwcGVkLnB1c2godGhpcy5jbGllbnQud3JhcElkZW50aWZpZXIoKHZhbHVlIHx8ICcnKS50cmltKCkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdyYXBwZWQuam9pbignLicpO1xuICB9XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBGb3JtYXR0ZXI7XG4iXX0=

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	
	// Builder
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _assert = __webpack_require__(63);

	var _assert2 = _interopRequireDefault(_assert);

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _events = __webpack_require__(18);

	var _raw = __webpack_require__(2);

	var _raw2 = _interopRequireDefault(_raw);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _joinclause = __webpack_require__(64);

	var _joinclause2 = _interopRequireDefault(_joinclause);

	var _lodash = __webpack_require__(5);

	// Typically called from `knex.builder`,
	// start a new query building chain.
	function Builder(client) {
	  this.client = client;
	  this.and = this;
	  this._single = {};
	  this._statements = [];
	  this._method = 'select';
	  this._debug = client.config && client.config.debug;

	  // Internal flags used in the builder.
	  this._joinFlag = 'inner';
	  this._boolFlag = 'and';
	  this._notFlag = false;
	}
	_inherits2['default'](Builder, _events.EventEmitter);

	_lodash.assign(Builder.prototype, {

	  toString: function toString() {
	    return this.toQuery();
	  },

	  // Convert the current query "toSQL"
	  toSQL: function toSQL(method, tz) {
	    return this.client.queryCompiler(this).toSQL(method || this._method, tz);
	  },

	  // Create a shallow clone of the current query builder.
	  clone: function clone() {
	    var cloned = new this.constructor(this.client);
	    cloned._method = this._method;
	    cloned._single = _lodash.clone(this._single);
	    cloned._statements = _lodash.clone(this._statements);
	    cloned._debug = this._debug;

	    // `_option` is assigned by the `Interface` mixin.
	    if (!_lodash.isUndefined(this._options)) {
	      cloned._options = _lodash.clone(this._options);
	    }

	    return cloned;
	  },

	  timeout: function timeout(ms) {
	    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var cancel = _ref.cancel;

	    if (_lodash.isNumber(ms) && ms > 0) {
	      this._timeout = ms;
	      if (cancel) {
	        this.client.assertCanCancelQuery();
	        this._cancelOnTimeout = true;
	      }
	    }
	    return this;
	  },

	  // Select
	  // ------

	  // Adds a column or columns to the list of "columns"
	  // being selected on the query.
	  columns: function columns(column) {
	    if (!column) return this;
	    this._statements.push({
	      grouping: 'columns',
	      value: helpers.normalizeArr.apply(null, arguments)
	    });
	    return this;
	  },

	  // Allow for a sub-select to be explicitly aliased as a column,
	  // without needing to compile the query in a where.
	  as: function as(column) {
	    this._single.as = column;
	    return this;
	  },

	  // Prepends the `schemaName` on `tableName` defined by `.table` and `.join`.
	  withSchema: function withSchema(schemaName) {
	    this._single.schema = schemaName;
	    return this;
	  },

	  // Sets the `tableName` on the query.
	  // Alias to "from" for select and "into" for insert statements
	  // e.g. builder.insert({a: value}).into('tableName')
	  table: function table(tableName) {
	    this._single.table = tableName;
	    return this;
	  },

	  // Adds a `distinct` clause to the query.
	  distinct: function distinct() {
	    this._statements.push({
	      grouping: 'columns',
	      value: helpers.normalizeArr.apply(null, arguments),
	      distinct: true
	    });
	    return this;
	  },

	  // Adds a join clause to the query, allowing for advanced joins
	  // with an anonymous function as the second argument.
	  // function(table, first, operator, second)
	  join: function join(table, first) {
	    var join = undefined;
	    var schema = this._single.schema;

	    var joinType = this._joinType();
	    if (typeof first === 'function') {
	      join = new _joinclause2['default'](table, joinType, schema);
	      first.call(join, join);
	    } else if (joinType === 'raw') {
	      join = new _joinclause2['default'](this.client.raw(table, first), 'raw');
	    } else {
	      join = new _joinclause2['default'](table, joinType, schema);
	      if (arguments.length > 1) {
	        join.on.apply(join, _lodash.toArray(arguments).slice(1));
	      }
	    }
	    this._statements.push(join);
	    return this;
	  },

	  // JOIN blocks:
	  innerJoin: function innerJoin() {
	    return this._joinType('inner').join.apply(this, arguments);
	  },
	  leftJoin: function leftJoin() {
	    return this._joinType('left').join.apply(this, arguments);
	  },
	  leftOuterJoin: function leftOuterJoin() {
	    return this._joinType('left outer').join.apply(this, arguments);
	  },
	  rightJoin: function rightJoin() {
	    return this._joinType('right').join.apply(this, arguments);
	  },
	  rightOuterJoin: function rightOuterJoin() {
	    return this._joinType('right outer').join.apply(this, arguments);
	  },
	  outerJoin: function outerJoin() {
	    return this._joinType('outer').join.apply(this, arguments);
	  },
	  fullOuterJoin: function fullOuterJoin() {
	    return this._joinType('full outer').join.apply(this, arguments);
	  },
	  crossJoin: function crossJoin() {
	    return this._joinType('cross').join.apply(this, arguments);
	  },
	  joinRaw: function joinRaw() {
	    return this._joinType('raw').join.apply(this, arguments);
	  },

	  // The where function can be used in several ways:
	  // The most basic is `where(key, value)`, which expands to
	  // where key = value.
	  where: function where(column, operator, value) {

	    // Support "where true || where false"
	    if (column === false || column === true) {
	      return this.where(1, '=', column ? 1 : 0);
	    }

	    // Check if the column is a function, in which case it's
	    // a where statement wrapped in parens.
	    if (typeof column === 'function') {
	      return this.whereWrapped(column);
	    }

	    // Allow a raw statement to be passed along to the query.
	    if (column instanceof _raw2['default'] && arguments.length === 1) return this.whereRaw(column);

	    // Allows `where({id: 2})` syntax.
	    if (_lodash.isObject(column) && !(column instanceof _raw2['default'])) return this._objectWhere(column);

	    // Enable the where('key', value) syntax, only when there
	    // are explicitly two arguments passed, so it's not possible to
	    // do where('key', '!=') and have that turn into where key != null
	    if (arguments.length === 2) {
	      value = operator;
	      operator = '=';

	      // If the value is null, and it's a two argument query,
	      // we assume we're going for a `whereNull`.
	      if (value === null) {
	        return this.whereNull(column);
	      }
	    }

	    // lower case the operator for comparison purposes
	    var checkOperator = ('' + operator).toLowerCase().trim();

	    // If there are 3 arguments, check whether 'in' is one of them.
	    if (arguments.length === 3) {
	      if (checkOperator === 'in' || checkOperator === 'not in') {
	        return this._not(checkOperator === 'not in').whereIn(arguments[0], arguments[2]);
	      }
	      if (checkOperator === 'between' || checkOperator === 'not between') {
	        return this._not(checkOperator === 'not between').whereBetween(arguments[0], arguments[2]);
	      }
	    }

	    // If the value is still null, check whether they're meaning
	    // where value is null
	    if (value === null) {

	      // Check for .where(key, 'is', null) or .where(key, 'is not', 'null');
	      if (checkOperator === 'is' || checkOperator === 'is not') {
	        return this._not(checkOperator === 'is not').whereNull(column);
	      }
	    }

	    // Push onto the where statement stack.
	    this._statements.push({
	      grouping: 'where',
	      type: 'whereBasic',
	      column: column,
	      operator: operator,
	      value: value,
	      not: this._not(),
	      bool: this._bool()
	    });
	    return this;
	  },
	  // Adds an `or where` clause to the query.
	  orWhere: function orWhere() {
	    this._bool('or');
	    var obj = arguments[0];
	    if (_lodash.isObject(obj) && !_lodash.isFunction(obj) && !(obj instanceof _raw2['default'])) {
	      return this.whereWrapped(function () {
	        for (var key in obj) {
	          this.andWhere(key, obj[key]);
	        }
	      });
	    }
	    return this.where.apply(this, arguments);
	  },

	  // Adds an `not where` clause to the query.
	  whereNot: function whereNot() {
	    return this._not(true).where.apply(this, arguments);
	  },

	  // Adds an `or not where` clause to the query.
	  orWhereNot: function orWhereNot() {
	    return this._bool('or').whereNot.apply(this, arguments);
	  },

	  // Processes an object literal provided in a "where" clause.
	  _objectWhere: function _objectWhere(obj) {
	    var boolVal = this._bool();
	    var notVal = this._not() ? 'Not' : '';
	    for (var key in obj) {
	      this[boolVal + 'Where' + notVal](key, obj[key]);
	    }
	    return this;
	  },

	  // Adds a raw `where` clause to the query.
	  whereRaw: function whereRaw(sql, bindings) {
	    var raw = sql instanceof _raw2['default'] ? sql : this.client.raw(sql, bindings);
	    this._statements.push({
	      grouping: 'where',
	      type: 'whereRaw',
	      value: raw,
	      not: this._not(),
	      bool: this._bool()
	    });
	    return this;
	  },

	  orWhereRaw: function orWhereRaw(sql, bindings) {
	    return this._bool('or').whereRaw(sql, bindings);
	  },

	  // Helper for compiling any advanced `where` queries.
	  whereWrapped: function whereWrapped(callback) {
	    this._statements.push({
	      grouping: 'where',
	      type: 'whereWrapped',
	      value: callback,
	      not: this._not(),
	      bool: this._bool()
	    });
	    return this;
	  },

	  // Helper for compiling any advanced `having` queries.
	  havingWrapped: function havingWrapped(callback) {
	    this._statements.push({
	      grouping: 'having',
	      type: 'whereWrapped',
	      value: callback,
	      bool: this._bool()
	    });
	    return this;
	  },

	  // Adds a `where exists` clause to the query.
	  whereExists: function whereExists(callback) {
	    this._statements.push({
	      grouping: 'where',
	      type: 'whereExists',
	      value: callback,
	      not: this._not(),
	      bool: this._bool()
	    });
	    return this;
	  },

	  // Adds an `or where exists` clause to the query.
	  orWhereExists: function orWhereExists(callback) {
	    return this._bool('or').whereExists(callback);
	  },

	  // Adds a `where not exists` clause to the query.
	  whereNotExists: function whereNotExists(callback) {
	    return this._not(true).whereExists(callback);
	  },

	  // Adds a `or where not exists` clause to the query.
	  orWhereNotExists: function orWhereNotExists(callback) {
	    return this._bool('or').whereNotExists(callback);
	  },

	  // Adds a `where in` clause to the query.
	  whereIn: function whereIn(column, values) {
	    if (Array.isArray(values) && _lodash.isEmpty(values)) return this.where(this._not());
	    this._statements.push({
	      grouping: 'where',
	      type: 'whereIn',
	      column: column,
	      value: values,
	      not: this._not(),
	      bool: this._bool()
	    });
	    return this;
	  },

	  // Adds a `or where in` clause to the query.
	  orWhereIn: function orWhereIn(column, values) {
	    return this._bool('or').whereIn(column, values);
	  },

	  // Adds a `where not in` clause to the query.
	  whereNotIn: function whereNotIn(column, values) {
	    return this._not(true).whereIn(column, values);
	  },

	  // Adds a `or where not in` clause to the query.
	  orWhereNotIn: function orWhereNotIn(column, values) {
	    return this._bool('or')._not(true).whereIn(column, values);
	  },

	  // Adds a `where null` clause to the query.
	  whereNull: function whereNull(column) {
	    this._statements.push({
	      grouping: 'where',
	      type: 'whereNull',
	      column: column,
	      not: this._not(),
	      bool: this._bool()
	    });
	    return this;
	  },

	  // Adds a `or where null` clause to the query.
	  orWhereNull: function orWhereNull(column) {
	    return this._bool('or').whereNull(column);
	  },

	  // Adds a `where not null` clause to the query.
	  whereNotNull: function whereNotNull(column) {
	    return this._not(true).whereNull(column);
	  },

	  // Adds a `or where not null` clause to the query.
	  orWhereNotNull: function orWhereNotNull(column) {
	    return this._bool('or').whereNotNull(column);
	  },

	  // Adds a `where between` clause to the query.
	  whereBetween: function whereBetween(column, values) {
	    _assert2['default'](Array.isArray(values), 'The second argument to whereBetween must be an array.');
	    _assert2['default'](values.length === 2, 'You must specify 2 values for the whereBetween clause');
	    this._statements.push({
	      grouping: 'where',
	      type: 'whereBetween',
	      column: column,
	      value: values,
	      not: this._not(),
	      bool: this._bool()
	    });
	    return this;
	  },

	  // Adds a `where not between` clause to the query.
	  whereNotBetween: function whereNotBetween(column, values) {
	    return this._not(true).whereBetween(column, values);
	  },

	  // Adds a `or where between` clause to the query.
	  orWhereBetween: function orWhereBetween(column, values) {
	    return this._bool('or').whereBetween(column, values);
	  },

	  // Adds a `or where not between` clause to the query.
	  orWhereNotBetween: function orWhereNotBetween(column, values) {
	    return this._bool('or').whereNotBetween(column, values);
	  },

	  // Adds a `group by` clause to the query.
	  groupBy: function groupBy(item) {
	    if (item instanceof _raw2['default']) {
	      return this.groupByRaw.apply(this, arguments);
	    }
	    this._statements.push({
	      grouping: 'group',
	      type: 'groupByBasic',
	      value: helpers.normalizeArr.apply(null, arguments)
	    });
	    return this;
	  },

	  // Adds a raw `group by` clause to the query.
	  groupByRaw: function groupByRaw(sql, bindings) {
	    var raw = sql instanceof _raw2['default'] ? sql : this.client.raw(sql, bindings);
	    this._statements.push({
	      grouping: 'group',
	      type: 'groupByRaw',
	      value: raw
	    });
	    return this;
	  },

	  // Adds a `order by` clause to the query.
	  orderBy: function orderBy(column, direction) {
	    this._statements.push({
	      grouping: 'order',
	      type: 'orderByBasic',
	      value: column,
	      direction: direction
	    });
	    return this;
	  },

	  // Add a raw `order by` clause to the query.
	  orderByRaw: function orderByRaw(sql, bindings) {
	    var raw = sql instanceof _raw2['default'] ? sql : this.client.raw(sql, bindings);
	    this._statements.push({
	      grouping: 'order',
	      type: 'orderByRaw',
	      value: raw
	    });
	    return this;
	  },

	  // Add a union statement to the query.
	  union: function union(callbacks, wrap) {
	    if (arguments.length === 1 || arguments.length === 2 && _lodash.isBoolean(wrap)) {
	      if (!Array.isArray(callbacks)) {
	        callbacks = [callbacks];
	      }
	      for (var i = 0, l = callbacks.length; i < l; i++) {
	        this._statements.push({
	          grouping: 'union',
	          clause: 'union',
	          value: callbacks[i],
	          wrap: wrap || false
	        });
	      }
	    } else {
	      callbacks = _lodash.toArray(arguments).slice(0, arguments.length - 1);
	      wrap = arguments[arguments.length - 1];
	      if (!_lodash.isBoolean(wrap)) {
	        callbacks.push(wrap);
	        wrap = false;
	      }
	      this.union(callbacks, wrap);
	    }
	    return this;
	  },

	  // Adds a union all statement to the query.
	  unionAll: function unionAll(callback, wrap) {
	    this._statements.push({
	      grouping: 'union',
	      clause: 'union all',
	      value: callback,
	      wrap: wrap || false
	    });
	    return this;
	  },

	  // Adds a `having` clause to the query.
	  having: function having(column, operator, value) {
	    if (column instanceof _raw2['default'] && arguments.length === 1) {
	      return this._havingRaw(column);
	    }

	    // Check if the column is a function, in which case it's
	    // a having statement wrapped in parens.
	    if (typeof column === 'function') {
	      return this.havingWrapped(column);
	    }

	    this._statements.push({
	      grouping: 'having',
	      type: 'havingBasic',
	      column: column,
	      operator: operator,
	      value: value,
	      bool: this._bool()
	    });
	    return this;
	  },
	  // Adds an `or having` clause to the query.
	  orHaving: function orHaving() {
	    return this._bool('or').having.apply(this, arguments);
	  },
	  havingRaw: function havingRaw(sql, bindings) {
	    return this._havingRaw(sql, bindings);
	  },
	  orHavingRaw: function orHavingRaw(sql, bindings) {
	    return this._bool('or').havingRaw(sql, bindings);
	  },
	  // Adds a raw `having` clause to the query.
	  _havingRaw: function _havingRaw(sql, bindings) {
	    var raw = sql instanceof _raw2['default'] ? sql : this.client.raw(sql, bindings);
	    this._statements.push({
	      grouping: 'having',
	      type: 'havingRaw',
	      value: raw,
	      bool: this._bool()
	    });
	    return this;
	  },

	  // Only allow a single "offset" to be set for the current query.
	  offset: function offset(value) {
	    this._single.offset = value;
	    return this;
	  },

	  // Only allow a single "limit" to be set for the current query.
	  limit: function limit(value) {
	    var val = parseInt(value, 10);
	    if (isNaN(val)) {
	      helpers.warn('A valid integer must be provided to limit');
	    } else {
	      this._single.limit = val;
	    }
	    return this;
	  },

	  // Retrieve the "count" result of the query.
	  count: function count(column) {
	    return this._aggregate('count', column || '*');
	  },

	  // Retrieve the minimum value of a given column.
	  min: function min(column) {
	    return this._aggregate('min', column);
	  },

	  // Retrieve the maximum value of a given column.
	  max: function max(column) {
	    return this._aggregate('max', column);
	  },

	  // Retrieve the sum of the values of a given column.
	  sum: function sum(column) {
	    return this._aggregate('sum', column);
	  },

	  // Retrieve the average of the values of a given column.
	  avg: function avg(column) {
	    return this._aggregate('avg', column);
	  },

	  // Retrieve the "count" of the distinct results of the query.
	  countDistinct: function countDistinct(column) {
	    return this._aggregate('count', column || '*', true);
	  },

	  // Retrieve the sum of the distinct values of a given column.
	  sumDistinct: function sumDistinct(column) {
	    return this._aggregate('sum', column, true);
	  },

	  // Retrieve the vg of the distinct results of the query.
	  avgDistinct: function avgDistinct(column) {
	    return this._aggregate('avg', column, true);
	  },

	  // Increments a column's value by the specified amount.
	  increment: function increment(column, amount) {
	    return this._counter(column, amount);
	  },

	  // Decrements a column's value by the specified amount.
	  decrement: function decrement(column, amount) {
	    return this._counter(column, amount, '-');
	  },

	  // Sets the values for a `select` query, informing that only the first
	  // row should be returned (limit 1).
	  first: function first() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    this.select.apply(this, args);
	    this._method = 'first';
	    this.limit(1);
	    return this;
	  },

	  // Pluck a column from a query.
	  pluck: function pluck(column) {
	    this._method = 'pluck';
	    this._single.pluck = column;
	    this._statements.push({
	      grouping: 'columns',
	      type: 'pluck',
	      value: column
	    });
	    return this;
	  },

	  // Insert & Update
	  // ------

	  // Sets the values for an `insert` query.
	  insert: function insert(values, returning) {
	    this._method = 'insert';
	    if (!_lodash.isEmpty(returning)) this.returning(returning);
	    this._single.insert = values;
	    return this;
	  },

	  // Sets the values for an `update`, allowing for both
	  // `.update(key, value, [returning])` and `.update(obj, [returning])` syntaxes.
	  update: function update(values, returning) {
	    var ret = undefined;
	    var obj = this._single.update || {};
	    this._method = 'update';
	    if (_lodash.isString(values)) {
	      obj[values] = returning;
	      if (arguments.length > 2) {
	        ret = arguments[2];
	      }
	    } else {
	      var keys = Object.keys(values);
	      if (this._single.update) {
	        helpers.warn('Update called multiple times with objects.');
	      }
	      var i = -1;
	      while (++i < keys.length) {
	        obj[keys[i]] = values[keys[i]];
	      }
	      ret = arguments[1];
	    }
	    if (!_lodash.isEmpty(ret)) this.returning(ret);
	    this._single.update = obj;
	    return this;
	  },

	  // Sets the returning value for the query.
	  returning: function returning(_returning) {
	    this._single.returning = _returning;
	    return this;
	  },

	  // Delete
	  // ------

	  // Executes a delete statement on the query;
	  'delete': function _delete(ret) {
	    this._method = 'del';
	    if (!_lodash.isEmpty(ret)) this.returning(ret);
	    return this;
	  },

	  // Truncates a table, ends the query chain.
	  truncate: function truncate(tableName) {
	    this._method = 'truncate';
	    if (tableName) {
	      this._single.table = tableName;
	    }
	    return this;
	  },

	  // Retrieves columns for the table specified by `knex(tableName)`
	  columnInfo: function columnInfo(column) {
	    this._method = 'columnInfo';
	    this._single.columnInfo = column;
	    return this;
	  },

	  // Set a lock for update constraint.
	  forUpdate: function forUpdate() {
	    this._single.lock = 'forUpdate';
	    return this;
	  },

	  // Set a lock for share constraint.
	  forShare: function forShare() {
	    this._single.lock = 'forShare';
	    return this;
	  },

	  // Takes a JS object of methods to call and calls them
	  fromJS: function fromJS(obj) {
	    var _this = this;

	    _lodash.each(obj, function (val, key) {
	      if (typeof _this[key] !== 'function') {
	        helpers.warn('Knex Error: unknown key ' + key);
	      }
	      if (Array.isArray(val)) {
	        _this[key].apply(_this, val);
	      } else {
	        _this[key](val);
	      }
	    });
	    return this;
	  },

	  // Passes query to provided callback function, useful for e.g. composing
	  // domain-specific helpers
	  modify: function modify(callback) {
	    callback.apply(this, [this].concat(_lodash.tail(arguments)));
	    return this;
	  },

	  // ----------------------------------------------------------------------

	  // Helper for the incrementing/decrementing queries.
	  _counter: function _counter(column, amount, symbol) {
	    var amt = parseInt(amount, 10);
	    if (isNaN(amt)) amt = 1;
	    this._method = 'counter';
	    this._single.counter = {
	      column: column,
	      amount: amt,
	      symbol: symbol || '+'
	    };
	    return this;
	  },

	  // Helper to get or set the "boolFlag" value.
	  _bool: function _bool(val) {
	    if (arguments.length === 1) {
	      this._boolFlag = val;
	      return this;
	    }
	    var ret = this._boolFlag;
	    this._boolFlag = 'and';
	    return ret;
	  },

	  // Helper to get or set the "notFlag" value.
	  _not: function _not(val) {
	    if (arguments.length === 1) {
	      this._notFlag = val;
	      return this;
	    }
	    var ret = this._notFlag;
	    this._notFlag = false;
	    return ret;
	  },

	  // Helper to get or set the "joinFlag" value.
	  _joinType: function _joinType(val) {
	    if (arguments.length === 1) {
	      this._joinFlag = val;
	      return this;
	    }
	    var ret = this._joinFlag || 'inner';
	    this._joinFlag = 'inner';
	    return ret;
	  },

	  // Helper for compiling any aggregate queries.
	  _aggregate: function _aggregate(method, column, aggregateDistinct) {
	    this._statements.push({
	      grouping: 'columns',
	      type: 'aggregate',
	      method: method,
	      value: column,
	      aggregateDistinct: aggregateDistinct || false
	    });
	    return this;
	  }

	});

	Object.defineProperty(Builder.prototype, 'or', {
	  get: function get() {
	    return this._bool('or');
	  }
	});

	Object.defineProperty(Builder.prototype, 'not', {
	  get: function get() {
	    return this._not(true);
	  }
	});

	Builder.prototype.select = Builder.prototype.columns;
	Builder.prototype.column = Builder.prototype.columns;
	Builder.prototype.andWhereNot = Builder.prototype.whereNot;
	Builder.prototype.andWhere = Builder.prototype.where;
	Builder.prototype.andWhereRaw = Builder.prototype.whereRaw;
	Builder.prototype.andWhereBetween = Builder.prototype.whereBetween;
	Builder.prototype.andWhereNotBetween = Builder.prototype.whereNotBetween;
	Builder.prototype.andHaving = Builder.prototype.having;
	Builder.prototype.from = Builder.prototype.table;
	Builder.prototype.into = Builder.prototype.table;
	Builder.prototype.del = Builder.prototype['delete'];

	// Attach all of the top level promise methods that should be chainable.
	__webpack_require__(41)(Builder);

	exports['default'] = Builder;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9xdWVyeS9idWlsZGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O3NCQUdtQixRQUFROzs7O3dCQUNOLFVBQVU7Ozs7c0JBQ0YsUUFBUTs7bUJBRXJCLFFBQVE7Ozs7dUJBQ0MsWUFBWTs7SUFBekIsT0FBTzs7MEJBQ0ksY0FBYzs7OztzQkFJOUIsUUFBUTs7OztBQUlmLFNBQVMsT0FBTyxDQUFDLE1BQU0sRUFBRTtBQUN2QixNQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQTtBQUNwQixNQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQztBQUNoQixNQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztBQUNsQixNQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQztBQUN0QixNQUFJLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQTtBQUN2QixNQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7OztBQUduRCxNQUFJLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQztBQUN6QixNQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztBQUN2QixNQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztDQUN2QjtBQUNELHNCQUFTLE9BQU8sdUJBQWUsQ0FBQzs7QUFFaEMsZUFBTyxPQUFPLENBQUMsU0FBUyxFQUFFOztBQUV4QixVQUFRLEVBQUEsb0JBQUc7QUFDVCxXQUFPLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztHQUN2Qjs7O0FBR0QsT0FBSyxFQUFBLGVBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRTtBQUNoQixXQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQztHQUMxRTs7O0FBR0QsT0FBSyxFQUFBLGlCQUFHO0FBQ04sUUFBTSxNQUFNLEdBQUcsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNqRCxVQUFNLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7QUFDOUIsVUFBTSxDQUFDLE9BQU8sR0FBRyxjQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNyQyxVQUFNLENBQUMsV0FBVyxHQUFHLGNBQU0sSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQzdDLFVBQU0sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQzs7O0FBRzVCLFFBQUksQ0FBQyxvQkFBWSxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUU7QUFDL0IsWUFBTSxDQUFDLFFBQVEsR0FBRyxjQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUN4Qzs7QUFFRCxXQUFPLE1BQU0sQ0FBQztHQUNmOztBQUVELFNBQU8sRUFBQSxpQkFBQyxFQUFFLEVBQWlCO3FFQUFKLEVBQUU7O1FBQVosTUFBTSxRQUFOLE1BQU07O0FBQ2pCLFFBQUcsaUJBQVMsRUFBRSxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsRUFBRTtBQUN6QixVQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztBQUNuQixVQUFJLE1BQU0sRUFBRTtBQUNWLFlBQUksQ0FBQyxNQUFNLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztBQUNuQyxZQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDO09BQzlCO0tBQ0Y7QUFDRCxXQUFPLElBQUksQ0FBQztHQUNiOzs7Ozs7O0FBT0QsU0FBTyxFQUFBLGlCQUFDLE1BQU0sRUFBRTtBQUNkLFFBQUksQ0FBQyxNQUFNLEVBQUUsT0FBTyxJQUFJLENBQUM7QUFDekIsUUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7QUFDcEIsY0FBUSxFQUFFLFNBQVM7QUFDbkIsV0FBSyxFQUFFLE9BQU8sQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUM7S0FDbkQsQ0FBQyxDQUFDO0FBQ0gsV0FBTyxJQUFJLENBQUM7R0FDYjs7OztBQUlELElBQUUsRUFBQSxZQUFDLE1BQU0sRUFBRTtBQUNULFFBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxHQUFHLE1BQU0sQ0FBQztBQUN6QixXQUFPLElBQUksQ0FBQztHQUNiOzs7QUFHRCxZQUFVLEVBQUEsb0JBQUMsVUFBVSxFQUFFO0FBQ3JCLFFBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLFVBQVUsQ0FBQztBQUNqQyxXQUFPLElBQUksQ0FBQztHQUNiOzs7OztBQUtELE9BQUssRUFBQSxlQUFDLFNBQVMsRUFBRTtBQUNmLFFBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQztBQUMvQixXQUFPLElBQUksQ0FBQztHQUNiOzs7QUFHRCxVQUFRLEVBQUEsb0JBQUc7QUFDVCxRQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztBQUNwQixjQUFRLEVBQUUsU0FBUztBQUNuQixXQUFLLEVBQUUsT0FBTyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQztBQUNsRCxjQUFRLEVBQUUsSUFBSTtLQUNmLENBQUMsQ0FBQztBQUNILFdBQU8sSUFBSSxDQUFDO0dBQ2I7Ozs7O0FBS0QsTUFBSSxFQUFBLGNBQUMsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUNqQixRQUFJLElBQUksWUFBQSxDQUFDO1FBQ0QsTUFBTSxHQUFLLElBQUksQ0FBQyxPQUFPLENBQXZCLE1BQU07O0FBQ2QsUUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO0FBQ2xDLFFBQUksT0FBTyxLQUFLLEtBQUssVUFBVSxFQUFFO0FBQy9CLFVBQUksR0FBRyw0QkFBZSxLQUFLLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQy9DLFdBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQ3hCLE1BQU0sSUFBSSxRQUFRLEtBQUssS0FBSyxFQUFFO0FBQzdCLFVBQUksR0FBRyw0QkFBZSxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7S0FDN0QsTUFBTTtBQUNMLFVBQUksR0FBRyw0QkFBZSxLQUFLLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQy9DLFVBQUksU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7QUFDeEIsWUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLGdCQUFRLFNBQVMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO09BQ2xEO0tBQ0Y7QUFDRCxRQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM1QixXQUFPLElBQUksQ0FBQztHQUNiOzs7QUFHRCxXQUFTLEVBQUEscUJBQUc7QUFDVixXQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7R0FDNUQ7QUFDRCxVQUFRLEVBQUEsb0JBQUc7QUFDVCxXQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7R0FDM0Q7QUFDRCxlQUFhLEVBQUEseUJBQUc7QUFDZCxXQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7R0FDakU7QUFDRCxXQUFTLEVBQUEscUJBQUc7QUFDVixXQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7R0FDNUQ7QUFDRCxnQkFBYyxFQUFBLDBCQUFHO0FBQ2YsV0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0dBQ2xFO0FBQ0QsV0FBUyxFQUFBLHFCQUFHO0FBQ1YsV0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0dBQzVEO0FBQ0QsZUFBYSxFQUFBLHlCQUFHO0FBQ2QsV0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0dBQ2pFO0FBQ0QsV0FBUyxFQUFBLHFCQUFHO0FBQ1YsV0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0dBQzVEO0FBQ0QsU0FBTyxFQUFBLG1CQUFHO0FBQ1IsV0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0dBQzFEOzs7OztBQUtELE9BQUssRUFBQSxlQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFOzs7QUFHN0IsUUFBSSxNQUFNLEtBQUssS0FBSyxJQUFJLE1BQU0sS0FBSyxJQUFJLEVBQUU7QUFDdkMsYUFBTyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsTUFBTSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQTtLQUMxQzs7OztBQUlELFFBQUksT0FBTyxNQUFNLEtBQUssVUFBVSxFQUFFO0FBQ2hDLGFBQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUNsQzs7O0FBR0QsUUFBSSxNQUFNLDRCQUFlLElBQUksU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsT0FBTyxJQUFJ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QVMsQ0FBQyxPQUFPLENBQUE7QUFDcEQsT0FBTyxDQUFDLFNBQVMsQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUE7QUFDMUQsT0FBTyxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUE7QUFDcEQsT0FBTyxDQUFDLFNBQVMsQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUE7QUFDMUQsT0FBTyxDQUFDLFNBQVMsQ0FBQyxlQUFlLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUE7QUFDbEUsT0FBTyxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLGVBQWUsQ0FBQTtBQUN4RSxPQUFPLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQTtBQUN0RCxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQTtBQUNoRCxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQTtBQUNoRCxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsR0FBRyxPQUFPLENBQUMsU0FBUyxVQUFPLENBQUE7OztBQUdoRCxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7O3FCQUVsQixPQUFPIiwiZmlsZSI6ImJ1aWxkZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8vIEJ1aWxkZXJcbi8vIC0tLS0tLS1cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuXG5pbXBvcnQgUmF3IGZyb20gJy4uL3Jhdyc7XG5pbXBvcnQgKiBhcyBoZWxwZXJzIGZyb20gJy4uL2hlbHBlcnMnO1xuaW1wb3J0IEpvaW5DbGF1c2UgZnJvbSAnLi9qb2luY2xhdXNlJztcbmltcG9ydCB7XG4gIGFzc2lnbiwgY2xvbmUsIGVhY2gsIGlzQm9vbGVhbiwgaXNFbXB0eSwgaXNGdW5jdGlvbiwgaXNOdW1iZXIsIGlzT2JqZWN0LFxuICBpc1N0cmluZywgaXNVbmRlZmluZWQsIHRhaWwsIHRvQXJyYXlcbn0gZnJvbSAnbG9kYXNoJztcblxuLy8gVHlwaWNhbGx5IGNhbGxlZCBmcm9tIGBrbmV4LmJ1aWxkZXJgLFxuLy8gc3RhcnQgYSBuZXcgcXVlcnkgYnVpbGRpbmcgY2hhaW4uXG5mdW5jdGlvbiBCdWlsZGVyKGNsaWVudCkge1xuICB0aGlzLmNsaWVudCA9IGNsaWVudFxuICB0aGlzLmFuZCA9IHRoaXM7XG4gIHRoaXMuX3NpbmdsZSA9IHt9O1xuICB0aGlzLl9zdGF0ZW1lbnRzID0gW107XG4gIHRoaXMuX21ldGhvZCA9ICdzZWxlY3QnXG4gIHRoaXMuX2RlYnVnID0gY2xpZW50LmNvbmZpZyAmJiBjbGllbnQuY29uZmlnLmRlYnVnO1xuXG4gIC8vIEludGVybmFsIGZsYWdzIHVzZWQgaW4gdGhlIGJ1aWxkZXIuXG4gIHRoaXMuX2pvaW5GbGFnID0gJ2lubmVyJztcbiAgdGhpcy5fYm9vbEZsYWcgPSAnYW5kJztcbiAgdGhpcy5fbm90RmxhZyA9IGZhbHNlO1xufVxuaW5oZXJpdHMoQnVpbGRlciwgRXZlbnRFbWl0dGVyKTtcblxuYXNzaWduKEJ1aWxkZXIucHJvdG90eXBlLCB7XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9RdWVyeSgpO1xuICB9LFxuXG4gIC8vIENvbnZlcnQgdGhlIGN1cnJlbnQgcXVlcnkgXCJ0b1NRTFwiXG4gIHRvU1FMKG1ldGhvZCwgdHopIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQucXVlcnlDb21waWxlcih0aGlzKS50b1NRTChtZXRob2QgfHwgdGhpcy5fbWV0aG9kLCB0eik7XG4gIH0sXG5cbiAgLy8gQ3JlYXRlIGEgc2hhbGxvdyBjbG9uZSBvZiB0aGUgY3VycmVudCBxdWVyeSBidWlsZGVyLlxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZWQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmNsaWVudCk7XG4gICAgY2xvbmVkLl9tZXRob2QgPSB0aGlzLl9tZXRob2Q7XG4gICAgY2xvbmVkLl9zaW5nbGUgPSBjbG9uZSh0aGlzLl9zaW5nbGUpO1xuICAgIGNsb25lZC5fc3RhdGVtZW50cyA9IGNsb25lKHRoaXMuX3N0YXRlbWVudHMpO1xuICAgIGNsb25lZC5fZGVidWcgPSB0aGlzLl9kZWJ1ZztcblxuICAgIC8vIGBfb3B0aW9uYCBpcyBhc3NpZ25lZCBieSB0aGUgYEludGVyZmFjZWAgbWl4aW4uXG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9vcHRpb25zKSkge1xuICAgICAgY2xvbmVkLl9vcHRpb25zID0gY2xvbmUodGhpcy5fb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfSxcblxuICB0aW1lb3V0KG1zLCB7Y2FuY2VsfSA9IHt9KSB7XG4gICAgaWYoaXNOdW1iZXIobXMpICYmIG1zID4gMCkge1xuICAgICAgdGhpcy5fdGltZW91dCA9IG1zO1xuICAgICAgaWYgKGNhbmNlbCkge1xuICAgICAgICB0aGlzLmNsaWVudC5hc3NlcnRDYW5DYW5jZWxRdWVyeSgpO1xuICAgICAgICB0aGlzLl9jYW5jZWxPblRpbWVvdXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBTZWxlY3RcbiAgLy8gLS0tLS0tXG5cbiAgLy8gQWRkcyBhIGNvbHVtbiBvciBjb2x1bW5zIHRvIHRoZSBsaXN0IG9mIFwiY29sdW1uc1wiXG4gIC8vIGJlaW5nIHNlbGVjdGVkIG9uIHRoZSBxdWVyeS5cbiAgY29sdW1ucyhjb2x1bW4pIHtcbiAgICBpZiAoIWNvbHVtbikgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5fc3RhdGVtZW50cy5wdXNoKHtcbiAgICAgIGdyb3VwaW5nOiAnY29sdW1ucycsXG4gICAgICB2YWx1ZTogaGVscGVycy5ub3JtYWxpemVBcnIuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIEFsbG93IGZvciBhIHN1Yi1zZWxlY3QgdG8gYmUgZXhwbGljaXRseSBhbGlhc2VkIGFzIGEgY29sdW1uLFxuICAvLyB3aXRob3V0IG5lZWRpbmcgdG8gY29tcGlsZSB0aGUgcXVlcnkgaW4gYSB3aGVyZS5cbiAgYXMoY29sdW1uKSB7XG4gICAgdGhpcy5fc2luZ2xlLmFzID0gY29sdW1uO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIFByZXBlbmRzIHRoZSBgc2NoZW1hTmFtZWAgb24gYHRhYmxlTmFtZWAgZGVmaW5lZCBieSBgLnRhYmxlYCBhbmQgYC5qb2luYC5cbiAgd2l0aFNjaGVtYShzY2hlbWFOYW1lKSB7XG4gICAgdGhpcy5fc2luZ2xlLnNjaGVtYSA9IHNjaGVtYU5hbWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gU2V0cyB0aGUgYHRhYmxlTmFtZWAgb24gdGhlIHF1ZXJ5LlxuICAvLyBBbGlhcyB0byBcImZyb21cIiBmb3Igc2VsZWN0IGFuZCBcImludG9cIiBmb3IgaW5zZXJ0IHN0YXRlbWVudHNcbiAgLy8gZS5nLiBidWlsZGVyLmluc2VydCh7YTogdmFsdWV9KS5pbnRvKCd0YWJsZU5hbWUnKVxuICB0YWJsZSh0YWJsZU5hbWUpIHtcbiAgICB0aGlzLl9zaW5nbGUudGFibGUgPSB0YWJsZU5hbWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gQWRkcyBhIGBkaXN0aW5jdGAgY2xhdXNlIHRvIHRoZSBxdWVyeS5cbiAgZGlzdGluY3QoKSB7XG4gICAgdGhpcy5fc3RhdGVtZW50cy5wdXNoKHtcbiAgICAgIGdyb3VwaW5nOiAnY29sdW1ucycsXG4gICAgICB2YWx1ZTogaGVscGVycy5ub3JtYWxpemVBcnIuYXBwbHkobnVsbCwgYXJndW1lbnRzKSxcbiAgICAgIGRpc3RpbmN0OiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gQWRkcyBhIGpvaW4gY2xhdXNlIHRvIHRoZSBxdWVyeSwgYWxsb3dpbmcgZm9yIGFkdmFuY2VkIGpvaW5zXG4gIC8vIHdpdGggYW4gYW5vbnltb3VzIGZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gIC8vIGZ1bmN0aW9uKHRhYmxlLCBmaXJzdCwgb3BlcmF0b3IsIHNlY29uZClcbiAgam9pbih0YWJsZSwgZmlyc3QpIHtcbiAgICBsZXQgam9pbjtcbiAgICBjb25zdCB7IHNjaGVtYSB9ID0gdGhpcy5fc2luZ2xlO1xuICAgIGNvbnN0IGpvaW5UeXBlID0gdGhpcy5fam9pblR5cGUoKTtcbiAgICBpZiAodHlwZW9mIGZpcnN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBqb2luID0gbmV3IEpvaW5DbGF1c2UodGFibGUsIGpvaW5UeXBlLCBzY2hlbWEpO1xuICAgICAgZmlyc3QuY2FsbChqb2luLCBqb2luKTtcbiAgICB9IGVsc2UgaWYgKGpvaW5UeXBlID09PSAncmF3Jykge1xuICAgICAgam9pbiA9IG5ldyBKb2luQ2xhdXNlKHRoaXMuY2xpZW50LnJhdyh0YWJsZSwgZmlyc3QpLCAncmF3Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGpvaW4gPSBuZXcgSm9pbkNsYXVzZSh0YWJsZSwgam9pblR5cGUsIHNjaGVtYSk7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgam9pbi5vbi5hcHBseShqb2luLCB0b0FycmF5KGFyZ3VtZW50cykuc2xpY2UoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9zdGF0ZW1lbnRzLnB1c2goam9pbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gSk9JTiBibG9ja3M6XG4gIGlubmVySm9pbigpIHtcbiAgICByZXR1cm4gdGhpcy5fam9pblR5cGUoJ2lubmVyJykuam9pbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuICBsZWZ0Sm9pbigpIHtcbiAgICByZXR1cm4gdGhpcy5fam9pblR5cGUoJ2xlZnQnKS5qb2luLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGxlZnRPdXRlckpvaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2pvaW5UeXBlKCdsZWZ0IG91dGVyJykuam9pbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuICByaWdodEpvaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2pvaW5UeXBlKCdyaWdodCcpLmpvaW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcbiAgcmlnaHRPdXRlckpvaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2pvaW5UeXBlKCdyaWdodCBvdXRlcicpLmpvaW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcbiAgb3V0ZXJKb2luKCkge1xuICAgIHJldHVybiB0aGlzLl9qb2luVHlwZSgnb3V0ZXInKS5qb2luLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGZ1bGxPdXRlckpvaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2pvaW5UeXBlKCdmdWxsIG91dGVyJykuam9pbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuICBjcm9zc0pvaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2pvaW5UeXBlKCdjcm9zcycpLmpvaW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcbiAgam9pblJhdygpIHtcbiAgICByZXR1cm4gdGhpcy5fam9pblR5cGUoJ3JhdycpLmpvaW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvLyBUaGUgd2hlcmUgZnVuY3Rpb24gY2FuIGJlIHVzZWQgaW4gc2V2ZXJhbCB3YXlzOlxuICAvLyBUaGUgbW9zdCBiYXNpYyBpcyBgd2hlcmUoa2V5LCB2YWx1ZSlgLCB3aGljaCBleHBhbmRzIHRvXG4gIC8vIHdoZXJlIGtleSA9IHZhbHVlLlxuICB3aGVyZShjb2x1bW4sIG9wZXJhdG9yLCB2YWx1ZSkge1xuXG4gICAgLy8gU3VwcG9ydCBcIndoZXJlIHRydWUgfHwgd2hlcmUgZmFsc2VcIlxuICAgIGlmIChjb2x1bW4gPT09IGZhbHNlIHx8IGNvbHVtbiA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMud2hlcmUoMSwgJz0nLCBjb2x1bW4gPyAxIDogMClcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgY29sdW1uIGlzIGEgZnVuY3Rpb24sIGluIHdoaWNoIGNhc2UgaXQnc1xuICAgIC8vIGEgd2hlcmUgc3RhdGVtZW50IHdyYXBwZWQgaW4gcGFyZW5zLlxuICAgIGlmICh0eXBlb2YgY29sdW1uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy53aGVyZVdyYXBwZWQoY29sdW1uKTtcbiAgICB9XG5cbiAgICAvLyBBbGxvdyBhIHJhdyBzdGF0ZW1lbnQgdG8gYmUgcGFzc2VkIGFsb25nIHRvIHRoZSBxdWVyeS5cbiAgICBpZiAoY29sdW1uIGluc3RhbmNlb2YgUmF3ICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLndoZXJlUmF3KGNvbHVtbik7XG5cbiAgICAvLyBBbGxvd3MgYHdoZXJlKHtpZDogMn0pYCBzeW50YXguXG4gICAgaWYgKGlzT2JqZWN0KGNvbHVtbikgJiYgIShjb2x1bW4gaW5zdGFuY2VvZiBSYXcpKSByZXR1cm4gdGhpcy5fb2JqZWN0V2hlcmUoY29sdW1uKTtcblxuICAgIC8vIEVuYWJsZSB0aGUgd2hlcmUoJ2tleScsIHZhbHVlKSBzeW50YXgsIG9ubHkgd2hlbiB0aGVyZVxuICAgIC8vIGFyZSBleHBsaWNpdGx5IHR3byBhcmd1bWVudHMgcGFzc2VkLCBzbyBpdCdzIG5vdCBwb3NzaWJsZSB0b1xuICAgIC8vIGRvIHdoZXJlKCdrZXknLCAnIT0nKSBhbmQgaGF2ZSB0aGF0IHR1cm4gaW50byB3aGVyZSBrZXkgIT0gbnVsbFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YWx1ZSA9IG9wZXJhdG9yO1xuICAgICAgb3BlcmF0b3IgPSAnPSc7XG5cbiAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBudWxsLCBhbmQgaXQncyBhIHR3byBhcmd1bWVudCBxdWVyeSxcbiAgICAgIC8vIHdlIGFzc3VtZSB3ZSdyZSBnb2luZyBmb3IgYSBgd2hlcmVOdWxsYC5cbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aGVyZU51bGwoY29sdW1uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBsb3dlciBjYXNlIHRoZSBvcGVyYXRvciBmb3IgY29tcGFyaXNvbiBwdXJwb3Nlc1xuICAgIGNvbnN0IGNoZWNrT3BlcmF0b3IgPSAoYCR7b3BlcmF0b3J9YCkudG9Mb3dlckNhc2UoKS50cmltKCk7XG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgMyBhcmd1bWVudHMsIGNoZWNrIHdoZXRoZXIgJ2luJyBpcyBvbmUgb2YgdGhlbS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgaWYgKGNoZWNrT3BlcmF0b3IgPT09ICdpbicgfHwgY2hlY2tPcGVyYXRvciA9PT0gJ25vdCBpbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vdChjaGVja09wZXJhdG9yID09PSAnbm90IGluJykud2hlcmVJbihhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1syXSk7XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tPcGVyYXRvciA9PT0gJ2JldHdlZW4nIHx8IGNoZWNrT3BlcmF0b3IgPT09ICdub3QgYmV0d2VlbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vdChjaGVja09wZXJhdG9yID09PSAnbm90IGJldHdlZW4nKS53aGVyZUJldHdlZW4oYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBzdGlsbCBudWxsLCBjaGVjayB3aGV0aGVyIHRoZXkncmUgbWVhbmluZ1xuICAgIC8vIHdoZXJlIHZhbHVlIGlzIG51bGxcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcblxuICAgICAgLy8gQ2hlY2sgZm9yIC53aGVyZShrZXksICdpcycsIG51bGwpIG9yIC53aGVyZShrZXksICdpcyBub3QnLCAnbnVsbCcpO1xuICAgICAgaWYgKGNoZWNrT3BlcmF0b3IgPT09ICdpcycgfHwgY2hlY2tPcGVyYXRvciA9PT0gJ2lzIG5vdCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vdChjaGVja09wZXJhdG9yID09PSAnaXMgbm90Jykud2hlcmVOdWxsKGNvbHVtbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHVzaCBvbnRvIHRoZSB3aGVyZSBzdGF0ZW1lbnQgc3RhY2suXG4gICAgdGhpcy5fc3RhdGVtZW50cy5wdXNoKHtcbiAgICAgIGdyb3VwaW5nOiAnd2hlcmUnLFxuICAgICAgdHlwZTogJ3doZXJlQmFzaWMnLFxuICAgICAgY29sdW1uLFxuICAgICAgb3BlcmF0b3IsXG4gICAgICB2YWx1ZSxcbiAgICAgIG5vdDogdGhpcy5fbm90KCksXG4gICAgICBib29sOiB0aGlzLl9ib29sKClcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gQWRkcyBhbiBgb3Igd2hlcmVgIGNsYXVzZSB0byB0aGUgcXVlcnkuXG4gIG9yV2hlcmU6IGZ1bmN0aW9uIG9yV2hlcmUoKSB7XG4gICAgdGhpcy5fYm9vbCgnb3InKTtcbiAgICBjb25zdCBvYmogPSBhcmd1bWVudHNbMF07XG4gICAgaWYoaXNPYmplY3Qob2JqKSAmJiAhaXNGdW5jdGlvbihvYmopICYmICEob2JqIGluc3RhbmNlb2YgUmF3KSkge1xuICAgICAgcmV0dXJuIHRoaXMud2hlcmVXcmFwcGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICAgIHRoaXMuYW5kV2hlcmUoa2V5LCBvYmpba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53aGVyZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8vIEFkZHMgYW4gYG5vdCB3aGVyZWAgY2xhdXNlIHRvIHRoZSBxdWVyeS5cbiAgd2hlcmVOb3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vdCh0cnVlKS53aGVyZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8vIEFkZHMgYW4gYG9yIG5vdCB3aGVyZWAgY2xhdXNlIHRvIHRoZSBxdWVyeS5cbiAgb3JXaGVyZU5vdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYm9vbCgnb3InKS53aGVyZU5vdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8vIFByb2Nlc3NlcyBhbiBvYmplY3QgbGl0ZXJhbCBwcm92aWRlZCBpbiBhIFwid2hlcmVcIiBjbGF1c2UuXG4gIF9vYmplY3RXaGVyZShvYmopIHtcbiAgICBjb25zdCBib29sVmFsID0gdGhpcy5fYm9vbCgpO1xuICAgIGNvbnN0IG5vdFZhbCA9IHRoaXMuX25vdCgpID8gJ05vdCcgOiAnJztcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgIHRoaXNbYm9vbFZhbCArICdXaGVyZScgKyBub3RWYWxdKGtleSwgb2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBBZGRzIGEgcmF3IGB3aGVyZWAgY2xhdXNlIHRvIHRoZSBxdWVyeS5cbiAgd2hlcmVSYXcoc3FsLCBiaW5kaW5ncykge1xuICAgIGNvbnN0IHJhdyA9IChzcWwgaW5zdGFuY2VvZiBSYXcgPyBzcWwgOiB0aGlzLmNsaWVudC5yYXcoc3FsLCBiaW5kaW5ncykpO1xuICAgIHRoaXMuX3N0YXRlbWVudHMucHVzaCh7XG4gICAgICBncm91cGluZzogJ3doZXJlJyxcbiAgICAgIHR5cGU6ICd3aGVyZVJhdycsXG4gICAgICB2YWx1ZTogcmF3LFxuICAgICAgbm90OiB0aGlzLl9ub3QoKSxcbiAgICAgIGJvb2w6IHRoaXMuX2Jvb2woKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9yV2hlcmVSYXcoc3FsLCBiaW5kaW5ncykge1xuICAgIHJldHVybiB0aGlzLl9ib29sKCdvcicpLndoZXJlUmF3KHNxbCwgYmluZGluZ3MpO1xuICB9LFxuXG4gIC8vIEhlbHBlciBmb3IgY29tcGlsaW5nIGFueSBhZHZhbmNlZCBgd2hlcmVgIHF1ZXJpZXMuXG4gIHdoZXJlV3JhcHBlZChjYWxsYmFjaykge1xuICAgIHRoaXMuX3N0YXRlbWVudHMucHVzaCh7XG4gICAgICBncm91cGluZzogJ3doZXJlJyxcbiAgICAgIHR5cGU6ICd3aGVyZVdyYXBwZWQnLFxuICAgICAgdmFsdWU6IGNhbGxiYWNrLFxuICAgICAgbm90OiB0aGlzLl9ub3QoKSxcbiAgICAgIGJvb2w6IHRoaXMuX2Jvb2woKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG5cbiAgLy8gSGVscGVyIGZvciBjb21waWxpbmcgYW55IGFkdmFuY2VkIGBoYXZpbmdgIHF1ZXJpZXMuXG4gIGhhdmluZ1dyYXBwZWQoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9zdGF0ZW1lbnRzLnB1c2goe1xuICAgICAgZ3JvdXBpbmc6ICdoYXZpbmcnLFxuICAgICAgdHlwZTogJ3doZXJlV3JhcHBlZCcsXG4gICAgICB2YWx1ZTogY2FsbGJhY2ssXG4gICAgICBib29sOiB0aGlzLl9ib29sKClcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBBZGRzIGEgYHdoZXJlIGV4aXN0c2AgY2xhdXNlIHRvIHRoZSBxdWVyeS5cbiAgd2hlcmVFeGlzdHMoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9zdGF0ZW1lbnRzLnB1c2goe1xuICAgICAgZ3JvdXBpbmc6ICd3aGVyZScsXG4gICAgICB0eXBlOiAnd2hlcmVFeGlzdHMnLFxuICAgICAgdmFsdWU6IGNhbGxiYWNrLFxuICAgICAgbm90OiB0aGlzLl9ub3QoKSxcbiAgICAgIGJvb2w6IHRoaXMuX2Jvb2woKSxcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBBZGRzIGFuIGBvciB3aGVyZSBleGlzdHNgIGNsYXVzZSB0byB0aGUgcXVlcnkuXG4gIG9yV2hlcmVFeGlzdHMoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fYm9vbCgnb3InKS53aGVyZUV4aXN0cyhjYWxsYmFjayk7XG4gIH0sXG5cbiAgLy8gQWRkcyBhIGB3aGVyZSBub3QgZXhpc3RzYCBjbGF1c2UgdG8gdGhlIHF1ZXJ5LlxuICB3aGVyZU5vdEV4aXN0cyhjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9ub3QodHJ1ZSkud2hlcmVFeGlzdHMoY2FsbGJhY2spO1xuICB9LFxuXG4gIC8vIEFkZHMgYSBgb3Igd2hlcmUgbm90IGV4aXN0c2AgY2xhdXNlIHRvIHRoZSBxdWVyeS5cbiAgb3JXaGVyZU5vdEV4aXN0cyhjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9ib29sKCdvcicpLndoZXJlTm90RXhpc3RzKGNhbGxiYWNrKTtcbiAgfSxcblxuICAvLyBBZGRzIGEgYHdoZXJlIGluYCBjbGF1c2UgdG8gdGhlIHF1ZXJ5LlxuICB3aGVyZUluKGNvbHVtbiwgdmFsdWVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSAmJiBpc0VtcHR5KHZhbHVlcykpIHJldHVybiB0aGlzLndoZXJlKHRoaXMuX25vdCgpKTtcbiAgICB0aGlzLl9zdGF0ZW1lbnRzLnB1c2goe1xuICAgICAgZ3JvdXBpbmc6ICd3aGVyZScsXG4gICAgICB0eXBlOiAnd2hlcmVJbicsXG4gICAgICBjb2x1bW4sXG4gICAgICB2YWx1ZTogdmFsdWVzLFxuICAgICAgbm90OiB0aGlzLl9ub3QoKSxcbiAgICAgIGJvb2w6IHRoaXMuX2Jvb2woKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIEFkZHMgYSBgb3Igd2hlcmUgaW5gIGNsYXVzZSB0byB0aGUgcXVlcnkuXG4gIG9yV2hlcmVJbihjb2x1bW4sIHZhbHVlcykge1xuICAgIHJldHVybiB0aGlzLl9ib29sKCdvcicpLndoZXJlSW4oY29sdW1uLCB2YWx1ZXMpO1xuICB9LFxuXG4gIC8vIEFkZHMgYSBgd2hlcmUgbm90IGluYCBjbGF1c2UgdG8gdGhlIHF1ZXJ5LlxuICB3aGVyZU5vdEluKGNvbHVtbiwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vdCh0cnVlKS53aGVyZUluKGNvbHVtbiwgdmFsdWVzKTtcbiAgfSxcblxuICAvLyBBZGRzIGEgYG9yIHdoZXJlIG5vdCBpbmAgY2xhdXNlIHRvIHRoZSBxdWVyeS5cbiAgb3JXaGVyZU5vdEluKGNvbHVtbiwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jvb2woJ29yJykuX25vdCh0cnVlKS53aGVyZUluKGNvbHVtbiwgdmFsdWVzKTtcbiAgfSxcblxuICAvLyBBZGRzIGEgYHdoZXJlIG51bGxgIGNsYXVzZSB0byB0aGUgcXVlcnkuXG4gIHdoZXJlTnVsbChjb2x1bW4pIHtcbiAgICB0aGlzLl9zdGF0ZW1lbnRzLnB1c2goe1xuICAgICAgZ3JvdXBpbmc6ICd3aGVyZScsXG4gICAgICB0eXBlOiAnd2hlcmVOdWxsJyxcbiAgICAgIGNvbHVtbixcbiAgICAgIG5vdDogdGhpcy5fbm90KCksXG4gICAgICBib29sOiB0aGlzLl9ib29sKClcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBBZGRzIGEgYG9yIHdoZXJlIG51bGxgIGNsYXVzZSB0byB0aGUgcXVlcnkuXG4gIG9yV2hlcmVOdWxsKGNvbHVtbikge1xuICAgIHJldHVybiB0aGlzLl9ib29sKCdvcicpLndoZXJlTnVsbChjb2x1bW4pO1xuICB9LFxuXG4gIC8vIEFkZHMgYSBgd2hlcmUgbm90IG51bGxgIGNsYXVzZSB0byB0aGUgcXVlcnkuXG4gIHdoZXJlTm90TnVsbChjb2x1bW4pIHtcbiAgICByZXR1cm4gdGhpcy5fbm90KHRydWUpLndoZXJlTnVsbChjb2x1bW4pO1xuICB9LFxuXG4gIC8vIEFkZHMgYSBgb3Igd2hlcmUgbm90IG51bGxgIGNsYXVzZSB0byB0aGUgcXVlcnkuXG4gIG9yV2hlcmVOb3ROdWxsKGNvbHVtbikge1xuICAgIHJldHVybiB0aGlzLl9ib29sKCdvcicpLndoZXJlTm90TnVsbChjb2x1bW4pO1xuICB9LFxuXG4gIC8vIEFkZHMgYSBgd2hlcmUgYmV0d2VlbmAgY2xhdXNlIHRvIHRoZSBxdWVyeS5cbiAgd2hlcmVCZXR3ZWVuKGNvbHVtbiwgdmFsdWVzKSB7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkodmFsdWVzKSwgJ1RoZSBzZWNvbmQgYXJndW1lbnQgdG8gd2hlcmVCZXR3ZWVuIG11c3QgYmUgYW4gYXJyYXkuJylcbiAgICBhc3NlcnQodmFsdWVzLmxlbmd0aCA9PT0gMiwgJ1lvdSBtdXN0IHNwZWNpZnkgMiB2YWx1ZXMgZm9yIHRoZSB3aGVyZUJldHdlZW4gY2xhdXNlJylcbiAgICB0aGlzLl9zdGF0ZW1lbnRzLnB1c2goe1xuICAgICAgZ3JvdXBpbmc6ICd3aGVyZScsXG4gICAgICB0eXBlOiAnd2hlcmVCZXR3ZWVuJyxcbiAgICAgIGNvbHVtbixcbiAgICAgIHZhbHVlOiB2YWx1ZXMsXG4gICAgICBub3Q6IHRoaXMuX25vdCgpLFxuICAgICAgYm9vbDogdGhpcy5fYm9vbCgpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gQWRkcyBhIGB3aGVyZSBub3QgYmV0d2VlbmAgY2xhdXNlIHRvIHRoZSBxdWVyeS5cbiAgd2hlcmVOb3RCZXR3ZWVuKGNvbHVtbiwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vdCh0cnVlKS53aGVyZUJldHdlZW4oY29sdW1uLCB2YWx1ZXMpO1xuICB9LFxuXG4gIC8vIEFkZHMgYSBgb3Igd2hlcmUgYmV0d2VlbmAgY2xhdXNlIHRvIHRoZSBxdWVyeS5cbiAgb3JXaGVyZUJldHdlZW4oY29sdW1uLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5fYm9vbCgnb3InKS53aGVyZUJldHdlZW4oY29sdW1uLCB2YWx1ZXMpO1xuICB9LFxuXG4gIC8vIEFkZHMgYSBgb3Igd2hlcmUgbm90IGJldHdlZW5gIGNsYXVzZSB0byB0aGUgcXVlcnkuXG4gIG9yV2hlcmVOb3RCZXR3ZWVuKGNvbHVtbiwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jvb2woJ29yJykud2hlcmVOb3RCZXR3ZWVuKGNvbHVtbiwgdmFsdWVzKTtcbiAgfSxcblxuICAvLyBBZGRzIGEgYGdyb3VwIGJ5YCBjbGF1c2UgdG8gdGhlIHF1ZXJ5LlxuICBncm91cEJ5KGl0ZW0pIHtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFJhdykge1xuICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBCeVJhdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0ZW1lbnRzLnB1c2goe1xuICAgICAgZ3JvdXBpbmc6ICdncm91cCcsXG4gICAgICB0eXBlOiAnZ3JvdXBCeUJhc2ljJyxcbiAgICAgIHZhbHVlOiBoZWxwZXJzLm5vcm1hbGl6ZUFyci5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gQWRkcyBhIHJhdyBgZ3JvdXAgYnlgIGNsYXVzZSB0byB0aGUgcXVlcnkuXG4gIGdyb3VwQnlSYXcoc3FsLCBiaW5kaW5ncykge1xuICAgIGNvbnN0IHJhdyA9IChzcWwgaW5zdGFuY2VvZiBSYXcgPyBzcWwgOiB0aGlzLmNsaWVudC5yYXcoc3FsLCBiaW5kaW5ncykpO1xuICAgIHRoaXMuX3N0YXRlbWVudHMucHVzaCh7XG4gICAgICBncm91cGluZzogJ2dyb3VwJyxcbiAgICAgIHR5cGU6ICdncm91cEJ5UmF3JyxcbiAgICAgIHZhbHVlOiByYXdcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBBZGRzIGEgYG9yZGVyIGJ5YCBjbGF1c2UgdG8gdGhlIHF1ZXJ5LlxuICBvcmRlckJ5KGNvbHVtbiwgZGlyZWN0aW9uKSB7XG4gICAgdGhpcy5fc3RhdGVtZW50cy5wdXNoKHtcbiAgICAgIGdyb3VwaW5nOiAnb3JkZXInLFxuICAgICAgdHlwZTogJ29yZGVyQnlCYXNpYycsXG4gICAgICB2YWx1ZTogY29sdW1uLFxuICAgICAgZGlyZWN0aW9uXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gQWRkIGEgcmF3IGBvcmRlciBieWAgY2xhdXNlIHRvIHRoZSBxdWVyeS5cbiAgb3JkZXJCeVJhdyhzcWwsIGJpbmRpbmdzKSB7XG4gICAgY29uc3QgcmF3ID0gKHNxbCBpbnN0YW5jZW9mIFJhdyA/IHNxbCA6IHRoaXMuY2xpZW50LnJhdyhzcWwsIGJpbmRpbmdzKSk7XG4gICAgdGhpcy5fc3RhdGVtZW50cy5wdXNoKHtcbiAgICAgIGdyb3VwaW5nOiAnb3JkZXInLFxuICAgICAgdHlwZTogJ29yZGVyQnlSYXcnLFxuICAgICAgdmFsdWU6IHJhd1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIEFkZCBhIHVuaW9uIHN0YXRlbWVudCB0byB0aGUgcXVlcnkuXG4gIHVuaW9uKGNhbGxiYWNrcywgd3JhcCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8XG4gICAgICAgIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIGlzQm9vbGVhbih3cmFwKSkpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShjYWxsYmFja3MpKSB7XG4gICAgICAgIGNhbGxiYWNrcyA9IFtjYWxsYmFja3NdO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlbWVudHMucHVzaCh7XG4gICAgICAgICAgZ3JvdXBpbmc6ICd1bmlvbicsXG4gICAgICAgICAgY2xhdXNlOiAndW5pb24nLFxuICAgICAgICAgIHZhbHVlOiBjYWxsYmFja3NbaV0sXG4gICAgICAgICAgd3JhcDogd3JhcCB8fCBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2tzID0gdG9BcnJheShhcmd1bWVudHMpLnNsaWNlKDAsIGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIHdyYXAgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKCFpc0Jvb2xlYW4od3JhcCkpIHtcbiAgICAgICAgY2FsbGJhY2tzLnB1c2god3JhcCk7XG4gICAgICAgIHdyYXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMudW5pb24oY2FsbGJhY2tzLCB3cmFwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gQWRkcyBhIHVuaW9uIGFsbCBzdGF0ZW1lbnQgdG8gdGhlIHF1ZXJ5LlxuICB1bmlvbkFsbChjYWxsYmFjaywgd3JhcCkge1xuICAgIHRoaXMuX3N0YXRlbWVudHMucHVzaCh7XG4gICAgICBncm91cGluZzogJ3VuaW9uJyxcbiAgICAgIGNsYXVzZTogJ3VuaW9uIGFsbCcsXG4gICAgICB2YWx1ZTogY2FsbGJhY2ssXG4gICAgICB3cmFwOiB3cmFwIHx8IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gQWRkcyBhIGBoYXZpbmdgIGNsYXVzZSB0byB0aGUgcXVlcnkuXG4gIGhhdmluZyhjb2x1bW4sIG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgIGlmIChjb2x1bW4gaW5zdGFuY2VvZiBSYXcgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhdmluZ1Jhdyhjb2x1bW4pO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZSBjb2x1bW4gaXMgYSBmdW5jdGlvbiwgaW4gd2hpY2ggY2FzZSBpdCdzXG4gICAgLy8gYSBoYXZpbmcgc3RhdGVtZW50IHdyYXBwZWQgaW4gcGFyZW5zLlxuICAgIGlmICh0eXBlb2YgY29sdW1uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXZpbmdXcmFwcGVkKGNvbHVtbik7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGVtZW50cy5wdXNoKHtcbiAgICAgIGdyb3VwaW5nOiAnaGF2aW5nJyxcbiAgICAgIHR5cGU6ICdoYXZpbmdCYXNpYycsXG4gICAgICBjb2x1bW4sXG4gICAgICBvcGVyYXRvcixcbiAgICAgIHZhbHVlLFxuICAgICAgYm9vbDogdGhpcy5fYm9vbCgpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIEFkZHMgYW4gYG9yIGhhdmluZ2AgY2xhdXNlIHRvIHRoZSBxdWVyeS5cbiAgb3JIYXZpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jvb2woJ29yJykuaGF2aW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIGhhdmluZ1JhdyhzcWwsIGJpbmRpbmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhdmluZ1JhdyhzcWwsIGJpbmRpbmdzKTtcbiAgfSxcbiAgb3JIYXZpbmdSYXcoc3FsLCBiaW5kaW5ncykge1xuICAgIHJldHVybiB0aGlzLl9ib29sKCdvcicpLmhhdmluZ1JhdyhzcWwsIGJpbmRpbmdzKTtcbiAgfSxcbiAgLy8gQWRkcyBhIHJhdyBgaGF2aW5nYCBjbGF1c2UgdG8gdGhlIHF1ZXJ5LlxuICBfaGF2aW5nUmF3KHNxbCwgYmluZGluZ3MpIHtcbiAgICBjb25zdCByYXcgPSAoc3FsIGluc3RhbmNlb2YgUmF3ID8gc3FsIDogdGhpcy5jbGllbnQucmF3KHNxbCwgYmluZGluZ3MpKTtcbiAgICB0aGlzLl9zdGF0ZW1lbnRzLnB1c2goe1xuICAgICAgZ3JvdXBpbmc6ICdoYXZpbmcnLFxuICAgICAgdHlwZTogJ2hhdmluZ1JhdycsXG4gICAgICB2YWx1ZTogcmF3LFxuICAgICAgYm9vbDogdGhpcy5fYm9vbCgpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gT25seSBhbGxvdyBhIHNpbmdsZSBcIm9mZnNldFwiIHRvIGJlIHNldCBmb3IgdGhlIGN1cnJlbnQgcXVlcnkuXG4gIG9mZnNldCh2YWx1ZSkge1xuICAgIHRoaXMuX3NpbmdsZS5vZmZzZXQgPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBPbmx5IGFsbG93IGEgc2luZ2xlIFwibGltaXRcIiB0byBiZSBzZXQgZm9yIHRoZSBjdXJyZW50IHF1ZXJ5LlxuICBsaW1pdCh2YWx1ZSkge1xuICAgIGNvbnN0IHZhbCA9IHBhcnNlSW50KHZhbHVlLCAxMClcbiAgICBpZiAoaXNOYU4odmFsKSkge1xuICAgICAgaGVscGVycy53YXJuKCdBIHZhbGlkIGludGVnZXIgbXVzdCBiZSBwcm92aWRlZCB0byBsaW1pdCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NpbmdsZS5saW1pdCA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gUmV0cmlldmUgdGhlIFwiY291bnRcIiByZXN1bHQgb2YgdGhlIHF1ZXJ5LlxuICBjb3VudChjb2x1bW4pIHtcbiAgICByZXR1cm4gdGhpcy5fYWdncmVnYXRlKCdjb3VudCcsIChjb2x1bW4gfHwgJyonKSk7XG4gIH0sXG5cbiAgLy8gUmV0cmlldmUgdGhlIG1pbmltdW0gdmFsdWUgb2YgYSBnaXZlbiBjb2x1bW4uXG4gIG1pbihjb2x1bW4pIHtcbiAgICByZXR1cm4gdGhpcy5fYWdncmVnYXRlKCdtaW4nLCBjb2x1bW4pO1xuICB9LFxuXG4gIC8vIFJldHJpZXZlIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGEgZ2l2ZW4gY29sdW1uLlxuICBtYXgoY29sdW1uKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FnZ3JlZ2F0ZSgnbWF4JywgY29sdW1uKTtcbiAgfSxcblxuICAvLyBSZXRyaWV2ZSB0aGUgc3VtIG9mIHRoZSB2YWx1ZXMgb2YgYSBnaXZlbiBjb2x1bW4uXG4gIHN1bShjb2x1bW4pIHtcbiAgICByZXR1cm4gdGhpcy5fYWdncmVnYXRlKCdzdW0nLCBjb2x1bW4pO1xuICB9LFxuXG4gIC8vIFJldHJpZXZlIHRoZSBhdmVyYWdlIG9mIHRoZSB2YWx1ZXMgb2YgYSBnaXZlbiBjb2x1bW4uXG4gIGF2Zyhjb2x1bW4pIHtcbiAgICByZXR1cm4gdGhpcy5fYWdncmVnYXRlKCdhdmcnLCBjb2x1bW4pO1xuICB9LFxuXG4gIC8vIFJldHJpZXZlIHRoZSBcImNvdW50XCIgb2YgdGhlIGRpc3RpbmN0IHJlc3VsdHMgb2YgdGhlIHF1ZXJ5LlxuICBjb3VudERpc3RpbmN0KGNvbHVtbikge1xuICAgIHJldHVybiB0aGlzLl9hZ2dyZWdhdGUoJ2NvdW50JywgKGNvbHVtbiB8fCAnKicpLCB0cnVlKTtcbiAgfSxcblxuICAvLyBSZXRyaWV2ZSB0aGUgc3VtIG9mIHRoZSBkaXN0aW5jdCB2YWx1ZXMgb2YgYSBnaXZlbiBjb2x1bW4uXG4gIHN1bURpc3RpbmN0KGNvbHVtbikge1xuICAgIHJldHVybiB0aGlzLl9hZ2dyZWdhdGUoJ3N1bScsIGNvbHVtbiwgdHJ1ZSk7XG4gIH0sXG5cbiAgLy8gUmV0cmlldmUgdGhlIHZnIG9mIHRoZSBkaXN0aW5jdCByZXN1bHRzIG9mIHRoZSBxdWVyeS5cbiAgYXZnRGlzdGluY3QoY29sdW1uKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FnZ3JlZ2F0ZSgnYXZnJywgY29sdW1uLCB0cnVlKTtcbiAgfSxcblxuICAvLyBJbmNyZW1lbnRzIGEgY29sdW1uJ3MgdmFsdWUgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuXG4gIGluY3JlbWVudChjb2x1bW4sIGFtb3VudCkge1xuICAgIHJldHVybiB0aGlzLl9jb3VudGVyKGNvbHVtbiwgYW1vdW50KTtcbiAgfSxcblxuICAvLyBEZWNyZW1lbnRzIGEgY29sdW1uJ3MgdmFsdWUgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuXG4gIGRlY3JlbWVudChjb2x1bW4sIGFtb3VudCkge1xuICAgIHJldHVybiB0aGlzLl9jb3VudGVyKGNvbHVtbiwgYW1vdW50LCAnLScpO1xuICB9LFxuXG4gIC8vIFNldHMgdGhlIHZhbHVlcyBmb3IgYSBgc2VsZWN0YCBxdWVyeSwgaW5mb3JtaW5nIHRoYXQgb25seSB0aGUgZmlyc3RcbiAgLy8gcm93IHNob3VsZCBiZSByZXR1cm5lZCAobGltaXQgMSkuXG4gIGZpcnN0KCkge1xuICAgIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICB0aGlzLnNlbGVjdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB0aGlzLl9tZXRob2QgPSAnZmlyc3QnO1xuICAgIHRoaXMubGltaXQoMSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gUGx1Y2sgYSBjb2x1bW4gZnJvbSBhIHF1ZXJ5LlxuICBwbHVjayhjb2x1bW4pIHtcbiAgICB0aGlzLl9tZXRob2QgPSAncGx1Y2snO1xuICAgIHRoaXMuX3NpbmdsZS5wbHVjayA9IGNvbHVtbjtcbiAgICB0aGlzLl9zdGF0ZW1lbnRzLnB1c2goe1xuICAgICAgZ3JvdXBpbmc6ICdjb2x1bW5zJyxcbiAgICAgIHR5cGU6ICdwbHVjaycsXG4gICAgICB2YWx1ZTogY29sdW1uXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gSW5zZXJ0ICYgVXBkYXRlXG4gIC8vIC0tLS0tLVxuXG4gIC8vIFNldHMgdGhlIHZhbHVlcyBmb3IgYW4gYGluc2VydGAgcXVlcnkuXG4gIGluc2VydCh2YWx1ZXMsIHJldHVybmluZykge1xuICAgIHRoaXMuX21ldGhvZCA9ICdpbnNlcnQnO1xuICAgIGlmICghaXNFbXB0eShyZXR1cm5pbmcpKSB0aGlzLnJldHVybmluZyhyZXR1cm5pbmcpO1xuICAgIHRoaXMuX3NpbmdsZS5pbnNlcnQgPSB2YWx1ZXNcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBTZXRzIHRoZSB2YWx1ZXMgZm9yIGFuIGB1cGRhdGVgLCBhbGxvd2luZyBmb3IgYm90aFxuICAvLyBgLnVwZGF0ZShrZXksIHZhbHVlLCBbcmV0dXJuaW5nXSlgIGFuZCBgLnVwZGF0ZShvYmosIFtyZXR1cm5pbmddKWAgc3ludGF4ZXMuXG4gIHVwZGF0ZSh2YWx1ZXMsIHJldHVybmluZykge1xuICAgIGxldCByZXQ7XG4gICAgY29uc3Qgb2JqID0gdGhpcy5fc2luZ2xlLnVwZGF0ZSB8fCB7fTtcbiAgICB0aGlzLl9tZXRob2QgPSAndXBkYXRlJztcbiAgICBpZiAoaXNTdHJpbmcodmFsdWVzKSkge1xuICAgICAgb2JqW3ZhbHVlc10gPSByZXR1cm5pbmc7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgcmV0ID0gYXJndW1lbnRzWzJdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWVzKTtcbiAgICAgIGlmICh0aGlzLl9zaW5nbGUudXBkYXRlKSB7XG4gICAgICAgIGhlbHBlcnMud2FybignVXBkYXRlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIG9iamVjdHMuJylcbiAgICAgIH1cbiAgICAgIGxldCBpID0gLTE7XG4gICAgICB3aGlsZSAoKytpIDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgb2JqW2tleXNbaV1dID0gdmFsdWVzW2tleXNbaV1dXG4gICAgICB9XG4gICAgICByZXQgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICAgIGlmICghaXNFbXB0eShyZXQpKSB0aGlzLnJldHVybmluZyhyZXQpO1xuICAgIHRoaXMuX3NpbmdsZS51cGRhdGUgPSBvYmo7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gU2V0cyB0aGUgcmV0dXJuaW5nIHZhbHVlIGZvciB0aGUgcXVlcnkuXG4gIHJldHVybmluZyhyZXR1cm5pbmcpIHtcbiAgICB0aGlzLl9zaW5nbGUucmV0dXJuaW5nID0gcmV0dXJuaW5nO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIERlbGV0ZVxuICAvLyAtLS0tLS1cblxuICAvLyBFeGVjdXRlcyBhIGRlbGV0ZSBzdGF0ZW1lbnQgb24gdGhlIHF1ZXJ5O1xuICBkZWxldGUocmV0KSB7XG4gICAgdGhpcy5fbWV0aG9kID0gJ2RlbCc7XG4gICAgaWYgKCFpc0VtcHR5KHJldCkpIHRoaXMucmV0dXJuaW5nKHJldCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cblxuICAvLyBUcnVuY2F0ZXMgYSB0YWJsZSwgZW5kcyB0aGUgcXVlcnkgY2hhaW4uXG4gIHRydW5jYXRlKHRhYmxlTmFtZSkge1xuICAgIHRoaXMuX21ldGhvZCA9ICd0cnVuY2F0ZSc7XG4gICAgaWYgKHRhYmxlTmFtZSkge1xuICAgICAgdGhpcy5fc2luZ2xlLnRhYmxlID0gdGFibGVOYW1lXG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIFJldHJpZXZlcyBjb2x1bW5zIGZvciB0aGUgdGFibGUgc3BlY2lmaWVkIGJ5IGBrbmV4KHRhYmxlTmFtZSlgXG4gIGNvbHVtbkluZm8oY29sdW1uKSB7XG4gICAgdGhpcy5fbWV0aG9kID0gJ2NvbHVtbkluZm8nO1xuICAgIHRoaXMuX3NpbmdsZS5jb2x1bW5JbmZvID0gY29sdW1uO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIFNldCBhIGxvY2sgZm9yIHVwZGF0ZSBjb25zdHJhaW50LlxuICBmb3JVcGRhdGUoKSB7XG4gICAgdGhpcy5fc2luZ2xlLmxvY2sgPSAnZm9yVXBkYXRlJztcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyBTZXQgYSBsb2NrIGZvciBzaGFyZSBjb25zdHJhaW50LlxuICBmb3JTaGFyZSgpIHtcbiAgICB0aGlzLl9zaW5nbGUubG9jayA9ICdmb3JTaGFyZSc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gVGFrZXMgYSBKUyBvYmplY3Qgb2YgbWV0aG9kcyB0byBjYWxsIGFuZCBjYWxscyB0aGVtXG4gIGZyb21KUyhvYmopIHtcbiAgICBlYWNoKG9iaiwgKHZhbCwga2V5KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRoaXNba2V5XSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBoZWxwZXJzLndhcm4oYEtuZXggRXJyb3I6IHVua25vd24ga2V5ICR7a2V5fWApXG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHRoaXNba2V5XS5hcHBseSh0aGlzLCB2YWwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW2tleV0odmFsKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcblxuICAvLyBQYXNzZXMgcXVlcnkgdG8gcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24sIHVzZWZ1bCBmb3IgZS5nLiBjb21wb3NpbmdcbiAgLy8gZG9tYWluLXNwZWNpZmljIGhlbHBlcnNcbiAgbW9kaWZ5KGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2suYXBwbHkodGhpcywgW3RoaXNdLmNvbmNhdCh0YWlsKGFyZ3VtZW50cykpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gSGVscGVyIGZvciB0aGUgaW5jcmVtZW50aW5nL2RlY3JlbWVudGluZyBxdWVyaWVzLlxuICBfY291bnRlcihjb2x1bW4sIGFtb3VudCwgc3ltYm9sKSB7XG4gICAgbGV0IGFtdCA9IHBhcnNlSW50KGFtb3VudCwgMTApO1xuICAgIGlmIChpc05hTihhbXQpKSBhbXQgPSAxO1xuICAgIHRoaXMuX21ldGhvZCA9ICdjb3VudGVyJztcbiAgICB0aGlzLl9zaW5nbGUuY291bnRlciA9IHtcbiAgICAgIGNvbHVtbixcbiAgICAgIGFtb3VudDogYW10LFxuICAgICAgc3ltYm9sOiAoc3ltYm9sIHx8ICcrJylcbiAgICB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIEhlbHBlciB0byBnZXQgb3Igc2V0IHRoZSBcImJvb2xGbGFnXCIgdmFsdWUuXG4gIF9ib29sKHZhbCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLl9ib29sRmxhZyA9IHZhbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCByZXQgPSB0aGlzLl9ib29sRmxhZztcbiAgICB0aGlzLl9ib29sRmxhZyA9ICdhbmQnO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLy8gSGVscGVyIHRvIGdldCBvciBzZXQgdGhlIFwibm90RmxhZ1wiIHZhbHVlLlxuICBfbm90KHZhbCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLl9ub3RGbGFnID0gdmFsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHRoaXMuX25vdEZsYWc7XG4gICAgdGhpcy5fbm90RmxhZyA9IGZhbHNlO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLy8gSGVscGVyIHRvIGdldCBvciBzZXQgdGhlIFwiam9pbkZsYWdcIiB2YWx1ZS5cbiAgX2pvaW5UeXBlICh2YWwpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy5fam9pbkZsYWcgPSB2YWw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgcmV0ID0gdGhpcy5fam9pbkZsYWcgfHwgJ2lubmVyJztcbiAgICB0aGlzLl9qb2luRmxhZyA9ICdpbm5lcic7XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvLyBIZWxwZXIgZm9yIGNvbXBpbGluZyBhbnkgYWdncmVnYXRlIHF1ZXJpZXMuXG4gIF9hZ2dyZWdhdGUobWV0aG9kLCBjb2x1bW4sIGFnZ3JlZ2F0ZURpc3RpbmN0KSB7XG4gICAgdGhpcy5fc3RhdGVtZW50cy5wdXNoKHtcbiAgICAgIGdyb3VwaW5nOiAnY29sdW1ucycsXG4gICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgIG1ldGhvZCxcbiAgICAgIHZhbHVlOiBjb2x1bW4sXG4gICAgICBhZ2dyZWdhdGVEaXN0aW5jdDogYWdncmVnYXRlRGlzdGluY3QgfHwgZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVpbGRlci5wcm90b3R5cGUsICdvcicsIHtcbiAgZ2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYm9vbCgnb3InKTtcbiAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWlsZGVyLnByb3RvdHlwZSwgJ25vdCcsIHtcbiAgZ2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbm90KHRydWUpO1xuICB9XG59KTtcblxuQnVpbGRlci5wcm90b3R5cGUuc2VsZWN0ID0gQnVpbGRlci5wcm90b3R5cGUuY29sdW1uc1xuQnVpbGRlci5wcm90b3R5cGUuY29sdW1uID0gQnVpbGRlci5wcm90b3R5cGUuY29sdW1uc1xuQnVpbGRlci5wcm90b3R5cGUuYW5kV2hlcmVOb3QgPSBCdWlsZGVyLnByb3RvdHlwZS53aGVyZU5vdFxuQnVpbGRlci5wcm90b3R5cGUuYW5kV2hlcmUgPSBCdWlsZGVyLnByb3RvdHlwZS53aGVyZVxuQnVpbGRlci5wcm90b3R5cGUuYW5kV2hlcmVSYXcgPSBCdWlsZGVyLnByb3RvdHlwZS53aGVyZVJhd1xuQnVpbGRlci5wcm90b3R5cGUuYW5kV2hlcmVCZXR3ZWVuID0gQnVpbGRlci5wcm90b3R5cGUud2hlcmVCZXR3ZWVuXG5CdWlsZGVyLnByb3RvdHlwZS5hbmRXaGVyZU5vdEJldHdlZW4gPSBCdWlsZGVyLnByb3RvdHlwZS53aGVyZU5vdEJldHdlZW5cbkJ1aWxkZXIucHJvdG90eXBlLmFuZEhhdmluZyA9IEJ1aWxkZXIucHJvdG90eXBlLmhhdmluZ1xuQnVpbGRlci5wcm90b3R5cGUuZnJvbSA9IEJ1aWxkZXIucHJvdG90eXBlLnRhYmxlXG5CdWlsZGVyLnByb3RvdHlwZS5pbnRvID0gQnVpbGRlci5wcm90b3R5cGUudGFibGVcbkJ1aWxkZXIucHJvdG90eXBlLmRlbCA9IEJ1aWxkZXIucHJvdG90eXBlLmRlbGV0ZVxuXG4vLyBBdHRhY2ggYWxsIG9mIHRoZSB0b3AgbGV2ZWwgcHJvbWlzZSBtZXRob2RzIHRoYXQgc2hvdWxkIGJlIGNoYWluYWJsZS5cbnJlcXVpcmUoJy4uL2ludGVyZmFjZScpKEJ1aWxkZXIpO1xuXG5leHBvcnQgZGVmYXVsdCBCdWlsZGVyO1xuIl19

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
	// original notice:

	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	function compare(a, b) {
	  if (a === b) {
	    return 0;
	  }

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break;
	    }
	  }

	  if (x < y) {
	    return -1;
	  }
	  if (y < x) {
	    return 1;
	  }
	  return 0;
	}
	function isBuffer(b) {
	  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
	    return global.Buffer.isBuffer(b);
	  }
	  return !!(b != null && b._isBuffer);
	}

	// based on node assert, original notice:

	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	var util = __webpack_require__(31);
	var hasOwn = Object.prototype.hasOwnProperty;
	var pSlice = Array.prototype.slice;
	var functionsHaveNames = (function () {
	  return function foo() {}.name === 'foo';
	}());
	function pToString (obj) {
	  return Object.prototype.toString.call(obj);
	}
	function isView(arrbuf) {
	  if (isBuffer(arrbuf)) {
	    return false;
	  }
	  if (typeof global.ArrayBuffer !== 'function') {
	    return false;
	  }
	  if (typeof ArrayBuffer.isView === 'function') {
	    return ArrayBuffer.isView(arrbuf);
	  }
	  if (!arrbuf) {
	    return false;
	  }
	  if (arrbuf instanceof DataView) {
	    return true;
	  }
	  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
	    return true;
	  }
	  return false;
	}
	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.

	var assert = module.exports = ok;

	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })

	var regex = /\s*function\s+([^\(\s]*)\s*/;
	// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
	function getName(func) {
	  if (!util.isFunction(func)) {
	    return;
	  }
	  if (functionsHaveNames) {
	    return func.name;
	  }
	  var str = func.toString();
	  var match = str.match(regex);
	  return match && match[1];
	}
	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  } else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;

	      // try to strip useless frames
	      var fn_name = getName(stackStartFunction);
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }

	      this.stack = out;
	    }
	  }
	};

	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);

	function truncate(s, n) {
	  if (typeof s === 'string') {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}
	function inspect(something) {
	  if (functionsHaveNames || !util.isFunction(something)) {
	    return util.inspect(something);
	  }
	  var rawname = getName(something);
	  var name = rawname ? ': ' + rawname : '';
	  return '[Function' +  name + ']';
	}
	function getMessage(self) {
	  return truncate(inspect(self.actual), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(inspect(self.expected), 128);
	}

	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.

	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.

	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}

	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;

	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.

	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;

	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);

	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};

	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);

	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};

	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);

	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};

	assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
	  }
	};

	function _deepEqual(actual, expected, strict, memos) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (isBuffer(actual) && isBuffer(expected)) {
	    return compare(actual, expected) === 0;

	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();

	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;

	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if ((actual === null || typeof actual !== 'object') &&
	             (expected === null || typeof expected !== 'object')) {
	    return strict ? actual === expected : actual == expected;

	  // If both values are instances of typed arrays, wrap their underlying
	  // ArrayBuffers in a Buffer each to increase performance
	  // This optimization requires the arrays to have the same type as checked by
	  // Object.prototype.toString (aka pToString). Never perform binary
	  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
	  // bit patterns are not identical.
	  } else if (isView(actual) && isView(expected) &&
	             pToString(actual) === pToString(expected) &&
	             !(actual instanceof Float32Array ||
	               actual instanceof Float64Array)) {
	    return compare(new Uint8Array(actual.buffer),
	                   new Uint8Array(expected.buffer)) === 0;

	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else if (isBuffer(actual) !== isBuffer(expected)) {
	    return false;
	  } else {
	    memos = memos || {actual: [], expected: []};

	    var actualIndex = memos.actual.indexOf(actual);
	    if (actualIndex !== -1) {
	      if (actualIndex === memos.expected.indexOf(expected)) {
	        return true;
	      }
	    }

	    memos.actual.push(actual);
	    memos.expected.push(expected);

	    return objEquiv(actual, expected, strict, memos);
	  }
	}

	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}

	function objEquiv(a, b, strict, actualVisitedObjects) {
	  if (a === null || a === undefined || b === null || b === undefined)
	    return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b))
	    return a === b;
	  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
	    return false;
	  var aIsArgs = isArguments(a);
	  var bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b, strict);
	  }
	  var ka = objectKeys(a);
	  var kb = objectKeys(b);
	  var key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length !== kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] !== kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
	      return false;
	  }
	  return true;
	}

	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);

	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};

	assert.notDeepStrictEqual = notDeepStrictEqual;
	function notDeepStrictEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
	  }
	}


	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);

	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};

	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};

	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }

	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  }

	  try {
	    if (actual instanceof expected) {
	      return true;
	    }
	  } catch (e) {
	    // Ignore.  The instanceof check doesn't work for arrow functions.
	  }

	  if (Error.isPrototypeOf(expected)) {
	    return false;
	  }

	  return expected.call({}, actual) === true;
	}

	function _tryBlock(block) {
	  var error;
	  try {
	    block();
	  } catch (e) {
	    error = e;
	  }
	  return error;
	}

	function _throws(shouldThrow, block, expected, message) {
	  var actual;

	  if (typeof block !== 'function') {
	    throw new TypeError('"block" argument must be a function');
	  }

	  if (typeof expected === 'string') {
	    message = expected;
	    expected = null;
	  }

	  actual = _tryBlock(block);

	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');

	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }

	  var userProvidedMessage = typeof message === 'string';
	  var isUnwantedException = !shouldThrow && util.isError(actual);
	  var isUnexpectedException = !shouldThrow && actual && !expected;

	  if ((isUnwantedException &&
	      userProvidedMessage &&
	      expectedException(actual, expected)) ||
	      isUnexpectedException) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }

	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}

	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);

	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws(true, block, error, message);
	};

	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
	  _throws(false, block, error, message);
	};

	assert.ifError = function(err) { if (err) throw err; };

	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _lodash = __webpack_require__(5);

	// JoinClause
	// -------

	// The "JoinClause" is an object holding any necessary info about a join,
	// including the type, and any associated tables & columns being joined.
	function JoinClause(table, type, schema) {
	  this.schema = schema;
	  this.table = table;
	  this.joinType = type;
	  this.and = this;
	  this.clauses = [];
	}

	_lodash.assign(JoinClause.prototype, {

	  grouping: 'join',

	  // Adds an "on" clause to the current join object.
	  on: function on(first, operator, second) {
	    if (typeof first === 'function') {
	      this.clauses.push({
	        type: 'onWrapped',
	        value: first,
	        bool: this._bool()
	      });
	      return this;
	    }

	    var data = undefined;
	    var bool = this._bool();
	    switch (arguments.length) {
	      case 1:
	        {
	          if (typeof first === 'object' && typeof first.toSQL !== 'function') {
	            var keys = Object.keys(first);
	            var i = -1;
	            var method = bool === 'or' ? 'orOn' : 'on';
	            while (++i < keys.length) {
	              this[method](keys[i], first[keys[i]]);
	            }
	            return this;
	          } else {
	            data = { type: 'onRaw', value: first, bool: bool };
	          }
	          break;
	        }
	      case 2:
	        data = { type: 'onBasic', column: first, operator: '=', value: operator, bool: bool };break;
	      default:
	        data = { type: 'onBasic', column: first, operator: operator, value: second, bool: bool };
	    }
	    this.clauses.push(data);
	    return this;
	  },

	  // Adds a "using" clause to the current join.
	  using: function using(column) {
	    return this.clauses.push({ type: 'onUsing', column: column, bool: this._bool() });
	  },

	  // Adds an "and on" clause to the current join object.
	  andOn: function andOn() {
	    return this.on.apply(this, arguments);
	  },

	  // Adds an "or on" clause to the current join object.
	  orOn: function orOn(first, operator, second) {
	    return this._bool('or').on.apply(this, arguments);
	  },

	  // Explicitly set the type of join, useful within a function when creating a grouped join.
	  type: function type(_type) {
	    this.joinType = _type;
	    return this;
	  },

	  _bool: function _bool(bool) {
	    if (arguments.length === 1) {
	      this._boolFlag = bool;
	      return this;
	    }
	    var ret = this._boolFlag || 'and';
	    this._boolFlag = 'and';
	    return ret;
	  }

	});

	Object.defineProperty(JoinClause.prototype, 'or', {
	  get: function get() {
	    return this._bool('or');
	  }
	});

	exports['default'] = JoinClause;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9xdWVyeS9qb2luY2xhdXNlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7c0JBQ3VCLFFBQVE7Ozs7Ozs7QUFPL0IsU0FBUyxVQUFVLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUU7QUFDdkMsTUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7QUFDckIsTUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDbkIsTUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7QUFDckIsTUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUM7QUFDaEIsTUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7Q0FDbkI7O0FBRUQsZUFBTyxVQUFVLENBQUMsU0FBUyxFQUFFOztBQUUzQixVQUFRLEVBQUUsTUFBTTs7O0FBR2hCLElBQUUsRUFBQSxZQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFO0FBQzFCLFFBQUksT0FBTyxLQUFLLEtBQUssVUFBVSxFQUFFO0FBQy9CLFVBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO0FBQ2hCLFlBQUksRUFBRSxXQUFXO0FBQ2pCLGFBQUssRUFBRSxLQUFLO0FBQ1osWUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUU7T0FDbkIsQ0FBQyxDQUFDO0FBQ0gsYUFBTyxJQUFJLENBQUM7S0FDYjs7QUFFRCxRQUFJLElBQUksWUFBQSxDQUFDO0FBQ1QsUUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFBO0FBQ3pCLFlBQVEsU0FBUyxDQUFDLE1BQU07QUFDdEIsV0FBSyxDQUFDO0FBQUc7QUFDUCxjQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsSUFBSSxPQUFPLEtBQUssQ0FBQyxLQUFLLEtBQUssVUFBVSxFQUFFO0FBQ2xFLGdCQUFNLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2hDLGdCQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNYLGdCQUFNLE1BQU0sR0FBRyxJQUFJLEtBQUssSUFBSSxHQUFHLE1BQU0sR0FBRyxJQUFJLENBQUE7QUFDNUMsbUJBQU8sRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUN4QixrQkFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTthQUN0QztBQUNELG1CQUFPLElBQUksQ0FBQztXQUNiLE1BQU07QUFDTCxnQkFBSSxHQUFHLEVBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBSixJQUFJLEVBQUMsQ0FBQztXQUM1QztBQUNELGdCQUFNO1NBQ1A7QUFBQSxBQUNELFdBQUssQ0FBQztBQUFHLFlBQUksR0FBRyxFQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFKLElBQUksRUFBQyxDQUFDLEFBQUMsTUFBTTtBQUFBLEFBQzlGO0FBQVMsWUFBSSxHQUFHLEVBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBUixRQUFRLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUosSUFBSSxFQUFDLENBQUM7QUFBQSxLQUNqRjtBQUNELFFBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3hCLFdBQU8sSUFBSSxDQUFDO0dBQ2I7OztBQUdELE9BQUssRUFBQSxlQUFDLE1BQU0sRUFBRTtBQUNaLFdBQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBTixNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsRUFBQyxDQUFDLENBQUM7R0FDekU7OztBQUdELE9BQUssRUFBQSxpQkFBRztBQUNOLFdBQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0dBQ3ZDOzs7QUFHRCxNQUFJLEVBQUEsY0FBQyxLQUFLLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRTtBQUM1QixXQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7R0FDbkQ7OztBQUdELE1BQUksRUFBQSxjQUFDLEtBQUksRUFBRTtBQUNULFFBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSSxDQUFDO0FBQ3JCLFdBQU8sSUFBSSxDQUFDO0dBQ2I7O0FBRUQsT0FBSyxFQUFBLGVBQUMsSUFBSSxFQUFFO0FBQ1YsUUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtBQUMxQixVQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztBQUN0QixhQUFPLElBQUksQ0FBQztLQUNiO0FBQ0QsUUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLFNBQVMsSUFBSSxLQUFLLENBQUM7QUFDcEMsUUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7QUFDdkIsV0FBTyxHQUFHLENBQUM7R0FDWjs7Q0FFRixDQUFDLENBQUE7O0FBRUYsTUFBTSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsU0FBUyxFQUFFLElBQUksRUFBRTtBQUNoRCxLQUFHLEVBQUMsZUFBRztBQUNMLFdBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztHQUN6QjtDQUNGLENBQUMsQ0FBQzs7cUJBRVksVUFBVSIsImZpbGUiOiJqb2luY2xhdXNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICdsb2Rhc2gnXG5cbi8vIEpvaW5DbGF1c2Vcbi8vIC0tLS0tLS1cblxuLy8gVGhlIFwiSm9pbkNsYXVzZVwiIGlzIGFuIG9iamVjdCBob2xkaW5nIGFueSBuZWNlc3NhcnkgaW5mbyBhYm91dCBhIGpvaW4sXG4vLyBpbmNsdWRpbmcgdGhlIHR5cGUsIGFuZCBhbnkgYXNzb2NpYXRlZCB0YWJsZXMgJiBjb2x1bW5zIGJlaW5nIGpvaW5lZC5cbmZ1bmN0aW9uIEpvaW5DbGF1c2UodGFibGUsIHR5cGUsIHNjaGVtYSkge1xuICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgdGhpcy50YWJsZSA9IHRhYmxlO1xuICB0aGlzLmpvaW5UeXBlID0gdHlwZTtcbiAgdGhpcy5hbmQgPSB0aGlzO1xuICB0aGlzLmNsYXVzZXMgPSBbXTtcbn1cblxuYXNzaWduKEpvaW5DbGF1c2UucHJvdG90eXBlLCB7XG5cbiAgZ3JvdXBpbmc6ICdqb2luJyxcblxuICAvLyBBZGRzIGFuIFwib25cIiBjbGF1c2UgdG8gdGhlIGN1cnJlbnQgam9pbiBvYmplY3QuXG4gIG9uKGZpcnN0LCBvcGVyYXRvciwgc2Vjb25kKSB7XG4gICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5jbGF1c2VzLnB1c2goe1xuICAgICAgICB0eXBlOiAnb25XcmFwcGVkJyxcbiAgICAgICAgdmFsdWU6IGZpcnN0LFxuICAgICAgICBib29sOiB0aGlzLl9ib29sKClcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbGV0IGRhdGE7XG4gICAgY29uc3QgYm9vbCA9IHRoaXMuX2Jvb2woKVxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOiAge1xuICAgICAgICBpZiAodHlwZW9mIGZpcnN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZmlyc3QudG9TUUwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmlyc3QpO1xuICAgICAgICAgIGxldCBpID0gLTE7XG4gICAgICAgICAgY29uc3QgbWV0aG9kID0gYm9vbCA9PT0gJ29yJyA/ICdvck9uJyA6ICdvbidcbiAgICAgICAgICB3aGlsZSAoKytpIDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kXShrZXlzW2ldLCBmaXJzdFtrZXlzW2ldXSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YSA9IHt0eXBlOiAnb25SYXcnLCB2YWx1ZTogZmlyc3QsIGJvb2x9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiAgZGF0YSA9IHt0eXBlOiAnb25CYXNpYycsIGNvbHVtbjogZmlyc3QsIG9wZXJhdG9yOiAnPScsIHZhbHVlOiBvcGVyYXRvciwgYm9vbH07IGJyZWFrO1xuICAgICAgZGVmYXVsdDogZGF0YSA9IHt0eXBlOiAnb25CYXNpYycsIGNvbHVtbjogZmlyc3QsIG9wZXJhdG9yLCB2YWx1ZTogc2Vjb25kLCBib29sfTtcbiAgICB9XG4gICAgdGhpcy5jbGF1c2VzLnB1c2goZGF0YSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gQWRkcyBhIFwidXNpbmdcIiBjbGF1c2UgdG8gdGhlIGN1cnJlbnQgam9pbi5cbiAgdXNpbmcoY29sdW1uKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xhdXNlcy5wdXNoKHt0eXBlOiAnb25Vc2luZycsIGNvbHVtbiwgYm9vbDogdGhpcy5fYm9vbCgpfSk7XG4gIH0sXG5cbiAgLy8gQWRkcyBhbiBcImFuZCBvblwiIGNsYXVzZSB0byB0aGUgY3VycmVudCBqb2luIG9iamVjdC5cbiAgYW5kT24oKSB7XG4gICAgcmV0dXJuIHRoaXMub24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvLyBBZGRzIGFuIFwib3Igb25cIiBjbGF1c2UgdG8gdGhlIGN1cnJlbnQgam9pbiBvYmplY3QuXG4gIG9yT24oZmlyc3QsIG9wZXJhdG9yLCBzZWNvbmQpIHtcbiAgICByZXR1cm4gdGhpcy5fYm9vbCgnb3InKS5vbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8vIEV4cGxpY2l0bHkgc2V0IHRoZSB0eXBlIG9mIGpvaW4sIHVzZWZ1bCB3aXRoaW4gYSBmdW5jdGlvbiB3aGVuIGNyZWF0aW5nIGEgZ3JvdXBlZCBqb2luLlxuICB0eXBlKHR5cGUpIHtcbiAgICB0aGlzLmpvaW5UeXBlID0gdHlwZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfYm9vbChib29sKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuX2Jvb2xGbGFnID0gYm9vbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCByZXQgPSB0aGlzLl9ib29sRmxhZyB8fCAnYW5kJztcbiAgICB0aGlzLl9ib29sRmxhZyA9ICdhbmQnO1xuICAgIHJldHVybiByZXQ7XG4gIH1cblxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEpvaW5DbGF1c2UucHJvdG90eXBlLCAnb3InLCB7XG4gIGdldCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jvb2woJ29yJyk7XG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBKb2luQ2xhdXNlO1xuIl19

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	
	// Transaction
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _promise = __webpack_require__(43);

	var _promise2 = _interopRequireDefault(_promise);

	var _events = __webpack_require__(18);

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _debug = __webpack_require__(66);

	var _debug2 = _interopRequireDefault(_debug);

	var _utilMakeKnex = __webpack_require__(69);

	var _utilMakeKnex2 = _interopRequireDefault(_utilMakeKnex);

	var _utilNoop = __webpack_require__(70);

	var _utilNoop2 = _interopRequireDefault(_utilNoop);

	var _lodash = __webpack_require__(5);

	// Acts as a facade for a Promise, keeping the internal state
	// and managing any child transactions.

	var debug = _debug2['default']('knex:tx');

	function Transaction(client, container, config, outerTx) {
	  var _this = this;

	  var txid = this.txid = _lodash.uniqueId('trx');

	  this.client = client;
	  this.outerTx = outerTx;
	  this.trxClient = undefined;
	  this._debug = client.config && client.config.debug;

	  debug('%s: Starting %s transaction', txid, outerTx ? 'nested' : 'top level');

	  this._promise = _promise2['default'].using(this.acquireConnection(client, config, txid), function (connection) {

	    var trxClient = _this.trxClient = makeTxClient(_this, client, connection);
	    var init = client.transacting ? _this.savepoint(connection) : _this.begin(connection);

	    init.then(function () {
	      return makeTransactor(_this, connection, trxClient);
	    }).then(function (transactor) {
	      // If we've returned a "thenable" from the transaction container, assume
	      // the rollback and commit are chained to this object's success / failure.
	      // Directly thrown errors are treated as automatic rollbacks.
	      var result = undefined;
	      try {
	        result = container(transactor);
	      } catch (err) {
	        result = _promise2['default'].reject(err);
	      }
	      if (result && result.then && typeof result.then === 'function') {
	        result.then(function (val) {
	          return transactor.commit(val);
	        })['catch'](function (err) {
	          return transactor.rollback(err);
	        });
	      }
	      return null;
	    })['catch'](function (e) {
	      return _this._rejecter(e);
	    });

	    return new _promise2['default'](function (resolver, rejecter) {
	      _this._resolver = resolver;
	      _this._rejecter = rejecter;
	    });
	  });

	  this._completed = false;

	  // If there's a wrapping transaction, we need to wait for any older sibling
	  // transactions to settle (commit or rollback) before we can start, and we
	  // need to register ourselves with the parent transaction so any younger
	  // siblings can wait for us to complete before they can start.
	  this._previousSibling = _promise2['default'].resolve(true);
	  if (outerTx) {
	    if (outerTx._lastChild) this._previousSibling = outerTx._lastChild;
	    outerTx._lastChild = this._promise;
	  }
	}
	_inherits2['default'](Transaction, _events.EventEmitter);

	_lodash.assign(Transaction.prototype, {

	  isCompleted: function isCompleted() {
	    return this._completed || this.outerTx && this.outerTx.isCompleted() || false;
	  },

	  begin: function begin(conn) {
	    return this.query(conn, 'BEGIN;');
	  },

	  savepoint: function savepoint(conn) {
	    return this.query(conn, 'SAVEPOINT ' + this.txid + ';');
	  },

	  commit: function commit(conn, value) {
	    return this.query(conn, 'COMMIT;', 1, value);
	  },

	  release: function release(conn, value) {
	    return this.query(conn, 'RELEASE SAVEPOINT ' + this.txid + ';', 1, value);
	  },

	  rollback: function rollback(conn, error) {
	    var _this2 = this;

	    return this.query(conn, 'ROLLBACK;', 2, error).timeout(5000)['catch'](_promise2['default'].TimeoutError, function () {
	      _this2._resolver();
	    });
	  },

	  rollbackTo: function rollbackTo(conn, error) {
	    var _this3 = this;

	    return this.query(conn, 'ROLLBACK TO SAVEPOINT ' + this.txid, 2, error).timeout(5000)['catch'](_promise2['default'].TimeoutError, function () {
	      _this3._resolver();
	    });
	  },

	  query: function query(conn, sql, status, value) {
	    var _this4 = this;

	    var q = this.trxClient.query(conn, sql)['catch'](function (err) {
	      status = 2;
	      value = err;
	      _this4._completed = true;
	      debug('%s error running transaction query', _this4.txid);
	    }).tap(function () {
	      if (status === 1) _this4._resolver(value);
	      if (status === 2) _this4._rejecter(value);
	    });
	    if (status === 1 || status === 2) {
	      this._completed = true;
	    }
	    return q;
	  },

	  debug: function debug(enabled) {
	    this._debug = arguments.length ? enabled : true;
	    return this;
	  },

	  // Acquire a connection and create a disposer - either using the one passed
	  // via config or getting one off the client. The disposer will be called once
	  // the original promise is marked completed.
	  acquireConnection: function acquireConnection(client, config, txid) {
	    var configConnection = config && config.connection;
	    return _promise2['default']['try'](function () {
	      return configConnection || client.acquireConnection().completed;
	    }).disposer(function (connection) {
	      if (!configConnection) {
	        debug('%s: releasing connection', txid);
	        client.releaseConnection(connection);
	      } else {
	        debug('%s: not releasing external connection', txid);
	      }
	    });
	  }

	});

	// The transactor is a full featured knex object, with a "commit", a "rollback"
	// and a "savepoint" function. The "savepoint" is just sugar for creating a new
	// transaction. If the rollback is run inside a savepoint, it rolls back to the
	// last savepoint - otherwise it rolls back the transaction.
	function makeTransactor(trx, connection, trxClient) {

	  var transactor = _utilMakeKnex2['default'](trxClient);

	  transactor.transaction = function (container, options) {
	    return new trxClient.Transaction(trxClient, container, options, trx);
	  };

	  transactor.savepoint = function (container, options) {
	    return transactor.transaction(container, options);
	  };

	  if (trx.client.transacting) {
	    transactor.commit = function (value) {
	      return trx.release(connection, value);
	    };
	    transactor.rollback = function (error) {
	      return trx.rollbackTo(connection, error);
	    };
	  } else {
	    transactor.commit = function (value) {
	      return trx.commit(connection, value);
	    };
	    transactor.rollback = function (error) {
	      return trx.rollback(connection, error);
	    };
	  }

	  return transactor;
	}

	// We need to make a client object which always acquires the same
	// connection and does not release back into the pool.
	function makeTxClient(trx, client, connection) {

	  var trxClient = Object.create(client.constructor.prototype);
	  trxClient.config = client.config;
	  trxClient.driver = client.driver;
	  trxClient.connectionSettings = client.connectionSettings;
	  trxClient.transacting = true;
	  trxClient.valueForUndefined = client.valueForUndefined;

	  trxClient.on('query', function (arg) {
	    trx.emit('query', arg);
	    client.emit('query', arg);
	  });

	  trxClient.on('query-error', function (err, obj) {
	    trx.emit('query-error', err, obj);
	    client.emit('query-error', err, obj);
	  });

	  trxClient.on('query-response', function (response, obj, builder) {
	    trx.emit('query-response', response, obj, builder);
	    client.emit('query-response', response, obj, builder);
	  });

	  var _query = trxClient.query;
	  trxClient.query = function (conn, obj) {
	    var completed = trx.isCompleted();
	    return _promise2['default']['try'](function () {
	      if (conn !== connection) throw new Error('Invalid connection for transaction query.');
	      if (completed) completedError(trx, obj);
	      return _query.call(trxClient, conn, obj);
	    });
	  };
	  var _stream = trxClient.stream;
	  trxClient.stream = function (conn, obj, stream, options) {
	    var completed = trx.isCompleted();
	    return _promise2['default']['try'](function () {
	      if (conn !== connection) throw new Error('Invalid connection for transaction query.');
	      if (completed) completedError(trx, obj);
	      return _stream.call(trxClient, conn, obj, stream, options);
	    });
	  };
	  trxClient.acquireConnection = function () {
	    return {
	      completed: trx._previousSibling.reflect().then(function () {
	        return connection;
	      }),
	      abort: _utilNoop2['default']
	    };
	  };
	  trxClient.releaseConnection = function () {
	    return _promise2['default'].resolve();
	  };

	  return trxClient;
	}

	function completedError(trx, obj) {
	  var sql = typeof obj === 'string' ? obj : obj && obj.sql;
	  debug('%s: Transaction completed: %s', trx.id, sql);
	  throw new Error('Transaction query already complete, run with DEBUG=knex:tx for more info');
	}

	var promiseInterface = ['then', 'bind', 'catch', 'finally', 'asCallback', 'spread', 'map', 'reduce', 'tap', 'thenReturn', 'return', 'yield', 'ensure', 'exec', 'reflect'];

	// Creates a method which "coerces" to a promise, by calling a
	// "then" method on the current `Target`.
	promiseInterface.forEach(function (method) {
	  Transaction.prototype[method] = function () {
	    return this._promise = this._promise[method].apply(this._promise, arguments);
	  };
	});

	exports['default'] = Transaction;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy90cmFuc2FjdGlvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7dUJBR29CLFdBQVc7Ozs7c0JBQ0YsUUFBUTs7d0JBQ2hCLFVBQVU7Ozs7cUJBQ2IsT0FBTzs7Ozs0QkFFSixrQkFBa0I7Ozs7d0JBQ3RCLGFBQWE7Ozs7c0JBSUcsUUFBUTs7Ozs7QUFGekMsSUFBTSxLQUFLLEdBQUcsbUJBQU0sU0FBUyxDQUFDLENBQUM7O0FBTS9CLFNBQVMsV0FBVyxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRTs7O0FBRXZELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLEdBQUcsaUJBQVMsS0FBSyxDQUFDLENBQUE7O0FBRXhDLE1BQUksQ0FBQyxNQUFNLEdBQU0sTUFBTSxDQUFBO0FBQ3ZCLE1BQUksQ0FBQyxPQUFPLEdBQUssT0FBTyxDQUFBO0FBQ3hCLE1BQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0FBQzNCLE1BQUksQ0FBQyxNQUFNLEdBQU0sTUFBTSxDQUFDLE1BQU0sSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQTs7QUFFckQsT0FBSyxDQUFDLDZCQUE2QixFQUFFLElBQUksRUFBRSxPQUFPLEdBQUcsUUFBUSxHQUFHLFdBQVcsQ0FBQyxDQUFBOztBQUU1RSxNQUFJLENBQUMsUUFBUSxHQUFHLHFCQUFRLEtBQUssQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsRUFBRSxVQUFDLFVBQVUsRUFBSzs7QUFFMUYsUUFBTSxTQUFTLEdBQUcsTUFBSyxTQUFTLEdBQUcsWUFBWSxRQUFPLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQTtBQUN6RSxRQUFNLElBQUksR0FBRyxNQUFNLENBQUMsV0FBVyxHQUFHLE1BQUssU0FBUyxDQUFDLFVBQVUsQ0FBQyxHQUFHLE1BQUssS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFBOztBQUVyRixRQUFJLENBQUMsSUFBSSxDQUFDLFlBQU07QUFDZCxhQUFPLGNBQWMsUUFBTyxVQUFVLEVBQUUsU0FBUyxDQUFDLENBQUE7S0FDbkQsQ0FBQyxDQUNELElBQUksQ0FBQyxVQUFDLFVBQVUsRUFBSzs7OztBQUlwQixVQUFJLE1BQU0sWUFBQSxDQUFBO0FBQ1YsVUFBSTtBQUNGLGNBQU0sR0FBRyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUE7T0FDL0IsQ0FBQyxPQUFPLEdBQUcsRUFBRTtBQUNaLGNBQU0sR0FBRyxxQkFBUSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUE7T0FDN0I7QUFDRCxVQUFJLE1BQU0sSUFBSSxNQUFNLENBQUMsSUFBSSxJQUFJLE9BQU8sTUFBTSxDQUFDLElBQUksS0FBSyxVQUFVLEVBQUU7QUFDOUQsY0FBTSxDQUFDLElBQUksQ0FBQyxVQUFDLEdBQUcsRUFBSztBQUNuQixpQkFBTyxVQUFVLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFBO1NBQzlCLENBQUMsU0FDSSxDQUFDLFVBQUMsR0FBRyxFQUFLO0FBQ2QsaUJBQU8sVUFBVSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQTtTQUNoQyxDQUFDLENBQUE7T0FDSDtBQUNELGFBQU8sSUFBSSxDQUFDO0tBQ2IsQ0FBQyxTQUNJLENBQUMsVUFBQyxDQUFDO2FBQUssTUFBSyxTQUFTLENBQUMsQ0FBQyxDQUFDO0tBQUEsQ0FBQyxDQUFBOztBQUVoQyxXQUFPLHlCQUFZLFVBQUMsUUFBUSxFQUFFLFFBQVEsRUFBSztBQUN6QyxZQUFLLFNBQVMsR0FBRyxRQUFRLENBQUE7QUFDekIsWUFBSyxTQUFTLEdBQUcsUUFBUSxDQUFBO0tBQzFCLENBQUMsQ0FBQTtHQUNILENBQUMsQ0FBQTs7QUFFRixNQUFJLENBQUMsVUFBVSxHQUFJLEtBQUssQ0FBQTs7Ozs7O0FBTXhCLE1BQUksQ0FBQyxnQkFBZ0IsR0FBRyxxQkFBUSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDOUMsTUFBSSxPQUFPLEVBQUU7QUFDWCxRQUFJLE9BQU8sQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUM7QUFDbkUsV0FBTyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO0dBQ3BDO0NBQ0Y7QUFDRCxzQkFBUyxXQUFXLHVCQUFlLENBQUE7O0FBRW5DLGVBQU8sV0FBVyxDQUFDLFNBQVMsRUFBRTs7QUFFNUIsYUFBVyxFQUFBLHVCQUFHO0FBQ1osV0FBTyxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsSUFBSSxLQUFLLENBQUE7R0FDOUU7O0FBRUQsT0FBSyxFQUFBLGVBQUMsSUFBSSxFQUFFO0FBQ1YsV0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQTtHQUNsQzs7QUFFRCxXQUFTLEVBQUEsbUJBQUMsSUFBSSxFQUFFO0FBQ2QsV0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksaUJBQWUsSUFBSSxDQUFDLElBQUksT0FBSSxDQUFBO0dBQ25EOztBQUVELFFBQU0sRUFBQSxnQkFBQyxJQUFJLEVBQUUsS0FBSyxFQUFFO0FBQ2xCLFdBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQTtHQUM3Qzs7QUFFRCxTQUFPLEVBQUEsaUJBQUMsSUFBSSxFQUFFLEtBQUssRUFBRTtBQUNuQixXQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSx5QkFBdUIsSUFBSSxDQUFDLElBQUksUUFBSyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUE7R0FDckU7O0FBRUQsVUFBUSxFQUFBLGtCQUFDLElBQUksRUFBRSxLQUFLLEVBQUU7OztBQUNwQixXQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQzNDLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FDUixDQUFDLHFCQUFRLFlBQVksRUFBRSxZQUFNO0FBQ2pDLGFBQUssU0FBUyxFQUFFLENBQUM7S0FDbEIsQ0FBQyxDQUFDO0dBQ047O0FBRUQsWUFBVSxFQUFBLG9CQUFDLElBQUksRUFBRSxLQUFLLEVBQUU7OztBQUN0QixXQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSw2QkFBMkIsSUFBSSxDQUFDLElBQUksRUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQ3BFLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FDUixDQUFDLHFCQUFRLFlBQVksRUFBRSxZQUFNO0FBQ2pDLGFBQUssU0FBUyxFQUFFLENBQUM7S0FDbEIsQ0FBQyxDQUFDO0dBQ047O0FBRUQsT0FBSyxFQUFBLGVBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFOzs7QUFDOUIsUUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxTQUNqQyxDQUFDLFVBQUMsR0FBRyxFQUFLO0FBQ2QsWUFBTSxHQUFHLENBQUMsQ0FBQTtBQUNWLFdBQUssR0FBSSxHQUFHLENBQUE7QUFDWixhQUFLLFVBQVUsR0FBRyxJQUFJLENBQUE7QUFDdEIsV0FBSyxDQUFDLG9DQUFvQyxFQUFFLE9BQUssSUFBSSxDQUFDLENBQUE7S0FDdkQsQ0FBQyxDQUNELEdBQUcsQ0FBQyxZQUFNO0FBQ1QsVUFBSSxNQUFNLEtBQUssQ0FBQyxFQUFFLE9BQUssU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFBO0FBQ3ZDLFVBQUksTUFBTSxLQUFLLENBQUMsRUFBRSxPQUFLLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQTtLQUN4QyxDQUFDLENBQUE7QUFDSixRQUFJLE1BQU0sS0FBSyxDQUFDLElBQUksTUFBTSxLQUFLLENBQUMsRUFBRTtBQUNoQyxVQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQTtLQUN2QjtBQUNELFdBQU8sQ0FBQyxDQUFDO0dBQ1Y7O0FBRUQsT0FBSyxFQUFBLGVBQUMsT0FBTyxFQUFFO0FBQ2IsUUFBSSxDQUFDLE1BQU0sR0FBRyxTQUFTLENBQUMsTUFBTSxHQUFHLE9BQU8sR0FBRyxJQUFJLENBQUM7QUFDaEQsV0FBTyxJQUFJLENBQUE7R0FDWjs7Ozs7QUFLRCxtQkFBaUIsRUFBQSwyQkFBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtBQUN0QyxRQUFNLGdCQUFnQixHQUFHLE1BQU0sSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFBO0FBQ3BELFdBQU8sMkJBQVcsQ0FBQzthQUFNLGdCQUFnQixJQUFJLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLFNBQVM7S0FBQSxDQUFDLENBQ2pGLFFBQVEsQ0FBQyxVQUFTLFVBQVUsRUFBRTtBQUM3QixVQUFJLENBQUMsZ0JBQWdCLEVBQUU7QUFDckIsYUFBSyxDQUFDLDBCQUEwQixFQUFFLElBQUksQ0FBQyxDQUFBO0FBQ3ZDLGNBQU0sQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsQ0FBQTtPQUNyQyxNQUFNO0FBQ0wsYUFBSyxDQUFDLHVDQUF1QyxFQUFFLElBQUksQ0FBQyxDQUFBO09BQ3JEO0tBQ0YsQ0FBQyxDQUFBO0dBQ0g7O0NBRUYsQ0FBQyxDQUFBOzs7Ozs7QUFNRixTQUFTLGNBQWMsQ0FBQyxHQUFHLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRTs7QUFFbEQsTUFBTSxVQUFVLEdBQUcsMEJBQVMsU0FBUyxDQUFDLENBQUM7O0FBRXZDLFlBQVUsQ0FBQyxXQUFXLEdBQUcsVUFBQyxTQUFTLEVBQUUsT0FBTztXQUMxQyxJQUFJLFNBQVMsQ0FBQyxXQUFXLENBQUMsU0FBUyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsR0FBRyxDQUFDO0dBQUEsQ0FBQzs7QUFFaEUsWUFBVSxDQUFDLFNBQVMsR0FBRyxVQUFDLFNBQVMsRUFBRSxPQUFPO1dBQ3hDLFVBQVUsQ0FBQyxXQUFXLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQztHQUFBLENBQUM7O0FBRTdDLE1BQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUU7QUFDMUIsY0FBVSxDQUFDLE1BQU0sR0FBRyxVQUFBLEtBQUs7YUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxLQUFLLENBQUM7S0FBQSxDQUFBO0FBQzNELGNBQVUsQ0FBQyxRQUFRLEdBQUcsVUFBQSxLQUFLO2FBQUksR0FBRyxDQUFDLFVBQVUsQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDO0tBQUEsQ0FBQTtHQUNqRSxNQUFNO0FBQ0wsY0FBVSxDQUFDLE1BQU0sR0FBRyxVQUFBLEtBQUs7YUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxLQUFLLENBQUM7S0FBQSxDQUFBO0FBQzFELGNBQVUsQ0FBQyxRQUFRLEdBQUcsVUFBQSxLQUFLO2FBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDO0tBQUEsQ0FBQTtHQUMvRDs7QUFFRCxTQUFPLFVBQVUsQ0FBQTtDQUNsQjs7OztBQUtELFNBQVMsWUFBWSxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFOztBQUU3QyxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUE7QUFDN0QsV0FBUyxDQUFDLE1BQU0sR0FBZSxNQUFNLENBQUMsTUFBTSxDQUFBO0FBQzVDLFdBQVMsQ0FBQyxNQUFNLEdBQWUsTUFBTSxDQUFDLE1BQU0sQ0FBQTtBQUM1QyxXQUFTLENBQUMsa0JBQWtCLEdBQUcsTUFBTSxDQUFDLGtCQUFrQixDQUFBO0FBQ3hELFdBQVMsQ0FBQyxXQUFXLEdBQVUsSUFBSSxDQUFBO0FBQ25DLFdBQVMsQ0FBQyxpQkFBaUIsR0FBSSxNQUFNLENBQUMsaUJBQWlCLENBQUE7O0FBRXZELFdBQVMsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLFVBQVMsR0FBRyxFQUFFO0FBQ2xDLE9BQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFBO0FBQ3RCLFVBQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFBO0dBQzFCLENBQUMsQ0FBQTs7QUFFRixXQUFTLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRSxVQUFTLEdBQUcsRUFBRSxHQUFHLEVBQUU7QUFDN0MsT0FBRyxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFBO0FBQ2pDLFVBQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQTtHQUNyQyxDQUFDLENBQUE7O0FBRUYsV0FBUyxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsRUFBRSxVQUFTLFFBQVEsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFO0FBQzlELE9BQUcsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQTtBQUNsRCxVQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUE7R0FDdEQsQ0FBQyxDQUFBOztBQUVGLE1BQU0sTUFBTSxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUM7QUFDL0IsV0FBUyxDQUFDLEtBQUssR0FBSSxVQUFTLElBQUksRUFBRSxHQUFHLEVBQUU7QUFDckMsUUFBTSxTQUFTLEdBQUcsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFBO0FBQ25DLFdBQU8sMkJBQVcsQ0FBQyxZQUFXO0FBQzVCLFVBQUksSUFBSSxLQUFLLFVBQVUsRUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLDJDQUEyQyxDQUFDLENBQUE7QUFDckYsVUFBSSxTQUFTLEVBQUUsY0FBYyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQTtBQUN2QyxhQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQTtLQUN6QyxDQUFDLENBQUE7R0FDSCxDQUFBO0FBQ0QsTUFBTSxPQUFPLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQTtBQUNoQyxXQUFTLENBQUMsTUFBTSxHQUFHLFVBQVMsSUFBSSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFO0FBQ3RELFFBQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQTtBQUNuQyxXQUFPLDJCQUFXLENBQUMsWUFBVztBQUM1QixVQUFJLElBQUksS0FBSyxVQUFVLEVBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQywyQ0FBMkMsQ0FBQyxDQUFBO0FBQ3JGLFVBQUksU0FBUyxFQUFFLGNBQWMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUE7QUFDdkMsYUFBTyxPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQTtLQUMzRCxDQUFDLENBQUE7R0FDSCxDQUFBO0FBQ0QsV0FBUyxDQUFDLGlCQUFpQixHQUFHLFlBQVk7QUFDeEMsV0FBTztBQUNMLGVBQVMsRUFBRSxHQUFHLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDO2VBQU0sVUFBVTtPQUFBLENBQUM7QUFDaEUsV0FBSyx1QkFBTTtLQUNaLENBQUE7R0FDRixDQUFBO0FBQ0QsV0FBUyxDQUFDLGlCQUFpQixHQUFHLFlBQVc7QUFDdkMsV0FBTyxxQkFBUSxPQUFPLEVBQUUsQ0FBQTtHQUN6QixDQUFBOztBQUVELFNBQU8sU0FBUyxDQUFBO0NBQ2pCOztBQUVELFNBQVMsY0FBYyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUU7QUFDaEMsTUFBTSxHQUFHLEdBQUcsT0FBTyxHQUFHLEtBQUssUUFBUSxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQTtBQUMxRCxPQUFLLENBQUMsK0JBQStCLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQTtBQUNuRCxRQUFNLElBQUksS0FBSyxDQUFDLDBFQUEwRSxDQUFDLENBQUE7Q0FDNUY7O0FBRUQsSUFBTSxnQkFBZ0IsR0FBRyxDQUN2QixNQUFNLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUNoRCxRQUFRLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUM5QyxRQUFRLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsU0FBUyxDQUMvQyxDQUFBOzs7O0FBSUQsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLFVBQVMsTUFBTSxFQUFFO0FBQ3hDLGFBQVcsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEdBQUcsWUFBVztBQUN6QyxXQUFRLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztHQUMvRSxDQUFBO0NBQ0YsQ0FBQyxDQUFBOztxQkFFYSxXQUFXIiwiZmlsZSI6InRyYW5zYWN0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBUcmFuc2FjdGlvblxuLy8gLS0tLS0tLVxuaW1wb3J0IFByb21pc2UgZnJvbSAnLi9wcm9taXNlJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuaW1wb3J0IERlYnVnIGZyb20gJ2RlYnVnJ1xuXG5pbXBvcnQgbWFrZUtuZXggZnJvbSAnLi91dGlsL21ha2Uta25leCc7XG5pbXBvcnQgbm9vcCBmcm9tICcuL3V0aWwvbm9vcCc7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoJ2tuZXg6dHgnKTtcblxuaW1wb3J0IHsgYXNzaWduLCB1bmlxdWVJZCB9IGZyb20gJ2xvZGFzaCc7XG5cbi8vIEFjdHMgYXMgYSBmYWNhZGUgZm9yIGEgUHJvbWlzZSwga2VlcGluZyB0aGUgaW50ZXJuYWwgc3RhdGVcbi8vIGFuZCBtYW5hZ2luZyBhbnkgY2hpbGQgdHJhbnNhY3Rpb25zLlxuZnVuY3Rpb24gVHJhbnNhY3Rpb24oY2xpZW50LCBjb250YWluZXIsIGNvbmZpZywgb3V0ZXJUeCkge1xuXG4gIGNvbnN0IHR4aWQgPSB0aGlzLnR4aWQgPSB1bmlxdWVJZCgndHJ4JylcblxuICB0aGlzLmNsaWVudCAgICA9IGNsaWVudFxuICB0aGlzLm91dGVyVHggICA9IG91dGVyVHhcbiAgdGhpcy50cnhDbGllbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX2RlYnVnICAgID0gY2xpZW50LmNvbmZpZyAmJiBjbGllbnQuY29uZmlnLmRlYnVnXG5cbiAgZGVidWcoJyVzOiBTdGFydGluZyAlcyB0cmFuc2FjdGlvbicsIHR4aWQsIG91dGVyVHggPyAnbmVzdGVkJyA6ICd0b3AgbGV2ZWwnKVxuXG4gIHRoaXMuX3Byb21pc2UgPSBQcm9taXNlLnVzaW5nKHRoaXMuYWNxdWlyZUNvbm5lY3Rpb24oY2xpZW50LCBjb25maWcsIHR4aWQpLCAoY29ubmVjdGlvbikgPT4ge1xuXG4gICAgY29uc3QgdHJ4Q2xpZW50ID0gdGhpcy50cnhDbGllbnQgPSBtYWtlVHhDbGllbnQodGhpcywgY2xpZW50LCBjb25uZWN0aW9uKVxuICAgIGNvbnN0IGluaXQgPSBjbGllbnQudHJhbnNhY3RpbmcgPyB0aGlzLnNhdmVwb2ludChjb25uZWN0aW9uKSA6IHRoaXMuYmVnaW4oY29ubmVjdGlvbilcblxuICAgIGluaXQudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gbWFrZVRyYW5zYWN0b3IodGhpcywgY29ubmVjdGlvbiwgdHJ4Q2xpZW50KVxuICAgIH0pXG4gICAgLnRoZW4oKHRyYW5zYWN0b3IpID0+IHtcbiAgICAgIC8vIElmIHdlJ3ZlIHJldHVybmVkIGEgXCJ0aGVuYWJsZVwiIGZyb20gdGhlIHRyYW5zYWN0aW9uIGNvbnRhaW5lciwgYXNzdW1lXG4gICAgICAvLyB0aGUgcm9sbGJhY2sgYW5kIGNvbW1pdCBhcmUgY2hhaW5lZCB0byB0aGlzIG9iamVjdCdzIHN1Y2Nlc3MgLyBmYWlsdXJlLlxuICAgICAgLy8gRGlyZWN0bHkgdGhyb3duIGVycm9ycyBhcmUgdHJlYXRlZCBhcyBhdXRvbWF0aWMgcm9sbGJhY2tzLlxuICAgICAgbGV0IHJlc3VsdFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gY29udGFpbmVyKHRyYW5zYWN0b3IpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVzdWx0ID0gUHJvbWlzZS5yZWplY3QoZXJyKVxuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbiAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzdWx0LnRoZW4oKHZhbCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0cmFuc2FjdG9yLmNvbW1pdCh2YWwpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRyYW5zYWN0b3Iucm9sbGJhY2soZXJyKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSlcbiAgICAuY2F0Y2goKGUpID0+IHRoaXMuX3JlamVjdGVyKGUpKVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlciwgcmVqZWN0ZXIpID0+IHtcbiAgICAgIHRoaXMuX3Jlc29sdmVyID0gcmVzb2x2ZXJcbiAgICAgIHRoaXMuX3JlamVjdGVyID0gcmVqZWN0ZXJcbiAgICB9KVxuICB9KVxuXG4gIHRoaXMuX2NvbXBsZXRlZCAgPSBmYWxzZVxuXG4gIC8vIElmIHRoZXJlJ3MgYSB3cmFwcGluZyB0cmFuc2FjdGlvbiwgd2UgbmVlZCB0byB3YWl0IGZvciBhbnkgb2xkZXIgc2libGluZ1xuICAvLyB0cmFuc2FjdGlvbnMgdG8gc2V0dGxlIChjb21taXQgb3Igcm9sbGJhY2spIGJlZm9yZSB3ZSBjYW4gc3RhcnQsIGFuZCB3ZVxuICAvLyBuZWVkIHRvIHJlZ2lzdGVyIG91cnNlbHZlcyB3aXRoIHRoZSBwYXJlbnQgdHJhbnNhY3Rpb24gc28gYW55IHlvdW5nZXJcbiAgLy8gc2libGluZ3MgY2FuIHdhaXQgZm9yIHVzIHRvIGNvbXBsZXRlIGJlZm9yZSB0aGV5IGNhbiBzdGFydC5cbiAgdGhpcy5fcHJldmlvdXNTaWJsaW5nID0gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICBpZiAob3V0ZXJUeCkge1xuICAgIGlmIChvdXRlclR4Ll9sYXN0Q2hpbGQpIHRoaXMuX3ByZXZpb3VzU2libGluZyA9IG91dGVyVHguX2xhc3RDaGlsZDtcbiAgICBvdXRlclR4Ll9sYXN0Q2hpbGQgPSB0aGlzLl9wcm9taXNlO1xuICB9XG59XG5pbmhlcml0cyhUcmFuc2FjdGlvbiwgRXZlbnRFbWl0dGVyKVxuXG5hc3NpZ24oVHJhbnNhY3Rpb24ucHJvdG90eXBlLCB7XG5cbiAgaXNDb21wbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBsZXRlZCB8fCB0aGlzLm91dGVyVHggJiYgdGhpcy5vdXRlclR4LmlzQ29tcGxldGVkKCkgfHwgZmFsc2VcbiAgfSxcblxuICBiZWdpbihjb25uKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnkoY29ubiwgJ0JFR0lOOycpXG4gIH0sXG5cbiAgc2F2ZXBvaW50KGNvbm4pIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeShjb25uLCBgU0FWRVBPSU5UICR7dGhpcy50eGlkfTtgKVxuICB9LFxuXG4gIGNvbW1pdChjb25uLCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5KGNvbm4sICdDT01NSVQ7JywgMSwgdmFsdWUpXG4gIH0sXG5cbiAgcmVsZWFzZShjb25uLCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5KGNvbm4sIGBSRUxFQVNFIFNBVkVQT0lOVCAke3RoaXMudHhpZH07YCwgMSwgdmFsdWUpXG4gIH0sXG5cbiAgcm9sbGJhY2soY29ubiwgZXJyb3IpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeShjb25uLCAnUk9MTEJBQ0s7JywgMiwgZXJyb3IpXG4gICAgICAudGltZW91dCg1MDAwKVxuICAgICAgLmNhdGNoKFByb21pc2UuVGltZW91dEVycm9yLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVyKCk7XG4gICAgICB9KTtcbiAgfSxcblxuICByb2xsYmFja1RvKGNvbm4sIGVycm9yKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnkoY29ubiwgYFJPTExCQUNLIFRPIFNBVkVQT0lOVCAke3RoaXMudHhpZH1gLCAyLCBlcnJvcilcbiAgICAgIC50aW1lb3V0KDUwMDApXG4gICAgICAuY2F0Y2goUHJvbWlzZS5UaW1lb3V0RXJyb3IsICgpID0+IHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZXIoKTtcbiAgICAgIH0pO1xuICB9LFxuXG4gIHF1ZXJ5KGNvbm4sIHNxbCwgc3RhdHVzLCB2YWx1ZSkge1xuICAgIGNvbnN0IHEgPSB0aGlzLnRyeENsaWVudC5xdWVyeShjb25uLCBzcWwpXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBzdGF0dXMgPSAyXG4gICAgICAgIHZhbHVlICA9IGVyclxuICAgICAgICB0aGlzLl9jb21wbGV0ZWQgPSB0cnVlXG4gICAgICAgIGRlYnVnKCclcyBlcnJvciBydW5uaW5nIHRyYW5zYWN0aW9uIHF1ZXJ5JywgdGhpcy50eGlkKVxuICAgICAgfSlcbiAgICAgIC50YXAoKCkgPT4ge1xuICAgICAgICBpZiAoc3RhdHVzID09PSAxKSB0aGlzLl9yZXNvbHZlcih2YWx1ZSlcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMikgdGhpcy5fcmVqZWN0ZXIodmFsdWUpXG4gICAgICB9KVxuICAgIGlmIChzdGF0dXMgPT09IDEgfHwgc3RhdHVzID09PSAyKSB7XG4gICAgICB0aGlzLl9jb21wbGV0ZWQgPSB0cnVlXG4gICAgfVxuICAgIHJldHVybiBxO1xuICB9LFxuXG4gIGRlYnVnKGVuYWJsZWQpIHtcbiAgICB0aGlzLl9kZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPyBlbmFibGVkIDogdHJ1ZTtcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuXG4gIC8vIEFjcXVpcmUgYSBjb25uZWN0aW9uIGFuZCBjcmVhdGUgYSBkaXNwb3NlciAtIGVpdGhlciB1c2luZyB0aGUgb25lIHBhc3NlZFxuICAvLyB2aWEgY29uZmlnIG9yIGdldHRpbmcgb25lIG9mZiB0aGUgY2xpZW50LiBUaGUgZGlzcG9zZXIgd2lsbCBiZSBjYWxsZWQgb25jZVxuICAvLyB0aGUgb3JpZ2luYWwgcHJvbWlzZSBpcyBtYXJrZWQgY29tcGxldGVkLlxuICBhY3F1aXJlQ29ubmVjdGlvbihjbGllbnQsIGNvbmZpZywgdHhpZCkge1xuICAgIGNvbnN0IGNvbmZpZ0Nvbm5lY3Rpb24gPSBjb25maWcgJiYgY29uZmlnLmNvbm5lY3Rpb25cbiAgICByZXR1cm4gUHJvbWlzZS50cnkoKCkgPT4gY29uZmlnQ29ubmVjdGlvbiB8fCBjbGllbnQuYWNxdWlyZUNvbm5lY3Rpb24oKS5jb21wbGV0ZWQpXG4gICAgLmRpc3Bvc2VyKGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgIGlmICghY29uZmlnQ29ubmVjdGlvbikge1xuICAgICAgICBkZWJ1ZygnJXM6IHJlbGVhc2luZyBjb25uZWN0aW9uJywgdHhpZClcbiAgICAgICAgY2xpZW50LnJlbGVhc2VDb25uZWN0aW9uKGNvbm5lY3Rpb24pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygnJXM6IG5vdCByZWxlYXNpbmcgZXh0ZXJuYWwgY29ubmVjdGlvbicsIHR4aWQpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG59KVxuXG4vLyBUaGUgdHJhbnNhY3RvciBpcyBhIGZ1bGwgZmVhdHVyZWQga25leCBvYmplY3QsIHdpdGggYSBcImNvbW1pdFwiLCBhIFwicm9sbGJhY2tcIlxuLy8gYW5kIGEgXCJzYXZlcG9pbnRcIiBmdW5jdGlvbi4gVGhlIFwic2F2ZXBvaW50XCIgaXMganVzdCBzdWdhciBmb3IgY3JlYXRpbmcgYSBuZXdcbi8vIHRyYW5zYWN0aW9uLiBJZiB0aGUgcm9sbGJhY2sgaXMgcnVuIGluc2lkZSBhIHNhdmVwb2ludCwgaXQgcm9sbHMgYmFjayB0byB0aGVcbi8vIGxhc3Qgc2F2ZXBvaW50IC0gb3RoZXJ3aXNlIGl0IHJvbGxzIGJhY2sgdGhlIHRyYW5zYWN0aW9uLlxuZnVuY3Rpb24gbWFrZVRyYW5zYWN0b3IodHJ4LCBjb25uZWN0aW9uLCB0cnhDbGllbnQpIHtcblxuICBjb25zdCB0cmFuc2FjdG9yID0gbWFrZUtuZXgodHJ4Q2xpZW50KTtcblxuICB0cmFuc2FjdG9yLnRyYW5zYWN0aW9uID0gKGNvbnRhaW5lciwgb3B0aW9ucykgPT5cbiAgICBuZXcgdHJ4Q2xpZW50LlRyYW5zYWN0aW9uKHRyeENsaWVudCwgY29udGFpbmVyLCBvcHRpb25zLCB0cngpO1xuXG4gIHRyYW5zYWN0b3Iuc2F2ZXBvaW50ID0gKGNvbnRhaW5lciwgb3B0aW9ucykgPT5cbiAgICB0cmFuc2FjdG9yLnRyYW5zYWN0aW9uKGNvbnRhaW5lciwgb3B0aW9ucyk7XG5cbiAgaWYgKHRyeC5jbGllbnQudHJhbnNhY3RpbmcpIHtcbiAgICB0cmFuc2FjdG9yLmNvbW1pdCA9IHZhbHVlID0+IHRyeC5yZWxlYXNlKGNvbm5lY3Rpb24sIHZhbHVlKVxuICAgIHRyYW5zYWN0b3Iucm9sbGJhY2sgPSBlcnJvciA9PiB0cngucm9sbGJhY2tUbyhjb25uZWN0aW9uLCBlcnJvcilcbiAgfSBlbHNlIHtcbiAgICB0cmFuc2FjdG9yLmNvbW1pdCA9IHZhbHVlID0+IHRyeC5jb21taXQoY29ubmVjdGlvbiwgdmFsdWUpXG4gICAgdHJhbnNhY3Rvci5yb2xsYmFjayA9IGVycm9yID0+IHRyeC5yb2xsYmFjayhjb25uZWN0aW9uLCBlcnJvcilcbiAgfVxuXG4gIHJldHVybiB0cmFuc2FjdG9yXG59XG5cblxuLy8gV2UgbmVlZCB0byBtYWtlIGEgY2xpZW50IG9iamVjdCB3aGljaCBhbHdheXMgYWNxdWlyZXMgdGhlIHNhbWVcbi8vIGNvbm5lY3Rpb24gYW5kIGRvZXMgbm90IHJlbGVhc2UgYmFjayBpbnRvIHRoZSBwb29sLlxuZnVuY3Rpb24gbWFrZVR4Q2xpZW50KHRyeCwgY2xpZW50LCBjb25uZWN0aW9uKSB7XG5cbiAgY29uc3QgdHJ4Q2xpZW50ID0gT2JqZWN0LmNyZWF0ZShjbGllbnQuY29uc3RydWN0b3IucHJvdG90eXBlKVxuICB0cnhDbGllbnQuY29uZmlnICAgICAgICAgICAgID0gY2xpZW50LmNvbmZpZ1xuICB0cnhDbGllbnQuZHJpdmVyICAgICAgICAgICAgID0gY2xpZW50LmRyaXZlclxuICB0cnhDbGllbnQuY29ubmVjdGlvblNldHRpbmdzID0gY2xpZW50LmNvbm5lY3Rpb25TZXR0aW5nc1xuICB0cnhDbGllbnQudHJhbnNhY3RpbmcgICAgICAgID0gdHJ1ZVxuICB0cnhDbGllbnQudmFsdWVGb3JVbmRlZmluZWQgID0gY2xpZW50LnZhbHVlRm9yVW5kZWZpbmVkXG5cbiAgdHJ4Q2xpZW50Lm9uKCdxdWVyeScsIGZ1bmN0aW9uKGFyZykge1xuICAgIHRyeC5lbWl0KCdxdWVyeScsIGFyZylcbiAgICBjbGllbnQuZW1pdCgncXVlcnknLCBhcmcpXG4gIH0pXG5cbiAgdHJ4Q2xpZW50Lm9uKCdxdWVyeS1lcnJvcicsIGZ1bmN0aW9uKGVyciwgb2JqKSB7XG4gICAgdHJ4LmVtaXQoJ3F1ZXJ5LWVycm9yJywgZXJyLCBvYmopXG4gICAgY2xpZW50LmVtaXQoJ3F1ZXJ5LWVycm9yJywgZXJyLCBvYmopXG4gIH0pXG5cbiAgdHJ4Q2xpZW50Lm9uKCdxdWVyeS1yZXNwb25zZScsIGZ1bmN0aW9uKHJlc3BvbnNlLCBvYmosIGJ1aWxkZXIpIHtcbiAgICB0cnguZW1pdCgncXVlcnktcmVzcG9uc2UnLCByZXNwb25zZSwgb2JqLCBidWlsZGVyKVxuICAgIGNsaWVudC5lbWl0KCdxdWVyeS1yZXNwb25zZScsIHJlc3BvbnNlLCBvYmosIGJ1aWxkZXIpXG4gIH0pXG5cbiAgY29uc3QgX3F1ZXJ5ID0gdHJ4Q2xpZW50LnF1ZXJ5O1xuICB0cnhDbGllbnQucXVlcnkgID0gZnVuY3Rpb24oY29ubiwgb2JqKSB7XG4gICAgY29uc3QgY29tcGxldGVkID0gdHJ4LmlzQ29tcGxldGVkKClcbiAgICByZXR1cm4gUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoY29ubiAhPT0gY29ubmVjdGlvbikgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbm5lY3Rpb24gZm9yIHRyYW5zYWN0aW9uIHF1ZXJ5LicpXG4gICAgICBpZiAoY29tcGxldGVkKSBjb21wbGV0ZWRFcnJvcih0cngsIG9iailcbiAgICAgIHJldHVybiBfcXVlcnkuY2FsbCh0cnhDbGllbnQsIGNvbm4sIG9iailcbiAgICB9KVxuICB9XG4gIGNvbnN0IF9zdHJlYW0gPSB0cnhDbGllbnQuc3RyZWFtXG4gIHRyeENsaWVudC5zdHJlYW0gPSBmdW5jdGlvbihjb25uLCBvYmosIHN0cmVhbSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNvbXBsZXRlZCA9IHRyeC5pc0NvbXBsZXRlZCgpXG4gICAgcmV0dXJuIFByb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGNvbm4gIT09IGNvbm5lY3Rpb24pIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb25uZWN0aW9uIGZvciB0cmFuc2FjdGlvbiBxdWVyeS4nKVxuICAgICAgaWYgKGNvbXBsZXRlZCkgY29tcGxldGVkRXJyb3IodHJ4LCBvYmopXG4gICAgICByZXR1cm4gX3N0cmVhbS5jYWxsKHRyeENsaWVudCwgY29ubiwgb2JqLCBzdHJlYW0sIG9wdGlvbnMpXG4gICAgfSlcbiAgfVxuICB0cnhDbGllbnQuYWNxdWlyZUNvbm5lY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBsZXRlZDogdHJ4Ll9wcmV2aW91c1NpYmxpbmcucmVmbGVjdCgpLnRoZW4oKCkgPT4gY29ubmVjdGlvbiksXG4gICAgICBhYm9ydDogbm9vcFxuICAgIH1cbiAgfVxuICB0cnhDbGllbnQucmVsZWFzZUNvbm5lY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxuXG4gIHJldHVybiB0cnhDbGllbnRcbn1cblxuZnVuY3Rpb24gY29tcGxldGVkRXJyb3IodHJ4LCBvYmopIHtcbiAgY29uc3Qgc3FsID0gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgPyBvYmogOiBvYmogJiYgb2JqLnNxbFxuICBkZWJ1ZygnJXM6IFRyYW5zYWN0aW9uIGNvbXBsZXRlZDogJXMnLCB0cnguaWQsIHNxbClcbiAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBxdWVyeSBhbHJlYWR5IGNvbXBsZXRlLCBydW4gd2l0aCBERUJVRz1rbmV4OnR4IGZvciBtb3JlIGluZm8nKVxufVxuXG5jb25zdCBwcm9taXNlSW50ZXJmYWNlID0gW1xuICAndGhlbicsICdiaW5kJywgJ2NhdGNoJywgJ2ZpbmFsbHknLCAnYXNDYWxsYmFjaycsXG4gICdzcHJlYWQnLCAnbWFwJywgJ3JlZHVjZScsICd0YXAnLCAndGhlblJldHVybicsXG4gICdyZXR1cm4nLCAneWllbGQnLCAnZW5zdXJlJywgJ2V4ZWMnLCAncmVmbGVjdCdcbl1cblxuLy8gQ3JlYXRlcyBhIG1ldGhvZCB3aGljaCBcImNvZXJjZXNcIiB0byBhIHByb21pc2UsIGJ5IGNhbGxpbmcgYVxuLy8gXCJ0aGVuXCIgbWV0aG9kIG9uIHRoZSBjdXJyZW50IGBUYXJnZXRgLlxucHJvbWlzZUludGVyZmFjZS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBUcmFuc2FjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fcHJvbWlzZSA9IHRoaXMuX3Byb21pc2VbbWV0aG9kXS5hcHBseSh0aGlzLl9wcm9taXNlLCBhcmd1bWVudHMpKVxuICB9XG59KVxuXG5leHBvcnQgZGVmYXVsdCBUcmFuc2FjdGlvbjtcbiJdfQ==

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(67);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();

	/**
	 * Colors.
	 */

	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};


	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;

	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);

	  if (!useColors) return args;

	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });

	  args.splice(lastC, 0, c);
	  return args;
	}

	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */

	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}

	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */

	exports.enable(load());

	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */

	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(68);

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */

	exports.formatters = {};

	/**
	 * Previously assigned color.
	 */

	var prevColor = 0;

	/**
	 * Previous log timestamp.
	 */

	var prevTime;

	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */

	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function debug(namespace) {

	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;

	  // define the `enabled` version
	  function enabled() {

	    var self = enabled;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();

	    var args = Array.prototype.slice.call(arguments);

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;

	  var fn = exports.enabled(namespace) ? enabled : disabled;

	  fn.namespace = namespace;

	  return fn;
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;

	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 68 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = makeKnex;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _events = __webpack_require__(18);

	var _migrate = __webpack_require__(70);

	var _migrate2 = _interopRequireDefault(_migrate);

	var _seed = __webpack_require__(70);

	var _seed2 = _interopRequireDefault(_seed);

	var _functionhelper = __webpack_require__(71);

	var _functionhelper2 = _interopRequireDefault(_functionhelper);

	var _queryMethods = __webpack_require__(72);

	var _queryMethods2 = _interopRequireDefault(_queryMethods);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _lodash = __webpack_require__(5);

	var _batchInsert = __webpack_require__(73);

	var _batchInsert2 = _interopRequireDefault(_batchInsert);

	function makeKnex(client) {

	  // The object we're potentially using to kick off an initial chain.
	  function knex(tableName) {
	    var qb = knex.queryBuilder();
	    if (!tableName) helpers.warn('calling knex without a tableName is deprecated. Use knex.queryBuilder() instead.');
	    return tableName ? qb.table(tableName) : qb;
	  }

	  _lodash.assign(knex, {

	    Promise: __webpack_require__(43),

	    // A new query builder instance.
	    queryBuilder: function queryBuilder() {
	      return client.queryBuilder();
	    },

	    raw: function raw() {
	      return client.raw.apply(client, arguments);
	    },

	    batchInsert: function batchInsert(table, batch) {
	      var chunkSize = arguments.length <= 2 || arguments[2] === undefined ? 1000 : arguments[2];

	      return new _batchInsert2['default'](this, table, batch, chunkSize);
	    },

	    // Runs a new transaction, taking a container and returning a promise
	    // for when the transaction is resolved.
	    transaction: function transaction(container, config) {
	      return client.transaction(container, config);
	    },

	    // Typically never needed, initializes the pool for a knex client.
	    initialize: function initialize(config) {
	      return client.initialize(config);
	    },

	    // Convenience method for tearing down the pool.
	    destroy: function destroy(callback) {
	      return client.destroy(callback);
	    }

	  });

	  // The `__knex__` is used if you need to duck-type check whether this
	  // is a knex builder, without a full on `instanceof` check.
	  knex.VERSION = knex.__knex__ = __webpack_require__(74).version;

	  // Hook up the "knex" object as an EventEmitter.
	  var ee = new _events.EventEmitter();
	  for (var key in ee) {
	    knex[key] = ee[key];
	  }

	  // Allow chaining methods from the root object, before
	  // any other information is specified.
	  _queryMethods2['default'].forEach(function (method) {
	    knex[method] = function () {
	      var builder = knex.queryBuilder();
	      return builder[method].apply(builder, arguments);
	    };
	  });

	  knex.client = client;

	  Object.defineProperties(knex, {

	    schema: {
	      get: function get() {
	        return client.schemaBuilder();
	      }
	    },

	    migrate: {
	      get: function get() {
	        return new _migrate2['default'](knex);
	      }
	    },

	    seed: {
	      get: function get() {
	        return new _seed2['default'](knex);
	      }
	    },

	    fn: {
	      get: function get() {
	        return new _functionhelper2['default'](client);
	      }
	    }

	  });

	  // Passthrough all "start" and "query" events to the knex object.
	  client.on('start', function (obj) {
	    knex.emit('start', obj);
	  });

	  client.on('query', function (obj) {
	    knex.emit('query', obj);
	  });

	  client.on('query-error', function (err, obj) {
	    knex.emit('query-error', err, obj);
	  });

	  client.on('query-response', function (response, obj, builder) {
	    knex.emit('query-response', response, obj, builder);
	  });

	  client.makeKnex = makeKnex;

	  return knex;
	}

	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL21ha2Uta25leC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7cUJBV3dCLFFBQVE7Ozs7OztzQkFWSCxRQUFROzt1QkFFaEIsWUFBWTs7OztvQkFDZCxTQUFTOzs7OzhCQUNELG1CQUFtQjs7Ozs0QkFDbkIsa0JBQWtCOzs7O3VCQUNwQixZQUFZOztJQUF6QixPQUFPOztzQkFDSSxRQUFROzsyQkFDUCxlQUFlOzs7O0FBRXhCLFNBQVMsUUFBUSxDQUFDLE1BQU0sRUFBRTs7O0FBR3ZDLFdBQVMsSUFBSSxDQUFDLFNBQVMsRUFBRTtBQUN2QixRQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUE7QUFDOUIsUUFBSSxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsSUFBSSxDQUMxQixrRkFBa0YsQ0FDbkYsQ0FBQztBQUNGLFdBQU8sU0FBUyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFBO0dBQzVDOztBQUVELGlCQUFPLElBQUksRUFBRTs7QUFFWCxXQUFPLEVBQUUsT0FBTyxDQUFDLFlBQVksQ0FBQzs7O0FBRzlCLGdCQUFZLEVBQUEsd0JBQUc7QUFDYixhQUFPLE1BQU0sQ0FBQyxZQUFZLEVBQUUsQ0FBQTtLQUM3Qjs7QUFFRCxPQUFHLEVBQUEsZUFBRztBQUNKLGFBQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFBO0tBQzNDOztBQUVELGVBQVcsRUFBQSxxQkFBQyxLQUFLLEVBQUUsS0FBSyxFQUFvQjtVQUFsQixTQUFTLHlEQUFHLElBQUk7O0FBQ3hDLGFBQU8sNkJBQWdCLElBQUksRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0tBQ3ZEOzs7O0FBSUQsZUFBVyxFQUFBLHFCQUFDLFNBQVMsRUFBRSxNQUFNLEVBQUU7QUFDN0IsYUFBTyxNQUFNLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQTtLQUM3Qzs7O0FBR0QsY0FBVSxFQUFBLG9CQUFDLE1BQU0sRUFBRTtBQUNqQixhQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUE7S0FDakM7OztBQUdELFdBQU8sRUFBQSxpQkFBQyxRQUFRLEVBQUU7QUFDaEIsYUFBTyxNQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFBO0tBQ2hDOztHQUVGLENBQUMsQ0FBQTs7OztBQUlGLE1BQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxPQUFPLENBQUM7OztBQUdyRSxNQUFNLEVBQUUsR0FBRywwQkFBa0IsQ0FBQTtBQUM3QixPQUFLLElBQU0sR0FBRyxJQUFJLEVBQUUsRUFBRTtBQUNwQixRQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFBO0dBQ3BCOzs7O0FBSUQsNEJBQWUsT0FBTyxDQUFDLFVBQVMsTUFBTSxFQUFFO0FBQ3RDLFFBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxZQUFXO0FBQ3hCLFVBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQTtBQUNuQyxhQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFBO0tBQ2pELENBQUE7R0FDRixDQUFDLENBQUE7O0FBRUYsTUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUE7O0FBRXBCLFFBQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUU7O0FBRTVCLFVBQU0sRUFBRTtBQUNOLFNBQUcsRUFBQSxlQUFHO0FBQ0osZUFBTyxNQUFNLENBQUMsYUFBYSxFQUFFLENBQUE7T0FDOUI7S0FDRjs7QUFFRCxXQUFPLEVBQUU7QUFDUCxTQUFHLEVBQUEsZUFBRztBQUNKLGVBQU8seUJBQWEsSUFBSSxDQUFDLENBQUE7T0FDMUI7S0FDRjs7QUFFRCxRQUFJLEVBQUU7QUFDSixTQUFHLEVBQUEsZUFBRztBQUNKLGVBQU8sc0JBQVcsSUFBSSxDQUFDLENBQUE7T0FDeEI7S0FDRjs7QUFFRCxNQUFFLEVBQUU7QUFDRixTQUFHLEVBQUEsZUFBRztBQUNKLGVBQU8sZ0NBQW1CLE1BQU0sQ0FBQyxDQUFBO09BQ2xDO0tBQ0Y7O0dBRUYsQ0FBQyxDQUFBOzs7QUFHRixRQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxVQUFTLEdBQUcsRUFBRTtBQUMvQixRQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQTtHQUN4QixDQUFDLENBQUE7O0FBRUYsUUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsVUFBUyxHQUFHLEVBQUU7QUFDL0IsUUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQUE7R0FDeEIsQ0FBQyxDQUFBOztBQUVGLFFBQU0sQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFLFVBQVMsR0FBRyxFQUFFLEdBQUcsRUFBRTtBQUMxQyxRQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUE7R0FDbkMsQ0FBQyxDQUFBOztBQUVGLFFBQU0sQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLEVBQUUsVUFBUyxRQUFRLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRTtBQUMzRCxRQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUE7R0FDcEQsQ0FBQyxDQUFBOztBQUVGLFFBQU0sQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFBOztBQUUxQixTQUFPLElBQUksQ0FBQTtDQUNaIiwiZmlsZSI6Im1ha2Uta25leC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcblxuaW1wb3J0IE1pZ3JhdG9yIGZyb20gJy4uL21pZ3JhdGUnO1xuaW1wb3J0IFNlZWRlciBmcm9tICcuLi9zZWVkJztcbmltcG9ydCBGdW5jdGlvbkhlbHBlciBmcm9tICcuLi9mdW5jdGlvbmhlbHBlcic7XG5pbXBvcnQgUXVlcnlJbnRlcmZhY2UgZnJvbSAnLi4vcXVlcnkvbWV0aG9kcyc7XG5pbXBvcnQgKiBhcyBoZWxwZXJzIGZyb20gJy4uL2hlbHBlcnMnO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnbG9kYXNoJ1xuaW1wb3J0IEJhdGNoSW5zZXJ0IGZyb20gJy4vYmF0Y2hJbnNlcnQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYWtlS25leChjbGllbnQpIHtcblxuICAvLyBUaGUgb2JqZWN0IHdlJ3JlIHBvdGVudGlhbGx5IHVzaW5nIHRvIGtpY2sgb2ZmIGFuIGluaXRpYWwgY2hhaW4uXG4gIGZ1bmN0aW9uIGtuZXgodGFibGVOYW1lKSB7XG4gICAgY29uc3QgcWIgPSBrbmV4LnF1ZXJ5QnVpbGRlcigpXG4gICAgaWYgKCF0YWJsZU5hbWUpIGhlbHBlcnMud2FybihcbiAgICAgICdjYWxsaW5nIGtuZXggd2l0aG91dCBhIHRhYmxlTmFtZSBpcyBkZXByZWNhdGVkLiBVc2Uga25leC5xdWVyeUJ1aWxkZXIoKSBpbnN0ZWFkLidcbiAgICApO1xuICAgIHJldHVybiB0YWJsZU5hbWUgPyBxYi50YWJsZSh0YWJsZU5hbWUpIDogcWJcbiAgfVxuXG4gIGFzc2lnbihrbmV4LCB7XG5cbiAgICBQcm9taXNlOiByZXF1aXJlKCcuLi9wcm9taXNlJyksXG5cbiAgICAvLyBBIG5ldyBxdWVyeSBidWlsZGVyIGluc3RhbmNlLlxuICAgIHF1ZXJ5QnVpbGRlcigpIHtcbiAgICAgIHJldHVybiBjbGllbnQucXVlcnlCdWlsZGVyKClcbiAgICB9LFxuXG4gICAgcmF3KCkge1xuICAgICAgcmV0dXJuIGNsaWVudC5yYXcuYXBwbHkoY2xpZW50LCBhcmd1bWVudHMpXG4gICAgfSxcblxuICAgIGJhdGNoSW5zZXJ0KHRhYmxlLCBiYXRjaCwgY2h1bmtTaXplID0gMTAwMCkge1xuICAgICAgcmV0dXJuIG5ldyBCYXRjaEluc2VydCh0aGlzLCB0YWJsZSwgYmF0Y2gsIGNodW5rU2l6ZSk7XG4gICAgfSxcblxuICAgIC8vIFJ1bnMgYSBuZXcgdHJhbnNhY3Rpb24sIHRha2luZyBhIGNvbnRhaW5lciBhbmQgcmV0dXJuaW5nIGEgcHJvbWlzZVxuICAgIC8vIGZvciB3aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyByZXNvbHZlZC5cbiAgICB0cmFuc2FjdGlvbihjb250YWluZXIsIGNvbmZpZykge1xuICAgICAgcmV0dXJuIGNsaWVudC50cmFuc2FjdGlvbihjb250YWluZXIsIGNvbmZpZylcbiAgICB9LFxuXG4gICAgLy8gVHlwaWNhbGx5IG5ldmVyIG5lZWRlZCwgaW5pdGlhbGl6ZXMgdGhlIHBvb2wgZm9yIGEga25leCBjbGllbnQuXG4gICAgaW5pdGlhbGl6ZShjb25maWcpIHtcbiAgICAgIHJldHVybiBjbGllbnQuaW5pdGlhbGl6ZShjb25maWcpXG4gICAgfSxcblxuICAgIC8vIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgdGVhcmluZyBkb3duIHRoZSBwb29sLlxuICAgIGRlc3Ryb3koY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjbGllbnQuZGVzdHJveShjYWxsYmFjaylcbiAgICB9XG5cbiAgfSlcblxuICAvLyBUaGUgYF9fa25leF9fYCBpcyB1c2VkIGlmIHlvdSBuZWVkIHRvIGR1Y2stdHlwZSBjaGVjayB3aGV0aGVyIHRoaXNcbiAgLy8gaXMgYSBrbmV4IGJ1aWxkZXIsIHdpdGhvdXQgYSBmdWxsIG9uIGBpbnN0YW5jZW9mYCBjaGVjay5cbiAga25leC5WRVJTSU9OID0ga25leC5fX2tuZXhfXyA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5cbiAgLy8gSG9vayB1cCB0aGUgXCJrbmV4XCIgb2JqZWN0IGFzIGFuIEV2ZW50RW1pdHRlci5cbiAgY29uc3QgZWUgPSBuZXcgRXZlbnRFbWl0dGVyKClcbiAgZm9yIChjb25zdCBrZXkgaW4gZWUpIHtcbiAgICBrbmV4W2tleV0gPSBlZVtrZXldXG4gIH1cblxuICAvLyBBbGxvdyBjaGFpbmluZyBtZXRob2RzIGZyb20gdGhlIHJvb3Qgb2JqZWN0LCBiZWZvcmVcbiAgLy8gYW55IG90aGVyIGluZm9ybWF0aW9uIGlzIHNwZWNpZmllZC5cbiAgUXVlcnlJbnRlcmZhY2UuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICBrbmV4W21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGJ1aWxkZXIgPSBrbmV4LnF1ZXJ5QnVpbGRlcigpXG4gICAgICByZXR1cm4gYnVpbGRlclttZXRob2RdLmFwcGx5KGJ1aWxkZXIsIGFyZ3VtZW50cylcbiAgICB9XG4gIH0pXG5cbiAga25leC5jbGllbnQgPSBjbGllbnRcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhrbmV4LCB7XG5cbiAgICBzY2hlbWE6IHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5zY2hlbWFCdWlsZGVyKClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbWlncmF0ZToge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gbmV3IE1pZ3JhdG9yKGtuZXgpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHNlZWQ6IHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWVkZXIoa25leClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZm46IHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkhlbHBlcihjbGllbnQpXG4gICAgICB9XG4gICAgfVxuXG4gIH0pXG5cbiAgLy8gUGFzc3Rocm91Z2ggYWxsIFwic3RhcnRcIiBhbmQgXCJxdWVyeVwiIGV2ZW50cyB0byB0aGUga25leCBvYmplY3QuXG4gIGNsaWVudC5vbignc3RhcnQnLCBmdW5jdGlvbihvYmopIHtcbiAgICBrbmV4LmVtaXQoJ3N0YXJ0Jywgb2JqKVxuICB9KVxuXG4gIGNsaWVudC5vbigncXVlcnknLCBmdW5jdGlvbihvYmopIHtcbiAgICBrbmV4LmVtaXQoJ3F1ZXJ5Jywgb2JqKVxuICB9KVxuXG4gIGNsaWVudC5vbigncXVlcnktZXJyb3InLCBmdW5jdGlvbihlcnIsIG9iaikge1xuICAgIGtuZXguZW1pdCgncXVlcnktZXJyb3InLCBlcnIsIG9iailcbiAgfSlcblxuICBjbGllbnQub24oJ3F1ZXJ5LXJlc3BvbnNlJywgZnVuY3Rpb24ocmVzcG9uc2UsIG9iaiwgYnVpbGRlcikge1xuICAgIGtuZXguZW1pdCgncXVlcnktcmVzcG9uc2UnLCByZXNwb25zZSwgb2JqLCBidWlsZGVyKVxuICB9KVxuXG4gIGNsaWVudC5tYWtlS25leCA9IG1ha2VLbmV4XG5cbiAgcmV0dXJuIGtuZXhcbn1cbiJdfQ==

/***/ },
/* 70 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;

	exports["default"] = function () {};

	module.exports = exports["default"];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL25vb3AuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztxQkFBZSxZQUFXLEVBQUUiLCJmaWxlIjoibm9vcC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge31cbiJdfQ==

/***/ },
/* 71 */
/***/ function(module, exports) {

	
	// FunctionHelper
	// -------
	'use strict';

	exports.__esModule = true;
	function FunctionHelper(client) {
	  this.client = client;
	}

	FunctionHelper.prototype.now = function () {
	  return this.client.raw('CURRENT_TIMESTAMP');
	};

	exports['default'] = FunctionHelper;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9mdW5jdGlvbmhlbHBlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFHQSxTQUFTLGNBQWMsQ0FBQyxNQUFNLEVBQUU7QUFDOUIsTUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUE7Q0FDckI7O0FBRUQsY0FBYyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQUcsWUFBVztBQUN4QyxTQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUE7Q0FDNUMsQ0FBQTs7cUJBRWMsY0FBYyIsImZpbGUiOiJmdW5jdGlvbmhlbHBlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLy8gRnVuY3Rpb25IZWxwZXJcbi8vIC0tLS0tLS1cbmZ1bmN0aW9uIEZ1bmN0aW9uSGVscGVyKGNsaWVudCkge1xuICB0aGlzLmNsaWVudCA9IGNsaWVudFxufVxuXG5GdW5jdGlvbkhlbHBlci5wcm90b3R5cGUubm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNsaWVudC5yYXcoJ0NVUlJFTlRfVElNRVNUQU1QJylcbn1cblxuZXhwb3J0IGRlZmF1bHQgRnVuY3Rpb25IZWxwZXJcbiJdfQ==

/***/ },
/* 72 */
/***/ function(module, exports) {

	
	// All properties we can use to start a query chain
	// from the `knex` object, e.g. `knex.select('*').from(...`
	'use strict';

	exports.__esModule = true;
	exports['default'] = ['select', 'as', 'columns', 'column', 'from', 'fromJS', 'into', 'withSchema', 'table', 'distinct', 'join', 'joinRaw', 'innerJoin', 'leftJoin', 'leftOuterJoin', 'rightJoin', 'rightOuterJoin', 'outerJoin', 'fullOuterJoin', 'crossJoin', 'where', 'andWhere', 'orWhere', 'whereNot', 'orWhereNot', 'whereRaw', 'whereWrapped', 'havingWrapped', 'orWhereRaw', 'whereExists', 'orWhereExists', 'whereNotExists', 'orWhereNotExists', 'whereIn', 'orWhereIn', 'whereNotIn', 'orWhereNotIn', 'whereNull', 'orWhereNull', 'whereNotNull', 'orWhereNotNull', 'whereBetween', 'whereNotBetween', 'andWhereBetween', 'andWhereNotBetween', 'orWhereBetween', 'orWhereNotBetween', 'groupBy', 'groupByRaw', 'orderBy', 'orderByRaw', 'union', 'unionAll', 'having', 'havingRaw', 'orHaving', 'orHavingRaw', 'offset', 'limit', 'count', 'countDistinct', 'min', 'max', 'sum', 'sumDistinct', 'avg', 'avgDistinct', 'increment', 'decrement', 'first', 'debug', 'pluck', 'insert', 'update', 'returning', 'del', 'delete', 'truncate', 'transacting', 'connection'];
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9xdWVyeS9tZXRob2RzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztxQkFHZSxDQUNiLFFBQVEsRUFDUixJQUFJLEVBQ0osU0FBUyxFQUNULFFBQVEsRUFDUixNQUFNLEVBQ04sUUFBUSxFQUNSLE1BQU0sRUFDTixZQUFZLEVBQ1osT0FBTyxFQUNQLFVBQVUsRUFDVixNQUFNLEVBQ04sU0FBUyxFQUNULFdBQVcsRUFDWCxVQUFVLEVBQ1YsZUFBZSxFQUNmLFdBQVcsRUFDWCxnQkFBZ0IsRUFDaEIsV0FBVyxFQUNYLGVBQWUsRUFDZixXQUFXLEVBQ1gsT0FBTyxFQUNQLFVBQVUsRUFDVixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixVQUFVLEVBQ1YsY0FBYyxFQUNkLGVBQWUsRUFDZixZQUFZLEVBQ1osYUFBYSxFQUNiLGVBQWUsRUFDZixnQkFBZ0IsRUFDaEIsa0JBQWtCLEVBQ2xCLFNBQVMsRUFDVCxXQUFXLEVBQ1gsWUFBWSxFQUNaLGNBQWMsRUFDZCxXQUFXLEVBQ1gsYUFBYSxFQUNiLGNBQWMsRUFDZCxnQkFBZ0IsRUFDaEIsY0FBYyxFQUNkLGlCQUFpQixFQUNqQixpQkFBaUIsRUFDakIsb0JBQW9CLEVBQ3BCLGdCQUFnQixFQUNoQixtQkFBbUIsRUFDbkIsU0FBUyxFQUNULFlBQVksRUFDWixTQUFTLEVBQ1QsWUFBWSxFQUNaLE9BQU8sRUFDUCxVQUFVLEVBQ1YsUUFBUSxFQUNSLFdBQVcsRUFDWCxVQUFVLEVBQ1YsYUFBYSxFQUNiLFFBQVEsRUFDUixPQUFPLEVBQ1AsT0FBTyxFQUNQLGVBQWUsRUFDZixLQUFLLEVBQ0wsS0FBSyxFQUNMLEtBQUssRUFDTCxhQUFhLEVBQ2IsS0FBSyxFQUNMLGFBQWEsRUFDYixXQUFXLEVBQ1gsV0FBVyxFQUNYLE9BQU8sRUFDUCxPQUFPLEVBQ1AsT0FBTyxFQUNQLFFBQVEsRUFDUixRQUFRLEVBQ1IsV0FBVyxFQUNYLEtBQUssRUFDTCxRQUFRLEVBQ1IsVUFBVSxFQUNWLGFBQWEsRUFDYixZQUFZLENBQ2IiLCJmaWxlIjoibWV0aG9kcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLy8gQWxsIHByb3BlcnRpZXMgd2UgY2FuIHVzZSB0byBzdGFydCBhIHF1ZXJ5IGNoYWluXG4vLyBmcm9tIHRoZSBga25leGAgb2JqZWN0LCBlLmcuIGBrbmV4LnNlbGVjdCgnKicpLmZyb20oLi4uYFxuZXhwb3J0IGRlZmF1bHQgW1xuICAnc2VsZWN0JyxcbiAgJ2FzJyxcbiAgJ2NvbHVtbnMnLFxuICAnY29sdW1uJyxcbiAgJ2Zyb20nLFxuICAnZnJvbUpTJyxcbiAgJ2ludG8nLFxuICAnd2l0aFNjaGVtYScsXG4gICd0YWJsZScsXG4gICdkaXN0aW5jdCcsXG4gICdqb2luJyxcbiAgJ2pvaW5SYXcnLFxuICAnaW5uZXJKb2luJyxcbiAgJ2xlZnRKb2luJyxcbiAgJ2xlZnRPdXRlckpvaW4nLFxuICAncmlnaHRKb2luJyxcbiAgJ3JpZ2h0T3V0ZXJKb2luJyxcbiAgJ291dGVySm9pbicsXG4gICdmdWxsT3V0ZXJKb2luJyxcbiAgJ2Nyb3NzSm9pbicsXG4gICd3aGVyZScsXG4gICdhbmRXaGVyZScsXG4gICdvcldoZXJlJyxcbiAgJ3doZXJlTm90JyxcbiAgJ29yV2hlcmVOb3QnLFxuICAnd2hlcmVSYXcnLFxuICAnd2hlcmVXcmFwcGVkJyxcbiAgJ2hhdmluZ1dyYXBwZWQnLFxuICAnb3JXaGVyZVJhdycsXG4gICd3aGVyZUV4aXN0cycsXG4gICdvcldoZXJlRXhpc3RzJyxcbiAgJ3doZXJlTm90RXhpc3RzJyxcbiAgJ29yV2hlcmVOb3RFeGlzdHMnLFxuICAnd2hlcmVJbicsXG4gICdvcldoZXJlSW4nLFxuICAnd2hlcmVOb3RJbicsXG4gICdvcldoZXJlTm90SW4nLFxuICAnd2hlcmVOdWxsJyxcbiAgJ29yV2hlcmVOdWxsJyxcbiAgJ3doZXJlTm90TnVsbCcsXG4gICdvcldoZXJlTm90TnVsbCcsXG4gICd3aGVyZUJldHdlZW4nLFxuICAnd2hlcmVOb3RCZXR3ZWVuJyxcbiAgJ2FuZFdoZXJlQmV0d2VlbicsXG4gICdhbmRXaGVyZU5vdEJldHdlZW4nLFxuICAnb3JXaGVyZUJldHdlZW4nLFxuICAnb3JXaGVyZU5vdEJldHdlZW4nLFxuICAnZ3JvdXBCeScsXG4gICdncm91cEJ5UmF3JyxcbiAgJ29yZGVyQnknLFxuICAnb3JkZXJCeVJhdycsXG4gICd1bmlvbicsXG4gICd1bmlvbkFsbCcsXG4gICdoYXZpbmcnLFxuICAnaGF2aW5nUmF3JyxcbiAgJ29ySGF2aW5nJyxcbiAgJ29ySGF2aW5nUmF3JyxcbiAgJ29mZnNldCcsXG4gICdsaW1pdCcsXG4gICdjb3VudCcsXG4gICdjb3VudERpc3RpbmN0JyxcbiAgJ21pbicsXG4gICdtYXgnLFxuICAnc3VtJyxcbiAgJ3N1bURpc3RpbmN0JyxcbiAgJ2F2ZycsXG4gICdhdmdEaXN0aW5jdCcsXG4gICdpbmNyZW1lbnQnLFxuICAnZGVjcmVtZW50JyxcbiAgJ2ZpcnN0JyxcbiAgJ2RlYnVnJyxcbiAgJ3BsdWNrJyxcbiAgJ2luc2VydCcsXG4gICd1cGRhdGUnLFxuICAncmV0dXJuaW5nJyxcbiAgJ2RlbCcsXG4gICdkZWxldGUnLFxuICAndHJ1bmNhdGUnLFxuICAndHJhbnNhY3RpbmcnLFxuICAnY29ubmVjdGlvbidcbl07XG4iXX0=

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _lodash = __webpack_require__(5);

	var _promise = __webpack_require__(43);

	var _promise2 = _interopRequireDefault(_promise);

	var BatchInsert = (function () {
	  function BatchInsert(client, tableName, batch) {
	    var chunkSize = arguments.length <= 3 || arguments[3] === undefined ? 1000 : arguments[3];

	    _classCallCheck(this, BatchInsert);

	    if (!_lodash.isNumber(chunkSize) || chunkSize < 1) {
	      throw new TypeError('Invalid chunkSize: ' + chunkSize);
	    }

	    if (!_lodash.isArray(batch)) {
	      throw new TypeError('Invalid batch: Expected array, got ' + typeof batch);
	    }

	    this.client = client;
	    this.tableName = tableName;
	    this.batch = _lodash.chunk(batch, chunkSize);
	    this._returning = void 0;
	    this._transaction = null;
	    this._autoTransaction = true;

	    if (client.transacting) {
	      this.transacting(client);
	    }
	  }

	  /**
	   * Columns to return from the batch operation.
	   * @param returning
	   */

	  BatchInsert.prototype.returning = function returning(_returning) {
	    if (_lodash.isArray(_returning) || _lodash.isString(_returning)) {
	      this._returning = _returning;
	    }
	    return this;
	  };

	  /**
	   * User may supply their own transaction. If this is the case,
	   * `autoTransaction = false`, meaning we don't automatically commit/rollback
	   * the transaction. The responsibility instead falls on the user.
	   *
	   * @param transaction
	   */

	  BatchInsert.prototype.transacting = function transacting(transaction) {
	    this._transaction = transaction;
	    this._autoTransaction = false;
	    return this;
	  };

	  BatchInsert.prototype._getTransaction = function _getTransaction() {
	    var _this = this;

	    return new _promise2['default'](function (resolve) {
	      if (_this._transaction) {
	        return resolve(_this._transaction);
	      }
	      _this.client.transaction(function (tr) {
	        return resolve(tr);
	      });
	    });
	  };

	  BatchInsert.prototype.then = function then() {
	    var _this2 = this;

	    var callback = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];

	    return this._getTransaction().then(function (transaction) {
	      return _promise2['default'].all(_this2.batch.map(function (items) {
	        return transaction(_this2.tableName).insert(items, _this2._returning);
	      })).then(function (result) {
	        if (_this2._autoTransaction) {
	          transaction.commit();
	        }
	        return callback(_lodash.flatten(result || []));
	      })['catch'](function (error) {
	        if (_this2._autoTransaction) {
	          transaction.rollback(error);
	        }
	        throw error;
	      });
	    });
	  };

	  return BatchInsert;
	})();

	exports['default'] = BatchInsert;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL2JhdGNoSW5zZXJ0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O3NCQUU0RCxRQUFROzt1QkFDaEQsWUFBWTs7OztJQUVYLFdBQVc7QUFDbkIsV0FEUSxXQUFXLENBQ2xCLE1BQU0sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFvQjtRQUFsQixTQUFTLHlEQUFHLElBQUk7OzBCQURuQyxXQUFXOztBQUU1QixRQUFHLENBQUMsaUJBQVMsU0FBUyxDQUFDLElBQUksU0FBUyxHQUFHLENBQUMsRUFBRTtBQUN4QyxZQUFNLElBQUksU0FBUyx5QkFBdUIsU0FBUyxDQUFHLENBQUM7S0FDeEQ7O0FBRUQsUUFBRyxDQUFDLGdCQUFRLEtBQUssQ0FBQyxFQUFFO0FBQ2xCLFlBQU0sSUFBSSxTQUFTLHlDQUF1QyxPQUFPLEtBQUssQ0FBRyxDQUFBO0tBQzFFOztBQUVELFFBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0FBQ3JCLFFBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0FBQzNCLFFBQUksQ0FBQyxLQUFLLEdBQUcsY0FBTSxLQUFLLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDckMsUUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUMsQ0FBQztBQUN6QixRQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztBQUN6QixRQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDOztBQUU3QixRQUFJLE1BQU0sQ0FBQyxXQUFXLEVBQUU7QUFDdEIsVUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUMxQjtHQUNGOzs7Ozs7O0FBcEJrQixhQUFXLFdBMEI5QixTQUFTLEdBQUEsbUJBQUMsVUFBUyxFQUFFO0FBQ25CLFFBQUcsZ0JBQVEsVUFBUyxDQUFDLElBQUksaUJBQVMsVUFBUyxDQUFDLEVBQUU7QUFDNUMsVUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFTLENBQUM7S0FDN0I7QUFDRCxXQUFPLElBQUksQ0FBQztHQUNiOzs7Ozs7Ozs7O0FBL0JrQixhQUFXLFdBd0M5QixXQUFXLEdBQUEscUJBQUMsV0FBVyxFQUFFO0FBQ3ZCLFFBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO0FBQ2hDLFFBQUksQ0FBQyxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7QUFDOUIsV0FBTyxJQUFJLENBQUM7R0FDYjs7QUE1Q2tCLGFBQVcsV0E4QzlCLGVBQWUsR0FBQSwyQkFBRzs7O0FBQ2hCLFdBQU8seUJBQVksVUFBQyxPQUFPLEVBQUs7QUFDOUIsVUFBRyxNQUFLLFlBQVksRUFBRTtBQUNwQixlQUFPLE9BQU8sQ0FBQyxNQUFLLFlBQVksQ0FBQyxDQUFDO09BQ25DO0FBQ0QsWUFBSyxNQUFNLENBQUMsV0FBVyxDQUFDLFVBQUMsRUFBRTtlQUFLLE9BQU8sQ0FBQyxFQUFFLENBQUM7T0FBQSxDQUFDLENBQUM7S0FDOUMsQ0FBQyxDQUFDO0dBQ0o7O0FBckRrQixhQUFXLFdBdUQ5QixJQUFJLEdBQUEsZ0JBQTJCOzs7UUFBMUIsUUFBUSx5REFBRyxZQUFXLEVBQUU7O0FBQzNCLFdBQU8sSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUMxQixJQUFJLENBQUMsVUFBQyxXQUFXLEVBQUs7QUFDckIsYUFBTyxxQkFBUSxHQUFHLENBQUMsT0FBSyxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQUMsS0FBSyxFQUFLO0FBQzNDLGVBQU8sV0FBVyxDQUFDLE9BQUssU0FBUyxDQUFDLENBQy9CLE1BQU0sQ0FBQyxLQUFLLEVBQUUsT0FBSyxVQUFVLENBQUMsQ0FBQztPQUNuQyxDQUFDLENBQUMsQ0FDQSxJQUFJLENBQUMsVUFBQyxNQUFNLEVBQUs7QUFDaEIsWUFBRyxPQUFLLGdCQUFnQixFQUFFO0FBQ3hCLHFCQUFXLENBQUMsTUFBTSxFQUFFLENBQUM7U0FDdEI7QUFDRCxlQUFPLFFBQVEsQ0FBQyxnQkFBUSxNQUFNLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztPQUN4QyxDQUFDLFNBQ0ksQ0FBQyxVQUFDLEtBQUssRUFBSztBQUNoQixZQUFHLE9BQUssZ0JBQWdCLEVBQUU7QUFDeEIscUJBQVcsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDN0I7QUFDRCxjQUFNLEtBQUssQ0FBQztPQUNiLENBQUMsQ0FBQztLQUNOLENBQUMsQ0FBQztHQUNOOztTQTNFa0IsV0FBVzs7O3FCQUFYLFdBQVciLCJmaWxlIjoiYmF0Y2hJbnNlcnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcclxuXHJcbmltcG9ydCB7IGlzTnVtYmVyLCBpc1N0cmluZywgaXNBcnJheSwgY2h1bmssIGZsYXR0ZW4gfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgUHJvbWlzZSBmcm9tICcuLi9wcm9taXNlJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhdGNoSW5zZXJ0IHtcclxuICBjb25zdHJ1Y3RvcihjbGllbnQsIHRhYmxlTmFtZSwgYmF0Y2gsIGNodW5rU2l6ZSA9IDEwMDApIHtcclxuICAgIGlmKCFpc051bWJlcihjaHVua1NpemUpIHx8IGNodW5rU2l6ZSA8IDEpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBjaHVua1NpemU6ICR7Y2h1bmtTaXplfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKCFpc0FycmF5KGJhdGNoKSkge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGJhdGNoOiBFeHBlY3RlZCBhcnJheSwgZ290ICR7dHlwZW9mIGJhdGNofWApXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XHJcbiAgICB0aGlzLnRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcclxuICAgIHRoaXMuYmF0Y2ggPSBjaHVuayhiYXRjaCwgY2h1bmtTaXplKTtcclxuICAgIHRoaXMuX3JldHVybmluZyA9IHZvaWQgMDtcclxuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gbnVsbDtcclxuICAgIHRoaXMuX2F1dG9UcmFuc2FjdGlvbiA9IHRydWU7XHJcblxyXG4gICAgaWYgKGNsaWVudC50cmFuc2FjdGluZykge1xyXG4gICAgICB0aGlzLnRyYW5zYWN0aW5nKGNsaWVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb2x1bW5zIHRvIHJldHVybiBmcm9tIHRoZSBiYXRjaCBvcGVyYXRpb24uXHJcbiAgICogQHBhcmFtIHJldHVybmluZ1xyXG4gICAqL1xyXG4gIHJldHVybmluZyhyZXR1cm5pbmcpIHtcclxuICAgIGlmKGlzQXJyYXkocmV0dXJuaW5nKSB8fCBpc1N0cmluZyhyZXR1cm5pbmcpKSB7XHJcbiAgICAgIHRoaXMuX3JldHVybmluZyA9IHJldHVybmluZztcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXNlciBtYXkgc3VwcGx5IHRoZWlyIG93biB0cmFuc2FjdGlvbi4gSWYgdGhpcyBpcyB0aGUgY2FzZSxcclxuICAgKiBgYXV0b1RyYW5zYWN0aW9uID0gZmFsc2VgLCBtZWFuaW5nIHdlIGRvbid0IGF1dG9tYXRpY2FsbHkgY29tbWl0L3JvbGxiYWNrXHJcbiAgICogdGhlIHRyYW5zYWN0aW9uLiBUaGUgcmVzcG9uc2liaWxpdHkgaW5zdGVhZCBmYWxscyBvbiB0aGUgdXNlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvblxyXG4gICAqL1xyXG4gIHRyYW5zYWN0aW5nKHRyYW5zYWN0aW9uKSB7XHJcbiAgICB0aGlzLl90cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xyXG4gICAgdGhpcy5fYXV0b1RyYW5zYWN0aW9uID0gZmFsc2U7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIF9nZXRUcmFuc2FjdGlvbigpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICBpZih0aGlzLl90cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlKHRoaXMuX3RyYW5zYWN0aW9uKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmNsaWVudC50cmFuc2FjdGlvbigodHIpID0+IHJlc29sdmUodHIpKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgdGhlbihjYWxsYmFjayA9IGZ1bmN0aW9uKCkge30pIHtcclxuICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2FjdGlvbigpXHJcbiAgICAgIC50aGVuKCh0cmFuc2FjdGlvbikgPT4ge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLmJhdGNoLm1hcCgoaXRlbXMpID0+IHtcclxuICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbih0aGlzLnRhYmxlTmFtZSlcclxuICAgICAgICAgICAgLmluc2VydChpdGVtcywgdGhpcy5fcmV0dXJuaW5nKTtcclxuICAgICAgICB9KSlcclxuICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgaWYodGhpcy5fYXV0b1RyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY29tbWl0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGZsYXR0ZW4ocmVzdWx0IHx8IFtdKSk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBpZih0aGlzLl9hdXRvVHJhbnNhY3Rpb24pIHtcclxuICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5yb2xsYmFjayhlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgfVxyXG59XHJcbiJdfQ==

/***/ },
/* 74 */
/***/ function(module, exports) {

	module.exports = {
		"name": "knex",
		"version": "0.11.6",
		"description": "A batteries-included SQL query & schema builder for Postgres, MySQL and SQLite3 and the Browser",
		"main": "lib",
		"dependencies": {
			"bluebird": "^3.3.4",
			"chalk": "^1.0.0",
			"commander": "^2.2.0",
			"debug": "^2.1.3",
			"inherits": "~2.0.1",
			"interpret": "^0.6.5",
			"liftoff": "~2.2.0",
			"lodash": "^4.6.0",
			"minimist": "~1.1.0",
			"mkdirp": "^0.5.0",
			"node-uuid": "~1.4.0",
			"pg-connection-string": "^0.1.3",
			"pool2": "^1.1.0",
			"readable-stream": "^1.1.12",
			"tildify": "~1.0.0",
			"v8flags": "^2.0.2"
		},
		"bin": {
			"knex": "./lib/bin/cli.js"
		},
		"repository": {
			"type": "git",
			"url": "git://github.com/tgriesser/knex.git"
		},
		"keywords": [
			"sql",
			"query",
			"postgresql",
			"mysql",
			"mariadb",
			"sqlite3",
			"oracle",
			"mssql"
		],
		"author": {
			"name": "Tim Griesser",
			"web": "https://github.com/tgriesser"
		},
		"browser": {
			"bluebird/js/main/promise": "./lib/util/bluebird.js",
			"./lib/migrate/index.js": "./lib/util/noop.js",
			"./lib/bin/cli.js": "./lib/util/noop.js",
			"./lib/seed/index.js": "./lib/util/noop.js",
			"pool2": "./lib/util/noop.js",
			"mssql": false,
			"mysql": false,
			"mysql2": false,
			"mariasql": false,
			"pg": false,
			"pg-query-stream": false,
			"oracle": false,
			"strong-oracle": false,
			"sqlite3": false
		},
		"files": [
			"README.md",
			"src/*",
			"lib/*",
			"build/*",
			"knex.js",
			"LICENSE"
		],
		"license": "MIT"
	};

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	
	// Query Compiler
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _raw = __webpack_require__(2);

	var _raw2 = _interopRequireDefault(_raw);

	var _joinclause = __webpack_require__(64);

	var _joinclause2 = _interopRequireDefault(_joinclause);

	var _lodash = __webpack_require__(5);

	var _nodeUuid = __webpack_require__(19);

	var _nodeUuid2 = _interopRequireDefault(_nodeUuid);

	// The "QueryCompiler" takes all of the query statements which
	// have been gathered in the "QueryBuilder" and turns them into a
	// properly formatted / bound query string.
	function QueryCompiler(client, builder) {
	  this.client = client;
	  this.method = builder._method || 'select';
	  this.options = builder._options;
	  this.single = builder._single;
	  this.timeout = builder._timeout || false;
	  this.cancelOnTimeout = builder._cancelOnTimeout || false;
	  this.grouped = _lodash.groupBy(builder._statements, 'grouping');
	  this.formatter = client.formatter();
	}

	var components = ['columns', 'join', 'where', 'union', 'group', 'having', 'order', 'limit', 'offset', 'lock'];

	_lodash.assign(QueryCompiler.prototype, {

	  // Used when the insert call is empty.
	  _emptyInsertValue: 'default values',

	  // Collapse the builder into a single object
	  toSQL: function toSQL(method, tz) {
	    this._undefinedInWhereClause = false;

	    method = method || this.method;
	    var val = this[method]();
	    var defaults = {
	      method: method,
	      options: _lodash.reduce(this.options, _lodash.assign, {}),
	      timeout: this.timeout,
	      cancelOnTimeout: this.cancelOnTimeout,
	      bindings: this.formatter.bindings,
	      __knexQueryUid: _nodeUuid2['default'].v4()
	    };
	    if (_lodash.isString(val)) {
	      val = { sql: val };
	    }

	    defaults.bindings = defaults.bindings || [];

	    if (method === 'select') {
	      if (this.single.as) {
	        defaults.as = this.single.as;
	      }
	    }

	    if (this._undefinedInWhereClause) {
	      throw new Error('Undefined binding(s) detected when compiling ' + (method.toUpperCase() + ' query: ' + val.sql));
	    }

	    defaults.bindings = this.client.prepBindings(defaults.bindings, tz);

	    return _lodash.assign(defaults, val);
	  },

	  // Compiles the `select` statement, or nested sub-selects by calling each of
	  // the component compilers, trimming out the empties, and returning a
	  // generated query string.
	  select: function select() {
	    var _this = this;

	    var statements = components.map(function (component) {
	      return _this[component](_this);
	    });
	    return _lodash.compact(statements).join(' ');
	  },

	  pluck: function pluck() {
	    return {
	      sql: this.select(),
	      pluck: this.single.pluck
	    };
	  },

	  // Compiles an "insert" query, allowing for multiple
	  // inserts using a single query statement.
	  insert: function insert() {
	    var insertValues = this.single.insert || [];
	    var sql = 'insert into ' + this.tableName + ' ';

	    if (Array.isArray(insertValues)) {
	      if (insertValues.length === 0) {
	        return '';
	      }
	    } else if (typeof insertValues === 'object' && _lodash.isEmpty(insertValues)) {
	      return sql + this._emptyInsertValue;
	    }

	    var insertData = this._prepInsert(insertValues);
	    if (typeof insertData === 'string') {
	      sql += insertData;
	    } else {
	      if (insertData.columns.length) {
	        sql += '(' + this.formatter.columnize(insertData.columns);
	        sql += ') values (';
	        var i = -1;
	        while (++i < insertData.values.length) {
	          if (i !== 0) sql += '), (';
	          sql += this.formatter.parameterize(insertData.values[i], this.client.valueForUndefined);
	        }
	        sql += ')';
	      } else if (insertValues.length === 1 && insertValues[0]) {
	        sql += this._emptyInsertValue;
	      } else {
	        sql = '';
	      }
	    }
	    return sql;
	  },

	  // Compiles the "update" query.
	  update: function update() {
	    // Make sure tableName is processed by the formatter first.
	    var tableName = this.tableName;

	    var updateData = this._prepUpdate(this.single.update);
	    var wheres = this.where();
	    return 'update ' + tableName + ' set ' + updateData.join(', ') + (wheres ? ' ' + wheres : '');
	  },

	  // Compiles the columns in the query, specifying if an item was distinct.
	  columns: function columns() {
	    var distinct = false;
	    if (this.onlyUnions()) return '';
	    var columns = this.grouped.columns || [];
	    var i = -1,
	        sql = [];
	    if (columns) {
	      while (++i < columns.length) {
	        var stmt = columns[i];
	        if (stmt.distinct) distinct = true;
	        if (stmt.type === 'aggregate') {
	          sql.push(this.aggregate(stmt));
	        } else if (stmt.value && stmt.value.length > 0) {
	          sql.push(this.formatter.columnize(stmt.value));
	        }
	      }
	    }
	    if (sql.length === 0) sql = ['*'];
	    return 'select ' + (distinct ? 'distinct ' : '') + sql.join(', ') + (this.tableName ? ' from ' + this.tableName : '');
	  },

	  aggregate: function aggregate(stmt) {
	    var val = stmt.value;
	    var splitOn = val.toLowerCase().indexOf(' as ');
	    var distinct = stmt.aggregateDistinct ? 'distinct ' : '';
	    // Allows us to speciy an alias for the aggregate types.
	    if (splitOn !== -1) {
	      var col = val.slice(0, splitOn);
	      var alias = val.slice(splitOn + 4);
	      return stmt.method + '(' + (distinct + this.formatter.wrap(col)) + ') ' + ('as ' + this.formatter.wrap(alias));
	    }
	    return stmt.method + '(' + (distinct + this.formatter.wrap(val)) + ')';
	  },

	  // Compiles all each of the `join` clauses on the query,
	  // including any nested join queries.
	  join: function join() {
	    var sql = '';
	    var i = -1;
	    var joins = this.grouped.join;
	    if (!joins) return '';
	    while (++i < joins.length) {
	      var join = joins[i];
	      var table = join.schema ? join.schema + '.' + join.table : join.table;
	      if (i > 0) sql += ' ';
	      if (join.joinType === 'raw') {
	        sql += this.formatter.unwrapRaw(join.table);
	      } else {
	        sql += join.joinType + ' join ' + this.formatter.wrap(table);
	        var ii = -1;
	        while (++ii < join.clauses.length) {
	          var clause = join.clauses[ii];
	          if (ii > 0) {
	            sql += ' ' + clause.bool + ' ';
	          } else {
	            sql += ' ' + (clause.type === 'onUsing' ? 'using' : 'on') + ' ';
	          }
	          var val = this[clause.type].call(this, clause);
	          if (val) {
	            sql += val;
	          }
	        }
	      }
	    }
	    return sql;
	  },

	  // Compiles all `where` statements on the query.
	  where: function where() {
	    var wheres = this.grouped.where;
	    if (!wheres) return;
	    var sql = [];
	    var i = -1;
	    while (++i < wheres.length) {
	      var stmt = wheres[i];
	      if (stmt.hasOwnProperty('value') && helpers.containsUndefined(stmt.value)) {
	        this._undefinedInWhereClause = true;
	      }
	      var val = this[stmt.type](stmt);
	      if (val) {
	        if (sql.length === 0) {
	          sql[0] = 'where';
	        } else {
	          sql.push(stmt.bool);
	        }
	        sql.push(val);
	      }
	    }
	    return sql.length > 1 ? sql.join(' ') : '';
	  },

	  group: function group() {
	    return this._groupsOrders('group');
	  },

	  order: function order() {
	    return this._groupsOrders('order');
	  },

	  // Compiles the `having` statements.
	  having: function having() {
	    var havings = this.grouped.having;
	    if (!havings) return '';
	    var sql = ['having'];
	    for (var i = 0, l = havings.length; i < l; i++) {
	      var str = '';
	      var s = havings[i];
	      if (i !== 0) str = s.bool + ' ';
	      if (s.type === 'havingBasic') {
	        sql.push(str + this.formatter.columnize(s.column) + ' ' + this.formatter.operator(s.operator) + ' ' + this.formatter.parameter(s.value));
	      } else {
	        if (s.type === 'whereWrapped') {
	          var val = this.whereWrapped(s);
	          if (val) sql.push(val);
	        } else {
	          sql.push(str + this.formatter.unwrapRaw(s.value));
	        }
	      }
	    }
	    return sql.length > 1 ? sql.join(' ') : '';
	  },

	  // Compile the "union" queries attached to the main query.
	  union: function union() {
	    var onlyUnions = this.onlyUnions();
	    var unions = this.grouped.union;
	    if (!unions) return '';
	    var sql = '';
	    for (var i = 0, l = unions.length; i < l; i++) {
	      var union = unions[i];
	      if (i > 0) sql += ' ';
	      if (i > 0 || !onlyUnions) sql += union.clause + ' ';
	      var statement = this.formatter.rawOrFn(union.value);
	      if (statement) {
	        if (union.wrap) sql += '(';
	        sql += statement;
	        if (union.wrap) sql += ')';
	      }
	    }
	    return sql;
	  },

	  // If we haven't specified any columns or a `tableName`, we're assuming this
	  // is only being used for unions.
	  onlyUnions: function onlyUnions() {
	    return !this.grouped.columns && this.grouped.union && !this.tableName;
	  },

	  limit: function limit() {
	    var noLimit = !this.single.limit && this.single.limit !== 0;
	    if (noLimit) return '';
	    return 'limit ' + this.formatter.parameter(this.single.limit);
	  },

	  offset: function offset() {
	    if (!this.single.offset) return '';
	    return 'offset ' + this.formatter.parameter(this.single.offset);
	  },

	  // Compiles a `delete` query.
	  del: function del() {
	    // Make sure tableName is processed by the formatter first.
	    var tableName = this.tableName;

	    var wheres = this.where();
	    return 'delete from ' + tableName + (wheres ? ' ' + wheres : '');
	  },

	  // Compiles a `truncate` query.
	  truncate: function truncate() {
	    return 'truncate ' + this.tableName;
	  },

	  // Compiles the "locks".
	  lock: function lock() {
	    if (this.single.lock) {
	      if (!this.client.transacting) {
	        helpers.warn('You are attempting to perform a "lock" command outside of a transaction.');
	      } else {
	        return this[this.single.lock]();
	      }
	    }
	  },

	  // Compile the "counter".
	  counter: function counter() {
	    var counter = this.single.counter;

	    var toUpdate = {};
	    toUpdate[counter.column] = this.client.raw(this.formatter.wrap(counter.column) + ' ' + (counter.symbol || '+') + ' ' + counter.amount);
	    this.single.update = toUpdate;
	    return this.update();
	  },

	  // On Clause
	  // ------

	  onWrapped: function onWrapped(clause) {
	    var self = this;

	    var wrapJoin = new _joinclause2['default']();
	    clause.value.call(wrapJoin, wrapJoin);

	    var sql = '';
	    wrapJoin.clauses.forEach(function (wrapClause, ii) {
	      if (ii > 0) {
	        sql += ' ' + wrapClause.bool + ' ';
	      }
	      var val = self[wrapClause.type](wrapClause);
	      if (val) {
	        sql += val;
	      }
	    });

	    if (sql.length) {
	      return '(' + sql + ')';
	    }
	    return '';
	  },

	  onBasic: function onBasic(clause) {
	    return this.formatter.wrap(clause.column) + ' ' + this.formatter.operator(clause.operator) + ' ' + this.formatter.wrap(clause.value);
	  },

	  onRaw: function onRaw(clause) {
	    return this.formatter.unwrapRaw(clause.value);
	  },

	  onUsing: function onUsing(clause) {
	    return this.formatter.wrap(clause.column);
	  },

	  // Where Clause
	  // ------

	  whereIn: function whereIn(statement) {
	    if (Array.isArray(statement.column)) return this.multiWhereIn(statement);
	    return this.formatter.wrap(statement.column) + ' ' + this._not(statement, 'in ') + this.wrap(this.formatter.parameterize(statement.value));
	  },

	  multiWhereIn: function multiWhereIn(statement) {
	    var i = -1,
	        sql = '(' + this.formatter.columnize(statement.column) + ') ';
	    sql += this._not(statement, 'in ') + '((';
	    while (++i < statement.value.length) {
	      if (i !== 0) sql += '),(';
	      sql += this.formatter.parameterize(statement.value[i]);
	    }
	    return sql + '))';
	  },

	  whereNull: function whereNull(statement) {
	    return this.formatter.wrap(statement.column) + ' is ' + this._not(statement, 'null');
	  },

	  // Compiles a basic "where" clause.
	  whereBasic: function whereBasic(statement) {
	    return this._not(statement, '') + this.formatter.wrap(statement.column) + ' ' + this.formatter.operator(statement.operator) + ' ' + this.formatter.parameter(statement.value);
	  },

	  whereExists: function whereExists(statement) {
	    return this._not(statement, 'exists') + ' (' + this.formatter.rawOrFn(statement.value) + ')';
	  },

	  whereWrapped: function whereWrapped(statement) {
	    var val = this.formatter.rawOrFn(statement.value, 'where');
	    return val && this._not(statement, '') + '(' + val.slice(6) + ')' || '';
	  },

	  whereBetween: function whereBetween(statement) {
	    return this.formatter.wrap(statement.column) + ' ' + this._not(statement, 'between') + ' ' + _lodash.map(statement.value, _lodash.bind(this.formatter.parameter, this.formatter)).join(' and ');
	  },

	  // Compiles a "whereRaw" query.
	  whereRaw: function whereRaw(statement) {
	    return this._not(statement, '') + this.formatter.unwrapRaw(statement.value);
	  },

	  wrap: function wrap(str) {
	    if (str.charAt(0) !== '(') return '(' + str + ')';
	    return str;
	  },

	  // Determines whether to add a "not" prefix to the where clause.
	  _not: function _not(statement, str) {
	    if (statement.not) return 'not ' + str;
	    return str;
	  },

	  _prepInsert: function _prepInsert(data) {
	    var isRaw = this.formatter.rawOrFn(data);
	    if (isRaw) return isRaw;
	    var columns = [];
	    var values = [];
	    if (!Array.isArray(data)) data = data ? [data] : [];
	    var i = -1;
	    while (++i < data.length) {
	      if (data[i] == null) break;
	      if (i === 0) columns = Object.keys(data[i]).sort();
	      var row = new Array(columns.length);
	      var keys = Object.keys(data[i]);
	      var j = -1;
	      while (++j < keys.length) {
	        var key = keys[j];
	        var idx = columns.indexOf(key);
	        if (idx === -1) {
	          columns = columns.concat(key).sort();
	          idx = columns.indexOf(key);
	          var k = -1;
	          while (++k < values.length) {
	            values[k].splice(idx, 0, undefined);
	          }
	          row.splice(idx, 0, undefined);
	        }
	        row[idx] = data[i][key];
	      }
	      values.push(row);
	    }
	    return {
	      columns: columns,
	      values: values
	    };
	  },

	  // "Preps" the update.
	  _prepUpdate: function _prepUpdate(data) {
	    data = _lodash.omitBy(data, _lodash.isUndefined);
	    var vals = [];
	    var sorted = Object.keys(data).sort();
	    var i = -1;
	    while (++i < sorted.length) {
	      vals.push(this.formatter.wrap(sorted[i]) + ' = ' + this.formatter.parameter(data[sorted[i]]));
	    }
	    return vals;
	  },

	  // Compiles the `order by` statements.
	  _groupsOrders: function _groupsOrders(type) {
	    var items = this.grouped[type];
	    if (!items) return '';
	    var formatter = this.formatter;

	    var sql = items.map(function (item) {
	      var column = item.value instanceof _raw2['default'] ? formatter.unwrapRaw(item.value) : formatter.columnize(item.value);
	      var direction = type === 'order' && item.type !== 'orderByRaw' ? ' ' + formatter.direction(item.direction) : '';
	      return column + direction;
	    });
	    return sql.length ? type + ' by ' + sql.join(', ') : '';
	  }

	});

	QueryCompiler.prototype.first = QueryCompiler.prototype.select;

	// Get the table name, wrapping it if necessary.
	// Implemented as a property to prevent ordering issues as described in #704.
	Object.defineProperty(QueryCompiler.prototype, 'tableName', {
	  get: function get() {
	    if (!this._tableName) {
	      // Only call this.formatter.wrap() the first time this property is accessed.
	      var tableName = this.single.table;
	      var schemaName = this.single.schema;

	      if (tableName && schemaName) tableName = schemaName + '.' + tableName;

	      this._tableName = tableName ? this.formatter.wrap(tableName) : '';
	    }
	    return this._tableName;
	  }
	});

	exports['default'] = QueryCompiler;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9xdWVyeS9jb21waWxlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozt1QkFHeUIsWUFBWTs7SUFBekIsT0FBTzs7bUJBQ0gsUUFBUTs7OzswQkFDRCxjQUFjOzs7O3NCQUs5QixRQUFROzt3QkFFRSxXQUFXOzs7Ozs7O0FBSzVCLFNBQVMsYUFBYSxDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUU7QUFDdEMsTUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUE7QUFDcEIsTUFBSSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsT0FBTyxJQUFJLFFBQVEsQ0FBQztBQUMxQyxNQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUM7QUFDaEMsTUFBSSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDO0FBQzlCLE1BQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLFFBQVEsSUFBSSxLQUFLLENBQUM7QUFDekMsTUFBSSxDQUFDLGVBQWUsR0FBRyxPQUFPLENBQUMsZ0JBQWdCLElBQUksS0FBSyxDQUFDO0FBQ3pELE1BQUksQ0FBQyxPQUFPLEdBQUcsZ0JBQVEsT0FBTyxDQUFDLFdBQVcsRUFBRSxVQUFVLENBQUMsQ0FBQztBQUN4RCxNQUFJLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQTtDQUNwQzs7QUFFRCxJQUFNLFVBQVUsR0FBRyxDQUNqQixTQUFTLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUM1QyxRQUFRLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUM3QyxDQUFDOztBQUVGLGVBQU8sYUFBYSxDQUFDLFNBQVMsRUFBRTs7O0FBRzlCLG1CQUFpQixFQUFFLGdCQUFnQjs7O0FBR25DLE9BQUssRUFBQSxlQUFDLE1BQU0sRUFBRSxFQUFFLEVBQUU7QUFDaEIsUUFBSSxDQUFDLHVCQUF1QixHQUFHLEtB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QUFFLFdBQVcsRUFBRTtBQUMxRCxLQUFHLEVBQUEsZUFBRztBQUNKLFFBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFOztBQUVuQixVQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztBQUNsQyxVQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQzs7QUFFdEMsVUFBSSxTQUFTLElBQUksVUFBVSxFQUFFLFNBQVMsR0FBTSxVQUFVLFNBQUksU0FBUyxBQUFFLENBQUM7O0FBRXRFLFVBQUksQ0FBQyxVQUFVLEdBQUcsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztLQUNuRTtBQUNELFdBQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztHQUN4QjtDQUNGLENBQUMsQ0FBQzs7cUJBR1ksYUFBYSIsImZpbGUiOiJjb21waWxlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLy8gUXVlcnkgQ29tcGlsZXJcbi8vIC0tLS0tLS1cbmltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSAnLi4vaGVscGVycyc7XG5pbXBvcnQgUmF3IGZyb20gJy4uL3Jhdyc7XG5pbXBvcnQgSm9pbkNsYXVzZSBmcm9tICcuL2pvaW5jbGF1c2UnO1xuXG5pbXBvcnQge1xuICBhc3NpZ24sIGJpbmQsIGNvbXBhY3QsIGdyb3VwQnksIGlzRW1wdHksIGlzU3RyaW5nLCBpc1VuZGVmaW5lZCwgbWFwLCBvbWl0QnksXG4gIHJlZHVjZVxufSBmcm9tICdsb2Rhc2gnO1xuXG5pbXBvcnQgdXVpZCBmcm9tICdub2RlLXV1aWQnO1xuXG4vLyBUaGUgXCJRdWVyeUNvbXBpbGVyXCIgdGFrZXMgYWxsIG9mIHRoZSBxdWVyeSBzdGF0ZW1lbnRzIHdoaWNoXG4vLyBoYXZlIGJlZW4gZ2F0aGVyZWQgaW4gdGhlIFwiUXVlcnlCdWlsZGVyXCIgYW5kIHR1cm5zIHRoZW0gaW50byBhXG4vLyBwcm9wZXJseSBmb3JtYXR0ZWQgLyBib3VuZCBxdWVyeSBzdHJpbmcuXG5mdW5jdGlvbiBRdWVyeUNvbXBpbGVyKGNsaWVudCwgYnVpbGRlcikge1xuICB0aGlzLmNsaWVudCA9IGNsaWVudFxuICB0aGlzLm1ldGhvZCA9IGJ1aWxkZXIuX21ldGhvZCB8fCAnc2VsZWN0JztcbiAgdGhpcy5vcHRpb25zID0gYnVpbGRlci5fb3B0aW9ucztcbiAgdGhpcy5zaW5nbGUgPSBidWlsZGVyLl9zaW5nbGU7XG4gIHRoaXMudGltZW91dCA9IGJ1aWxkZXIuX3RpbWVvdXQgfHwgZmFsc2U7XG4gIHRoaXMuY2FuY2VsT25UaW1lb3V0ID0gYnVpbGRlci5fY2FuY2VsT25UaW1lb3V0IHx8IGZhbHNlO1xuICB0aGlzLmdyb3VwZWQgPSBncm91cEJ5KGJ1aWxkZXIuX3N0YXRlbWVudHMsICdncm91cGluZycpO1xuICB0aGlzLmZvcm1hdHRlciA9IGNsaWVudC5mb3JtYXR0ZXIoKVxufVxuXG5jb25zdCBjb21wb25lbnRzID0gW1xuICAnY29sdW1ucycsICdqb2luJywgJ3doZXJlJywgJ3VuaW9uJywgJ2dyb3VwJyxcbiAgJ2hhdmluZycsICdvcmRlcicsICdsaW1pdCcsICdvZmZzZXQnLCAnbG9jaydcbl07XG5cbmFzc2lnbihRdWVyeUNvbXBpbGVyLnByb3RvdHlwZSwge1xuXG4gIC8vIFVzZWQgd2hlbiB0aGUgaW5zZXJ0IGNhbGwgaXMgZW1wdHkuXG4gIF9lbXB0eUluc2VydFZhbHVlOiAnZGVmYXVsdCB2YWx1ZXMnLFxuXG4gIC8vIENvbGxhcHNlIHRoZSBidWlsZGVyIGludG8gYSBzaW5nbGUgb2JqZWN0XG4gIHRvU1FMKG1ldGhvZCwgdHopIHtcbiAgICB0aGlzLl91bmRlZmluZWRJbldoZXJlQ2xhdXNlID0gZmFsc2U7XG5cbiAgICBtZXRob2QgPSBtZXRob2QgfHwgdGhpcy5tZXRob2RcbiAgICBsZXQgdmFsID0gdGhpc1ttZXRob2RdKClcbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIG9wdGlvbnM6IHJlZHVjZSh0aGlzLm9wdGlvbnMsIGFzc2lnbiwge30pLFxuICAgICAgdGltZW91dDogdGhpcy50aW1lb3V0LFxuICAgICAgY2FuY2VsT25UaW1lb3V0OiB0aGlzLmNhbmNlbE9uVGltZW91dCxcbiAgICAgIGJpbmRpbmdzOiB0aGlzLmZvcm1hdHRlci5iaW5kaW5ncyxcbiAgICAgIF9fa25leFF1ZXJ5VWlkOiB1dWlkLnY0KClcbiAgICB9O1xuICAgIGlmIChpc1N0cmluZyh2YWwpKSB7XG4gICAgICB2YWwgPSB7c3FsOiB2YWx9O1xuICAgIH1cblxuICAgIGRlZmF1bHRzLmJpbmRpbmdzID0gZGVmYXVsdHMuYmluZGluZ3MgfHwgW107XG5cbiAgICBpZiAobWV0aG9kID09PSAnc2VsZWN0Jykge1xuICAgICAgaWYodGhpcy5zaW5nbGUuYXMpIHtcbiAgICAgICAgZGVmYXVsdHMuYXMgPSB0aGlzLnNpbmdsZS5hcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZih0aGlzLl91bmRlZmluZWRJbldoZXJlQ2xhdXNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBVbmRlZmluZWQgYmluZGluZyhzKSBkZXRlY3RlZCB3aGVuIGNvbXBpbGluZyBgICtcbiAgICAgICAgYCR7bWV0aG9kLnRvVXBwZXJDYXNlKCl9IHF1ZXJ5OiAke3ZhbC5zcWx9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBkZWZhdWx0cy5iaW5kaW5ncyA9IHRoaXMuY2xpZW50LnByZXBCaW5kaW5ncyhkZWZhdWx0cy5iaW5kaW5ncywgdHopO1xuXG4gICAgcmV0dXJuIGFzc2lnbihkZWZhdWx0cywgdmFsKTtcbiAgfSxcblxuICAvLyBDb21waWxlcyB0aGUgYHNlbGVjdGAgc3RhdGVtZW50LCBvciBuZXN0ZWQgc3ViLXNlbGVjdHMgYnkgY2FsbGluZyBlYWNoIG9mXG4gIC8vIHRoZSBjb21wb25lbnQgY29tcGlsZXJzLCB0cmltbWluZyBvdXQgdGhlIGVtcHRpZXMsIGFuZCByZXR1cm5pbmcgYVxuICAvLyBnZW5lcmF0ZWQgcXVlcnkgc3RyaW5nLlxuICBzZWxlY3QoKSB7XG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IGNvbXBvbmVudHMubWFwKGNvbXBvbmVudCA9PlxuICAgICAgdGhpc1tjb21wb25lbnRdKHRoaXMpXG4gICAgKTtcbiAgICByZXR1cm4gY29tcGFjdChzdGF0ZW1lbnRzKS5qb2luKCcgJyk7XG4gIH0sXG5cbiAgcGx1Y2soKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNxbDogdGhpcy5zZWxlY3QoKSxcbiAgICAgIHBsdWNrOiB0aGlzLnNpbmdsZS5wbHVja1xuICAgIH07XG4gIH0sXG5cbiAgLy8gQ29tcGlsZXMgYW4gXCJpbnNlcnRcIiBxdWVyeSwgYWxsb3dpbmcgZm9yIG11bHRpcGxlXG4gIC8vIGluc2VydHMgdXNpbmcgYSBzaW5nbGUgcXVlcnkgc3RhdGVtZW50LlxuICBpbnNlcnQoKSB7XG4gICAgY29uc3QgaW5zZXJ0VmFsdWVzID0gdGhpcy5zaW5nbGUuaW5zZXJ0IHx8IFtdO1xuICAgIGxldCBzcWwgPSBgaW5zZXJ0IGludG8gJHt0aGlzLnRhYmxlTmFtZX0gYDtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGluc2VydFZhbHVlcykpIHtcbiAgICAgIGlmIChpbnNlcnRWYWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc2VydFZhbHVlcyA9PT0gJ29iamVjdCcgJiYgaXNFbXB0eShpbnNlcnRWYWx1ZXMpKSB7XG4gICAgICByZXR1cm4gc3FsICsgdGhpcy5fZW1wdHlJbnNlcnRWYWx1ZVxuICAgIH1cblxuICAgIGNvbnN0IGluc2VydERhdGEgPSB0aGlzLl9wcmVwSW5zZXJ0KGluc2VydFZhbHVlcyk7XG4gICAgaWYgKHR5cGVvZiBpbnNlcnREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgc3FsICs9IGluc2VydERhdGE7XG4gICAgfSBlbHNlICB7XG4gICAgICBpZiAoaW5zZXJ0RGF0YS5jb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICBzcWwgKz0gYCgke3RoaXMuZm9ybWF0dGVyLmNvbHVtbml6ZShpbnNlcnREYXRhLmNvbHVtbnMpfWBcbiAgICAgICAgc3FsICs9ICcpIHZhbHVlcyAoJ1xuICAgICAgICBsZXQgaSA9IC0xXG4gICAgICAgIHdoaWxlICgrK2kgPCBpbnNlcnREYXRhLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoaSAhPT0gMCkgc3FsICs9ICcpLCAoJ1xuICAgICAgICAgIHNxbCArPSB0aGlzLmZvcm1hdHRlci5wYXJhbWV0ZXJpemUoaW5zZXJ0RGF0YS52YWx1ZXNbaV0sIHRoaXMuY2xpZW50LnZhbHVlRm9yVW5kZWZpbmVkKVxuICAgICAgICB9XG4gICAgICAgIHNxbCArPSAnKSc7XG4gICAgICB9IGVsc2UgaWYgKGluc2VydFZhbHVlcy5sZW5ndGggPT09IDEgJiYgaW5zZXJ0VmFsdWVzWzBdKSB7XG4gICAgICAgIHNxbCArPSB0aGlzLl9lbXB0eUluc2VydFZhbHVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcWwgPSAnJ1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3FsO1xuICB9LFxuXG4gIC8vIENvbXBpbGVzIHRoZSBcInVwZGF0ZVwiIHF1ZXJ5LlxuICB1cGRhdGUoKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRhYmxlTmFtZSBpcyBwcm9jZXNzZWQgYnkgdGhlIGZvcm1hdHRlciBmaXJzdC5cbiAgICBjb25zdCB7IHRhYmxlTmFtZSB9ID0gdGhpcztcbiAgICBjb25zdCB1cGRhdGVEYXRhID0gdGhpcy5fcHJlcFVwZGF0ZSh0aGlzLnNpbmdsZS51cGRhdGUpO1xuICAgIGNvbnN0IHdoZXJlcyA9IHRoaXMud2hlcmUoKTtcbiAgICByZXR1cm4gYHVwZGF0ZSAke3RhYmxlTmFtZX1gICtcbiAgICAgICcgc2V0ICcgKyB1cGRhdGVEYXRhLmpvaW4oJywgJykgK1xuICAgICAgKHdoZXJlcyA/IGAgJHt3aGVyZXN9YCA6ICcnKTtcbiAgfSxcblxuICAvLyBDb21waWxlcyB0aGUgY29sdW1ucyBpbiB0aGUgcXVlcnksIHNwZWNpZnlpbmcgaWYgYW4gaXRlbSB3YXMgZGlzdGluY3QuXG4gIGNvbHVtbnMoKSB7XG4gICAgbGV0IGRpc3RpbmN0ID0gZmFsc2U7XG4gICAgaWYgKHRoaXMub25seVVuaW9ucygpKSByZXR1cm4gJydcbiAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5ncm91cGVkLmNvbHVtbnMgfHwgW11cbiAgICBsZXQgaSA9IC0xLCBzcWwgPSBbXTtcbiAgICBpZiAoY29sdW1ucykge1xuICAgICAgd2hpbGUgKCsraSA8IGNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHN0bXQgPSBjb2x1bW5zW2ldO1xuICAgICAgICBpZiAoc3RtdC5kaXN0aW5jdCkgZGlzdGluY3QgPSB0cnVlXG4gICAgICAgIGlmIChzdG10LnR5cGUgPT09ICdhZ2dyZWdhdGUnKSB7XG4gICAgICAgICAgc3FsLnB1c2godGhpcy5hZ2dyZWdhdGUoc3RtdCkpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RtdC52YWx1ZSAmJiBzdG10LnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzcWwucHVzaCh0aGlzLmZvcm1hdHRlci5jb2x1bW5pemUoc3RtdC52YWx1ZSkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNxbC5sZW5ndGggPT09IDApIHNxbCA9IFsnKiddO1xuICAgIHJldHVybiBgc2VsZWN0ICR7ZGlzdGluY3QgPyAnZGlzdGluY3QgJyA6ICcnfWAgK1xuICAgICAgc3FsLmpvaW4oJywgJykgKyAodGhpcy50YWJsZU5hbWUgPyBgIGZyb20gJHt0aGlzLnRhYmxlTmFtZX1gIDogJycpO1xuICB9LFxuXG4gIGFnZ3JlZ2F0ZShzdG10KSB7XG4gICAgY29uc3QgdmFsID0gc3RtdC52YWx1ZTtcbiAgICBjb25zdCBzcGxpdE9uID0gdmFsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignIGFzICcpO1xuICAgIGNvbnN0IGRpc3RpbmN0ID0gc3RtdC5hZ2dyZWdhdGVEaXN0aW5jdCA/ICdkaXN0aW5jdCAnIDogJyc7XG4gICAgLy8gQWxsb3dzIHVzIHRvIHNwZWNpeSBhbiBhbGlhcyBmb3IgdGhlIGFnZ3JlZ2F0ZSB0eXBlcy5cbiAgICBpZiAoc3BsaXRPbiAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGNvbCA9IHZhbC5zbGljZSgwLCBzcGxpdE9uKTtcbiAgICAgIGNvbnN0IGFsaWFzID0gdmFsLnNsaWNlKHNwbGl0T24gKyA0KTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGAke3N0bXQubWV0aG9kfSgke2Rpc3RpbmN0ICsgdGhpcy5mb3JtYXR0ZXIud3JhcChjb2wpfSkgYCArXG4gICAgICAgIGBhcyAke3RoaXMuZm9ybWF0dGVyLndyYXAoYWxpYXMpfWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBgJHtzdG10Lm1ldGhvZH0oJHtkaXN0aW5jdCArIHRoaXMuZm9ybWF0dGVyLndyYXAodmFsKX0pYDtcbiAgfSxcblxuICAvLyBDb21waWxlcyBhbGwgZWFjaCBvZiB0aGUgYGpvaW5gIGNsYXVzZXMgb24gdGhlIHF1ZXJ5LFxuICAvLyBpbmNsdWRpbmcgYW55IG5lc3RlZCBqb2luIHF1ZXJpZXMuXG4gIGpvaW4oKSB7XG4gICAgbGV0IHNxbCA9ICcnO1xuICAgIGxldCBpID0gLTE7XG4gICAgY29uc3Qgam9pbnMgPSB0aGlzLmdyb3VwZWQuam9pbjtcbiAgICBpZiAoIWpvaW5zKSByZXR1cm4gJyc7XG4gICAgd2hpbGUgKCsraSA8IGpvaW5zLmxlbmd0aCkge1xuICAgICAgY29uc3Qgam9pbiA9IGpvaW5zW2ldO1xuICAgICAgY29uc3QgdGFibGUgPSBqb2luLnNjaGVtYSA/IGAke2pvaW4uc2NoZW1hfS4ke2pvaW4udGFibGV9YCA6IGpvaW4udGFibGU7XG4gICAgICBpZiAoaSA+IDApIHNxbCArPSAnICdcbiAgICAgIGlmIChqb2luLmpvaW5UeXBlID09PSAncmF3Jykge1xuICAgICAgICBzcWwgKz0gdGhpcy5mb3JtYXR0ZXIudW53cmFwUmF3KGpvaW4udGFibGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcWwgKz0gam9pbi5qb2luVHlwZSArICcgam9pbiAnICsgdGhpcy5mb3JtYXR0ZXIud3JhcCh0YWJsZSlcbiAgICAgICAgbGV0IGlpID0gLTFcbiAgICAgICAgd2hpbGUgKCsraWkgPCBqb2luLmNsYXVzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgY2xhdXNlID0gam9pbi5jbGF1c2VzW2lpXVxuICAgICAgICAgIGlmIChpaSA+IDApIHtcbiAgICAgICAgICAgIHNxbCArPSBgICR7Y2xhdXNlLmJvb2x9IGA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNxbCArPSBgICR7Y2xhdXNlLnR5cGUgPT09ICdvblVzaW5nJyA/ICd1c2luZycgOiAnb24nfSBgO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzW2NsYXVzZS50eXBlXS5jYWxsKHRoaXMsIGNsYXVzZSk7XG4gICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgc3FsICs9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNxbDtcbiAgfSxcblxuICAvLyBDb21waWxlcyBhbGwgYHdoZXJlYCBzdGF0ZW1lbnRzIG9uIHRoZSBxdWVyeS5cbiAgd2hlcmUoKSB7XG4gICAgY29uc3Qgd2hlcmVzID0gdGhpcy5ncm91cGVkLndoZXJlO1xuICAgIGlmICghd2hlcmVzKSByZXR1cm47XG4gICAgY29uc3Qgc3FsID0gW107XG4gICAgbGV0IGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgd2hlcmVzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgc3RtdCA9IHdoZXJlc1tpXVxuICAgICAgaWYoc3RtdC5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSAmJiBoZWxwZXJzLmNvbnRhaW5zVW5kZWZpbmVkKHN0bXQudmFsdWUpKSB7XG4gICAgICAgIHRoaXMuX3VuZGVmaW5lZEluV2hlcmVDbGF1c2UgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsID0gdGhpc1tzdG10LnR5cGVdKHN0bXQpXG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIGlmIChzcWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgc3FsWzBdID0gJ3doZXJlJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNxbC5wdXNoKHN0bXQuYm9vbClcbiAgICAgICAgfVxuICAgICAgICBzcWwucHVzaCh2YWwpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcWwubGVuZ3RoID4gMSA/IHNxbC5qb2luKCcgJykgOiAnJztcbiAgfSxcblxuICBncm91cCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JvdXBzT3JkZXJzKCdncm91cCcpO1xuICB9LFxuXG4gIG9yZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9ncm91cHNPcmRlcnMoJ29yZGVyJyk7XG4gIH0sXG5cbiAgLy8gQ29tcGlsZXMgdGhlIGBoYXZpbmdgIHN0YXRlbWVudHMuXG4gIGhhdmluZygpIHtcbiAgICBjb25zdCBoYXZpbmdzID0gdGhpcy5ncm91cGVkLmhhdmluZztcbiAgICBpZiAoIWhhdmluZ3MpIHJldHVybiAnJztcbiAgICBjb25zdCBzcWwgPSBbJ2hhdmluZyddO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gaGF2aW5ncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxldCBzdHIgPSAnJztcbiAgICAgIGNvbnN0IHMgPSBoYXZpbmdzW2ldO1xuICAgICAgaWYgKGkgIT09IDApIHN0ciA9IHMuYm9vbCArICcgJztcbiAgICAgIGlmIChzLnR5cGUgPT09ICdoYXZpbmdCYXNpYycpIHtcbiAgICAgICAgc3FsLnB1c2goc3RyICsgdGhpcy5mb3JtYXR0ZXIuY29sdW1uaXplKHMuY29sdW1uKSArICcgJyArXG4gICAgICAgICAgdGhpcy5mb3JtYXR0ZXIub3BlcmF0b3Iocy5vcGVyYXRvcikgKyAnICcgKyB0aGlzLmZvcm1hdHRlci5wYXJhbWV0ZXIocy52YWx1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYocy50eXBlID09PSAnd2hlcmVXcmFwcGVkJyl7XG4gICAgICAgICAgY29uc3QgdmFsID0gdGhpcy53aGVyZVdyYXBwZWQocylcbiAgICAgICAgICBpZiAodmFsKSBzcWwucHVzaCh2YWwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3FsLnB1c2goc3RyICsgdGhpcy5mb3JtYXR0ZXIudW53cmFwUmF3KHMudmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3FsLmxlbmd0aCA+IDEgPyBzcWwuam9pbignICcpIDogJyc7XG4gIH0sXG5cbiAgLy8gQ29tcGlsZSB0aGUgXCJ1bmlvblwiIHF1ZXJpZXMgYXR0YWNoZWQgdG8gdGhlIG1haW4gcXVlcnkuXG4gIHVuaW9uKCkge1xuICAgIGNvbnN0IG9ubHlVbmlvbnMgPSB0aGlzLm9ubHlVbmlvbnMoKTtcbiAgICBjb25zdCB1bmlvbnMgPSB0aGlzLmdyb3VwZWQudW5pb247XG4gICAgaWYgKCF1bmlvbnMpIHJldHVybiAnJztcbiAgICBsZXQgc3FsID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB1bmlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCB1bmlvbiA9IHVuaW9uc1tpXTtcbiAgICAgIGlmIChpID4gMCkgc3FsICs9ICcgJztcbiAgICAgIGlmIChpID4gMCB8fCAhb25seVVuaW9ucykgc3FsICs9IHVuaW9uLmNsYXVzZSArICcgJztcbiAgICAgIGNvbnN0IHN0YXRlbWVudCA9IHRoaXMuZm9ybWF0dGVyLnJhd09yRm4odW5pb24udmFsdWUpO1xuICAgICAgaWYgKHN0YXRlbWVudCkge1xuICAgICAgICBpZiAodW5pb24ud3JhcCkgc3FsICs9ICcoJztcbiAgICAgICAgc3FsICs9IHN0YXRlbWVudDtcbiAgICAgICAgaWYgKHVuaW9uLndyYXApIHNxbCArPSAnKSc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcWw7XG4gIH0sXG5cbiAgLy8gSWYgd2UgaGF2ZW4ndCBzcGVjaWZpZWQgYW55IGNvbHVtbnMgb3IgYSBgdGFibGVOYW1lYCwgd2UncmUgYXNzdW1pbmcgdGhpc1xuICAvLyBpcyBvbmx5IGJlaW5nIHVzZWQgZm9yIHVuaW9ucy5cbiAgb25seVVuaW9ucygpIHtcbiAgICByZXR1cm4gKCF0aGlzLmdyb3VwZWQuY29sdW1ucyAmJiB0aGlzLmdyb3VwZWQudW5pb24gJiYgIXRoaXMudGFibGVOYW1lKTtcbiAgfSxcblxuICBsaW1pdCgpIHtcbiAgICBjb25zdCBub0xpbWl0ID0gIXRoaXMuc2luZ2xlLmxpbWl0ICYmIHRoaXMuc2luZ2xlLmxpbWl0ICE9PSAwO1xuICAgIGlmIChub0xpbWl0KSByZXR1cm4gJyc7XG4gICAgcmV0dXJuIGBsaW1pdCAke3RoaXMuZm9ybWF0dGVyLnBhcmFtZXRlcih0aGlzLnNpbmdsZS5saW1pdCl9YDtcbiAgfSxcblxuICBvZmZzZXQoKSB7XG4gICAgaWYgKCF0aGlzLnNpbmdsZS5vZmZzZXQpIHJldHVybiAnJztcbiAgICByZXR1cm4gYG9mZnNldCAke3RoaXMuZm9ybWF0dGVyLnBhcmFtZXRlcih0aGlzLnNpbmdsZS5vZmZzZXQpfWA7XG4gIH0sXG5cbiAgLy8gQ29tcGlsZXMgYSBgZGVsZXRlYCBxdWVyeS5cbiAgZGVsKCkge1xuICAgIC8vIE1ha2Ugc3VyZSB0YWJsZU5hbWUgaXMgcHJvY2Vzc2VkIGJ5IHRoZSBmb3JtYXR0ZXIgZmlyc3QuXG4gICAgY29uc3QgeyB0YWJsZU5hbWUgfSA9IHRoaXM7XG4gICAgY29uc3Qgd2hlcmVzID0gdGhpcy53aGVyZSgpO1xuICAgIHJldHVybiBgZGVsZXRlIGZyb20gJHt0YWJsZU5hbWV9YCArXG4gICAgICAod2hlcmVzID8gYCAke3doZXJlc31gIDogJycpO1xuICB9LFxuXG4gIC8vIENvbXBpbGVzIGEgYHRydW5jYXRlYCBxdWVyeS5cbiAgdHJ1bmNhdGUoKSB7XG4gICAgcmV0dXJuIGB0cnVuY2F0ZSAke3RoaXMudGFibGVOYW1lfWA7XG4gIH0sXG5cbiAgLy8gQ29tcGlsZXMgdGhlIFwibG9ja3NcIi5cbiAgbG9jaygpIHtcbiAgICBpZiAodGhpcy5zaW5nbGUubG9jaykge1xuICAgICAgaWYgKCF0aGlzLmNsaWVudC50cmFuc2FjdGluZykge1xuICAgICAgICBoZWxwZXJzLndhcm4oJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byBwZXJmb3JtIGEgXCJsb2NrXCIgY29tbWFuZCBvdXRzaWRlIG9mIGEgdHJhbnNhY3Rpb24uJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzW3RoaXMuc2luZ2xlLmxvY2tdKClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gQ29tcGlsZSB0aGUgXCJjb3VudGVyXCIuXG4gIGNvdW50ZXIoKSB7XG4gICAgY29uc3QgeyBjb3VudGVyIH0gPSB0aGlzLnNpbmdsZTtcbiAgICBjb25zdCB0b1VwZGF0ZSA9IHt9O1xuICAgIHRvVXBkYXRlW2NvdW50ZXIuY29sdW1uXSA9IHRoaXMuY2xpZW50LnJhdyh0aGlzLmZvcm1hdHRlci53cmFwKGNvdW50ZXIuY29sdW1uKSArXG4gICAgICAnICcgKyAoY291bnRlci5zeW1ib2wgfHwgJysnKSArXG4gICAgICAnICcgKyBjb3VudGVyLmFtb3VudCk7XG4gICAgdGhpcy5zaW5nbGUudXBkYXRlID0gdG9VcGRhdGU7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlKCk7XG4gIH0sXG5cbiAgLy8gT24gQ2xhdXNlXG4gIC8vIC0tLS0tLVxuXG4gIG9uV3JhcHBlZChjbGF1c2UpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGNvbnN0IHdyYXBKb2luID0gbmV3IEpvaW5DbGF1c2UoKTtcbiAgICBjbGF1c2UudmFsdWUuY2FsbCh3cmFwSm9pbiwgd3JhcEpvaW4pO1xuXG4gICAgbGV0IHNxbCA9ICcnO1xuICAgIHdyYXBKb2luLmNsYXVzZXMuZm9yRWFjaChmdW5jdGlvbih3cmFwQ2xhdXNlLCBpaSkge1xuICAgICAgaWYgKGlpID4gMCkge1xuICAgICAgICBzcWwgKz0gYCAke3dyYXBDbGF1c2UuYm9vbH0gYDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbCA9IHNlbGZbd3JhcENsYXVzZS50eXBlXSh3cmFwQ2xhdXNlKTtcbiAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgc3FsICs9IHZhbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChzcWwubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYCgke3NxbH0pYDtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9LFxuXG4gIG9uQmFzaWMoY2xhdXNlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuZm9ybWF0dGVyLndyYXAoY2xhdXNlLmNvbHVtbikgKyAnICcgK1xuICAgICAgdGhpcy5mb3JtYXR0ZXIub3BlcmF0b3IoY2xhdXNlLm9wZXJhdG9yKSArICcgJyArXG4gICAgICB0aGlzLmZvcm1hdHRlci53cmFwKGNsYXVzZS52YWx1ZSlcbiAgICApO1xuICB9LFxuXG4gIG9uUmF3KGNsYXVzZSkge1xuICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci51bndyYXBSYXcoY2xhdXNlLnZhbHVlKTtcbiAgfSxcblxuICBvblVzaW5nKGNsYXVzZSkge1xuICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci53cmFwKGNsYXVzZS5jb2x1bW4pO1xuICB9LFxuXG4gIC8vIFdoZXJlIENsYXVzZVxuICAvLyAtLS0tLS1cblxuICB3aGVyZUluKHN0YXRlbWVudCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0YXRlbWVudC5jb2x1bW4pKSByZXR1cm4gdGhpcy5tdWx0aVdoZXJlSW4oc3RhdGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIud3JhcChzdGF0ZW1lbnQuY29sdW1uKSArICcgJyArIHRoaXMuX25vdChzdGF0ZW1lbnQsICdpbiAnKSArXG4gICAgICB0aGlzLndyYXAodGhpcy5mb3JtYXR0ZXIucGFyYW1ldGVyaXplKHN0YXRlbWVudC52YWx1ZSkpO1xuICB9LFxuXG4gIG11bHRpV2hlcmVJbihzdGF0ZW1lbnQpIHtcbiAgICBsZXQgaSA9IC0xLCBzcWwgPSBgKCR7dGhpcy5mb3JtYXR0ZXIuY29sdW1uaXplKHN0YXRlbWVudC5jb2x1bW4pfSkgYFxuICAgIHNxbCArPSB0aGlzLl9ub3Qoc3RhdGVtZW50LCAnaW4gJykgKyAnKCgnXG4gICAgd2hpbGUgKCsraSA8IHN0YXRlbWVudC52YWx1ZS5sZW5ndGgpIHtcbiAgICAgIGlmIChpICE9PSAwKSBzcWwgKz0gJyksKCdcbiAgICAgIHNxbCArPSB0aGlzLmZvcm1hdHRlci5wYXJhbWV0ZXJpemUoc3RhdGVtZW50LnZhbHVlW2ldKVxuICAgIH1cbiAgICByZXR1cm4gc3FsICsgJykpJ1xuICB9LFxuXG4gIHdoZXJlTnVsbChzdGF0ZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIud3JhcChzdGF0ZW1lbnQuY29sdW1uKSArICcgaXMgJyArIHRoaXMuX25vdChzdGF0ZW1lbnQsICdudWxsJyk7XG4gIH0sXG5cbiAgLy8gQ29tcGlsZXMgYSBiYXNpYyBcIndoZXJlXCIgY2xhdXNlLlxuICB3aGVyZUJhc2ljKHN0YXRlbWVudCkge1xuICAgIHJldHVybiB0aGlzLl9ub3Qoc3RhdGVtZW50LCAnJykgK1xuICAgICAgdGhpcy5mb3JtYXR0ZXIud3JhcChzdGF0ZW1lbnQuY29sdW1uKSArICcgJyArXG4gICAgICB0aGlzLmZvcm1hdHRlci5vcGVyYXRvcihzdGF0ZW1lbnQub3BlcmF0b3IpICsgJyAnICtcbiAgICAgIHRoaXMuZm9ybWF0dGVyLnBhcmFtZXRlcihzdGF0ZW1lbnQudmFsdWUpO1xuICB9LFxuXG4gIHdoZXJlRXhpc3RzKHN0YXRlbWVudCkge1xuICAgIHJldHVybiB0aGlzLl9ub3Qoc3RhdGVtZW50LCAnZXhpc3RzJykgKyAnICgnICsgdGhpcy5mb3JtYXR0ZXIucmF3T3JGbihzdGF0ZW1lbnQudmFsdWUpICsgJyknO1xuICB9LFxuXG4gIHdoZXJlV3JhcHBlZChzdGF0ZW1lbnQpIHtcbiAgICBjb25zdCB2YWwgPSB0aGlzLmZvcm1hdHRlci5yYXdPckZuKHN0YXRlbWVudC52YWx1ZSwgJ3doZXJlJylcbiAgICByZXR1cm4gdmFsICYmIHRoaXMuX25vdChzdGF0ZW1lbnQsICcnKSArICcoJyArIHZhbC5zbGljZSg2KSArICcpJyB8fCAnJztcbiAgfSxcblxuICB3aGVyZUJldHdlZW4oc3RhdGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLndyYXAoc3RhdGVtZW50LmNvbHVtbikgKyAnICcgKyB0aGlzLl9ub3Qoc3RhdGVtZW50LCAnYmV0d2VlbicpICsgJyAnICtcbiAgICAgIG1hcChzdGF0ZW1lbnQudmFsdWUsIGJpbmQodGhpcy5mb3JtYXR0ZXIucGFyYW1ldGVyLCB0aGlzLmZvcm1hdHRlcikpLmpvaW4oJyBhbmQgJyk7XG4gIH0sXG5cbiAgLy8gQ29tcGlsZXMgYSBcIndoZXJlUmF3XCIgcXVlcnkuXG4gIHdoZXJlUmF3KHN0YXRlbWVudCkge1xuICAgIHJldHVybiB0aGlzLl9ub3Qoc3RhdGVtZW50LCAnJykgKyB0aGlzLmZvcm1hdHRlci51bndyYXBSYXcoc3RhdGVtZW50LnZhbHVlKTtcbiAgfSxcblxuICB3cmFwKHN0cikge1xuICAgIGlmIChzdHIuY2hhckF0KDApICE9PSAnKCcpIHJldHVybiBgKCR7c3RyfSlgO1xuICAgIHJldHVybiBzdHI7XG4gIH0sXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGFkZCBhIFwibm90XCIgcHJlZml4IHRvIHRoZSB3aGVyZSBjbGF1c2UuXG4gIF9ub3Qoc3RhdGVtZW50LCBzdHIpIHtcbiAgICBpZiAoc3RhdGVtZW50Lm5vdCkgcmV0dXJuIGBub3QgJHtzdHJ9YDtcbiAgICByZXR1cm4gc3RyO1xuICB9LFxuXG4gIF9wcmVwSW5zZXJ0KGRhdGEpIHtcbiAgICBjb25zdCBpc1JhdyA9IHRoaXMuZm9ybWF0dGVyLnJhd09yRm4oZGF0YSk7XG4gICAgaWYgKGlzUmF3KSByZXR1cm4gaXNSYXc7XG4gICAgbGV0IGNvbHVtbnMgPSBbXTtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIGRhdGEgPSBkYXRhID8gW2RhdGFdIDogW107XG4gICAgbGV0IGkgPSAtMVxuICAgIHdoaWxlICgrK2kgPCBkYXRhLmxlbmd0aCkge1xuICAgICAgaWYgKGRhdGFbaV0gPT0gbnVsbCkgYnJlYWs7XG4gICAgICBpZiAoaSA9PT0gMCkgY29sdW1ucyA9IE9iamVjdC5rZXlzKGRhdGFbaV0pLnNvcnQoKVxuICAgICAgY29uc3Qgcm93ID0gbmV3IEFycmF5KGNvbHVtbnMubGVuZ3RoKVxuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGFbaV0pXG4gICAgICBsZXQgaiA9IC0xXG4gICAgICB3aGlsZSAoKytqIDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgbGV0IGlkeCA9IGNvbHVtbnMuaW5kZXhPZihrZXkpO1xuICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgIGNvbHVtbnMgPSBjb2x1bW5zLmNvbmNhdChrZXkpLnNvcnQoKVxuICAgICAgICAgIGlkeCA9IGNvbHVtbnMuaW5kZXhPZihrZXkpXG4gICAgICAgICAgbGV0IGsgPSAtMVxuICAgICAgICAgIHdoaWxlICgrK2sgPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWx1ZXNba10uc3BsaWNlKGlkeCwgMCwgdW5kZWZpbmVkKVxuICAgICAgICAgIH1cbiAgICAgICAgICByb3cuc3BsaWNlKGlkeCwgMCwgdW5kZWZpbmVkKVxuICAgICAgICB9XG4gICAgICAgIHJvd1tpZHhdID0gZGF0YVtpXVtrZXldXG4gICAgICB9XG4gICAgICB2YWx1ZXMucHVzaChyb3cpXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5zLFxuICAgICAgdmFsdWVzXG4gICAgfTtcbiAgfSxcblxuICAvLyBcIlByZXBzXCIgdGhlIHVwZGF0ZS5cbiAgX3ByZXBVcGRhdGUoZGF0YSkge1xuICAgIGRhdGEgPSBvbWl0QnkoZGF0YSwgaXNVbmRlZmluZWQpXG4gICAgY29uc3QgdmFscyA9IFtdXG4gICAgY29uc3Qgc29ydGVkID0gT2JqZWN0LmtleXMoZGF0YSkuc29ydCgpXG4gICAgbGV0IGkgPSAtMVxuICAgIHdoaWxlICgrK2kgPCBzb3J0ZWQubGVuZ3RoKSB7XG4gICAgICB2YWxzLnB1c2goXG4gICAgICAgIHRoaXMuZm9ybWF0dGVyLndyYXAoc29ydGVkW2ldKSArXG4gICAgICAgICcgPSAnICtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZXIucGFyYW1ldGVyKGRhdGFbc29ydGVkW2ldXSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB2YWxzO1xuICB9LFxuXG4gIC8vIENvbXBpbGVzIHRoZSBgb3JkZXIgYnlgIHN0YXRlbWVudHMuXG4gIF9ncm91cHNPcmRlcnModHlwZSkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5ncm91cGVkW3R5cGVdO1xuICAgIGlmICghaXRlbXMpIHJldHVybiAnJztcbiAgICBjb25zdCB7IGZvcm1hdHRlciB9ID0gdGhpcztcbiAgICBjb25zdCBzcWwgPSBpdGVtcy5tYXAoaXRlbSA9PiB7XG4gICAgICBjb25zdCBjb2x1bW4gPSBpdGVtLnZhbHVlIGluc3RhbmNlb2YgUmF3XG4gICAgICAgID8gZm9ybWF0dGVyLnVud3JhcFJhdyhpdGVtLnZhbHVlKVxuICAgICAgICA6IGZvcm1hdHRlci5jb2x1bW5pemUoaXRlbS52YWx1ZSk7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSB0eXBlID09PSAnb3JkZXInICYmIGl0ZW0udHlwZSAhPT0gJ29yZGVyQnlSYXcnXG4gICAgICAgID8gYCAke2Zvcm1hdHRlci5kaXJlY3Rpb24oaXRlbS5kaXJlY3Rpb24pfWBcbiAgICAgICAgOiAnJztcbiAgICAgIHJldHVybiBjb2x1bW4gKyBkaXJlY3Rpb247XG4gICAgfSk7XG4gICAgcmV0dXJuIHNxbC5sZW5ndGggPyB0eXBlICsgJyBieSAnICsgc3FsLmpvaW4oJywgJykgOiAnJztcbiAgfVxuXG59KVxuXG5RdWVyeUNvbXBpbGVyLnByb3RvdHlwZS5maXJzdCA9IFF1ZXJ5Q29tcGlsZXIucHJvdG90eXBlLnNlbGVjdDtcblxuLy8gR2V0IHRoZSB0YWJsZSBuYW1lLCB3cmFwcGluZyBpdCBpZiBuZWNlc3NhcnkuXG4vLyBJbXBsZW1lbnRlZCBhcyBhIHByb3BlcnR5IHRvIHByZXZlbnQgb3JkZXJpbmcgaXNzdWVzIGFzIGRlc2NyaWJlZCBpbiAjNzA0LlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5Q29tcGlsZXIucHJvdG90eXBlLCAndGFibGVOYW1lJywge1xuICBnZXQoKSB7XG4gICAgaWYoIXRoaXMuX3RhYmxlTmFtZSkge1xuICAgICAgLy8gT25seSBjYWxsIHRoaXMuZm9ybWF0dGVyLndyYXAoKSB0aGUgZmlyc3QgdGltZSB0aGlzIHByb3BlcnR5IGlzIGFjY2Vzc2VkLlxuICAgICAgbGV0IHRhYmxlTmFtZSA9IHRoaXMuc2luZ2xlLnRhYmxlO1xuICAgICAgY29uc3Qgc2NoZW1hTmFtZSA9IHRoaXMuc2luZ2xlLnNjaGVtYTtcblxuICAgICAgaWYgKHRhYmxlTmFtZSAmJiBzY2hlbWFOYW1lKSB0YWJsZU5hbWUgPSBgJHtzY2hlbWFOYW1lfS4ke3RhYmxlTmFtZX1gO1xuXG4gICAgICB0aGlzLl90YWJsZU5hbWUgPSB0YWJsZU5hbWUgPyB0aGlzLmZvcm1hdHRlci53cmFwKHRhYmxlTmFtZSkgOiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RhYmxlTmFtZTtcbiAgfVxufSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgUXVlcnlDb21waWxlcjtcbiJdfQ==

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _events = __webpack_require__(18);

	var _lodash = __webpack_require__(5);

	// Constructor for the builder instance, typically called from
	// `knex.builder`, accepting the current `knex` instance,
	// and pulling out the `client` and `grammar` from the current
	// knex instance.
	function SchemaBuilder(client) {
	  this.client = client;
	  this._sequence = [];
	  this._debug = client.config && client.config.debug;
	}
	_inherits2['default'](SchemaBuilder, _events.EventEmitter);

	// Each of the schema builder methods just add to the
	// "_sequence" array for consistency.
	_lodash.each(['createTable', 'createTableIfNotExists', 'createSchema', 'createSchemaIfNotExists', 'dropSchema', 'dropSchemaIfExists', 'createExtension', 'createExtensionIfNotExists', 'dropExtension', 'dropExtensionIfExists', 'table', 'alterTable', 'hasTable', 'hasColumn', 'dropTable', 'renameTable', 'dropTableIfExists', 'raw'], function (method) {
	  SchemaBuilder.prototype[method] = function () {
	    if (method === 'table') method = 'alterTable';
	    this._sequence.push({
	      method: method,
	      args: _lodash.toArray(arguments)
	    });
	    return this;
	  };
	});

	__webpack_require__(41)(SchemaBuilder);

	SchemaBuilder.prototype.withSchema = function (schemaName) {
	  this._schema = schemaName;
	  return this;
	};

	SchemaBuilder.prototype.toString = function () {
	  return this.toQuery();
	};

	SchemaBuilder.prototype.toSQL = function () {
	  return this.client.schemaCompiler(this).toSQL();
	};

	exports['default'] = SchemaBuilder;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWEvYnVpbGRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7d0JBQ3FCLFVBQVU7Ozs7c0JBQ0YsUUFBUTs7c0JBQ1AsUUFBUTs7Ozs7O0FBTXRDLFNBQVMsYUFBYSxDQUFDLE1BQU0sRUFBRTtBQUM3QixNQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQTtBQUNwQixNQUFJLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQTtBQUNuQixNQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUE7Q0FDbkQ7QUFDRCxzQkFBUyxhQUFhLHVCQUFlLENBQUE7Ozs7QUFJckMsYUFBSyxDQUNILGFBQWEsRUFDYix3QkFBd0IsRUFDeEIsY0FBYyxFQUNkLHlCQUF5QixFQUN6QixZQUFZLEVBQ1osb0JBQW9CLEVBQ3BCLGlCQUFpQixFQUNqQiw0QkFBNEIsRUFDNUIsZUFBZSxFQUNmLHVCQUF1QixFQUN2QixPQUFPLEVBQ1AsWUFBWSxFQUNaLFVBQVUsRUFDVixXQUFXLEVBQ1gsV0FBVyxFQUNYLGFBQWEsRUFDYixtQkFBbUIsRUFDbkIsS0FBSyxDQUNOLEVBQUUsVUFBUyxNQUFNLEVBQUU7QUFDbEIsZUFBYSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsR0FBRyxZQUFXO0FBQzNDLFFBQUksTUFBTSxLQUFLLE9BQU8sRUFBRSxNQUFNLEdBQUcsWUFBWSxDQUFDO0FBQzlDLFFBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDO0FBQ2xCLFlBQU0sRUFBTixNQUFNO0FBQ04sVUFBSSxFQUFFLGdCQUFRLFNBQVMsQ0FBQztLQUN6QixDQUFDLENBQUM7QUFDSCxXQUFPLElBQUksQ0FBQztHQUNiLENBQUE7Q0FDRixDQUFDLENBQUE7O0FBRUYsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFBOztBQUV0QyxhQUFhLENBQUMsU0FBUyxDQUFDLFVBQVUsR0FBRyxVQUFTLFVBQVUsRUFBRTtBQUN4RCxNQUFJLENBQUMsT0FBTyxHQUFHLFVBQVUsQ0FBQztBQUMxQixTQUFPLElBQUksQ0FBQztDQUNiLENBQUE7O0FBRUQsYUFBYSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsWUFBVztBQUM1QyxTQUFPLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQTtDQUN0QixDQUFBOztBQUVELGFBQWEsQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLFlBQVc7QUFDekMsU0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQTtDQUNoRCxDQUFBOztxQkFFYyxhQUFhIiwiZmlsZSI6ImJ1aWxkZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgZWFjaCwgdG9BcnJheSB9IGZyb20gJ2xvZGFzaCdcblxuLy8gQ29uc3RydWN0b3IgZm9yIHRoZSBidWlsZGVyIGluc3RhbmNlLCB0eXBpY2FsbHkgY2FsbGVkIGZyb21cbi8vIGBrbmV4LmJ1aWxkZXJgLCBhY2NlcHRpbmcgdGhlIGN1cnJlbnQgYGtuZXhgIGluc3RhbmNlLFxuLy8gYW5kIHB1bGxpbmcgb3V0IHRoZSBgY2xpZW50YCBhbmQgYGdyYW1tYXJgIGZyb20gdGhlIGN1cnJlbnRcbi8vIGtuZXggaW5zdGFuY2UuXG5mdW5jdGlvbiBTY2hlbWFCdWlsZGVyKGNsaWVudCkge1xuICB0aGlzLmNsaWVudCA9IGNsaWVudFxuICB0aGlzLl9zZXF1ZW5jZSA9IFtdXG4gIHRoaXMuX2RlYnVnID0gY2xpZW50LmNvbmZpZyAmJiBjbGllbnQuY29uZmlnLmRlYnVnXG59XG5pbmhlcml0cyhTY2hlbWFCdWlsZGVyLCBFdmVudEVtaXR0ZXIpXG5cbi8vIEVhY2ggb2YgdGhlIHNjaGVtYSBidWlsZGVyIG1ldGhvZHMganVzdCBhZGQgdG8gdGhlXG4vLyBcIl9zZXF1ZW5jZVwiIGFycmF5IGZvciBjb25zaXN0ZW5jeS5cbmVhY2goW1xuICAnY3JlYXRlVGFibGUnLFxuICAnY3JlYXRlVGFibGVJZk5vdEV4aXN0cycsXG4gICdjcmVhdGVTY2hlbWEnLFxuICAnY3JlYXRlU2NoZW1hSWZOb3RFeGlzdHMnLFxuICAnZHJvcFNjaGVtYScsXG4gICdkcm9wU2NoZW1hSWZFeGlzdHMnLFxuICAnY3JlYXRlRXh0ZW5zaW9uJyxcbiAgJ2NyZWF0ZUV4dGVuc2lvbklmTm90RXhpc3RzJyxcbiAgJ2Ryb3BFeHRlbnNpb24nLFxuICAnZHJvcEV4dGVuc2lvbklmRXhpc3RzJyxcbiAgJ3RhYmxlJyxcbiAgJ2FsdGVyVGFibGUnLFxuICAnaGFzVGFibGUnLFxuICAnaGFzQ29sdW1uJyxcbiAgJ2Ryb3BUYWJsZScsXG4gICdyZW5hbWVUYWJsZScsXG4gICdkcm9wVGFibGVJZkV4aXN0cycsXG4gICdyYXcnXG5dLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgU2NoZW1hQnVpbGRlci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChtZXRob2QgPT09ICd0YWJsZScpIG1ldGhvZCA9ICdhbHRlclRhYmxlJztcbiAgICB0aGlzLl9zZXF1ZW5jZS5wdXNoKHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIGFyZ3M6IHRvQXJyYXkoYXJndW1lbnRzKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59KVxuXG5yZXF1aXJlKCcuLi9pbnRlcmZhY2UnKShTY2hlbWFCdWlsZGVyKVxuXG5TY2hlbWFCdWlsZGVyLnByb3RvdHlwZS53aXRoU2NoZW1hID0gZnVuY3Rpb24oc2NoZW1hTmFtZSkge1xuICB0aGlzLl9zY2hlbWEgPSBzY2hlbWFOYW1lO1xuICByZXR1cm4gdGhpcztcbn1cblxuU2NoZW1hQnVpbGRlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9RdWVyeSgpXG59XG5cblNjaGVtYUJ1aWxkZXIucHJvdG90eXBlLnRvU1FMID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNsaWVudC5zY2hlbWFDb21waWxlcih0aGlzKS50b1NRTCgpXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNjaGVtYUJ1aWxkZXJcbiJdfQ==

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _helpers = __webpack_require__(78);

	var _lodash = __webpack_require__(5);

	// The "SchemaCompiler" takes all of the query statements which have been
	// gathered in the "SchemaBuilder" and turns them into an array of
	// properly formatted / bound query strings.
	function SchemaCompiler(client, builder) {
	  this.builder = builder;
	  this.client = client;
	  this.schema = builder._schema;
	  this.formatter = client.formatter();
	  this.sequence = [];
	}

	_lodash.assign(SchemaCompiler.prototype, {

	  pushQuery: _helpers.pushQuery,

	  pushAdditional: _helpers.pushAdditional,

	  createTable: buildTable('create'),

	  createTableIfNotExists: buildTable('createIfNot'),

	  alterTable: buildTable('alter'),

	  dropTablePrefix: 'drop table ',

	  dropTable: function dropTable(tableName) {
	    this.pushQuery(this.dropTablePrefix + this.formatter.wrap(prefixedTableName(this.schema, tableName)));
	  },

	  dropTableIfExists: function dropTableIfExists(tableName) {
	    this.pushQuery(this.dropTablePrefix + 'if exists ' + this.formatter.wrap(prefixedTableName(this.schema, tableName)));
	  },

	  raw: function raw(sql, bindings) {
	    this.sequence.push(this.client.raw(sql, bindings).toSQL());
	  },

	  toSQL: function toSQL() {
	    var sequence = this.builder._sequence;
	    for (var i = 0, l = sequence.length; i < l; i++) {
	      var query = sequence[i];
	      this[query.method].apply(this, query.args);
	    }
	    return this.sequence;
	  }

	});

	function buildTable(type) {
	  return function (tableName, fn) {
	    var builder = this.client.tableBuilder(type, tableName, fn);

	    builder.setSchema(this.schema);
	    var sql = builder.toSQL();

	    for (var i = 0, l = sql.length; i < l; i++) {
	      this.sequence.push(sql[i]);
	    }
	  };
	}

	function prefixedTableName(prefix, table) {
	  return prefix ? prefix + '.' + table : table;
	}

	exports['default'] = SchemaCompiler;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWEvY29tcGlsZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozt1QkFDMEMsV0FBVzs7c0JBRTlCLFFBQVE7Ozs7O0FBSy9CLFNBQVMsY0FBYyxDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUU7QUFDdkMsTUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUE7QUFDdEIsTUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUE7QUFDcEIsTUFBSSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDO0FBQzlCLE1BQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFBO0FBQ25DLE1BQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFBO0NBQ25COztBQUVELGVBQU8sY0FBYyxDQUFDLFNBQVMsRUFBRTs7QUFFL0IsV0FBUyxvQkFBVzs7QUFFcEIsZ0JBQWMseUJBQWdCOztBQUU5QixhQUFXLEVBQUUsVUFBVSxDQUFDLFFBQVEsQ0FBQzs7QUFFakMsd0JBQXNCLEVBQUUsVUFBVSxDQUFDLGFBQWEsQ0FBQzs7QUFFakQsWUFBVSxFQUFFLFVBQVUsQ0FBQyxPQUFPLENBQUM7O0FBRS9CLGlCQUFlLEVBQUUsYUFBYTs7QUFFOUIsV0FBUyxFQUFBLG1CQUFDLFNBQVMsRUFBRTtBQUNuQixRQUFJLENBQUMsU0FBUyxDQUNaLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUN0RixDQUFDO0dBQ0g7O0FBRUQsbUJBQWlCLEVBQUEsMkJBQUMsU0FBUyxFQUFFO0FBQzNCLFFBQUksQ0FBQyxTQUFTLENBQ1osSUFBSSxDQUFDLGVBQWUsR0FBRyxZQUFZLEdBQ25DLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FDL0QsQ0FBQztHQUNIOztBQUVELEtBQUcsRUFBQSxhQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUU7QUFDakIsUUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7R0FDNUQ7O0FBRUQsT0FBSyxFQUFBLGlCQUFHO0FBQ04sUUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUM7QUFDeEMsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMvQyxVQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDMUIsVUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUM1QztBQUNELFdBQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztHQUN0Qjs7Q0FFRixDQUFDLENBQUE7O0FBRUYsU0FBUyxVQUFVLENBQUMsSUFBSSxFQUFFO0FBQ3hCLFNBQU8sVUFBUyxTQUFTLEVBQUUsRUFBRSxFQUFFO0FBQzdCLFFBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsRUFBRSxDQUFDLENBQUM7O0FBRTlELFdBQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQy9CLFFBQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQzs7QUFFNUIsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUMxQyxVQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUM1QjtHQUNGLENBQUM7Q0FDSDs7QUFFRCxTQUFTLGlCQUFpQixDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUU7QUFDeEMsU0FBTyxNQUFNLEdBQU0sTUFBTSxTQUFJLEtBQUssR0FBSyxLQUFLLENBQUM7Q0FDOUM7O3FCQUVjLGNBQWMiLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IHB1c2hRdWVyeSwgcHVzaEFkZGl0aW9uYWwgfSBmcm9tICcuL2hlbHBlcnMnO1xuXG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICdsb2Rhc2gnXG5cbi8vIFRoZSBcIlNjaGVtYUNvbXBpbGVyXCIgdGFrZXMgYWxsIG9mIHRoZSBxdWVyeSBzdGF0ZW1lbnRzIHdoaWNoIGhhdmUgYmVlblxuLy8gZ2F0aGVyZWQgaW4gdGhlIFwiU2NoZW1hQnVpbGRlclwiIGFuZCB0dXJucyB0aGVtIGludG8gYW4gYXJyYXkgb2Zcbi8vIHByb3Blcmx5IGZvcm1hdHRlZCAvIGJvdW5kIHF1ZXJ5IHN0cmluZ3MuXG5mdW5jdGlvbiBTY2hlbWFDb21waWxlcihjbGllbnQsIGJ1aWxkZXIpIHtcbiAgdGhpcy5idWlsZGVyID0gYnVpbGRlclxuICB0aGlzLmNsaWVudCA9IGNsaWVudFxuICB0aGlzLnNjaGVtYSA9IGJ1aWxkZXIuX3NjaGVtYTtcbiAgdGhpcy5mb3JtYXR0ZXIgPSBjbGllbnQuZm9ybWF0dGVyKClcbiAgdGhpcy5zZXF1ZW5jZSA9IFtdXG59XG5cbmFzc2lnbihTY2hlbWFDb21waWxlci5wcm90b3R5cGUsIHtcblxuICBwdXNoUXVlcnk6IHB1c2hRdWVyeSxcblxuICBwdXNoQWRkaXRpb25hbDogcHVzaEFkZGl0aW9uYWwsXG5cbiAgY3JlYXRlVGFibGU6IGJ1aWxkVGFibGUoJ2NyZWF0ZScpLFxuXG4gIGNyZWF0ZVRhYmxlSWZOb3RFeGlzdHM6IGJ1aWxkVGFibGUoJ2NyZWF0ZUlmTm90JyksXG5cbiAgYWx0ZXJUYWJsZTogYnVpbGRUYWJsZSgnYWx0ZXInKSxcblxuICBkcm9wVGFibGVQcmVmaXg6ICdkcm9wIHRhYmxlICcsXG5cbiAgZHJvcFRhYmxlKHRhYmxlTmFtZSkge1xuICAgIHRoaXMucHVzaFF1ZXJ5KFxuICAgICAgdGhpcy5kcm9wVGFibGVQcmVmaXggKyB0aGlzLmZvcm1hdHRlci53cmFwKHByZWZpeGVkVGFibGVOYW1lKHRoaXMuc2NoZW1hLCB0YWJsZU5hbWUpKVxuICAgICk7XG4gIH0sXG5cbiAgZHJvcFRhYmxlSWZFeGlzdHModGFibGVOYW1lKSB7XG4gICAgdGhpcy5wdXNoUXVlcnkoXG4gICAgICB0aGlzLmRyb3BUYWJsZVByZWZpeCArICdpZiBleGlzdHMgJyArXG4gICAgICB0aGlzLmZvcm1hdHRlci53cmFwKHByZWZpeGVkVGFibGVOYW1lKHRoaXMuc2NoZW1hLCB0YWJsZU5hbWUpKVxuICAgICk7XG4gIH0sXG5cbiAgcmF3KHNxbCwgYmluZGluZ3MpIHtcbiAgICB0aGlzLnNlcXVlbmNlLnB1c2godGhpcy5jbGllbnQucmF3KHNxbCwgYmluZGluZ3MpLnRvU1FMKCkpO1xuICB9LFxuXG4gIHRvU1FMKCkge1xuICAgIGNvbnN0IHNlcXVlbmNlID0gdGhpcy5idWlsZGVyLl9zZXF1ZW5jZTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNlcXVlbmNlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgcXVlcnkgPSBzZXF1ZW5jZVtpXTtcbiAgICAgIHRoaXNbcXVlcnkubWV0aG9kXS5hcHBseSh0aGlzLCBxdWVyeS5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVuY2U7XG4gIH1cblxufSlcblxuZnVuY3Rpb24gYnVpbGRUYWJsZSh0eXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbih0YWJsZU5hbWUsIGZuKSB7XG4gICAgY29uc3QgYnVpbGRlciA9IHRoaXMuY2xpZW50LnRhYmxlQnVpbGRlcih0eXBlLCB0YWJsZU5hbWUsIGZuKTtcblxuICAgIGJ1aWxkZXIuc2V0U2NoZW1hKHRoaXMuc2NoZW1hKTtcbiAgICBjb25zdCBzcWwgPSBidWlsZGVyLnRvU1FMKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNxbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMuc2VxdWVuY2UucHVzaChzcWxbaV0pO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJlZml4ZWRUYWJsZU5hbWUocHJlZml4LCB0YWJsZSkge1xuICByZXR1cm4gcHJlZml4ID8gYCR7cHJlZml4fS4ke3RhYmxlfWAgOiB0YWJsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2NoZW1hQ29tcGlsZXI7XG4iXX0=

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.pushQuery = pushQuery;
	exports.pushAdditional = pushAdditional;

	var _lodash = __webpack_require__(5);

	// Push a new query onto the compiled "sequence" stack,
	// creating a new formatter, returning the compiler.

	function pushQuery(query) {
	  if (!query) return;
	  if (_lodash.isString(query)) {
	    query = { sql: query };
	  }
	  if (!query.bindings) {
	    query.bindings = this.formatter.bindings;
	  }
	  this.sequence.push(query);
	  this.formatter = this.client.formatter();
	}

	// Used in cases where we need to push some additional column specific statements.

	function pushAdditional(fn) {
	  var child = new this.constructor(this.client, this.tableCompiler, this.columnBuilder);
	  fn.call(child, _lodash.tail(arguments));
	  this.sequence.additional = (this.sequence.additional || []).concat(child.sequence);
	}
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWEvaGVscGVycy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7c0JBQytCLFFBQVE7Ozs7O0FBSWhDLFNBQVMsU0FBUyxDQUFDLEtBQUssRUFBRTtBQUMvQixNQUFJLENBQUMsS0FBSyxFQUFFLE9BQU87QUFDbkIsTUFBSSxpQkFBUyxLQUFLLENBQUMsRUFBRTtBQUNuQixTQUFLLEdBQUcsRUFBQyxHQUFHLEVBQUUsS0FBSyxFQUFDLENBQUM7R0FDdEI7QUFDRCxNQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRTtBQUNuQixTQUFLLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDO0dBQzFDO0FBQ0QsTUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDMUIsTUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDO0NBQzFDOzs7O0FBR00sU0FBUyxjQUFjLENBQUMsRUFBRSxFQUFFO0FBQ2pDLE1BQU0sS0FBSyxHQUFHLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ3hGLElBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLGFBQUssU0FBUyxDQUFDLENBQUMsQ0FBQztBQUNoQyxNQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQSxDQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7Q0FDcEYiLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgaXNTdHJpbmcsIHRhaWwgfSBmcm9tICdsb2Rhc2gnXG5cbi8vIFB1c2ggYSBuZXcgcXVlcnkgb250byB0aGUgY29tcGlsZWQgXCJzZXF1ZW5jZVwiIHN0YWNrLFxuLy8gY3JlYXRpbmcgYSBuZXcgZm9ybWF0dGVyLCByZXR1cm5pbmcgdGhlIGNvbXBpbGVyLlxuZXhwb3J0IGZ1bmN0aW9uIHB1c2hRdWVyeShxdWVyeSkge1xuICBpZiAoIXF1ZXJ5KSByZXR1cm47XG4gIGlmIChpc1N0cmluZyhxdWVyeSkpIHtcbiAgICBxdWVyeSA9IHtzcWw6IHF1ZXJ5fTtcbiAgfVxuICBpZiAoIXF1ZXJ5LmJpbmRpbmdzKSB7XG4gICAgcXVlcnkuYmluZGluZ3MgPSB0aGlzLmZvcm1hdHRlci5iaW5kaW5ncztcbiAgfVxuICB0aGlzLnNlcXVlbmNlLnB1c2gocXVlcnkpO1xuICB0aGlzLmZvcm1hdHRlciA9IHRoaXMuY2xpZW50LmZvcm1hdHRlcigpO1xufVxuXG4vLyBVc2VkIGluIGNhc2VzIHdoZXJlIHdlIG5lZWQgdG8gcHVzaCBzb21lIGFkZGl0aW9uYWwgY29sdW1uIHNwZWNpZmljIHN0YXRlbWVudHMuXG5leHBvcnQgZnVuY3Rpb24gcHVzaEFkZGl0aW9uYWwoZm4pIHtcbiAgY29uc3QgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmNsaWVudCwgdGhpcy50YWJsZUNvbXBpbGVyLCB0aGlzLmNvbHVtbkJ1aWxkZXIpO1xuICBmbi5jYWxsKGNoaWxkLCB0YWlsKGFyZ3VtZW50cykpO1xuICB0aGlzLnNlcXVlbmNlLmFkZGl0aW9uYWwgPSAodGhpcy5zZXF1ZW5jZS5hZGRpdGlvbmFsIHx8IFtdKS5jb25jYXQoY2hpbGQuc2VxdWVuY2UpO1xufVxuIl19

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	
	// TableBuilder

	// Takes the function passed to the "createTable" or "table/editTable"
	// functions and calls it with the "TableBuilder" as both the context and
	// the first argument. Inside this function we can specify what happens to the
	// method, pushing everything we want to do onto the "allStatements" array,
	// which is then compiled into sql.
	// ------
	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	var _lodash = __webpack_require__(5);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	function TableBuilder(client, method, tableName, fn) {
	  this.client = client;
	  this._fn = fn;
	  this._method = method;
	  this._schemaName = undefined;
	  this._tableName = tableName;
	  this._statements = [];
	  this._single = {};

	  if (!_lodash.isFunction(this._fn)) {
	    throw new TypeError('A callback function must be supplied to calls against `.createTable` ' + 'and `.table`');
	  }
	}

	TableBuilder.prototype.setSchema = function (schemaName) {
	  this._schemaName = schemaName;
	};

	// Convert the current tableBuilder object "toSQL"
	// giving us additional methods if we're altering
	// rather than creating the table.
	TableBuilder.prototype.toSQL = function () {
	  if (this._method === 'alter') {
	    _lodash.extend(this, AlterMethods);
	  }
	  this._fn.call(this, this);
	  return this.client.tableCompiler(this).toSQL();
	};

	_lodash.each([

	// Each of the index methods can be called individually, with the
	// column name to be used, e.g. table.unique('column').
	'index', 'primary', 'unique',

	// Key specific
	'dropPrimary', 'dropUnique', 'dropIndex', 'dropForeign'], function (method) {
	  TableBuilder.prototype[method] = function () {
	    this._statements.push({
	      grouping: 'alterTable',
	      method: method,
	      args: _lodash.toArray(arguments)
	    });
	    return this;
	  };
	});

	// Warn for dialect-specific table methods, since that's the
	// only time these are supported.
	var specialMethods = {
	  mysql: ['engine', 'charset', 'collate'],
	  postgresql: ['inherits']
	};
	_lodash.each(specialMethods, function (methods, dialect) {
	  _lodash.each(methods, function (method) {
	    TableBuilder.prototype[method] = function (value) {
	      if (this.client.dialect !== dialect) {
	        helpers.warn('Knex only supports ' + method + ' statement with ' + dialect + '.');
	      }
	      if (this._method === 'alter') {
	        helpers.warn('Knex does not support altering the ' + method + ' outside of create ' + 'table, please use knex.raw statement.');
	      }
	      this._single[method] = value;
	    };
	  });
	});

	// Each of the column types that we can add, we create a new ColumnBuilder
	// instance and push it onto the statements array.
	var columnTypes = [

	// Numeric
	'tinyint', 'smallint', 'mediumint', 'int', 'bigint', 'decimal', 'float', 'double', 'real', 'bit', 'boolean', 'serial',

	// Date / Time
	'date', 'datetime', 'timestamp', 'time', 'year',

	// String
	'char', 'varchar', 'tinytext', 'tinyText', 'text', 'mediumtext', 'mediumText', 'longtext', 'longText', 'binary', 'varbinary', 'tinyblob', 'tinyBlob', 'mediumblob', 'mediumBlob', 'blob', 'longblob', 'longBlob', 'enum', 'set',

	// Increments, Aliases, and Additional
	'bool', 'dateTime', 'increments', 'bigincrements', 'bigIncrements', 'integer', 'biginteger', 'bigInteger', 'string', 'timestamps', 'json', 'jsonb', 'uuid', 'enu', 'specificType'];

	// For each of the column methods, create a new "ColumnBuilder" interface,
	// push it onto the "allStatements" stack, and then return the interface,
	// with which we can add indexes, etc.
	_lodash.each(columnTypes, function (type) {
	  TableBuilder.prototype[type] = function () {
	    var args = _lodash.toArray(arguments);

	    // The "timestamps" call is really a compound call to set the
	    // `created_at` and `updated_at` columns.
	    if (type === 'timestamps') {
	      var col = args[0] === true ? 'timestamp' : 'datetime';
	      var createdAt = this[col]('created_at');
	      var updatedAt = this[col]('updated_at');
	      if (args[1] === true) {
	        var now = this.client.raw('CURRENT_TIMESTAMP');
	        createdAt.notNullable().defaultTo(now);
	        updatedAt.notNullable().defaultTo(now);
	      }
	      return;
	    }
	    var builder = this.client.columnBuilder(this, type, args);

	    this._statements.push({
	      grouping: 'columns',
	      builder: builder
	    });
	    return builder;
	  };
	});

	// Set the comment value for a table, they're only allowed to be called
	// once per table.
	TableBuilder.prototype.comment = function (value) {
	  this._single.comment = value;
	};

	// Set a foreign key on the table, calling
	// `table.foreign('column_name').references('column').on('table').onDelete()...
	// Also called from the ColumnBuilder context when chaining.
	TableBuilder.prototype.foreign = function (column) {
	  var foreignData = { column: column };
	  this._statements.push({
	    grouping: 'alterTable',
	    method: 'foreign',
	    args: [foreignData]
	  });
	  var returnObj = {
	    references: function references(tableColumn) {
	      var pieces = undefined;
	      if (_lodash.isString(tableColumn)) {
	        pieces = tableColumn.split('.');
	      }
	      if (!pieces || pieces.length === 1) {
	        foreignData.references = pieces ? pieces[0] : tableColumn;
	        return {
	          on: function on(tableName) {
	            if (typeof tableName !== 'string') {
	              throw new TypeError('Expected tableName to be a string, got: ' + typeof tableName);
	            }
	            foreignData.inTable = tableName;
	            return returnObj;
	          },
	          inTable: function inTable() {
	            return this.on.apply(this, arguments);
	          }
	        };
	      }
	      foreignData.inTable = pieces[0];
	      foreignData.references = pieces[1];
	      return returnObj;
	    },
	    onUpdate: function onUpdate(statement) {
	      foreignData.onUpdate = statement;
	      return returnObj;
	    },
	    onDelete: function onDelete(statement) {
	      foreignData.onDelete = statement;
	      return returnObj;
	    },
	    _columnBuilder: function _columnBuilder(builder) {
	      _lodash.extend(builder, returnObj);
	      returnObj = builder;
	      return builder;
	    }
	  };
	  return returnObj;
	};

	var AlterMethods = {

	  // Renames the current column `from` the current
	  // TODO: this.column(from).rename(to)
	  renameColumn: function renameColumn(from, to) {
	    this._statements.push({
	      grouping: 'alterTable',
	      method: 'renameColumn',
	      args: [from, to]
	    });
	    return this;
	  },

	  dropTimestamps: function dropTimestamps() {
	    return this.dropColumns(['created_at', 'updated_at']);
	  }

	  // TODO: changeType
	};

	// Drop a column from the current table.
	// TODO: Enable this.column(columnName).drop();
	AlterMethods.dropColumn = AlterMethods.dropColumns = function () {
	  this._statements.push({
	    grouping: 'alterTable',
	    method: 'dropColumn',
	    args: _lodash.toArray(arguments)
	  });
	  return this;
	};

	exports['default'] = TableBuilder;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWEvdGFibGVidWlsZGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztzQkFTNEQsUUFBUTs7dUJBQzNDLFlBQVk7O0lBQXpCLE9BQU87O0FBRW5CLFNBQVMsWUFBWSxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLEVBQUUsRUFBRTtBQUNuRCxNQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQTtBQUNwQixNQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNkLE1BQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO0FBQ3RCLE1BQUksQ0FBQyxXQUFXLEdBQUcsU0FBUyxDQUFDO0FBQzdCLE1BQUksQ0FBQyxVQUFVLEdBQUcsU0FBUyxDQUFDO0FBQzVCLE1BQUksQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDO0FBQ3RCLE1BQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDOztBQUVsQixNQUFHLENBQUMsbUJBQVcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQ3hCLFVBQU0sSUFBSSxTQUFTLENBQ2pCLHVFQUF1RSxHQUN2RSxjQUFjLENBQ2YsQ0FBQztHQUNIO0NBQ0Y7O0FBRUQsWUFBWSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsVUFBUyxVQUFVLEVBQUU7QUFDdEQsTUFBSSxDQUFDLFdBQVcsR0FBRyxVQUFVLENBQUM7Q0FDL0IsQ0FBQzs7Ozs7QUFLRixZQUFZLENBQUMsU0FBUyxDQUFDLEtBQUssR0FBRyxZQUFXO0FBQ3hDLE1BQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxPQUFPLEVBQUU7QUFDNUIsbUJBQU8sSUFBSSxFQUFFLFlBQVksQ0FBQyxDQUFDO0dBQzVCO0FBQ0QsTUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQzFCLFNBQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENB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QUFFO0FBQ3RCLHFCQUFPLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQztBQUMzQixlQUFTLEdBQUcsT0FBTyxDQUFDO0FBQ3BCLGFBQU8sT0FBTyxDQUFDO0tBQ2hCO0dBQ0YsQ0FBQztBQUNGLFNBQU8sU0FBUyxDQUFDO0NBQ2xCLENBQUE7O0FBRUQsSUFBTSxZQUFZLEdBQUc7Ozs7QUFJbkIsY0FBWSxFQUFBLHNCQUFDLElBQUksRUFBRSxFQUFFLEVBQUU7QUFDckIsUUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7QUFDcEIsY0FBUSxFQUFFLFlBQVk7QUFDdEIsWUFBTSxFQUFFLGNBQWM7QUFDdEIsVUFBSSxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQztLQUNqQixDQUFDLENBQUM7QUFDSCxXQUFPLElBQUksQ0FBQztHQUNiOztBQUVELGdCQUFjLEVBQUEsMEJBQUc7QUFDZixXQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxZQUFZLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQztHQUN2RDs7O0NBR0YsQ0FBQzs7OztBQUlGLFlBQVksQ0FBQyxVQUFVLEdBQ3ZCLFlBQVksQ0FBQyxXQUFXLEdBQUcsWUFBVztBQUNwQyxNQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztBQUNwQixZQUFRLEVBQUUsWUFBWTtBQUN0QixVQUFNLEVBQUUsWUFBWTtBQUNwQixRQUFJLEVBQUUsZ0JBQVEsU0FBUyxDQUFDO0dBQ3pCLENBQUMsQ0FBQztBQUNILFNBQU8sSUFBSSxDQUFDO0NBQ2IsQ0FBQzs7cUJBR2EsWUFBWSIsImZpbGUiOiJ0YWJsZWJ1aWxkZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8vIFRhYmxlQnVpbGRlclxuXG4vLyBUYWtlcyB0aGUgZnVuY3Rpb24gcGFzc2VkIHRvIHRoZSBcImNyZWF0ZVRhYmxlXCIgb3IgXCJ0YWJsZS9lZGl0VGFibGVcIlxuLy8gZnVuY3Rpb25zIGFuZCBjYWxscyBpdCB3aXRoIHRoZSBcIlRhYmxlQnVpbGRlclwiIGFzIGJvdGggdGhlIGNvbnRleHQgYW5kXG4vLyB0aGUgZmlyc3QgYXJndW1lbnQuIEluc2lkZSB0aGlzIGZ1bmN0aW9uIHdlIGNhbiBzcGVjaWZ5IHdoYXQgaGFwcGVucyB0byB0aGVcbi8vIG1ldGhvZCwgcHVzaGluZyBldmVyeXRoaW5nIHdlIHdhbnQgdG8gZG8gb250byB0aGUgXCJhbGxTdGF0ZW1lbnRzXCIgYXJyYXksXG4vLyB3aGljaCBpcyB0aGVuIGNvbXBpbGVkIGludG8gc3FsLlxuLy8gLS0tLS0tXG5pbXBvcnQgeyBleHRlbmQsIGVhY2gsIHRvQXJyYXksIGlzU3RyaW5nLCBpc0Z1bmN0aW9uIH0gZnJvbSAnbG9kYXNoJ1xuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuLi9oZWxwZXJzJztcblxuZnVuY3Rpb24gVGFibGVCdWlsZGVyKGNsaWVudCwgbWV0aG9kLCB0YWJsZU5hbWUsIGZuKSB7XG4gIHRoaXMuY2xpZW50ID0gY2xpZW50XG4gIHRoaXMuX2ZuID0gZm47XG4gIHRoaXMuX21ldGhvZCA9IG1ldGhvZDtcbiAgdGhpcy5fc2NoZW1hTmFtZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fdGFibGVOYW1lID0gdGFibGVOYW1lO1xuICB0aGlzLl9zdGF0ZW1lbnRzID0gW107XG4gIHRoaXMuX3NpbmdsZSA9IHt9O1xuXG4gIGlmKCFpc0Z1bmN0aW9uKHRoaXMuX2ZuKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnQSBjYWxsYmFjayBmdW5jdGlvbiBtdXN0IGJlIHN1cHBsaWVkIHRvIGNhbGxzIGFnYWluc3QgYC5jcmVhdGVUYWJsZWAgJyArXG4gICAgICAnYW5kIGAudGFibGVgJ1xuICAgICk7XG4gIH1cbn1cblxuVGFibGVCdWlsZGVyLnByb3RvdHlwZS5zZXRTY2hlbWEgPSBmdW5jdGlvbihzY2hlbWFOYW1lKSB7XG4gIHRoaXMuX3NjaGVtYU5hbWUgPSBzY2hlbWFOYW1lO1xufTtcblxuLy8gQ29udmVydCB0aGUgY3VycmVudCB0YWJsZUJ1aWxkZXIgb2JqZWN0IFwidG9TUUxcIlxuLy8gZ2l2aW5nIHVzIGFkZGl0aW9uYWwgbWV0aG9kcyBpZiB3ZSdyZSBhbHRlcmluZ1xuLy8gcmF0aGVyIHRoYW4gY3JlYXRpbmcgdGhlIHRhYmxlLlxuVGFibGVCdWlsZGVyLnByb3RvdHlwZS50b1NRTCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fbWV0aG9kID09PSAnYWx0ZXInKSB7XG4gICAgZXh0ZW5kKHRoaXMsIEFsdGVyTWV0aG9kcyk7XG4gIH1cbiAgdGhpcy5fZm4uY2FsbCh0aGlzLCB0aGlzKTtcbiAgcmV0dXJuIHRoaXMuY2xpZW50LnRhYmxlQ29tcGlsZXIodGhpcykudG9TUUwoKTtcbn07XG5cbmVhY2goW1xuXG4gIC8vIEVhY2ggb2YgdGhlIGluZGV4IG1ldGhvZHMgY2FuIGJlIGNhbGxlZCBpbmRpdmlkdWFsbHksIHdpdGggdGhlXG4gIC8vIGNvbHVtbiBuYW1lIHRvIGJlIHVzZWQsIGUuZy4gdGFibGUudW5pcXVlKCdjb2x1bW4nKS5cbiAgJ2luZGV4JywgJ3ByaW1hcnknLCAndW5pcXVlJyxcblxuICAvLyBLZXkgc3BlY2lmaWNcbiAgJ2Ryb3BQcmltYXJ5JywgJ2Ryb3BVbmlxdWUnLCAnZHJvcEluZGV4JywgJ2Ryb3BGb3JlaWduJ1xuXG5dLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgVGFibGVCdWlsZGVyLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fc3RhdGVtZW50cy5wdXNoKHtcbiAgICAgIGdyb3VwaW5nOiAnYWx0ZXJUYWJsZScsXG4gICAgICBtZXRob2QsXG4gICAgICBhcmdzOiB0b0FycmF5KGFyZ3VtZW50cylcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pO1xuXG4vLyBXYXJuIGZvciBkaWFsZWN0LXNwZWNpZmljIHRhYmxlIG1ldGhvZHMsIHNpbmNlIHRoYXQncyB0aGVcbi8vIG9ubHkgdGltZSB0aGVzZSBhcmUgc3VwcG9ydGVkLlxuY29uc3Qgc3BlY2lhbE1ldGhvZHMgPSB7XG4gIG15c3FsOiBbJ2VuZ2luZScsICdjaGFyc2V0JywgJ2NvbGxhdGUnXSxcbiAgcG9zdGdyZXNxbDogWydpbmhlcml0cyddXG59O1xuZWFjaChzcGVjaWFsTWV0aG9kcywgZnVuY3Rpb24obWV0aG9kcywgZGlhbGVjdCkge1xuICBlYWNoKG1ldGhvZHMsIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIFRhYmxlQnVpbGRlci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5jbGllbnQuZGlhbGVjdCAhPT0gZGlhbGVjdCkge1xuICAgICAgICBoZWxwZXJzLndhcm4oYEtuZXggb25seSBzdXBwb3J0cyAke21ldGhvZH0gc3RhdGVtZW50IHdpdGggJHtkaWFsZWN0fS5gKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9tZXRob2QgPT09ICdhbHRlcicpIHtcbiAgICAgICAgaGVscGVycy53YXJuKFxuICAgICAgICAgIGBLbmV4IGRvZXMgbm90IHN1cHBvcnQgYWx0ZXJpbmcgdGhlICR7bWV0aG9kfSBvdXRzaWRlIG9mIGNyZWF0ZSBgICtcbiAgICAgICAgICBgdGFibGUsIHBsZWFzZSB1c2Uga25leC5yYXcgc3RhdGVtZW50LmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NpbmdsZVttZXRob2RdID0gdmFsdWU7XG4gICAgfTtcbiAgfSk7XG59KTtcblxuLy8gRWFjaCBvZiB0aGUgY29sdW1uIHR5cGVzIHRoYXQgd2UgY2FuIGFkZCwgd2UgY3JlYXRlIGEgbmV3IENvbHVtbkJ1aWxkZXJcbi8vIGluc3RhbmNlIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YXRlbWVudHMgYXJyYXkuXG5jb25zdCBjb2x1bW5UeXBlcyA9IFtcblxuICAvLyBOdW1lcmljXG4gICd0aW55aW50JyxcbiAgJ3NtYWxsaW50JyxcbiAgJ21lZGl1bWludCcsXG4gICdpbnQnLFxuICAnYmlnaW50JyxcbiAgJ2RlY2ltYWwnLFxuICAnZmxvYXQnLFxuICAnZG91YmxlJyxcbiAgJ3JlYWwnLFxuICAnYml0JyxcbiAgJ2Jvb2xlYW4nLFxuICAnc2VyaWFsJyxcblxuICAvLyBEYXRlIC8gVGltZVxuICAnZGF0ZScsXG4gICdkYXRldGltZScsXG4gICd0aW1lc3RhbXAnLFxuICAndGltZScsXG4gICd5ZWFyJyxcblxuICAvLyBTdHJpbmdcbiAgJ2NoYXInLFxuICAndmFyY2hhcicsXG4gICd0aW55dGV4dCcsXG4gICd0aW55VGV4dCcsXG4gICd0ZXh0JyxcbiAgJ21lZGl1bXRleHQnLFxuICAnbWVkaXVtVGV4dCcsXG4gICdsb25ndGV4dCcsXG4gICdsb25nVGV4dCcsXG4gICdiaW5hcnknLFxuICAndmFyYmluYXJ5JyxcbiAgJ3RpbnlibG9iJyxcbiAgJ3RpbnlCbG9iJyxcbiAgJ21lZGl1bWJsb2InLFxuICAnbWVkaXVtQmxvYicsXG4gICdibG9iJyxcbiAgJ2xvbmdibG9iJyxcbiAgJ2xvbmdCbG9iJyxcbiAgJ2VudW0nLFxuICAnc2V0JyxcblxuICAvLyBJbmNyZW1lbnRzLCBBbGlhc2VzLCBhbmQgQWRkaXRpb25hbFxuICAnYm9vbCcsXG4gICdkYXRlVGltZScsXG4gICdpbmNyZW1lbnRzJyxcbiAgJ2JpZ2luY3JlbWVudHMnLFxuICAnYmlnSW5jcmVtZW50cycsXG4gICdpbnRlZ2VyJyxcbiAgJ2JpZ2ludGVnZXInLFxuICAnYmlnSW50ZWdlcicsXG4gICdzdHJpbmcnLFxuICAndGltZXN0YW1wcycsXG4gICdqc29uJyxcbiAgJ2pzb25iJyxcbiAgJ3V1aWQnLFxuICAnZW51JyxcbiAgJ3NwZWNpZmljVHlwZSdcbl07XG5cbi8vIEZvciBlYWNoIG9mIHRoZSBjb2x1bW4gbWV0aG9kcywgY3JlYXRlIGEgbmV3IFwiQ29sdW1uQnVpbGRlclwiIGludGVyZmFjZSxcbi8vIHB1c2ggaXQgb250byB0aGUgXCJhbGxTdGF0ZW1lbnRzXCIgc3RhY2ssIGFuZCB0aGVuIHJldHVybiB0aGUgaW50ZXJmYWNlLFxuLy8gd2l0aCB3aGljaCB3ZSBjYW4gYWRkIGluZGV4ZXMsIGV0Yy5cbmVhY2goY29sdW1uVHlwZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgVGFibGVCdWlsZGVyLnByb3RvdHlwZVt0eXBlXSA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG5cbiAgICAvLyBUaGUgXCJ0aW1lc3RhbXBzXCIgY2FsbCBpcyByZWFsbHkgYSBjb21wb3VuZCBjYWxsIHRvIHNldCB0aGVcbiAgICAvLyBgY3JlYXRlZF9hdGAgYW5kIGB1cGRhdGVkX2F0YCBjb2x1bW5zLlxuICAgIGlmICh0eXBlID09PSAndGltZXN0YW1wcycpIHtcbiAgICAgIGNvbnN0IGNvbCA9IChhcmdzWzBdID09PSB0cnVlKSA/ICd0aW1lc3RhbXAnIDogJ2RhdGV0aW1lJztcbiAgICAgIGNvbnN0IGNyZWF0ZWRBdCA9IHRoaXNbY29sXSgnY3JlYXRlZF9hdCcpO1xuICAgICAgY29uc3QgdXBkYXRlZEF0ID0gdGhpc1tjb2xdKCd1cGRhdGVkX2F0Jyk7XG4gICAgICBpZiAoYXJnc1sxXSA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBub3cgPSB0aGlzLmNsaWVudC5yYXcoJ0NVUlJFTlRfVElNRVNUQU1QJyk7XG4gICAgICAgIGNyZWF0ZWRBdC5ub3ROdWxsYWJsZSgpLmRlZmF1bHRUbyhub3cpO1xuICAgICAgICB1cGRhdGVkQXQubm90TnVsbGFibGUoKS5kZWZhdWx0VG8obm93KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYnVpbGRlciA9IHRoaXMuY2xpZW50LmNvbHVtbkJ1aWxkZXIodGhpcywgdHlwZSwgYXJncyk7XG5cbiAgICB0aGlzLl9zdGF0ZW1lbnRzLnB1c2goe1xuICAgICAgZ3JvdXBpbmc6ICdjb2x1bW5zJyxcbiAgICAgIGJ1aWxkZXJcbiAgICB9KTtcbiAgICByZXR1cm4gYnVpbGRlcjtcbiAgfTtcblxufSk7XG5cbi8vIFNldCB0aGUgY29tbWVudCB2YWx1ZSBmb3IgYSB0YWJsZSwgdGhleSdyZSBvbmx5IGFsbG93ZWQgdG8gYmUgY2FsbGVkXG4vLyBvbmNlIHBlciB0YWJsZS5cblRhYmxlQnVpbGRlci5wcm90b3R5cGUuY29tbWVudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMuX3NpbmdsZS5jb21tZW50ID0gdmFsdWU7XG59O1xuXG4vLyBTZXQgYSBmb3JlaWduIGtleSBvbiB0aGUgdGFibGUsIGNhbGxpbmdcbi8vIGB0YWJsZS5mb3JlaWduKCdjb2x1bW5fbmFtZScpLnJlZmVyZW5jZXMoJ2NvbHVtbicpLm9uKCd0YWJsZScpLm9uRGVsZXRlKCkuLi5cbi8vIEFsc28gY2FsbGVkIGZyb20gdGhlIENvbHVtbkJ1aWxkZXIgY29udGV4dCB3aGVuIGNoYWluaW5nLlxuVGFibGVCdWlsZGVyLnByb3RvdHlwZS5mb3JlaWduID0gZnVuY3Rpb24oY29sdW1uKSB7XG4gIGNvbnN0IGZvcmVpZ25EYXRhID0ge2NvbHVtbn07XG4gIHRoaXMuX3N0YXRlbWVudHMucHVzaCh7XG4gICAgZ3JvdXBpbmc6ICdhbHRlclRhYmxlJyxcbiAgICBtZXRob2Q6ICdmb3JlaWduJyxcbiAgICBhcmdzOiBbZm9yZWlnbkRhdGFdXG4gIH0pO1xuICBsZXQgcmV0dXJuT2JqID0ge1xuICAgIHJlZmVyZW5jZXModGFibGVDb2x1bW4pIHtcbiAgICAgIGxldCBwaWVjZXM7XG4gICAgICBpZiAoaXNTdHJpbmcodGFibGVDb2x1bW4pKSB7XG4gICAgICAgIHBpZWNlcyA9IHRhYmxlQ29sdW1uLnNwbGl0KCcuJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXBpZWNlcyB8fCBwaWVjZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGZvcmVpZ25EYXRhLnJlZmVyZW5jZXMgPSBwaWVjZXMgPyBwaWVjZXNbMF0gOiB0YWJsZUNvbHVtbjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBvbih0YWJsZU5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFibGVOYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCB0YWJsZU5hbWUgdG8gYmUgYSBzdHJpbmcsIGdvdDogJHt0eXBlb2YgdGFibGVOYW1lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yZWlnbkRhdGEuaW5UYWJsZSA9IHRhYmxlTmFtZTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5PYmo7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpblRhYmxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmb3JlaWduRGF0YS5pblRhYmxlID0gcGllY2VzWzBdO1xuICAgICAgZm9yZWlnbkRhdGEucmVmZXJlbmNlcyA9IHBpZWNlc1sxXTtcbiAgICAgIHJldHVybiByZXR1cm5PYmo7XG4gICAgfSxcbiAgICBvblVwZGF0ZShzdGF0ZW1lbnQpIHtcbiAgICAgIGZvcmVpZ25EYXRhLm9uVXBkYXRlID0gc3RhdGVtZW50O1xuICAgICAgcmV0dXJuIHJldHVybk9iajtcbiAgICB9LFxuICAgIG9uRGVsZXRlKHN0YXRlbWVudCkge1xuICAgICAgZm9yZWlnbkRhdGEub25EZWxldGUgPSBzdGF0ZW1lbnQ7XG4gICAgICByZXR1cm4gcmV0dXJuT2JqO1xuICAgIH0sXG4gICAgX2NvbHVtbkJ1aWxkZXIoYnVpbGRlcikge1xuICAgICAgZXh0ZW5kKGJ1aWxkZXIsIHJldHVybk9iaik7XG4gICAgICByZXR1cm5PYmogPSBidWlsZGVyO1xuICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfVxuICB9O1xuICByZXR1cm4gcmV0dXJuT2JqO1xufVxuXG5jb25zdCBBbHRlck1ldGhvZHMgPSB7XG5cbiAgLy8gUmVuYW1lcyB0aGUgY3VycmVudCBjb2x1bW4gYGZyb21gIHRoZSBjdXJyZW50XG4gIC8vIFRPRE86IHRoaXMuY29sdW1uKGZyb20pLnJlbmFtZSh0bylcbiAgcmVuYW1lQ29sdW1uKGZyb20sIHRvKSB7XG4gICAgdGhpcy5fc3RhdGVtZW50cy5wdXNoKHtcbiAgICAgIGdyb3VwaW5nOiAnYWx0ZXJUYWJsZScsXG4gICAgICBtZXRob2Q6ICdyZW5hbWVDb2x1bW4nLFxuICAgICAgYXJnczogW2Zyb20sIHRvXVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGRyb3BUaW1lc3RhbXBzKCkge1xuICAgIHJldHVybiB0aGlzLmRyb3BDb2x1bW5zKFsnY3JlYXRlZF9hdCcsICd1cGRhdGVkX2F0J10pO1xuICB9XG5cbiAgLy8gVE9ETzogY2hhbmdlVHlwZVxufTtcblxuLy8gRHJvcCBhIGNvbHVtbiBmcm9tIHRoZSBjdXJyZW50IHRhYmxlLlxuLy8gVE9ETzogRW5hYmxlIHRoaXMuY29sdW1uKGNvbHVtbk5hbWUpLmRyb3AoKTtcbkFsdGVyTWV0aG9kcy5kcm9wQ29sdW1uID1cbkFsdGVyTWV0aG9kcy5kcm9wQ29sdW1ucyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9zdGF0ZW1lbnRzLnB1c2goe1xuICAgIGdyb3VwaW5nOiAnYWx0ZXJUYWJsZScsXG4gICAgbWV0aG9kOiAnZHJvcENvbHVtbicsXG4gICAgYXJnczogdG9BcnJheShhcmd1bWVudHMpXG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgVGFibGVCdWlsZGVyO1xuIl19

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint max-len:0 */

	// Table Compiler
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	var _helpers = __webpack_require__(78);

	var _helpers2 = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers2);

	var _lodash = __webpack_require__(5);

	function TableCompiler(client, tableBuilder) {
	  this.client = client;
	  this.method = tableBuilder._method;
	  this.schemaNameRaw = tableBuilder._schemaName;
	  this.tableNameRaw = tableBuilder._tableName;
	  this.single = tableBuilder._single;
	  this.grouped = _lodash.groupBy(tableBuilder._statements, 'grouping');
	  this.formatter = client.formatter();
	  this.sequence = [];
	  this._formatting = client.config && client.config.formatting;
	}

	TableCompiler.prototype.pushQuery = _helpers.pushQuery;

	TableCompiler.prototype.pushAdditional = _helpers.pushAdditional;

	// Convert the tableCompiler toSQL
	TableCompiler.prototype.toSQL = function () {
	  this[this.method]();
	  return this.sequence;
	};

	TableCompiler.prototype.lowerCase = true;

	// Column Compilation
	// -------

	// If this is a table "creation", we need to first run through all
	// of the columns to build them into a single string,
	// and then run through anything else and push it to the query sequence.
	TableCompiler.prototype.createAlterTableMethods = null;
	TableCompiler.prototype.create = function (ifNot) {
	  var columns = this.getColumns();
	  var columnTypes = this.getColumnTypes(columns);
	  if (this.createAlterTableMethods) {
	    this.alterTableForCreate(columnTypes);
	  }
	  this.createQuery(columnTypes, ifNot);
	  this.columnQueries(columns);
	  delete this.single.comment;
	  this.alterTable();
	};

	// Only create the table if it doesn't exist.
	TableCompiler.prototype.createIfNot = function () {
	  this.create(true);
	};

	// If we're altering the table, we need to one-by-one
	// go through and handle each of the queries associated
	// with altering the table's schema.
	TableCompiler.prototype.alter = function () {
	  var columns = this.getColumns();
	  var columnTypes = this.getColumnTypes(columns);
	  this.addColumns(columnTypes);
	  this.columnQueries(columns);
	  this.alterTable();
	};

	TableCompiler.prototype.foreign = function (foreignData) {
	  if (foreignData.inTable && foreignData.references) {
	    var keyName = this._indexCommand('foreign', this.tableNameRaw, foreignData.column);
	    var column = this.formatter.columnize(foreignData.column);
	    var references = this.formatter.columnize(foreignData.references);
	    var inTable = this.formatter.wrap(foreignData.inTable);
	    var onUpdate = foreignData.onUpdate ? (this.lowerCase ? ' on update ' : ' ON UPDATE ') + foreignData.onUpdate : '';
	    var onDelete = foreignData.onDelete ? (this.lowerCase ? ' on delete ' : ' ON DELETE ') + foreignData.onDelete : '';
	    if (this.lowerCase) {
	      this.pushQuery((!this.forCreate ? 'alter table ' + this.tableName() + ' add ' : '') + 'constraint ' + keyName + ' ' + 'foreign key (' + column + ') references ' + inTable + ' (' + references + ')' + onUpdate + onDelete);
	    } else {
	      this.pushQuery((!this.forCreate ? 'ALTER TABLE ' + this.tableName() + ' ADD ' : '') + 'CONSTRAINT ' + keyName + ' ' + 'FOREIGN KEY (' + column + ') REFERENCES ' + inTable + ' (' + references + ')' + onUpdate + onDelete);
	    }
	  }
	};

	// Get all of the column sql & bindings individually for building the table queries.
	TableCompiler.prototype.getColumnTypes = function (columns) {
	  return _lodash.reduce(_lodash.map(columns, _lodash.first), function (memo, column) {
	    memo.sql.push(column.sql);
	    memo.bindings.concat(column.bindings);
	    return memo;
	  }, { sql: [], bindings: [] });
	};

	// Adds all of the additional queries from the "column"
	TableCompiler.prototype.columnQueries = function (columns) {
	  var queries = _lodash.reduce(_lodash.map(columns, _lodash.tail), function (memo, column) {
	    if (!_lodash.isEmpty(column)) return memo.concat(column);
	    return memo;
	  }, []);
	  for (var i = 0, l = queries.length; i < l; i++) {
	    this.pushQuery(queries[i]);
	  }
	};

	// Add a new column.
	TableCompiler.prototype.addColumnsPrefix = 'add column ';

	// All of the columns to "add" for the query
	TableCompiler.prototype.addColumns = function (columns) {
	  var _this = this;

	  if (columns.sql.length > 0) {
	    var columnSql = _lodash.map(columns.sql, function (column) {
	      return _this.addColumnsPrefix + column;
	    });
	    this.pushQuery({
	      sql: (this.lowerCase ? 'alter table ' : 'ALTER TABLE ') + this.tableName() + ' ' + columnSql.join(', '),
	      bindings: columns.bindings
	    });
	  }
	};

	// Compile the columns as needed for the current create or alter table
	TableCompiler.prototype.getColumns = function () {
	  var _this2 = this;

	  var columns = this.grouped.columns || [];
	  return columns.map(function (column) {
	    return _this2.client.columnCompiler(_this2, column.builder).toSQL();
	  });
	};

	TableCompiler.prototype.tableName = function () {
	  var name = this.schemaNameRaw ? this.schemaNameRaw + '.' + this.tableNameRaw : this.tableNameRaw;

	  return this.formatter.wrap(name);
	};

	// Generate all of the alter column statements necessary for the query.
	TableCompiler.prototype.alterTable = function () {
	  var alterTable = this.grouped.alterTable || [];
	  for (var i = 0, l = alterTable.length; i < l; i++) {
	    var statement = alterTable[i];
	    if (this[statement.method]) {
	      this[statement.method].apply(this, statement.args);
	    } else {
	      helpers.error('Debug: ' + statement.method + ' does not exist');
	    }
	  }
	  for (var item in this.single) {
	    if (typeof this[item] === 'function') this[item](this.single[item]);
	  }
	};

	TableCompiler.prototype.alterTableForCreate = function (columnTypes) {
	  this.forCreate = true;
	  var savedSequence = this.sequence;
	  var alterTable = this.grouped.alterTable || [];
	  this.grouped.alterTable = [];
	  for (var i = 0, l = alterTable.length; i < l; i++) {
	    var statement = alterTable[i];
	    if (_lodash.indexOf(this.createAlterTableMethods, statement.method) < 0) {
	      this.grouped.alterTable.push(statement);
	      continue;
	    }
	    if (this[statement.method]) {
	      this.sequence = [];
	      this[statement.method].apply(this, statement.args);
	      columnTypes.sql.push(this.sequence[0].sql);
	    } else {
	      helpers.error('Debug: ' + statement.method + ' does not exist');
	    }
	  }
	  this.sequence = savedSequence;
	  this.forCreate = false;
	};

	// Drop the index on the current table.
	TableCompiler.prototype.dropIndex = function (value) {
	  this.pushQuery('drop index' + value);
	};

	// Drop the unique
	TableCompiler.prototype.dropUnique = TableCompiler.prototype.dropForeign = function () {
	  throw new Error('Method implemented in the dialect driver');
	};

	TableCompiler.prototype.dropColumnPrefix = 'drop column ';
	TableCompiler.prototype.dropColumn = function () {
	  var _this3 = this;

	  var columns = helpers.normalizeArr.apply(null, arguments);
	  var drops = _lodash.map(_lodash.isArray(columns) ? columns : [columns], function (column) {
	    return _this3.dropColumnPrefix + _this3.formatter.wrap(column);
	  });
	  this.pushQuery((this.lowerCase ? 'alter table ' : 'ALTER TABLE ') + this.tableName() + ' ' + drops.join(', '));
	};

	// If no name was specified for this index, we will create one using a basic
	// convention of the table name, followed by the columns, followed by an
	// index type, such as primary or index, which makes the index unique.
	TableCompiler.prototype._indexCommand = function (type, tableName, columns) {
	  if (!_lodash.isArray(columns)) columns = columns ? [columns] : [];
	  var table = tableName.replace(/\.|-/g, '_');
	  var indexName = (table + '_' + columns.join('_') + '_' + type).toLowerCase();
	  return this.formatter.wrap(indexName);
	};

	exports['default'] = TableCompiler;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWEvdGFibGVjb21waWxlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O3VCQUkwQyxXQUFXOzt3QkFDNUIsWUFBWTs7SUFBekIsT0FBTzs7c0JBQzBELFFBQVE7O0FBRXJGLFNBQVMsYUFBYSxDQUFDLE1BQU0sRUFBRSxZQUFZLEVBQUU7QUFDM0MsTUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUE7QUFDcEIsTUFBSSxDQUFDLE1BQU0sR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDO0FBQ25DLE1BQUksQ0FBQyxhQUFhLEdBQUcsWUFBWSxDQUFDLFdBQVcsQ0FBQztBQUM5QyxNQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQyxVQUFVLENBQUM7QUFDNUMsTUFBSSxDQUFDLE1BQU0sR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDO0FBQ25DLE1BQUksQ0FBQyxPQUFPLEdBQUcsZ0JBQVEsWUFBWSxDQUFDLFdBQVcsRUFBRSxVQUFVLENBQUMsQ0FBQztBQUM3RCxNQUFJLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUNwQyxNQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztBQUNuQixNQUFJLENBQUMsV0FBVyxHQUFHLE1BQU0sQ0FBQyxNQUFNLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUE7Q0FDN0Q7O0FBRUQsYUFBYSxDQUFDLFNBQVMsQ0FBQyxTQUFTLHFCQUFZLENBQUE7O0FBRTdDLGFBQWEsQ0FBQyxTQUFTLENBQUMsY0FBYywwQkFBaUIsQ0FBQTs7O0FBR3ZELGFBQWEsQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLFlBQVk7QUFDMUMsTUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO0FBQ3BCLFNBQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztDQUN0QixDQUFDOztBQUVGLGFBQWEsQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFHLElBQUks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QyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUEsQ0FBRSxXQUFXLEVBQUUsQ0FBQztBQUMvRSxTQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0NBQ3ZDLENBQUM7O3FCQUVhLGFBQWEiLCJmaWxlIjoidGFibGVjb21waWxlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBtYXgtbGVuOjAgKi9cblxuLy8gVGFibGUgQ29tcGlsZXJcbi8vIC0tLS0tLS1cbmltcG9ydCB7IHB1c2hBZGRpdGlvbmFsLCBwdXNoUXVlcnkgfSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCB7IGdyb3VwQnksIHJlZHVjZSwgbWFwLCBmaXJzdCwgdGFpbCwgaXNFbXB0eSwgaW5kZXhPZiwgaXNBcnJheSB9IGZyb20gJ2xvZGFzaCdcblxuZnVuY3Rpb24gVGFibGVDb21waWxlcihjbGllbnQsIHRhYmxlQnVpbGRlcikge1xuICB0aGlzLmNsaWVudCA9IGNsaWVudFxuICB0aGlzLm1ldGhvZCA9IHRhYmxlQnVpbGRlci5fbWV0aG9kO1xuICB0aGlzLnNjaGVtYU5hbWVSYXcgPSB0YWJsZUJ1aWxkZXIuX3NjaGVtYU5hbWU7XG4gIHRoaXMudGFibGVOYW1lUmF3ID0gdGFibGVCdWlsZGVyLl90YWJsZU5hbWU7XG4gIHRoaXMuc2luZ2xlID0gdGFibGVCdWlsZGVyLl9zaW5nbGU7XG4gIHRoaXMuZ3JvdXBlZCA9IGdyb3VwQnkodGFibGVCdWlsZGVyLl9zdGF0ZW1lbnRzLCAnZ3JvdXBpbmcnKTtcbiAgdGhpcy5mb3JtYXR0ZXIgPSBjbGllbnQuZm9ybWF0dGVyKCk7XG4gIHRoaXMuc2VxdWVuY2UgPSBbXTtcbiAgdGhpcy5fZm9ybWF0dGluZyA9IGNsaWVudC5jb25maWcgJiYgY2xpZW50LmNvbmZpZy5mb3JtYXR0aW5nXG59XG5cblRhYmxlQ29tcGlsZXIucHJvdG90eXBlLnB1c2hRdWVyeSA9IHB1c2hRdWVyeVxuXG5UYWJsZUNvbXBpbGVyLnByb3RvdHlwZS5wdXNoQWRkaXRpb25hbCA9IHB1c2hBZGRpdGlvbmFsXG5cbi8vIENvbnZlcnQgdGhlIHRhYmxlQ29tcGlsZXIgdG9TUUxcblRhYmxlQ29tcGlsZXIucHJvdG90eXBlLnRvU1FMID0gZnVuY3Rpb24gKCkge1xuICB0aGlzW3RoaXMubWV0aG9kXSgpO1xuICByZXR1cm4gdGhpcy5zZXF1ZW5jZTtcbn07XG5cblRhYmxlQ29tcGlsZXIucHJvdG90eXBlLmxvd2VyQ2FzZSA9IHRydWU7XG5cbi8vIENvbHVtbiBDb21waWxhdGlvblxuLy8gLS0tLS0tLVxuXG4vLyBJZiB0aGlzIGlzIGEgdGFibGUgXCJjcmVhdGlvblwiLCB3ZSBuZWVkIHRvIGZpcnN0IHJ1biB0aHJvdWdoIGFsbFxuLy8gb2YgdGhlIGNvbHVtbnMgdG8gYnVpbGQgdGhlbSBpbnRvIGEgc2luZ2xlIHN0cmluZyxcbi8vIGFuZCB0aGVuIHJ1biB0aHJvdWdoIGFueXRoaW5nIGVsc2UgYW5kIHB1c2ggaXQgdG8gdGhlIHF1ZXJ5IHNlcXVlbmNlLlxuVGFibGVDb21waWxlci5wcm90b3R5cGUuY3JlYXRlQWx0ZXJUYWJsZU1ldGhvZHMgPSBudWxsO1xuVGFibGVDb21waWxlci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGlmTm90KSB7XG4gIGNvbnN0IGNvbHVtbnMgPSB0aGlzLmdldENvbHVtbnMoKTtcbiAgY29uc3QgY29sdW1uVHlwZXMgPSB0aGlzLmdldENvbHVtblR5cGVzKGNvbHVtbnMpO1xuICBpZiAodGhpcy5jcmVhdGVBbHRlclRhYmxlTWV0aG9kcykge1xuICAgIHRoaXMuYWx0ZXJUYWJsZUZvckNyZWF0ZShjb2x1bW5UeXBlcyk7XG4gIH1cbiAgdGhpcy5jcmVhdGVRdWVyeShjb2x1bW5UeXBlcywgaWZOb3QpO1xuICB0aGlzLmNvbHVtblF1ZXJpZXMoY29sdW1ucyk7XG4gIGRlbGV0ZSB0aGlzLnNpbmdsZS5jb21tZW50O1xuICB0aGlzLmFsdGVyVGFibGUoKTtcbn07XG5cbi8vIE9ubHkgY3JlYXRlIHRoZSB0YWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuVGFibGVDb21waWxlci5wcm90b3R5cGUuY3JlYXRlSWZOb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY3JlYXRlKHRydWUpO1xufTtcblxuLy8gSWYgd2UncmUgYWx0ZXJpbmcgdGhlIHRhYmxlLCB3ZSBuZWVkIHRvIG9uZS1ieS1vbmVcbi8vIGdvIHRocm91Z2ggYW5kIGhhbmRsZSBlYWNoIG9mIHRoZSBxdWVyaWVzIGFzc29jaWF0ZWRcbi8vIHdpdGggYWx0ZXJpbmcgdGhlIHRhYmxlJ3Mgc2NoZW1hLlxuVGFibGVDb21waWxlci5wcm90b3R5cGUuYWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGNvbHVtbnMgPSB0aGlzLmdldENvbHVtbnMoKTtcbiAgY29uc3QgY29sdW1uVHlwZXMgPSB0aGlzLmdldENvbHVtblR5cGVzKGNvbHVtbnMpO1xuICB0aGlzLmFkZENvbHVtbnMoY29sdW1uVHlwZXMpO1xuICB0aGlzLmNvbHVtblF1ZXJpZXMoY29sdW1ucyk7XG4gIHRoaXMuYWx0ZXJUYWJsZSgpO1xufTtcblxuVGFibGVDb21waWxlci5wcm90b3R5cGUuZm9yZWlnbiA9IGZ1bmN0aW9uIChmb3JlaWduRGF0YSkge1xuICBpZiAoZm9yZWlnbkRhdGEuaW5UYWJsZSAmJiBmb3JlaWduRGF0YS5yZWZlcmVuY2VzKSB7XG4gICAgY29uc3Qga2V5TmFtZSA9IHRoaXMuX2luZGV4Q29tbWFuZCgnZm9yZWlnbicsIHRoaXMudGFibGVOYW1lUmF3LCBmb3JlaWduRGF0YS5jb2x1bW4pO1xuICAgIGNvbnN0IGNvbHVtbiA9IHRoaXMuZm9ybWF0dGVyLmNvbHVtbml6ZShmb3JlaWduRGF0YS5jb2x1bW4pO1xuICAgIGNvbnN0IHJlZmVyZW5jZXMgPSB0aGlzLmZvcm1hdHRlci5jb2x1bW5pemUoZm9yZWlnbkRhdGEucmVmZXJlbmNlcyk7XG4gICAgY29uc3QgaW5UYWJsZSA9IHRoaXMuZm9ybWF0dGVyLndyYXAoZm9yZWlnbkRhdGEuaW5UYWJsZSk7XG4gICAgY29uc3Qgb25VcGRhdGUgPSBmb3JlaWduRGF0YS5vblVwZGF0ZSA/ICh0aGlzLmxvd2VyQ2FzZSA/ICcgb24gdXBkYXRlICcgOiAnIE9OIFVQREFURSAnKSArIGZvcmVpZ25EYXRhLm9uVXBkYXRlIDogJyc7XG4gICAgY29uc3Qgb25EZWxldGUgPSBmb3JlaWduRGF0YS5vbkRlbGV0ZSA/ICh0aGlzLmxvd2VyQ2FzZSA/ICcgb24gZGVsZXRlICcgOiAnIE9OIERFTEVURSAnKSArIGZvcmVpZ25EYXRhLm9uRGVsZXRlIDogJyc7XG4gICAgaWYgKHRoaXMubG93ZXJDYXNlKSB7XG4gICAgICB0aGlzLnB1c2hRdWVyeSgoIXRoaXMuZm9yQ3JlYXRlID8gYGFsdGVyIHRhYmxlICR7dGhpcy50YWJsZU5hbWUoKX0gYWRkIGAgOiAnJykgKyAnY29uc3RyYWludCAnICsga2V5TmFtZSArICcgJyArXG4gICAgICAgICdmb3JlaWduIGtleSAoJyArIGNvbHVtbiArICcpIHJlZmVyZW5jZXMgJyArIGluVGFibGUgKyAnICgnICsgcmVmZXJlbmNlcyArICcpJyArIG9uVXBkYXRlICsgb25EZWxldGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hRdWVyeSgoIXRoaXMuZm9yQ3JlYXRlID8gYEFMVEVSIFRBQkxFICR7dGhpcy50YWJsZU5hbWUoKX0gQUREIGAgOiAnJykgKyAnQ09OU1RSQUlOVCAnICsga2V5TmFtZSArICcgJyArXG4gICAgICAgICdGT1JFSUdOIEtFWSAoJyArIGNvbHVtbiArICcpIFJFRkVSRU5DRVMgJyArIGluVGFibGUgKyAnICgnICsgcmVmZXJlbmNlcyArICcpJyArIG9uVXBkYXRlICsgb25EZWxldGUpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gR2V0IGFsbCBvZiB0aGUgY29sdW1uIHNxbCAmIGJpbmRpbmdzIGluZGl2aWR1YWxseSBmb3IgYnVpbGRpbmcgdGhlIHRhYmxlIHF1ZXJpZXMuXG5UYWJsZUNvbXBpbGVyLnByb3RvdHlwZS5nZXRDb2x1bW5UeXBlcyA9IGNvbHVtbnMgPT5cbiAgcmVkdWNlKG1hcChjb2x1bW5zLCBmaXJzdCksIGZ1bmN0aW9uIChtZW1vLCBjb2x1bW4pIHtcbiAgICBtZW1vLnNxbC5wdXNoKGNvbHVtbi5zcWwpO1xuICAgIG1lbW8uYmluZGluZ3MuY29uY2F0KGNvbHVtbi5iaW5kaW5ncyk7XG4gICAgcmV0dXJuIG1lbW87XG4gIH0sIHsgc3FsOiBbXSwgYmluZGluZ3M6IFtdIH0pXG47XG5cbi8vIEFkZHMgYWxsIG9mIHRoZSBhZGRpdGlvbmFsIHF1ZXJpZXMgZnJvbSB0aGUgXCJjb2x1bW5cIlxuVGFibGVDb21waWxlci5wcm90b3R5cGUuY29sdW1uUXVlcmllcyA9IGZ1bmN0aW9uIChjb2x1bW5zKSB7XG4gIGNvbnN0IHF1ZXJpZXMgPSByZWR1Y2UobWFwKGNvbHVtbnMsIHRhaWwpLCBmdW5jdGlvbiAobWVtbywgY29sdW1uKSB7XG4gICAgaWYgKCFpc0VtcHR5KGNvbHVtbikpIHJldHVybiBtZW1vLmNvbmNhdChjb2x1bW4pO1xuICAgIHJldHVybiBtZW1vO1xuICB9LCBbXSk7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gcXVlcmllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB0aGlzLnB1c2hRdWVyeShxdWVyaWVzW2ldKTtcbiAgfVxufTtcblxuLy8gQWRkIGEgbmV3IGNvbHVtbi5cblRhYmxlQ29tcGlsZXIucHJvdG90eXBlLmFkZENvbHVtbnNQcmVmaXggPSAnYWRkIGNvbHVtbiAnO1xuXG4vLyBBbGwgb2YgdGhlIGNvbHVtbnMgdG8gXCJhZGRcIiBmb3IgdGhlIHF1ZXJ5XG5UYWJsZUNvbXBpbGVyLnByb3RvdHlwZS5hZGRDb2x1bW5zID0gZnVuY3Rpb24gKGNvbHVtbnMpIHtcbiAgaWYgKGNvbHVtbnMuc3FsLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBjb2x1bW5TcWwgPSBtYXAoY29sdW1ucy5zcWwsIChjb2x1bW4pID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmFkZENvbHVtbnNQcmVmaXggKyBjb2x1bW47XG4gICAgfSk7XG4gICAgdGhpcy5wdXNoUXVlcnkoe1xuICAgICAgc3FsOiAodGhpcy5sb3dlckNhc2UgPyAnYWx0ZXIgdGFibGUgJyA6ICdBTFRFUiBUQUJMRSAnKSArIHRoaXMudGFibGVOYW1lKCkgKyAnICcgKyBjb2x1bW5TcWwuam9pbignLCAnKSxcbiAgICAgIGJpbmRpbmdzOiBjb2x1bW5zLmJpbmRpbmdzXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIENvbXBpbGUgdGhlIGNvbHVtbnMgYXMgbmVlZGVkIGZvciB0aGUgY3VycmVudCBjcmVhdGUgb3IgYWx0ZXIgdGFibGVcblRhYmxlQ29tcGlsZXIucHJvdG90eXBlLmdldENvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGNvbHVtbnMgPSB0aGlzLmdyb3VwZWQuY29sdW1ucyB8fCBbXTtcbiAgcmV0dXJuIGNvbHVtbnMubWFwKGNvbHVtbiA9PlxuICAgIHRoaXMuY2xpZW50LmNvbHVtbkNvbXBpbGVyKHRoaXMsIGNvbHVtbi5idWlsZGVyKS50b1NRTCgpXG4gICk7XG59O1xuXG5UYWJsZUNvbXBpbGVyLnByb3RvdHlwZS50YWJsZU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IG5hbWUgPSB0aGlzLnNjaGVtYU5hbWVSYXcgP1xuICAgIGAke3RoaXMuc2NoZW1hTmFtZVJhd30uJHt0aGlzLnRhYmxlTmFtZVJhd31gXG4gICAgOiB0aGlzLnRhYmxlTmFtZVJhdztcblxuICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIud3JhcChuYW1lKTtcbn07XG5cbi8vIEdlbmVyYXRlIGFsbCBvZiB0aGUgYWx0ZXIgY29sdW1uIHN0YXRlbWVudHMgbmVjZXNzYXJ5IGZvciB0aGUgcXVlcnkuXG5UYWJsZUNvbXBpbGVyLnByb3RvdHlwZS5hbHRlclRhYmxlID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBhbHRlclRhYmxlID0gdGhpcy5ncm91cGVkLmFsdGVyVGFibGUgfHwgW107XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYWx0ZXJUYWJsZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBzdGF0ZW1lbnQgPSBhbHRlclRhYmxlW2ldO1xuICAgIGlmICh0aGlzW3N0YXRlbWVudC5tZXRob2RdKSB7XG4gICAgICB0aGlzW3N0YXRlbWVudC5tZXRob2RdLmFwcGx5KHRoaXMsIHN0YXRlbWVudC5hcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVscGVycy5lcnJvcihgRGVidWc6ICR7c3RhdGVtZW50Lm1ldGhvZH0gZG9lcyBub3QgZXhpc3RgKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBpdGVtIGluIHRoaXMuc2luZ2xlKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzW2l0ZW1dID09PSAnZnVuY3Rpb24nKSB0aGlzW2l0ZW1dKHRoaXMuc2luZ2xlW2l0ZW1dKTtcbiAgfVxufTtcblxuVGFibGVDb21waWxlci5wcm90b3R5cGUuYWx0ZXJUYWJsZUZvckNyZWF0ZSA9IGZ1bmN0aW9uIChjb2x1bW5UeXBlcykge1xuICB0aGlzLmZvckNyZWF0ZSA9IHRydWU7XG4gIGNvbnN0IHNhdmVkU2VxdWVuY2UgPSB0aGlzLnNlcXVlbmNlO1xuICBjb25zdCBhbHRlclRhYmxlID0gdGhpcy5ncm91cGVkLmFsdGVyVGFibGUgfHwgW107XG4gIHRoaXMuZ3JvdXBlZC5hbHRlclRhYmxlID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYWx0ZXJUYWJsZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBzdGF0ZW1lbnQgPSBhbHRlclRhYmxlW2ldO1xuICAgIGlmIChpbmRleE9mKHRoaXMuY3JlYXRlQWx0ZXJUYWJsZU1ldGhvZHMsIHN0YXRlbWVudC5tZXRob2QpIDwgMCkge1xuICAgICAgdGhpcy5ncm91cGVkLmFsdGVyVGFibGUucHVzaChzdGF0ZW1lbnQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0aGlzW3N0YXRlbWVudC5tZXRob2RdKSB7XG4gICAgICB0aGlzLnNlcXVlbmNlID0gW107XG4gICAgICB0aGlzW3N0YXRlbWVudC5tZXRob2RdLmFwcGx5KHRoaXMsIHN0YXRlbWVudC5hcmdzKTtcbiAgICAgIGNvbHVtblR5cGVzLnNxbC5wdXNoKHRoaXMuc2VxdWVuY2VbMF0uc3FsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVscGVycy5lcnJvcihgRGVidWc6ICR7c3RhdGVtZW50Lm1ldGhvZH0gZG9lcyBub3QgZXhpc3RgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5zZXF1ZW5jZSA9IHNhdmVkU2VxdWVuY2U7XG4gIHRoaXMuZm9yQ3JlYXRlID0gZmFsc2U7XG59O1xuXG5cbi8vIERyb3AgdGhlIGluZGV4IG9uIHRoZSBjdXJyZW50IHRhYmxlLlxuVGFibGVDb21waWxlci5wcm90b3R5cGUuZHJvcEluZGV4ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHRoaXMucHVzaFF1ZXJ5KGBkcm9wIGluZGV4JHt2YWx1ZX1gKTtcbn07XG5cbi8vIERyb3AgdGhlIHVuaXF1ZVxuVGFibGVDb21waWxlci5wcm90b3R5cGUuZHJvcFVuaXF1ZSA9XG5UYWJsZUNvbXBpbGVyLnByb3RvdHlwZS5kcm9wRm9yZWlnbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgaW1wbGVtZW50ZWQgaW4gdGhlIGRpYWxlY3QgZHJpdmVyJyk7XG59O1xuXG5UYWJsZUNvbXBpbGVyLnByb3RvdHlwZS5kcm9wQ29sdW1uUHJlZml4ID0gJ2Ryb3AgY29sdW1uICc7XG5UYWJsZUNvbXBpbGVyLnByb3RvdHlwZS5kcm9wQ29sdW1uID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBjb2x1bW5zID0gaGVscGVycy5ub3JtYWxpemVBcnIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgY29uc3QgZHJvcHMgPSBtYXAoaXNBcnJheShjb2x1bW5zKSA/IGNvbHVtbnMgOiBbY29sdW1uc10sIChjb2x1bW4pID0+IHtcbiAgICByZXR1cm4gdGhpcy5kcm9wQ29sdW1uUHJlZml4ICsgdGhpcy5mb3JtYXR0ZXIud3JhcChjb2x1bW4pO1xuICB9KTtcbiAgdGhpcy5wdXNoUXVlcnkoXG4gICAgKHRoaXMubG93ZXJDYXNlID8gJ2FsdGVyIHRhYmxlICcgOiAnQUxURVIgVEFCTEUgJykgK1xuICAgIHRoaXMudGFibGVOYW1lKCkgKyAnICcgKyBkcm9wcy5qb2luKCcsICcpXG4gICk7XG59O1xuXG4vLyBJZiBubyBuYW1lIHdhcyBzcGVjaWZpZWQgZm9yIHRoaXMgaW5kZXgsIHdlIHdpbGwgY3JlYXRlIG9uZSB1c2luZyBhIGJhc2ljXG4vLyBjb252ZW50aW9uIG9mIHRoZSB0YWJsZSBuYW1lLCBmb2xsb3dlZCBieSB0aGUgY29sdW1ucywgZm9sbG93ZWQgYnkgYW5cbi8vIGluZGV4IHR5cGUsIHN1Y2ggYXMgcHJpbWFyeSBvciBpbmRleCwgd2hpY2ggbWFrZXMgdGhlIGluZGV4IHVuaXF1ZS5cblRhYmxlQ29tcGlsZXIucHJvdG90eXBlLl9pbmRleENvbW1hbmQgPSBmdW5jdGlvbiAodHlwZSwgdGFibGVOYW1lLCBjb2x1bW5zKSB7XG4gIGlmICghaXNBcnJheShjb2x1bW5zKSkgY29sdW1ucyA9IGNvbHVtbnMgPyBbY29sdW1uc10gOiBbXTtcbiAgY29uc3QgdGFibGUgPSB0YWJsZU5hbWUucmVwbGFjZSgvXFwufC0vZywgJ18nKTtcbiAgY29uc3QgaW5kZXhOYW1lID0gKHRhYmxlICsgJ18nICsgY29sdW1ucy5qb2luKCdfJykgKyAnXycgKyB0eXBlKS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIud3JhcChpbmRleE5hbWUpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVGFibGVDb21waWxlcjtcbiJdfQ==

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = ColumnBuilder;

	var _lodash = __webpack_require__(5);

	// The chainable interface off the original "column" method.

	function ColumnBuilder(client, tableBuilder, type, args) {
	  this.client = client;
	  this._single = {};
	  this._modifiers = {};
	  this._statements = [];
	  this._type = columnAlias[type] || type;
	  this._args = args;
	  this._tableBuilder = tableBuilder;

	  // If we're altering the table, extend the object
	  // with the available "alter" methods.
	  if (tableBuilder._method === 'alter') {
	    _lodash.extend(this, AlterMethods);
	  }
	}

	// All of the modifier methods that can be used to modify the current query.
	var modifiers = ['default', 'defaultsTo', 'defaultTo', 'unsigned', 'nullable', 'notNull', 'notNullable', 'first', 'after', 'comment', 'collate'];

	// If we call any of the modifiers (index or otherwise) on the chainable, we pretend
	// as though we're calling `table.method(column)` directly.
	_lodash.each(modifiers, function (method) {
	  ColumnBuilder.prototype[method] = function () {
	    if (aliasMethod[method]) {
	      method = aliasMethod[method];
	    }
	    if (method === 'notNullable') return this.nullable(false);
	    this._modifiers[method] = _lodash.toArray(arguments);
	    return this;
	  };
	});

	_lodash.each(['index', 'primary', 'unique'], function (method) {
	  ColumnBuilder.prototype[method] = function () {
	    if (this._type.toLowerCase().indexOf('increments') === -1) {
	      this._tableBuilder[method].apply(this._tableBuilder, [this._args[0]].concat(_lodash.toArray(arguments)));
	    }
	    return this;
	  };
	});

	// Specify that the current column "references" a column,
	// which may be tableName.column or just "column"
	ColumnBuilder.prototype.references = function (value) {
	  return this._tableBuilder.foreign.call(this._tableBuilder, this._args[0], this)._columnBuilder(this).references(value);
	};

	var AlterMethods = {};

	// Specify that the column is to be dropped. This takes precedence
	// over all other rules for the column.
	AlterMethods.drop = function () {
	  this._single.drop = true;
	  return this;
	};

	// Specify the "type" that we're looking to set the
	// Knex takes no responsibility for any data-loss that may
	// occur when changing data types.
	AlterMethods.alterType = function (type) {
	  this._statements.push({
	    grouping: 'alterType',
	    value: type
	  });
	  return this;
	};

	// Aliases for convenience.
	var aliasMethod = {
	  'default': 'defaultTo',
	  defaultsTo: 'defaultTo',
	  notNull: 'notNullable'
	};

	// Alias a few methods for clarity when processing.
	var columnAlias = {
	  'float': 'floating',
	  'enum': 'enu',
	  'boolean': 'bool',
	  'string': 'varchar',
	  'bigint': 'bigInteger'
	};
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWEvY29sdW1uYnVpbGRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7cUJBSXdCLGFBQWE7O3NCQUhDLFFBQVE7Ozs7QUFHL0IsU0FBUyxhQUFhLENBQUMsTUFBTSxFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQ3RFLE1BQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFBO0FBQ3BCLE1BQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO0FBQ2xCLE1BQUksQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDO0FBQ3JCLE1BQUksQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDO0FBQ3RCLE1BQUksQ0FBQyxLQUFLLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQztBQUN2QyxNQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztBQUNsQixNQUFJLENBQUMsYUFBYSxHQUFHLFlBQVksQ0FBQzs7OztBQUlsQyxNQUFJLFlBQVksQ0FBQyxPQUFPLEtBQUssT0FBTyxFQUFFO0FBQ3BDLG1CQUFPLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQztHQUM1QjtDQUNGOzs7QUFHRCxJQUFNLFNBQVMsR0FBRyxDQUNoQixTQUFTLEVBQUUsWUFBWSxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQ2hELFVBQVUsRUFBRSxTQUFTLEVBQUUsYUFBYSxFQUNwQyxPQUFPLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQ3ZDLENBQUM7Ozs7QUFJRixhQUFLLFNBQVMsRUFBRSxVQUFTLE1BQU0sRUFBRTtBQUMvQixlQUFhLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFHLFlBQVc7QUFDM0MsUUFBSSxXQUFXLENBQUMsTUFBTSxDQUFDLEVBQUU7QUFDdkIsWUFBTSxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUM5QjtBQUNELFFBQUksTUFBTSxLQUFLLGFBQWEsRUFBRSxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDMUQsUUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsR0FBRyxnQkFBUSxTQUFTLENBQUMsQ0FBQztBQUM3QyxXQUFPLElBQUksQ0FBQztHQUNiLENBQUM7Q0FDSCxDQUFDLENBQUM7O0FBRUgsYUFBSyxDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxDQUFDLEVBQUUsVUFBUyxNQUFNLEVBQUU7QUFDcEQsZUFBYSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsR0FBRyxZQUFXO0FBQzNDLFFBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7QUFDekQsVUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFDakQsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLGdCQUFRLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUMvQztBQUNELFdBQU8sSUFBSSxDQUFDO0dBQ2IsQ0FBQztDQUNILENBQUMsQ0FBQzs7OztBQUlILGFBQWEsQ0FBQyxTQUFTLENBQUMsVUFBVSxHQUFHLFVBQVMsS0FBSyxFQUFFO0FBQ25ELFNBQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FDNUUsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUNwQixVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7Q0FDdEIsQ0FBQzs7QUFFRixJQUFNLFlBQVksR0FBRyxFQUFFLENBQUM7Ozs7QUFJeEIsWUFBWSxDQUFDLElBQUksR0FBRyxZQUFXO0FBQzdCLE1BQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUN6QixTQUFPLElBQUksQ0FBQztDQUNiLENBQUM7Ozs7O0FBS0YsWUFBWSxDQUFDLFNBQVMsR0FBRyxVQUFTLElBQUksRUFBRTtBQUN0QyxNQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztBQUNwQixZQUFRLEVBQUUsV0FBVztBQUNyQixTQUFLLEVBQUUsSUFBSTtHQUNaLENBQUMsQ0FBQztBQUNILFNBQU8sSUFBSSxDQUFDO0NBQ2IsQ0FBQzs7O0FBR0YsSUFBTSxXQUFXLEdBQUc7QUFDbEIsYUFBWSxXQUFXO0FBQ3ZCLFlBQVUsRUFBRSxXQUFXO0FBQ3ZCLFNBQU8sRUFBSyxhQUFhO0NBQzFCLENBQUM7OztBQUdGLElBQU0sV0FBVyxHQUFHO0FBQ2xCLFNBQU8sRUFBSSxVQUFVO0FBQ3JCLFFBQU0sRUFBSyxLQUFLO0FBQ2hCLFdBQVMsRUFBRSxNQUFNO0FBQ2pCLFVBQVEsRUFBRyxTQUFTO0FBQ3BCLFVBQVEsRUFBRyxZQUFZO0NBQ3hCLENBQUMiLCJmaWxlIjoiY29sdW1uYnVpbGRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgZXh0ZW5kLCBlYWNoLCB0b0FycmF5IH0gZnJvbSAnbG9kYXNoJ1xuXG4vLyBUaGUgY2hhaW5hYmxlIGludGVyZmFjZSBvZmYgdGhlIG9yaWdpbmFsIFwiY29sdW1uXCIgbWV0aG9kLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29sdW1uQnVpbGRlcihjbGllbnQsIHRhYmxlQnVpbGRlciwgdHlwZSwgYXJncykge1xuICB0aGlzLmNsaWVudCA9IGNsaWVudFxuICB0aGlzLl9zaW5nbGUgPSB7fTtcbiAgdGhpcy5fbW9kaWZpZXJzID0ge307XG4gIHRoaXMuX3N0YXRlbWVudHMgPSBbXTtcbiAgdGhpcy5fdHlwZSA9IGNvbHVtbkFsaWFzW3R5cGVdIHx8IHR5cGU7XG4gIHRoaXMuX2FyZ3MgPSBhcmdzO1xuICB0aGlzLl90YWJsZUJ1aWxkZXIgPSB0YWJsZUJ1aWxkZXI7XG5cbiAgLy8gSWYgd2UncmUgYWx0ZXJpbmcgdGhlIHRhYmxlLCBleHRlbmQgdGhlIG9iamVjdFxuICAvLyB3aXRoIHRoZSBhdmFpbGFibGUgXCJhbHRlclwiIG1ldGhvZHMuXG4gIGlmICh0YWJsZUJ1aWxkZXIuX21ldGhvZCA9PT0gJ2FsdGVyJykge1xuICAgIGV4dGVuZCh0aGlzLCBBbHRlck1ldGhvZHMpO1xuICB9XG59XG5cbi8vIEFsbCBvZiB0aGUgbW9kaWZpZXIgbWV0aG9kcyB0aGF0IGNhbiBiZSB1c2VkIHRvIG1vZGlmeSB0aGUgY3VycmVudCBxdWVyeS5cbmNvbnN0IG1vZGlmaWVycyA9IFtcbiAgJ2RlZmF1bHQnLCAnZGVmYXVsdHNUbycsICdkZWZhdWx0VG8nLCAndW5zaWduZWQnLFxuICAnbnVsbGFibGUnLCAnbm90TnVsbCcsICdub3ROdWxsYWJsZScsXG4gICdmaXJzdCcsICdhZnRlcicsICdjb21tZW50JywgJ2NvbGxhdGUnXG5dO1xuXG4vLyBJZiB3ZSBjYWxsIGFueSBvZiB0aGUgbW9kaWZpZXJzIChpbmRleCBvciBvdGhlcndpc2UpIG9uIHRoZSBjaGFpbmFibGUsIHdlIHByZXRlbmRcbi8vIGFzIHRob3VnaCB3ZSdyZSBjYWxsaW5nIGB0YWJsZS5tZXRob2QoY29sdW1uKWAgZGlyZWN0bHkuXG5lYWNoKG1vZGlmaWVycywgZnVuY3Rpb24obWV0aG9kKSB7XG4gIENvbHVtbkJ1aWxkZXIucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoYWxpYXNNZXRob2RbbWV0aG9kXSkge1xuICAgICAgbWV0aG9kID0gYWxpYXNNZXRob2RbbWV0aG9kXTtcbiAgICB9XG4gICAgaWYgKG1ldGhvZCA9PT0gJ25vdE51bGxhYmxlJykgcmV0dXJuIHRoaXMubnVsbGFibGUoZmFsc2UpO1xuICAgIHRoaXMuX21vZGlmaWVyc1ttZXRob2RdID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufSk7XG5cbmVhY2goWydpbmRleCcsICdwcmltYXJ5JywgJ3VuaXF1ZSddLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgQ29sdW1uQnVpbGRlci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl90eXBlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignaW5jcmVtZW50cycpID09PSAtMSkge1xuICAgICAgdGhpcy5fdGFibGVCdWlsZGVyW21ldGhvZF0uYXBwbHkodGhpcy5fdGFibGVCdWlsZGVyLFxuICAgICAgICBbdGhpcy5fYXJnc1swXV0uY29uY2F0KHRvQXJyYXkoYXJndW1lbnRzKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pO1xuXG4vLyBTcGVjaWZ5IHRoYXQgdGhlIGN1cnJlbnQgY29sdW1uIFwicmVmZXJlbmNlc1wiIGEgY29sdW1uLFxuLy8gd2hpY2ggbWF5IGJlIHRhYmxlTmFtZS5jb2x1bW4gb3IganVzdCBcImNvbHVtblwiXG5Db2x1bW5CdWlsZGVyLnByb3RvdHlwZS5yZWZlcmVuY2VzID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX3RhYmxlQnVpbGRlci5mb3JlaWduLmNhbGwodGhpcy5fdGFibGVCdWlsZGVyLCB0aGlzLl9hcmdzWzBdLCB0aGlzKVxuICAgIC5fY29sdW1uQnVpbGRlcih0aGlzKVxuICAgIC5yZWZlcmVuY2VzKHZhbHVlKTtcbn07XG5cbmNvbnN0IEFsdGVyTWV0aG9kcyA9IHt9O1xuXG4vLyBTcGVjaWZ5IHRoYXQgdGhlIGNvbHVtbiBpcyB0byBiZSBkcm9wcGVkLiBUaGlzIHRha2VzIHByZWNlZGVuY2Vcbi8vIG92ZXIgYWxsIG90aGVyIHJ1bGVzIGZvciB0aGUgY29sdW1uLlxuQWx0ZXJNZXRob2RzLmRyb3AgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc2luZ2xlLmRyb3AgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFNwZWNpZnkgdGhlIFwidHlwZVwiIHRoYXQgd2UncmUgbG9va2luZyB0byBzZXQgdGhlXG4vLyBLbmV4IHRha2VzIG5vIHJlc3BvbnNpYmlsaXR5IGZvciBhbnkgZGF0YS1sb3NzIHRoYXQgbWF5XG4vLyBvY2N1ciB3aGVuIGNoYW5naW5nIGRhdGEgdHlwZXMuXG5BbHRlck1ldGhvZHMuYWx0ZXJUeXBlID0gZnVuY3Rpb24odHlwZSkge1xuICB0aGlzLl9zdGF0ZW1lbnRzLnB1c2goe1xuICAgIGdyb3VwaW5nOiAnYWx0ZXJUeXBlJyxcbiAgICB2YWx1ZTogdHlwZVxuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBBbGlhc2VzIGZvciBjb252ZW5pZW5jZS5cbmNvbnN0IGFsaWFzTWV0aG9kID0ge1xuICBkZWZhdWx0OiAgICAnZGVmYXVsdFRvJyxcbiAgZGVmYXVsdHNUbzogJ2RlZmF1bHRUbycsXG4gIG5vdE51bGw6ICAgICdub3ROdWxsYWJsZSdcbn07XG5cbi8vIEFsaWFzIGEgZmV3IG1ldGhvZHMgZm9yIGNsYXJpdHkgd2hlbiBwcm9jZXNzaW5nLlxuY29uc3QgY29sdW1uQWxpYXMgPSB7XG4gICdmbG9hdCcgIDogJ2Zsb2F0aW5nJyxcbiAgJ2VudW0nICAgOiAnZW51JyxcbiAgJ2Jvb2xlYW4nOiAnYm9vbCcsXG4gICdzdHJpbmcnIDogJ3ZhcmNoYXInLFxuICAnYmlnaW50JyA6ICdiaWdJbnRlZ2VyJ1xufTtcbiJdfQ==

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	
	// Column Compiler
	// Used for designating column definitions
	// during the table "create" / "alter" statements.
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _raw = __webpack_require__(2);

	var _raw2 = _interopRequireDefault(_raw);

	var _helpers = __webpack_require__(78);

	var helpers = _interopRequireWildcard(_helpers);

	var _lodash = __webpack_require__(5);

	function ColumnCompiler(client, tableCompiler, columnBuilder) {
	  this.client = client;
	  this.tableCompiler = tableCompiler;
	  this.columnBuilder = columnBuilder;
	  this.args = columnBuilder._args;
	  this.type = columnBuilder._type.toLowerCase();
	  this.grouped = _lodash.groupBy(columnBuilder._statements, 'grouping');
	  this.modified = columnBuilder._modifiers;
	  this.isIncrements = this.type.indexOf('increments') !== -1;
	  this.formatter = client.formatter();
	  this.sequence = [];
	}

	ColumnCompiler.prototype.pushQuery = helpers.pushQuery;

	ColumnCompiler.prototype.pushAdditional = helpers.pushAdditional;

	// To convert to sql, we first go through and build the
	// column as it would be in the insert statement
	ColumnCompiler.prototype.toSQL = function () {
	  this.pushQuery(this.compileColumn());
	  if (this.sequence.additional) {
	    this.sequence = this.sequence.concat(this.sequence.additional);
	  }
	  return this.sequence;
	};

	// Compiles a column.
	ColumnCompiler.prototype.compileColumn = function () {
	  return this.formatter.wrap(this.getColumnName()) + ' ' + this.getColumnType() + this.getModifiers();
	};

	// Assumes the autoincrementing key is named `id` if not otherwise specified.
	ColumnCompiler.prototype.getColumnName = function () {
	  var value = _lodash.first(this.args);
	  if (value) return value;
	  if (this.isIncrements) {
	    return 'id';
	  } else {
	    throw new Error('You did not specify a column name for the ' + this.type + 'column.');
	  }
	};

	ColumnCompiler.prototype.getColumnType = function () {
	  var type = this[this.type];
	  return typeof type === 'function' ? type.apply(this, _lodash.tail(this.args)) : type;
	};

	ColumnCompiler.prototype.getModifiers = function () {
	  var modifiers = [];
	  if (this.type.indexOf('increments') === -1) {
	    for (var i = 0, l = this.modifiers.length; i < l; i++) {
	      var modifier = this.modifiers[i];
	      if (_lodash.has(this.modified, modifier)) {
	        var val = this[modifier].apply(this, this.modified[modifier]);
	        if (val) modifiers.push(val);
	      }
	    }
	  }
	  return modifiers.length > 0 ? ' ' + modifiers.join(' ') : '';
	};

	// Types
	// ------

	ColumnCompiler.prototype.increments = 'integer not null primary key autoincrement';
	ColumnCompiler.prototype.bigincrements = 'integer not null primary key autoincrement';
	ColumnCompiler.prototype.integer = ColumnCompiler.prototype.smallint = ColumnCompiler.prototype.mediumint = 'integer';
	ColumnCompiler.prototype.biginteger = 'bigint';
	ColumnCompiler.prototype.varchar = function (length) {
	  return 'varchar(' + this._num(length, 255) + ')';
	};
	ColumnCompiler.prototype.text = 'text';
	ColumnCompiler.prototype.tinyint = 'tinyint';
	ColumnCompiler.prototype.floating = function (precision, scale) {
	  return 'float(' + this._num(precision, 8) + ', ' + this._num(scale, 2) + ')';
	};
	ColumnCompiler.prototype.decimal = function (precision, scale) {
	  return 'decimal(' + this._num(precision, 8) + ', ' + this._num(scale, 2) + ')';
	};
	ColumnCompiler.prototype.binary = 'blob';
	ColumnCompiler.prototype.bool = 'boolean';
	ColumnCompiler.prototype.date = 'date';
	ColumnCompiler.prototype.datetime = 'datetime';
	ColumnCompiler.prototype.time = 'time';
	ColumnCompiler.prototype.timestamp = 'timestamp';
	ColumnCompiler.prototype.enu = 'varchar';

	ColumnCompiler.prototype.bit = ColumnCompiler.prototype.json = 'text';

	ColumnCompiler.prototype.uuid = 'char(36)';
	ColumnCompiler.prototype.specifictype = function (type) {
	  return type;
	};

	// Modifiers
	// -------

	ColumnCompiler.prototype.nullable = function (nullable) {
	  return nullable === false ? 'not null' : 'null';
	};
	ColumnCompiler.prototype.notNullable = function () {
	  return this.nullable(false);
	};
	ColumnCompiler.prototype.defaultTo = function (value) {
	  if (value === void 0) {
	    return '';
	  } else if (value === null) {
	    value = "null";
	  } else if (value instanceof _raw2['default']) {
	    value = value.toQuery();
	  } else if (this.type === 'bool') {
	    if (value === 'false') value = 0;
	    value = '\'' + (value ? 1 : 0) + '\'';
	  } else if (this.type === 'json' && _lodash.isObject(value)) {
	    return JSON.stringify(value);
	  } else {
	    value = '\'' + value + '\'';
	  }
	  return 'default ' + value;
	};
	ColumnCompiler.prototype._num = function (val, fallback) {
	  if (val === undefined || val === null) return fallback;
	  var number = parseInt(val, 10);
	  return isNaN(number) ? fallback : number;
	};

	exports['default'] = ColumnCompiler;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWEvY29sdW1uY29tcGlsZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OzttQkFLZ0IsUUFBUTs7Ozt1QkFDQyxXQUFXOztJQUF4QixPQUFPOztzQkFDaUMsUUFBUTs7QUFFNUQsU0FBUyxjQUFjLENBQUMsTUFBTSxFQUFFLGFBQWEsRUFBRSxhQUFhLEVBQUU7QUFDNUQsTUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUE7QUFDcEIsTUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUE7QUFDbEMsTUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUE7QUFDbEMsTUFBSSxDQUFDLElBQUksR0FBRyxhQUFhLENBQUMsS0FBSyxDQUFDO0FBQ2hDLE1BQUksQ0FBQyxJQUFJLEdBQUcsYUFBYSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUM5QyxNQUFJLENBQUMsT0FBTyxHQUFHLGdCQUFRLGFBQWEsQ0FBQyxXQUFXLEVBQUUsVUFBVSxDQUFDLENBQUM7QUFDOUQsTUFBSSxDQUFDLFFBQVEsR0FBRyxhQUFhLENBQUMsVUFBVSxDQUFDO0FBQ3pDLE1BQUksQ0FBQyxZQUFZLEdBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLEFBQUMsQ0FBQztBQUM3RCxNQUFJLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUNwQyxNQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztDQUNwQjs7QUFFRCxjQUFjLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFBOztBQUV0RCxjQUFjLENBQUMsU0FBUyxDQUFDLGNBQWMsR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFBOzs7O0FBSWhFLGNBQWMsQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLFlBQVc7QUFDMUMsTUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJ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RztDQUMzQixDQUFDO0FBQ0YsY0FBYyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsVUFBUyxHQUFHLEVBQUUsUUFBUSxFQUFFO0FBQ3RELE1BQUksR0FBRyxLQUFLLFNBQVMsSUFBSSxHQUFHLEtBQUssSUFBSSxFQUFFLE9BQU8sUUFBUSxDQUFDO0FBQ3ZELE1BQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDakMsU0FBTyxLQUFLLENBQUMsTUFBTSxDQUFDLEdBQUcsUUFBUSxHQUFHLE1BQU0sQ0FBQztDQUMxQyxDQUFDOztxQkFFYSxjQUFjIiwiZmlsZSI6ImNvbHVtbmNvbXBpbGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBDb2x1bW4gQ29tcGlsZXJcbi8vIFVzZWQgZm9yIGRlc2lnbmF0aW5nIGNvbHVtbiBkZWZpbml0aW9uc1xuLy8gZHVyaW5nIHRoZSB0YWJsZSBcImNyZWF0ZVwiIC8gXCJhbHRlclwiIHN0YXRlbWVudHMuXG4vLyAtLS0tLS0tXG5pbXBvcnQgUmF3IGZyb20gJy4uL3Jhdyc7XG5pbXBvcnQgKiBhcyBoZWxwZXJzIGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQgeyBncm91cEJ5LCBmaXJzdCwgdGFpbCwgaGFzLCBpc09iamVjdCB9IGZyb20gJ2xvZGFzaCdcblxuZnVuY3Rpb24gQ29sdW1uQ29tcGlsZXIoY2xpZW50LCB0YWJsZUNvbXBpbGVyLCBjb2x1bW5CdWlsZGVyKSB7XG4gIHRoaXMuY2xpZW50ID0gY2xpZW50XG4gIHRoaXMudGFibGVDb21waWxlciA9IHRhYmxlQ29tcGlsZXJcbiAgdGhpcy5jb2x1bW5CdWlsZGVyID0gY29sdW1uQnVpbGRlclxuICB0aGlzLmFyZ3MgPSBjb2x1bW5CdWlsZGVyLl9hcmdzO1xuICB0aGlzLnR5cGUgPSBjb2x1bW5CdWlsZGVyLl90eXBlLnRvTG93ZXJDYXNlKCk7XG4gIHRoaXMuZ3JvdXBlZCA9IGdyb3VwQnkoY29sdW1uQnVpbGRlci5fc3RhdGVtZW50cywgJ2dyb3VwaW5nJyk7XG4gIHRoaXMubW9kaWZpZWQgPSBjb2x1bW5CdWlsZGVyLl9tb2RpZmllcnM7XG4gIHRoaXMuaXNJbmNyZW1lbnRzID0gKHRoaXMudHlwZS5pbmRleE9mKCdpbmNyZW1lbnRzJykgIT09IC0xKTtcbiAgdGhpcy5mb3JtYXR0ZXIgPSBjbGllbnQuZm9ybWF0dGVyKCk7XG4gIHRoaXMuc2VxdWVuY2UgPSBbXTtcbn1cblxuQ29sdW1uQ29tcGlsZXIucHJvdG90eXBlLnB1c2hRdWVyeSA9IGhlbHBlcnMucHVzaFF1ZXJ5XG5cbkNvbHVtbkNvbXBpbGVyLnByb3RvdHlwZS5wdXNoQWRkaXRpb25hbCA9IGhlbHBlcnMucHVzaEFkZGl0aW9uYWxcblxuLy8gVG8gY29udmVydCB0byBzcWwsIHdlIGZpcnN0IGdvIHRocm91Z2ggYW5kIGJ1aWxkIHRoZVxuLy8gY29sdW1uIGFzIGl0IHdvdWxkIGJlIGluIHRoZSBpbnNlcnQgc3RhdGVtZW50XG5Db2x1bW5Db21waWxlci5wcm90b3R5cGUudG9TUUwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wdXNoUXVlcnkodGhpcy5jb21waWxlQ29sdW1uKCkpO1xuICBpZiAodGhpcy5zZXF1ZW5jZS5hZGRpdGlvbmFsKSB7XG4gICAgdGhpcy5zZXF1ZW5jZSA9IHRoaXMuc2VxdWVuY2UuY29uY2F0KHRoaXMuc2VxdWVuY2UuYWRkaXRpb25hbCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuc2VxdWVuY2U7XG59O1xuXG4vLyBDb21waWxlcyBhIGNvbHVtbi5cbkNvbHVtbkNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlQ29sdW1uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmZvcm1hdHRlci53cmFwKHRoaXMuZ2V0Q29sdW1uTmFtZSgpKSArICcgJyArXG4gICAgdGhpcy5nZXRDb2x1bW5UeXBlKCkgKyB0aGlzLmdldE1vZGlmaWVycygpO1xufTtcblxuLy8gQXNzdW1lcyB0aGUgYXV0b2luY3JlbWVudGluZyBrZXkgaXMgbmFtZWQgYGlkYCBpZiBub3Qgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbkNvbHVtbkNvbXBpbGVyLnByb3RvdHlwZS5nZXRDb2x1bW5OYW1lID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHZhbHVlID0gZmlyc3QodGhpcy5hcmdzKTtcbiAgaWYgKHZhbHVlKSByZXR1cm4gdmFsdWU7XG4gIGlmICh0aGlzLmlzSW5jcmVtZW50cykge1xuICAgIHJldHVybiAnaWQnO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgWW91IGRpZCBub3Qgc3BlY2lmeSBhIGNvbHVtbiBuYW1lIGZvciB0aGUgJHt0aGlzLnR5cGV9Y29sdW1uLmApO1xuICB9XG59O1xuXG5Db2x1bW5Db21waWxlci5wcm90b3R5cGUuZ2V0Q29sdW1uVHlwZSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCB0eXBlID0gdGhpc1t0aGlzLnR5cGVdO1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmFwcGx5KHRoaXMsIHRhaWwodGhpcy5hcmdzKSkgOiB0eXBlO1xufTtcblxuQ29sdW1uQ29tcGlsZXIucHJvdG90eXBlLmdldE1vZGlmaWVycyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBtb2RpZmllcnMgPSBbXTtcbiAgaWYgKHRoaXMudHlwZS5pbmRleE9mKCdpbmNyZW1lbnRzJykgPT09IC0xKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLm1vZGlmaWVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IG1vZGlmaWVyID0gdGhpcy5tb2RpZmllcnNbaV07XG4gICAgICBpZiAoaGFzKHRoaXMubW9kaWZpZWQsIG1vZGlmaWVyKSkge1xuICAgICAgICBjb25zdCB2YWwgPSB0aGlzW21vZGlmaWVyXS5hcHBseSh0aGlzLCB0aGlzLm1vZGlmaWVkW21vZGlmaWVyXSk7XG4gICAgICAgIGlmICh2YWwpIG1vZGlmaWVycy5wdXNoKHZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllcnMubGVuZ3RoID4gMCA/IGAgJHttb2RpZmllcnMuam9pbignICcpfWAgOiAnJztcbn07XG5cbi8vIFR5cGVzXG4vLyAtLS0tLS1cblxuQ29sdW1uQ29tcGlsZXIucHJvdG90eXBlLmluY3JlbWVudHMgPSAnaW50ZWdlciBub3QgbnVsbCBwcmltYXJ5IGtleSBhdXRvaW5jcmVtZW50JztcbkNvbHVtbkNvbXBpbGVyLnByb3RvdHlwZS5iaWdpbmNyZW1lbnRzID0gJ2ludGVnZXIgbm90IG51bGwgcHJpbWFyeSBrZXkgYXV0b2luY3JlbWVudCc7XG5Db2x1bW5Db21waWxlci5wcm90b3R5cGUuaW50ZWdlciAgICAgICA9XG5Db2x1bW5Db21waWxlci5wcm90b3R5cGUuc21hbGxpbnQgICAgICA9XG5Db2x1bW5Db21waWxlci5wcm90b3R5cGUubWVkaXVtaW50ID0gJ2ludGVnZXInO1xuQ29sdW1uQ29tcGlsZXIucHJvdG90eXBlLmJpZ2ludGVnZXIgPSAnYmlnaW50JztcbkNvbHVtbkNvbXBpbGVyLnByb3RvdHlwZS52YXJjaGFyID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gIHJldHVybiBgdmFyY2hhcigke3RoaXMuX251bShsZW5ndGgsIDI1NSl9KWA7XG59O1xuQ29sdW1uQ29tcGlsZXIucHJvdG90eXBlLnRleHQgPSAndGV4dCc7XG5Db2x1bW5Db21waWxlci5wcm90b3R5cGUudGlueWludCA9ICd0aW55aW50JztcbkNvbHVtbkNvbXBpbGVyLnByb3RvdHlwZS5mbG9hdGluZyA9IGZ1bmN0aW9uKHByZWNpc2lvbiwgc2NhbGUpIHtcbiAgcmV0dXJuIGBmbG9hdCgke3RoaXMuX251bShwcmVjaXNpb24sIDgpfSwgJHt0aGlzLl9udW0oc2NhbGUsIDIpfSlgO1xufTtcbkNvbHVtbkNvbXBpbGVyLnByb3RvdHlwZS5kZWNpbWFsID0gZnVuY3Rpb24ocHJlY2lzaW9uLCBzY2FsZSkge1xuICByZXR1cm4gYGRlY2ltYWwoJHt0aGlzLl9udW0ocHJlY2lzaW9uLCA4KX0sICR7dGhpcy5fbnVtKHNjYWxlLCAyKX0pYDtcbn07XG5Db2x1bW5Db21waWxlci5wcm90b3R5cGUuYmluYXJ5ID0gJ2Jsb2InO1xuQ29sdW1uQ29tcGlsZXIucHJvdG90eXBlLmJvb2wgPSAnYm9vbGVhbic7XG5Db2x1bW5Db21waWxlci5wcm90b3R5cGUuZGF0ZSA9ICdkYXRlJztcbkNvbHVtbkNvbXBpbGVyLnByb3RvdHlwZS5kYXRldGltZSA9ICdkYXRldGltZSc7XG5Db2x1bW5Db21waWxlci5wcm90b3R5cGUudGltZSA9ICd0aW1lJztcbkNvbHVtbkNvbXBpbGVyLnByb3RvdHlwZS50aW1lc3RhbXAgPSAndGltZXN0YW1wJztcbkNvbHVtbkNvbXBpbGVyLnByb3RvdHlwZS5lbnUgPSAndmFyY2hhcic7XG5cbkNvbHVtbkNvbXBpbGVyLnByb3RvdHlwZS5iaXQgPVxuQ29sdW1uQ29tcGlsZXIucHJvdG90eXBlLmpzb24gPSAndGV4dCc7XG5cbkNvbHVtbkNvbXBpbGVyLnByb3RvdHlwZS51dWlkID0gJ2NoYXIoMzYpJztcbkNvbHVtbkNvbXBpbGVyLnByb3RvdHlwZS5zcGVjaWZpY3R5cGUgPSB0eXBlID0+IHR5cGU7XG5cbi8vIE1vZGlmaWVyc1xuLy8gLS0tLS0tLVxuXG5Db2x1bW5Db21waWxlci5wcm90b3R5cGUubnVsbGFibGUgPSBudWxsYWJsZSA9PiBudWxsYWJsZSA9PT0gZmFsc2UgPyAnbm90IG51bGwnIDogJ251bGwnO1xuQ29sdW1uQ29tcGlsZXIucHJvdG90eXBlLm5vdE51bGxhYmxlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm51bGxhYmxlKGZhbHNlKTtcbn07XG5Db2x1bW5Db21waWxlci5wcm90b3R5cGUuZGVmYXVsdFRvID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICB2YWx1ZSA9IFwibnVsbFwiO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmF3KSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50b1F1ZXJ5KCk7XG4gIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSAnYm9vbCcpIHtcbiAgICBpZiAodmFsdWUgPT09ICdmYWxzZScpIHZhbHVlID0gMDtcbiAgICB2YWx1ZSA9IGAnJHt2YWx1ZSA/IDEgOiAwfSdgO1xuICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ2pzb24nICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBgJyR7dmFsdWV9J2A7XG4gIH1cbiAgcmV0dXJuIGBkZWZhdWx0ICR7dmFsdWV9YDtcbn07XG5Db2x1bW5Db21waWxlci5wcm90b3R5cGUuX251bSA9IGZ1bmN0aW9uKHZhbCwgZmFsbGJhY2spIHtcbiAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkIHx8IHZhbCA9PT0gbnVsbCkgcmV0dXJuIGZhbGxiYWNrO1xuICBjb25zdCBudW1iZXIgPSBwYXJzZUludCh2YWwsIDEwKTtcbiAgcmV0dXJuIGlzTmFOKG51bWJlcikgPyBmYWxsYmFjayA6IG51bWJlcjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENvbHVtbkNvbXBpbGVyO1xuIl19

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var SqlString = {};
	exports['default'] = SqlString;

	SqlString.escape = function (val, timeZone) {
	  // Can't do require on top of file because Raw has not yet been initialized
	  // when this file is executed for the first time.
	  var Raw = __webpack_require__(2);

	  if (val === null || val === undefined) {
	    return 'NULL';
	  }

	  switch (typeof val) {
	    case 'boolean':
	      return val ? 'true' : 'false';
	    case 'number':
	      return val + '';
	  }

	  if (val instanceof Date) {
	    val = SqlString.dateToString(val, timeZone || 'local');
	  }

	  if (Buffer.isBuffer(val)) {
	    return SqlString.bufferToString(val);
	  }

	  if (Array.isArray(val)) {
	    return SqlString.arrayToList(val, timeZone);
	  }

	  if (val instanceof Raw) {
	    return val;
	  }

	  if (typeof val === 'object') {
	    try {
	      val = JSON.stringify(val);
	    } catch (e) {
	      helpers.warn(e);
	      val = val + '';
	    }
	  }

	  val = val.replace(/(\\\?)|[\0\n\r\b\t\\\'\x1a]/g, function (s) {
	    switch (s) {
	      case "\0":
	        return "\\0";
	      case "\n":
	        return "\\n";
	      case "\r":
	        return "\\r";
	      case "\b":
	        return "\\b";
	      case "\t":
	        return "\\t";
	      case "\x1a":
	        return "\\Z";
	      case "\\?":
	        return "?";
	      case "\'":
	        return "''";
	      default:
	        return '${s}';
	    }
	  });
	  return '\'' + val + '\'';
	};

	SqlString.arrayToList = function (array, timeZone) {
	  var self = this;
	  return array.map(function (v) {
	    if (Array.isArray(v)) return '(' + SqlString.arrayToList(v, timeZone) + ')';
	    return self.escape(v, timeZone);
	  }).join(', ');
	};

	SqlString.format = function (sql, values, timeZone) {
	  var self = this;
	  values = values == null ? [] : [].concat(values);
	  var index = 0;
	  return sql.replace(/\\?\?/g, function (match) {
	    if (match === '\\?') return match;
	    if (index === values.length) {
	      return match;
	    }
	    var value = values[index++];
	    return self.escape(value, timeZone);
	  }).replace('\\?', '?');
	};

	SqlString.dateToString = function (date, timeZone) {
	  var dt = new Date(date);

	  if (timeZone !== 'local') {
	    var tz = convertTimezone(timeZone);

	    dt.setTime(dt.getTime() + dt.getTimezoneOffset() * 60000);
	    if (tz !== false) {
	      dt.setTime(dt.getTime() + tz * 60000);
	    }
	  }

	  var year = dt.getFullYear();
	  var month = zeroPad(dt.getMonth() + 1, 2);
	  var day = zeroPad(dt.getDate(), 2);
	  var hour = zeroPad(dt.getHours(), 2);
	  var minute = zeroPad(dt.getMinutes(), 2);
	  var second = zeroPad(dt.getSeconds(), 2);
	  var millisecond = zeroPad(dt.getMilliseconds(), 3);

	  return year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second + '.' + millisecond;
	};

	SqlString.bufferToString = function bufferToString(buffer) {
	  return 'X\'' + buffer.toString('hex') + '\'';
	};

	function zeroPad(number, length) {
	  number = number.toString();
	  while (number.length < length) {
	    number = '0' + number;
	  }

	  return number;
	}

	function convertTimezone(tz) {
	  if (tz === "Z") return 0;

	  var m = tz.match(/([\+\-\s])(\d\d):?(\d\d)?/);
	  if (m) {
	    return (m[1] === '-' ? -1 : 1) * (parseInt(m[2], 10) + (m[3] ? parseInt(m[3], 10) : 0) / 60) * 60;
	  }
	  return false;
	}
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9xdWVyeS9zdHJpbmcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O3VCQUF5QixZQUFZOztJQUF6QixPQUFPOztBQUVuQixJQUFNLFNBQVMsR0FBRyxFQUFFLENBQUM7cUJBQ1osU0FBUzs7QUFFbEIsU0FBUyxDQUFDLE1BQU0sR0FBRyxVQUFTLEdBQUcsRUFBRSxRQUFRLEVBQUU7OztBQUd6QyxNQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUE7O0FBRTdCLE1BQUksR0FBRyxLQUFLLElBQUksSUFBSSxHQUFHLEtBQUssU0FBUyxFQUFFO0FBQ3JDLFdBQU8sTUFBTSxDQUFDO0dBQ2Y7O0FBRUQsVUFBUSxPQUFPLEdBQUc7QUFDaEIsU0FBSyxTQUFTO0FBQUUsYUFBTyxBQUFDLEdBQUcsR0FBSSxNQUFNLEdBQUcsT0FBTyxDQUFDO0FBQUEsQUFDaEQsU0FBSyxRQUFRO0FBQUUsYUFBTyxHQUFHLEdBQUMsRUFBRSxDQUFDO0FBQUEsR0FDOUI7O0FBRUQsTUFBSSxHQUFHLFlBQVksSUFBSSxFQUFFO0FBQ3ZCLE9BQUcsR0FBRyxTQUFTLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxRQUFRLElBQUksT0FBTyxDQUFDLENBQUM7R0FDeEQ7O0FBRUQsTUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQ3hCLFdBQU8sU0FBUyxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQztHQUN0Qzs7QUFFRCxNQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDdEIsV0FBTyxTQUFTLENBQUMsV0FBVyxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQztHQUM3Qzs7QUFFRCxNQUFJLEdBQUcsWUFBWSxHQUFHLEVBQUU7QUFDdEIsV0FBTyxHQUFHLENBQUM7R0FDWjs7QUFFRCxNQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsRUFBRTtBQUMzQixRQUFJO0FBQ0YsU0FBRyxH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LEdBQUcsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO0FBQzNCLFNBQU8sTUFBTSxDQUFDLE1BQU0sR0FBRyxNQUFNLEVBQUU7QUFDN0IsVUFBTSxTQUFPLE1BQU0sQUFBRSxDQUFDO0dBQ3ZCOztBQUVELFNBQU8sTUFBTSxDQUFDO0NBQ2Y7O0FBRUQsU0FBUyxlQUFlLENBQUMsRUFBRSxFQUFFO0FBQzNCLE1BQUksRUFBRSxLQUFLLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQzs7QUFFekIsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO0FBQ2hELE1BQUksQ0FBQyxFQUFFO0FBQ0wsV0FDRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFBLElBQ3JCLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQ2xCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFBLEdBQUksRUFBRSxDQUFDLEFBQUMsR0FBRyxFQUFFLENBQzVDO0dBQ0g7QUFDRCxTQUFPLEtBQUssQ0FBQztDQUNkIiwiZmlsZSI6InN0cmluZy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSAnLi4vaGVscGVycyc7XG5cbmNvbnN0IFNxbFN0cmluZyA9IHt9O1xuZXhwb3J0IHsgU3FsU3RyaW5nIGFzIGRlZmF1bHQgfTtcblxuU3FsU3RyaW5nLmVzY2FwZSA9IGZ1bmN0aW9uKHZhbCwgdGltZVpvbmUpIHtcbiAgLy8gQ2FuJ3QgZG8gcmVxdWlyZSBvbiB0b3Agb2YgZmlsZSBiZWNhdXNlIFJhdyBoYXMgbm90IHlldCBiZWVuIGluaXRpYWxpemVkXG4gIC8vIHdoZW4gdGhpcyBmaWxlIGlzIGV4ZWN1dGVkIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgY29uc3QgUmF3ID0gcmVxdWlyZSgnLi4vcmF3JylcblxuICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICdOVUxMJztcbiAgfVxuXG4gIHN3aXRjaCAodHlwZW9mIHZhbCkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOiByZXR1cm4gKHZhbCkgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgIGNhc2UgJ251bWJlcic6IHJldHVybiB2YWwrJyc7XG4gIH1cblxuICBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHZhbCA9IFNxbFN0cmluZy5kYXRlVG9TdHJpbmcodmFsLCB0aW1lWm9uZSB8fCAnbG9jYWwnKTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIHJldHVybiBTcWxTdHJpbmcuYnVmZmVyVG9TdHJpbmcodmFsKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gU3FsU3RyaW5nLmFycmF5VG9MaXN0KHZhbCwgdGltZVpvbmUpO1xuICB9XG5cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFJhdykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICB0cnkge1xuICAgICAgdmFsID0gSlNPTi5zdHJpbmdpZnkodmFsKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhlbHBlcnMud2FybihlKVxuICAgICAgdmFsID0gdmFsICsgJydcbiAgICB9XG4gIH1cblxuICB2YWwgPSB2YWwucmVwbGFjZSgvKFxcXFxcXD8pfFtcXDBcXG5cXHJcXGJcXHRcXFxcXFwnXFx4MWFdL2csIGZ1bmN0aW9uKHMpIHtcbiAgICBzd2l0Y2gocykge1xuICAgICAgY2FzZSBcIlxcMFwiOiByZXR1cm4gXCJcXFxcMFwiO1xuICAgICAgY2FzZSBcIlxcblwiOiByZXR1cm4gXCJcXFxcblwiO1xuICAgICAgY2FzZSBcIlxcclwiOiByZXR1cm4gXCJcXFxcclwiO1xuICAgICAgY2FzZSBcIlxcYlwiOiByZXR1cm4gXCJcXFxcYlwiO1xuICAgICAgY2FzZSBcIlxcdFwiOiByZXR1cm4gXCJcXFxcdFwiO1xuICAgICAgY2FzZSBcIlxceDFhXCI6IHJldHVybiBcIlxcXFxaXCI7XG4gICAgICBjYXNlIFwiXFxcXD9cIjogcmV0dXJuIFwiP1wiO1xuICAgICAgY2FzZSBcIlxcJ1wiOiByZXR1cm4gXCInJ1wiO1xuICAgICAgZGVmYXVsdDogcmV0dXJuIGBcXCR7c31gO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBgJyR7dmFsfSdgO1xufTtcblxuU3FsU3RyaW5nLmFycmF5VG9MaXN0ID0gZnVuY3Rpb24oYXJyYXksIHRpbWVab25lKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICByZXR1cm4gYXJyYXkubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkgcmV0dXJuIGAoJHtTcWxTdHJpbmcuYXJyYXlUb0xpc3QodiwgdGltZVpvbmUpfSlgO1xuICAgIHJldHVybiBzZWxmLmVzY2FwZSh2LCB0aW1lWm9uZSk7XG4gIH0pLmpvaW4oJywgJyk7XG59O1xuXG5TcWxTdHJpbmcuZm9ybWF0ID0gZnVuY3Rpb24oc3FsLCB2YWx1ZXMsIHRpbWVab25lKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICB2YWx1ZXMgPSB2YWx1ZXMgPT0gbnVsbCA/IFtdIDogW10uY29uY2F0KHZhbHVlcyk7XG4gIGxldCBpbmRleCA9IDA7XG4gIHJldHVybiBzcWwucmVwbGFjZSgvXFxcXD9cXD8vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAobWF0Y2ggPT09ICdcXFxcPycpIHJldHVybiBtYXRjaDtcbiAgICBpZiAoaW5kZXggPT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXgrK107XG4gICAgcmV0dXJuIHNlbGYuZXNjYXBlKHZhbHVlLCB0aW1lWm9uZSlcbiAgfSkucmVwbGFjZSgnXFxcXD8nLCAnPycpO1xufTtcblxuU3FsU3RyaW5nLmRhdGVUb1N0cmluZyA9IGZ1bmN0aW9uKGRhdGUsIHRpbWVab25lKSB7XG4gIGNvbnN0IGR0ID0gbmV3IERhdGUoZGF0ZSk7XG5cbiAgaWYgKHRpbWVab25lICE9PSAnbG9jYWwnKSB7XG4gICAgY29uc3QgdHogPSBjb252ZXJ0VGltZXpvbmUodGltZVpvbmUpO1xuXG4gICAgZHQuc2V0VGltZShkdC5nZXRUaW1lKCkgKyAoZHQuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwKSk7XG4gICAgaWYgKHR6ICE9PSBmYWxzZSkge1xuICAgICAgZHQuc2V0VGltZShkdC5nZXRUaW1lKCkgKyAodHogKiA2MDAwMCkpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHllYXIgPSBkdC5nZXRGdWxsWWVhcigpO1xuICBjb25zdCBtb250aCA9IHplcm9QYWQoZHQuZ2V0TW9udGgoKSArIDEsIDIpO1xuICBjb25zdCBkYXkgPSB6ZXJvUGFkKGR0LmdldERhdGUoKSwgMik7XG4gIGNvbnN0IGhvdXIgPSB6ZXJvUGFkKGR0LmdldEhvdXJzKCksIDIpO1xuICBjb25zdCBtaW51dGUgPSB6ZXJvUGFkKGR0LmdldE1pbnV0ZXMoKSwgMik7XG4gIGNvbnN0IHNlY29uZCA9IHplcm9QYWQoZHQuZ2V0U2Vjb25kcygpLCAyKTtcbiAgY29uc3QgbWlsbGlzZWNvbmQgPSB6ZXJvUGFkKGR0LmdldE1pbGxpc2Vjb25kcygpLCAzKTtcblxuICByZXR1cm4gKFxuICAgIHllYXIgKyAnLScgKyBtb250aCArICctJyArIGRheSArICcgJyArIGhvdXIgKyAnOicgKyBtaW51dGUgKyAnOicgK1xuICAgIHNlY29uZCArICcuJyArIG1pbGxpc2Vjb25kXG4gICk7XG59O1xuXG5TcWxTdHJpbmcuYnVmZmVyVG9TdHJpbmcgPSBmdW5jdGlvbiBidWZmZXJUb1N0cmluZyhidWZmZXIpIHtcbiAgcmV0dXJuIGBYJyR7YnVmZmVyLnRvU3RyaW5nKCdoZXgnKX0nYDtcbn1cblxuZnVuY3Rpb24gemVyb1BhZChudW1iZXIsIGxlbmd0aCkge1xuICBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKTtcbiAgd2hpbGUgKG51bWJlci5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICBudW1iZXIgPSBgMCR7bnVtYmVyfWA7XG4gIH1cblxuICByZXR1cm4gbnVtYmVyO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VGltZXpvbmUodHopIHtcbiAgaWYgKHR6ID09PSBcIlpcIikgcmV0dXJuIDA7XG5cbiAgY29uc3QgbSA9IHR6Lm1hdGNoKC8oW1xcK1xcLVxcc10pKFxcZFxcZCk6PyhcXGRcXGQpPy8pO1xuICBpZiAobSkge1xuICAgIHJldHVybiAoXG4gICAgICAobVsxXSA9PT0gJy0nID8gLTEgOiAxKSAqXG4gICAgICAocGFyc2VJbnQobVsyXSwgMTApICtcbiAgICAgICgobVszXSA/IHBhcnNlSW50KG1bM10sIDEwKSA6IDApIC8gNjApKSAqIDYwXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iXX0=
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20).Buffer))

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = makeClient;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _lodash = __webpack_require__(5);

	// Ensure the client has fresh objects so we can tack onto
	// the prototypes without mutating them globally.

	function makeClient(ParentClient) {

	  if (typeof ParentClient.prototype === 'undefined') {
	    throw new Error('A valid parent client must be passed to makeClient');
	  }

	  function Client(config) {
	    ParentClient.call(this, config);
	  }
	  _inherits2['default'](Client, ParentClient);

	  function Formatter(client) {
	    Formatter.super_.call(this, client);
	  }
	  _inherits2['default'](Formatter, ParentClient.prototype.Formatter);

	  function QueryBuilder(client) {
	    QueryBuilder.super_.call(this, client);
	  }
	  _inherits2['default'](QueryBuilder, ParentClient.prototype.QueryBuilder);

	  function SchemaBuilder(client) {
	    SchemaBuilder.super_.call(this, client);
	  }
	  _inherits2['default'](SchemaBuilder, ParentClient.prototype.SchemaBuilder);

	  function SchemaCompiler(client, builder) {
	    SchemaCompiler.super_.call(this, client, builder);
	  }
	  _inherits2['default'](SchemaCompiler, ParentClient.prototype.SchemaCompiler);

	  function TableBuilder(client, method, tableName, fn) {
	    TableBuilder.super_.call(this, client, method, tableName, fn);
	  }
	  _inherits2['default'](TableBuilder, ParentClient.prototype.TableBuilder);

	  function TableCompiler(client, tableBuilder) {
	    TableCompiler.super_.call(this, client, tableBuilder);
	  }
	  _inherits2['default'](TableCompiler, ParentClient.prototype.TableCompiler);

	  function ColumnBuilder(client, tableBuilder, type, args) {
	    ColumnBuilder.super_.call(this, client, tableBuilder, type, args);
	  }
	  _inherits2['default'](ColumnBuilder, ParentClient.prototype.ColumnBuilder);

	  function ColumnCompiler(client, tableCompiler, columnBuilder) {
	    ColumnCompiler.super_.call(this, client, tableCompiler, columnBuilder);
	  }
	  _inherits2['default'](ColumnCompiler, ParentClient.prototype.ColumnCompiler);

	  _lodash.assign(Client.prototype, {
	    Formatter: Formatter,
	    QueryBuilder: QueryBuilder,
	    SchemaBuilder: SchemaBuilder,
	    SchemaCompiler: SchemaCompiler,
	    TableBuilder: TableBuilder,
	    TableCompiler: TableCompiler,
	    ColumnBuilder: ColumnBuilder,
	    ColumnCompiler: ColumnCompiler
	  });

	  return Client;
	}

	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL21ha2UtY2xpZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztxQkFPd0IsVUFBVTs7Ozt3QkFOYixVQUFVOzs7O3NCQUVSLFFBQVE7Ozs7O0FBSWhCLFNBQVMsVUFBVSxDQUFDLFlBQVksRUFBRTs7QUFFL0MsTUFBSSxPQUFPLFlBQVksQ0FBQyxTQUFTLEtBQUssV0FBVyxFQUFFO0FBQ2pELFVBQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQTtHQUN0RTs7QUFFRCxXQUFTLE1BQU0sQ0FBQyxNQUFNLEVBQUU7QUFDdEIsZ0JBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFBO0dBQ2hDO0FBQ0Qsd0JBQVMsTUFBTSxFQUFFLFlBQVksQ0FBQyxDQUFBOztBQUU5QixXQUFTLFNBQVMsQ0FBQyxNQUFNLEVBQUU7QUFDekIsYUFBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFBO0dBQ3BDO0FBQ0Qsd0JBQVMsU0FBUyxFQUFFLFlBQVksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUE7O0FBRXJELFdBQVMsWUFBWSxDQUFDLE1BQU0sRUFBRTtBQUM1QixnQkFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFBO0dBQ3ZDO0FBQ0Qsd0JBQVMsWUFBWSxFQUFFLFlBQVksQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLENBQUE7O0FBRTNELFdBQVMsYUFBYSxDQUFDLE1BQU0sRUFBRTtBQUM3QixpQkFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFBO0dBQ3hDO0FBQ0Qsd0JBQVMsYUFBYSxFQUFFLFlBQVksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLENBQUE7O0FBRTdELFdBQVMsY0FBYyxDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUU7QUFDdkMsa0JBQWMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUE7R0FDbEQ7QUFDRCx3QkFBUyxjQUFjLEVBQUUsWUFBWSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsQ0FBQTs7QUFFL0QsV0FBUyxZQUFZLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsRUFBRSxFQUFFO0FBQ25ELGdCQUFZLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsRUFBRSxDQUFDLENBQUE7R0FDOUQ7QUFDRCx3QkFBUyxZQUFZLEVBQUUsWUFBWSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQTs7QUFFM0QsV0FBUyxhQUFhLENBQUMsTUFBTSxFQUFFLFlBQVksRUFBRTtBQUMzQyxpQkFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxZQUFZLENBQUMsQ0FBQTtHQUN0RDtBQUNELHdCQUFTLGFBQWEsRUFBRSxZQUFZLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFBOztBQUU3RCxXQUFTLGFBQWEsQ0FBQyxNQUFNLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7QUFDdkQsaUJBQWEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQTtHQUNsRTtBQUNELHdCQUFTLGFBQWEsRUFBRSxZQUFZLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFBOztBQUU3RCxXQUFTLGNBQWMsQ0FBQyxNQUFNLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRTtBQUM1RCxrQkFBYyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxhQUFhLEVBQUUsYUFBYSxDQUFDLENBQUE7R0FDdkU7QUFDRCx3QkFBUyxjQUFjLEVBQUUsWUFBWSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsQ0FBQTs7QUFFL0QsaUJBQU8sTUFBTSxDQUFDLFNBQVMsRUFBRTtBQUN2QixhQUFTLEVBQVQsU0FBUztBQUNULGdCQUFZLEVBQVosWUFBWTtBQUNaLGlCQUFhLEVBQWIsYUFBYTtBQUNiLGtCQUFjLEVBQWQsY0FBYztBQUNkLGdCQUFZLEVBQVosWUFBWTtBQUNaLGlCQUFhLEVBQWIsYUFBYTtBQUNiLGlCQUFhLEVBQWIsYUFBYTtBQUNiLGtCQUFjLEVBQWQsY0FBYztHQUNmLENBQUMsQ0FBQTs7QUFFRixTQUFPLE1BQU0sQ0FBQTtDQUNkIiwiZmlsZSI6Im1ha2UtY2xpZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICdsb2Rhc2gnXG5cbi8vIEVuc3VyZSB0aGUgY2xpZW50IGhhcyBmcmVzaCBvYmplY3RzIHNvIHdlIGNhbiB0YWNrIG9udG9cbi8vIHRoZSBwcm90b3R5cGVzIHdpdGhvdXQgbXV0YXRpbmcgdGhlbSBnbG9iYWxseS5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1ha2VDbGllbnQoUGFyZW50Q2xpZW50KSB7XG5cbiAgaWYgKHR5cGVvZiBQYXJlbnRDbGllbnQucHJvdG90eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQSB2YWxpZCBwYXJlbnQgY2xpZW50IG11c3QgYmUgcGFzc2VkIHRvIG1ha2VDbGllbnQnKVxuICB9XG5cbiAgZnVuY3Rpb24gQ2xpZW50KGNvbmZpZykge1xuICAgIFBhcmVudENsaWVudC5jYWxsKHRoaXMsIGNvbmZpZylcbiAgfVxuICBpbmhlcml0cyhDbGllbnQsIFBhcmVudENsaWVudClcblxuICBmdW5jdGlvbiBGb3JtYXR0ZXIoY2xpZW50KSB7XG4gICAgRm9ybWF0dGVyLnN1cGVyXy5jYWxsKHRoaXMsIGNsaWVudClcbiAgfVxuICBpbmhlcml0cyhGb3JtYXR0ZXIsIFBhcmVudENsaWVudC5wcm90b3R5cGUuRm9ybWF0dGVyKVxuXG4gIGZ1bmN0aW9uIFF1ZXJ5QnVpbGRlcihjbGllbnQpIHtcbiAgICBRdWVyeUJ1aWxkZXIuc3VwZXJfLmNhbGwodGhpcywgY2xpZW50KVxuICB9XG4gIGluaGVyaXRzKFF1ZXJ5QnVpbGRlciwgUGFyZW50Q2xpZW50LnByb3RvdHlwZS5RdWVyeUJ1aWxkZXIpXG5cbiAgZnVuY3Rpb24gU2NoZW1hQnVpbGRlcihjbGllbnQpIHtcbiAgICBTY2hlbWFCdWlsZGVyLnN1cGVyXy5jYWxsKHRoaXMsIGNsaWVudClcbiAgfVxuICBpbmhlcml0cyhTY2hlbWFCdWlsZGVyLCBQYXJlbnRDbGllbnQucHJvdG90eXBlLlNjaGVtYUJ1aWxkZXIpXG5cbiAgZnVuY3Rpb24gU2NoZW1hQ29tcGlsZXIoY2xpZW50LCBidWlsZGVyKSB7XG4gICAgU2NoZW1hQ29tcGlsZXIuc3VwZXJfLmNhbGwodGhpcywgY2xpZW50LCBidWlsZGVyKVxuICB9XG4gIGluaGVyaXRzKFNjaGVtYUNvbXBpbGVyLCBQYXJlbnRDbGllbnQucHJvdG90eXBlLlNjaGVtYUNvbXBpbGVyKVxuXG4gIGZ1bmN0aW9uIFRhYmxlQnVpbGRlcihjbGllbnQsIG1ldGhvZCwgdGFibGVOYW1lLCBmbikge1xuICAgIFRhYmxlQnVpbGRlci5zdXBlcl8uY2FsbCh0aGlzLCBjbGllbnQsIG1ldGhvZCwgdGFibGVOYW1lLCBmbilcbiAgfVxuICBpbmhlcml0cyhUYWJsZUJ1aWxkZXIsIFBhcmVudENsaWVudC5wcm90b3R5cGUuVGFibGVCdWlsZGVyKVxuXG4gIGZ1bmN0aW9uIFRhYmxlQ29tcGlsZXIoY2xpZW50LCB0YWJsZUJ1aWxkZXIpIHtcbiAgICBUYWJsZUNvbXBpbGVyLnN1cGVyXy5jYWxsKHRoaXMsIGNsaWVudCwgdGFibGVCdWlsZGVyKVxuICB9XG4gIGluaGVyaXRzKFRhYmxlQ29tcGlsZXIsIFBhcmVudENsaWVudC5wcm90b3R5cGUuVGFibGVDb21waWxlcilcblxuICBmdW5jdGlvbiBDb2x1bW5CdWlsZGVyKGNsaWVudCwgdGFibGVCdWlsZGVyLCB0eXBlLCBhcmdzKSB7XG4gICAgQ29sdW1uQnVpbGRlci5zdXBlcl8uY2FsbCh0aGlzLCBjbGllbnQsIHRhYmxlQnVpbGRlciwgdHlwZSwgYXJncylcbiAgfVxuICBpbmhlcml0cyhDb2x1bW5CdWlsZGVyLCBQYXJlbnRDbGllbnQucHJvdG90eXBlLkNvbHVtbkJ1aWxkZXIpXG5cbiAgZnVuY3Rpb24gQ29sdW1uQ29tcGlsZXIoY2xpZW50LCB0YWJsZUNvbXBpbGVyLCBjb2x1bW5CdWlsZGVyKSB7XG4gICAgQ29sdW1uQ29tcGlsZXIuc3VwZXJfLmNhbGwodGhpcywgY2xpZW50LCB0YWJsZUNvbXBpbGVyLCBjb2x1bW5CdWlsZGVyKVxuICB9XG4gIGluaGVyaXRzKENvbHVtbkNvbXBpbGVyLCBQYXJlbnRDbGllbnQucHJvdG90eXBlLkNvbHVtbkNvbXBpbGVyKVxuXG4gIGFzc2lnbihDbGllbnQucHJvdG90eXBlLCB7XG4gICAgRm9ybWF0dGVyLFxuICAgIFF1ZXJ5QnVpbGRlcixcbiAgICBTY2hlbWFCdWlsZGVyLFxuICAgIFNjaGVtYUNvbXBpbGVyLFxuICAgIFRhYmxlQnVpbGRlcixcbiAgICBUYWJsZUNvbXBpbGVyLFxuICAgIENvbHVtbkJ1aWxkZXIsXG4gICAgQ29sdW1uQ29tcGlsZXJcbiAgfSlcblxuICByZXR1cm4gQ2xpZW50XG59XG4iXX0=

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = parseConnectionString;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _url = __webpack_require__(86);

	var _url2 = _interopRequireDefault(_url);

	var _pgConnectionString = __webpack_require__(91);

	function parseConnectionString(str) {
	  var parsed = _url2['default'].parse(str);
	  var protocol = parsed.protocol;

	  if (protocol && protocol.indexOf('maria') === 0) {
	    protocol = 'maria';
	  }
	  if (protocol === null) {
	    return {
	      client: 'sqlite3',
	      connection: {
	        filename: str
	      }
	    };
	  }
	  if (protocol.slice(-1) === ':') {
	    protocol = protocol.slice(0, -1);
	  }
	  return {
	    client: protocol,
	    connection: protocol === 'postgres' ? _pgConnectionString.parse(str) : connectionObject(parsed)
	  };
	}

	function connectionObject(parsed) {
	  var connection = {};
	  var db = parsed.pathname;
	  if (db[0] === '/') {
	    db = db.slice(1);
	  }
	  if (parsed.protocol.indexOf('maria') === 0) {
	    connection.db = db;
	  } else {
	    connection.database = db;
	  }
	  if (parsed.hostname) {
	    if (parsed.protocol.indexOf('mssql') === 0) {
	      connection.server = parsed.hostname;
	    } else {
	      connection.host = parsed.hostname;
	    }
	  }
	  if (parsed.port) {
	    connection.port = parsed.port;
	  }
	  if (parsed.auth) {
	    var idx = parsed.auth.indexOf(':');
	    if (idx !== -1) {
	      connection.user = parsed.auth.slice(0, idx);
	      if (idx < parsed.auth.length - 1) {
	        connection.password = parsed.auth.slice(idx + 1);
	      }
	    } else {
	      connection.user = parsed.auth;
	    }
	  }
	  return connection;
	}
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsL3BhcnNlLWNvbm5lY3Rpb24uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O3FCQUl3QixxQkFBcUI7Ozs7bUJBSDdCLEtBQUs7Ozs7a0NBQ1ksc0JBQXNCOztBQUV4QyxTQUFTLHFCQUFxQixDQUFDLEdBQUcsRUFBRTtBQUNqRCxNQUFNLE1BQU0sR0FBRyxpQkFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUE7TUFDdkIsUUFBUSxHQUFLLE1BQU0sQ0FBbkIsUUFBUTs7QUFDZCxNQUFJLFFBQVEsSUFBSSxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtBQUMvQyxZQUFRLEdBQUcsT0FBTyxDQUFBO0dBQ25CO0FBQ0QsTUFBSSxRQUFRLEtBQUssSUFBSSxFQUFFO0FBQ3JCLFdBQU87QUFDTCxZQUFNLEVBQUUsU0FBUztBQUNqQixnQkFBVSxFQUFFO0FBQ1YsZ0JBQVEsRUFBRSxHQUFHO09BQ2Q7S0FDRixDQUFBO0dBQ0Y7QUFDRCxNQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLEVBQUU7QUFDOUIsWUFBUSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7R0FDbEM7QUFDRCxTQUFPO0FBQ0wsVUFBTSxFQUFFLFFBQVE7QUFDaEIsY0FBVSxFQUFFLFFBQVEsS0FBSyxVQUFVLEdBQUcsMEJBQVEsR0FBRyxDQUFDLEdBQUcsZ0JBQWdCLENBQUMsTUFBTSxDQUFDO0dBQzlFLENBQUE7Q0FDRjs7QUFFRCxTQUFTLGdCQUFnQixDQUFDLE1BQU0sRUFBRTtBQUNoQyxNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUM7QUFDdEIsTUFBSSxFQUFFLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQztBQUN6QixNQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLEVBQUU7QUFDakIsTUFBRSxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUE7R0FDakI7QUFDRCxNQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtBQUMxQyxjQUFVLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQTtHQUNuQixNQUFNO0FBQ0wsY0FBVSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUE7R0FDekI7QUFDRCxNQUFJLE1BQU0sQ0FBQyxRQUFRLEVBQUU7QUFDbkIsUUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDMUMsZ0JBQVUsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQztLQUNyQyxNQUFNO0FBQ0wsZ0JBQVUsQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQztLQUNuQztHQUNGO0FBQ0QsTUFBSSxNQUFNLENBQUMsSUFBSSxFQUFFO0FBQ2YsY0FBVSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDO0dBQy9CO0FBQ0QsTUFBSSxNQUFNLENBQUMsSUFBSSxFQUFFO0FBQ2YsUUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDckMsUUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFDLEVBQUU7QUFDZCxnQkFBVSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDNUMsVUFBSSxHQUFHLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO0FBQ2hDLGtCQUFVLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztPQUNsRDtLQUNGLE1BQU07QUFDTCxnQkFBVSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDO0tBQy9CO0dBQ0Y7QUFDRCxTQUFPLFVBQVUsQ0FBQTtDQUNsQiIsImZpbGUiOiJwYXJzZS1jb25uZWN0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgdXJsIGZyb20gJ3VybCdcbmltcG9ydCB7IHBhcnNlIGFzIHBhcnNlUEcgfSBmcm9tICdwZy1jb25uZWN0aW9uLXN0cmluZydcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2VDb25uZWN0aW9uU3RyaW5nKHN0cikge1xuICBjb25zdCBwYXJzZWQgPSB1cmwucGFyc2Uoc3RyKVxuICBsZXQgeyBwcm90b2NvbCB9ID0gcGFyc2VkXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5pbmRleE9mKCdtYXJpYScpID09PSAwKSB7XG4gICAgcHJvdG9jb2wgPSAnbWFyaWEnXG4gIH1cbiAgaWYgKHByb3RvY29sID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsaWVudDogJ3NxbGl0ZTMnLFxuICAgICAgY29ubmVjdGlvbjoge1xuICAgICAgICBmaWxlbmFtZTogc3RyXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwcm90b2NvbC5zbGljZSgtMSkgPT09ICc6Jykge1xuICAgIHByb3RvY29sID0gcHJvdG9jb2wuc2xpY2UoMCwgLTEpO1xuICB9XG4gIHJldHVybiB7XG4gICAgY2xpZW50OiBwcm90b2NvbCxcbiAgICBjb25uZWN0aW9uOiBwcm90b2NvbCA9PT0gJ3Bvc3RncmVzJyA/IHBhcnNlUEcoc3RyKSA6IGNvbm5lY3Rpb25PYmplY3QocGFyc2VkKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbm5lY3Rpb25PYmplY3QocGFyc2VkKSB7XG4gIGNvbnN0IGNvbm5lY3Rpb24gPSB7fTtcbiAgbGV0IGRiID0gcGFyc2VkLnBhdGhuYW1lO1xuICBpZiAoZGJbMF0gPT09ICcvJykge1xuICAgIGRiID0gZGIuc2xpY2UoMSlcbiAgfVxuICBpZiAocGFyc2VkLnByb3RvY29sLmluZGV4T2YoJ21hcmlhJykgPT09IDApIHtcbiAgICBjb25uZWN0aW9uLmRiID0gZGJcbiAgfSBlbHNlIHtcbiAgICBjb25uZWN0aW9uLmRhdGFiYXNlID0gZGJcbiAgfVxuICBpZiAocGFyc2VkLmhvc3RuYW1lKSB7XG4gICAgaWYgKHBhcnNlZC5wcm90b2NvbC5pbmRleE9mKCdtc3NxbCcpID09PSAwKSB7XG4gICAgICBjb25uZWN0aW9uLnNlcnZlciA9IHBhcnNlZC5ob3N0bmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29ubmVjdGlvbi5ob3N0ID0gcGFyc2VkLmhvc3RuYW1lO1xuICAgIH1cbiAgfVxuICBpZiAocGFyc2VkLnBvcnQpIHtcbiAgICBjb25uZWN0aW9uLnBvcnQgPSBwYXJzZWQucG9ydDtcbiAgfVxuICBpZiAocGFyc2VkLmF1dGgpIHtcbiAgICBjb25zdCBpZHggPSBwYXJzZWQuYXV0aC5pbmRleE9mKCc6Jyk7XG4gICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgIGNvbm5lY3Rpb24udXNlciA9IHBhcnNlZC5hdXRoLnNsaWNlKDAsIGlkeCk7XG4gICAgICBpZiAoaWR4IDwgcGFyc2VkLmF1dGgubGVuZ3RoIC0gMSkge1xuICAgICAgICBjb25uZWN0aW9uLnBhc3N3b3JkID0gcGFyc2VkLmF1dGguc2xpY2UoaWR4ICsgMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbm5lY3Rpb24udXNlciA9IHBhcnNlZC5hdXRoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29ubmVjdGlvblxufVxuIl19

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var punycode = __webpack_require__(87);

	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;

	exports.Url = Url;

	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}

	// Reference: RFC 3986, RFC 1808, RFC 2396

	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,

	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(88);

	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;

	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}

	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }

	  var rest = url;

	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();

	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }

	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }

	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {

	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c

	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.

	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }

	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }

	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }

	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;

	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);

	    // pull out port.
	    this.parseHost();

	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';

	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';

	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }

	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }

	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }

	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;

	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }

	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {

	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }


	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }

	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }

	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};

	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}

	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }

	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';

	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }

	  if (this.query &&
	      isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }

	  var search = this.search || (query && ('?' + query)) || '';

	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }

	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;

	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');

	  return protocol + host + pathname + search + hash;
	};

	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}

	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};

	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}

	Url.prototype.resolveObject = function(relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }

	  var result = new Url();
	  Object.keys(this).forEach(function(k) {
	    result[k] = this[k];
	  }, this);

	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;

	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }

	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });

	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }

	    result.href = result.format();
	    return result;
	  }

	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }

	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }

	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];

	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }

	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }

	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }

	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');

	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }

	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }

	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }

	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');

	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }

	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }

	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }

	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};

	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};

	function isString(arg) {
	  return typeof arg === "string";
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return  arg == null;
	}


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {

		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}

		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,

		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},

		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,

		/** Temporary variable */
		key;

		/*--------------------------------------------------------------------------*/

		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}

		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}

		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}

		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}

		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}

		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

					if (index >= inputLength) {
						error('invalid-input');
					}

					digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}

					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

					if (digit < t) {
						break;
					}

					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}

					w *= baseMinusT;

				}

				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);

			}

			return ucs2encode(output);
		}

		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;

			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);

			// Cache the length
			inputLength = input.length;

			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;

			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}

			handledCPCount = basicLength = output.length;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];

					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}

					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}

				++delta;
				++n;

			}
			return output.join('');
		}

		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}

		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)(module), (function() { return this; }())))

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.decode = exports.parse = __webpack_require__(89);
	exports.encode = exports.stringify = __webpack_require__(90);


/***/ },
/* 89 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};


/***/ },
/* 90 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);

	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var url = __webpack_require__(86);

	//Parse method copied from https://github.com/brianc/node-postgres
	//Copyright (c) 2010-2014 Brian Carlson (brian.m.carlson@gmail.com)
	//MIT License

	//parses a connection string
	function parse(str) {
	  var config;
	  //unix socket
	  if(str.charAt(0) === '/') {
	    config = str.split(' ');
	    return { host: config[0], database: config[1] };
	  }
	  // url parse expects spaces encoded as %20
	  if(/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
	    str = encodeURI(str).replace(/\%25(\d\d)/g, "%$1");
	  }
	  var result = url.parse(str, true);
	  config = {};

	  if (result.query.application_name) {
	    config.application_name = result.query.application_name;
	  }
	  if (result.query.fallback_application_name) {
	    config.fallback_application_name = result.query.fallback_application_name;
	  }

	  config.port = result.port;
	  if(result.protocol == 'socket:') {
	    config.host = decodeURI(result.pathname);
	    config.database = result.query.db;
	    config.client_encoding = result.query.encoding;
	    return config;
	  }
	  config.host = result.hostname;

	  // result.pathname is not always guaranteed to have a '/' prefix (e.g. relative urls)
	  // only strip the slash if it is present.
	  var pathname = result.pathname;
	  if (pathname && pathname.charAt(0) === '/') {
	    pathname = result.pathname.slice(1) || null;
	  }
	  config.database = pathname && decodeURI(pathname);

	  var auth = (result.auth || ':').split(':');
	  config.user = auth[0];
	  config.password = auth.splice(1).join(':');

	  var ssl = result.query.ssl;
	  if (ssl === 'true' || ssl === '1') {
	    config.ssl = true;
	  }

	  return config;
	}

	module.exports = {
	  parse: parse
	};


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./maria/index.js": 93,
		"./mssql/index.js": 103,
		"./mysql/index.js": 94,
		"./mysql2/index.js": 111,
		"./oracle/index.js": 114,
		"./postgres/index.js": 125,
		"./sqlite3/index.js": 133,
		"./strong-oracle/index.js": 140,
		"./websql/index.js": 142
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 92;


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	
	// MariaSQL Client
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _mysql = __webpack_require__(94);

	var _mysql2 = _interopRequireDefault(_mysql);

	var _promise = __webpack_require__(43);

	var _promise2 = _interopRequireDefault(_promise);

	var _queryString = __webpack_require__(83);

	var _queryString2 = _interopRequireDefault(_queryString);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _transaction = __webpack_require__(101);

	var _transaction2 = _interopRequireDefault(_transaction);

	var _lodash = __webpack_require__(5);

	function Client_MariaSQL(config) {
	  _mysql2['default'].call(this, config);
	}
	_inherits2['default'](Client_MariaSQL, _mysql2['default']);

	_lodash.assign(Client_MariaSQL.prototype, {

	  dialect: 'mariadb',

	  driverName: 'mariasql',

	  Transaction: _transaction2['default'],

	  _driver: function _driver() {
	    return __webpack_require__(102);
	  },

	  // Get a raw connection, called by the `pool` whenever a new
	  // connection needs to be added to the pool.
	  acquireRawConnection: function acquireRawConnection() {
	    var connection = new this.driver();
	    connection.connect(_lodash.assign({ metadata: true }, this.connectionSettings));
	    return new _promise2['default'](function (resolver, rejecter) {
	      connection.on('ready', function () {
	        connection.removeAllListeners('end');
	        connection.removeAllListeners('error');
	        resolver(connection);
	      }).on('error', rejecter);
	    });
	  },

	  // Used to explicitly close a connection, called internally by the pool
	  // when a connection times out or the pool is shutdown.
	  destroyRawConnection: function destroyRawConnection(connection, cb) {
	    connection.end();
	    cb();
	  },

	  // Return the database for the MariaSQL client.
	  database: function database() {
	    return this.connectionSettings.db;
	  },

	  // Grab a connection, run the query via the MariaSQL streaming interface,
	  // and pass that through to the stream we've sent back to the client.
	  _stream: function _stream(connection, sql, stream) {
	    return new _promise2['default'](function (resolver, rejecter) {
	      connection.query(sql.sql, sql.bindings).on('result', function (res) {
	        res.on('error', rejecter).on('end', function () {
	          resolver(res.info);
	        }).on('data', function (data) {
	          stream.write(handleRow(data, res.info.metadata));
	        });
	      }).on('error', rejecter);
	    });
	  },

	  // Runs the query on the specified connection, providing the bindings
	  // and any other necessary prep work.
	  _query: function _query(connection, obj) {
	    var tz = this.connectionSettings.timezone || 'local';
	    return new _promise2['default'](function (resolver, rejecter) {
	      if (!obj.sql) return resolver();
	      var sql = _queryString2['default'].format(obj.sql, obj.bindings, tz);
	      connection.query(sql, function (err, rows) {
	        if (err) {
	          return rejecter(err);
	        }
	        handleRows(rows, rows.info.metadata);
	        obj.response = [rows, rows.info];
	        resolver(obj);
	      });
	    });
	  },

	  // Process the response as returned from the query.
	  processResponse: function processResponse(obj, runner) {
	    var response = obj.response;
	    var method = obj.method;

	    var rows = response[0];
	    var data = response[1];
	    if (obj.output) return obj.output.call(runner, rows /*, fields*/);
	    switch (method) {
	      case 'select':
	      case 'pluck':
	      case 'first':
	        {
	          var resp = helpers.skim(rows);
	          if (method === 'pluck') return _lodash.map(resp, obj.pluck);
	          return method === 'first' ? resp[0] : resp;
	        }
	      case 'insert':
	        return [data.insertId];
	      case 'del':
	      case 'update':
	      case 'counter':
	        return parseInt(data.affectedRows, 10);
	      default:
	        return response;
	    }
	  },

	  ping: function ping(resource, callback) {
	    resource.query('SELECT 1', callback);
	  }

	});

	function parseType(value, type) {
	  switch (type) {
	    case 'DATETIME':
	    case 'TIMESTAMP':
	      return new Date(value);
	    case 'INTEGER':
	      return parseInt(value, 10);
	    default:
	      return value;
	  }
	}

	function handleRow(row, metadata) {
	  var keys = Object.keys(metadata);
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var type = metadata[key].type;

	    row[key] = parseType(row[key], type);
	  }
	  return row;
	}

	function handleRows(rows, metadata) {
	  for (var i = 0; i < rows.length; i++) {
	    var row = rows[i];
	    handleRow(row, metadata);
	  }
	  return rows;
	}

	exports['default'] = Client_MariaSQL;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy9tYXJpYS9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozt3QkFHcUIsVUFBVTs7OztxQkFDTixVQUFVOzs7O3VCQUNmLGVBQWU7Ozs7MkJBQ2Isb0JBQW9COzs7O3VCQUNqQixlQUFlOztJQUE1QixPQUFPOzsyQkFDSyxlQUFlOzs7O3NCQUVYLFFBQVE7O0FBRXBDLFNBQVMsZUFBZSxDQUFDLE1BQU0sRUFBRTtBQUMvQixxQkFBYSxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFBO0NBQ2hDO0FBQ0Qsc0JBQVMsZUFBZSxxQkFBZSxDQUFBOztBQUV2QyxlQUFPLGVBQWUsQ0FBQyxTQUFTLEVBQUU7O0FBRWhDLFNBQU8sRUFBRSxTQUFTOztBQUVsQixZQUFVLEVBQUUsVUFBVTs7QUFFdEIsYUFBVywwQkFBQTs7QUFFWCxTQUFPLEVBQUEsbUJBQUc7QUFDUixXQUFPLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQTtHQUMzQjs7OztBQUlELHNCQUFvQixFQUFBLGdDQUFHO0FBQ3JCLFFBQU0sVUFBVSxHQUFHLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQ3JDLGNBQVUsQ0FBQyxPQUFPLENBQUMsZUFBTyxFQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUMsRUFBRSxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO0FBQ3RFLFdBQU8seUJBQVksVUFBUyxRQUFRLEVBQUUsUUFBUSxFQUFFO0FBQzlDLGdCQUFVLENBQ1AsRUFBRSxDQUFDLE9BQU8sRUFBRSxZQUFXO0FBQ3RCLGtCQUFVLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDckMsa0JBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUN2QyxnQkFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDO09BQ3RCLENBQUMsQ0FDRCxFQUFFLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFD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LEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDWixJQUFJLEdBQUssUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUF0QixJQUFJOztBQUNaLE9BQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0dBQ3RDO0FBQ0QsU0FBTyxHQUFHLENBQUM7Q0FDWjs7QUFFRCxTQUFTLFVBQVUsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFO0FBQ2xDLE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3BDLFFBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwQixhQUFTLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0dBQzFCO0FBQ0QsU0FBTyxJQUFJLENBQUM7Q0FDYjs7cUJBRWMsZUFBZSIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLy8gTWFyaWFTUUwgQ2xpZW50XG4vLyAtLS0tLS0tXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuaW1wb3J0IENsaWVudF9NeVNRTCBmcm9tICcuLi9teXNxbCc7XG5pbXBvcnQgUHJvbWlzZSBmcm9tICcuLi8uLi9wcm9taXNlJztcbmltcG9ydCBTcWxTdHJpbmcgZnJvbSAnLi4vLi4vcXVlcnkvc3RyaW5nJztcbmltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSAnLi4vLi4vaGVscGVycyc7XG5pbXBvcnQgVHJhbnNhY3Rpb24gZnJvbSAnLi90cmFuc2FjdGlvbic7XG5cbmltcG9ydCB7IGFzc2lnbiwgbWFwIH0gZnJvbSAnbG9kYXNoJ1xuXG5mdW5jdGlvbiBDbGllbnRfTWFyaWFTUUwoY29uZmlnKSB7XG4gIENsaWVudF9NeVNRTC5jYWxsKHRoaXMsIGNvbmZpZylcbn1cbmluaGVyaXRzKENsaWVudF9NYXJpYVNRTCwgQ2xpZW50X015U1FMKVxuXG5hc3NpZ24oQ2xpZW50X01hcmlhU1FMLnByb3RvdHlwZSwge1xuXG4gIGRpYWxlY3Q6ICdtYXJpYWRiJyxcblxuICBkcml2ZXJOYW1lOiAnbWFyaWFzcWwnLFxuXG4gIFRyYW5zYWN0aW9uLFxuXG4gIF9kcml2ZXIoKSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ21hcmlhc3FsJylcbiAgfSxcblxuICAvLyBHZXQgYSByYXcgY29ubmVjdGlvbiwgY2FsbGVkIGJ5IHRoZSBgcG9vbGAgd2hlbmV2ZXIgYSBuZXdcbiAgLy8gY29ubmVjdGlvbiBuZWVkcyB0byBiZSBhZGRlZCB0byB0aGUgcG9vbC5cbiAgYWNxdWlyZVJhd0Nvbm5lY3Rpb24oKSB7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IG5ldyB0aGlzLmRyaXZlcigpO1xuICAgIGNvbm5lY3Rpb24uY29ubmVjdChhc3NpZ24oe21ldGFkYXRhOiB0cnVlfSwgdGhpcy5jb25uZWN0aW9uU2V0dGluZ3MpKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZXIsIHJlamVjdGVyKSB7XG4gICAgICBjb25uZWN0aW9uXG4gICAgICAgIC5vbigncmVhZHknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjb25uZWN0aW9uLnJlbW92ZUFsbExpc3RlbmVycygnZW5kJyk7XG4gICAgICAgICAgY29ubmVjdGlvbi5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Vycm9yJyk7XG4gICAgICAgICAgcmVzb2x2ZXIoY29ubmVjdGlvbik7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZXJyb3InLCByZWplY3Rlcik7XG4gICAgfSlcbiAgfSxcblxuICAvLyBVc2VkIHRvIGV4cGxpY2l0bHkgY2xvc2UgYSBjb25uZWN0aW9uLCBjYWxsZWQgaW50ZXJuYWxseSBieSB0aGUgcG9vbFxuICAvLyB3aGVuIGEgY29ubmVjdGlvbiB0aW1lcyBvdXQgb3IgdGhlIHBvb2wgaXMgc2h1dGRvd24uXG4gIGRlc3Ryb3lSYXdDb25uZWN0aW9uKGNvbm5lY3Rpb24sIGNiKSB7XG4gICAgY29ubmVjdGlvbi5lbmQoKVxuICAgIGNiKClcbiAgfSxcblxuICAvLyBSZXR1cm4gdGhlIGRhdGFiYXNlIGZvciB0aGUgTWFyaWFTUUwgY2xpZW50LlxuICBkYXRhYmFzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uU2V0dGluZ3MuZGI7XG4gIH0sXG5cbiAgLy8gR3JhYiBhIGNvbm5lY3Rpb24sIHJ1biB0aGUgcXVlcnkgdmlhIHRoZSBNYXJpYVNRTCBzdHJlYW1pbmcgaW50ZXJmYWNlLFxuICAvLyBhbmQgcGFzcyB0aGF0IHRocm91Z2ggdG8gdGhlIHN0cmVhbSB3ZSd2ZSBzZW50IGJhY2sgdG8gdGhlIGNsaWVudC5cbiAgX3N0cmVhbShjb25uZWN0aW9uLCBzcWwsIHN0cmVhbSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlciwgcmVqZWN0ZXIpIHtcbiAgICAgIGNvbm5lY3Rpb24ucXVlcnkoc3FsLnNxbCwgc3FsLmJpbmRpbmdzKVxuICAgICAgICAub24oJ3Jlc3VsdCcsIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgIHJlc1xuICAgICAgICAgICAgLm9uKCdlcnJvcicsIHJlamVjdGVyKVxuICAgICAgICAgICAgLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZXIocmVzLmluZm8pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgIHN0cmVhbS53cml0ZShoYW5kbGVSb3coZGF0YSwgcmVzLmluZm8ubWV0YWRhdGEpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZXJyb3InLCByZWplY3Rlcik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLy8gUnVucyB0aGUgcXVlcnkgb24gdGhlIHNwZWNpZmllZCBjb25uZWN0aW9uLCBwcm92aWRpbmcgdGhlIGJpbmRpbmdzXG4gIC8vIGFuZCBhbnkgb3RoZXIgbmVjZXNzYXJ5IHByZXAgd29yay5cbiAgX3F1ZXJ5KGNvbm5lY3Rpb24sIG9iaikge1xuICAgIGNvbnN0IHR6ID0gdGhpcy5jb25uZWN0aW9uU2V0dGluZ3MudGltZXpvbmUgfHwgJ2xvY2FsJztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZXIsIHJlamVjdGVyKSB7XG4gICAgICBpZiAoIW9iai5zcWwpIHJldHVybiByZXNvbHZlcigpXG4gICAgICBjb25zdCBzcWwgPSBTcWxTdHJpbmcuZm9ybWF0KG9iai5zcWwsIG9iai5iaW5kaW5ncywgdHopO1xuICAgICAgY29ubmVjdGlvbi5xdWVyeShzcWwsIGZ1bmN0aW9uIChlcnIsIHJvd3MpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3RlcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZVJvd3Mocm93cywgcm93cy5pbmZvLm1ldGFkYXRhKTtcbiAgICAgICAgb2JqLnJlc3BvbnNlID0gW3Jvd3MsIHJvd3MuaW5mb107XG4gICAgICAgIHJlc29sdmVyKG9iaik7XG4gICAgICB9KVxuICAgIH0pO1xuICB9LFxuXG4gIC8vIFByb2Nlc3MgdGhlIHJlc3BvbnNlIGFzIHJldHVybmVkIGZyb20gdGhlIHF1ZXJ5LlxuICBwcm9jZXNzUmVzcG9uc2Uob2JqLCBydW5uZXIpIHtcbiAgICBjb25zdCB7IHJlc3BvbnNlIH0gPSBvYmo7XG4gICAgY29uc3QgeyBtZXRob2QgfSA9IG9iajtcbiAgICBjb25zdCByb3dzID0gcmVzcG9uc2VbMF07XG4gICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlWzFdO1xuICAgIGlmIChvYmoub3V0cHV0KSByZXR1cm4gb2JqLm91dHB1dC5jYWxsKHJ1bm5lciwgcm93cy8qLCBmaWVsZHMqLyk7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBjYXNlICdwbHVjayc6XG4gICAgICBjYXNlICdmaXJzdCc6IHtcbiAgICAgICAgY29uc3QgcmVzcCA9IGhlbHBlcnMuc2tpbShyb3dzKTtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ3BsdWNrJykgcmV0dXJuIG1hcChyZXNwLCBvYmoucGx1Y2spO1xuICAgICAgICByZXR1cm4gbWV0aG9kID09PSAnZmlyc3QnID8gcmVzcFswXSA6IHJlc3A7XG4gICAgICB9XG4gICAgICBjYXNlICdpbnNlcnQnOlxuICAgICAgICByZXR1cm4gW2RhdGEuaW5zZXJ0SWRdO1xuICAgICAgY2FzZSAnZGVsJzpcbiAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICBjYXNlICdjb3VudGVyJzpcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGRhdGEuYWZmZWN0ZWRSb3dzLCAxMCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICB9LFxuXG4gIHBpbmcocmVzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgcmVzb3VyY2UucXVlcnkoJ1NFTEVDVCAxJywgY2FsbGJhY2spO1xuICB9XG5cbn0pXG5cbmZ1bmN0aW9uIHBhcnNlVHlwZSh2YWx1ZSwgdHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdEQVRFVElNRSc6XG4gICAgY2FzZSAnVElNRVNUQU1QJzpcbiAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgY2FzZSAnSU5URUdFUic6XG4gICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVJvdyhyb3csIG1ldGFkYXRhKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhtZXRhZGF0YSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgY29uc3QgeyB0eXBlIH0gPSBtZXRhZGF0YVtrZXldO1xuICAgIHJvd1trZXldID0gcGFyc2VUeXBlKHJvd1trZXldLCB0eXBlKTtcbiAgfVxuICByZXR1cm4gcm93O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVSb3dzKHJvd3MsIG1ldGFkYXRhKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJvdyA9IHJvd3NbaV07XG4gICAgaGFuZGxlUm93KHJvdywgbWV0YWRhdGEpO1xuICB9XG4gIHJldHVybiByb3dzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBDbGllbnRfTWFyaWFTUUxcbiJdfQ==

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	
	// MySQL Client
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _client = __webpack_require__(42);

	var _client2 = _interopRequireDefault(_client);

	var _promise = __webpack_require__(43);

	var _promise2 = _interopRequireDefault(_promise);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _transaction = __webpack_require__(95);

	var _transaction2 = _interopRequireDefault(_transaction);

	var _queryCompiler = __webpack_require__(96);

	var _queryCompiler2 = _interopRequireDefault(_queryCompiler);

	var _schemaCompiler = __webpack_require__(97);

	var _schemaCompiler2 = _interopRequireDefault(_schemaCompiler);

	var _schemaTablecompiler = __webpack_require__(98);

	var _schemaTablecompiler2 = _interopRequireDefault(_schemaTablecompiler);

	var _schemaColumncompiler = __webpack_require__(99);

	var _schemaColumncompiler2 = _interopRequireDefault(_schemaColumncompiler);

	var _lodash = __webpack_require__(5);

	// Always initialize with the "QueryBuilder" and "QueryCompiler"
	// objects, which extend the base 'lib/query/builder' and
	// 'lib/query/compiler', respectively.
	function Client_MySQL(config) {
	  _client2['default'].call(this, config);
	}
	_inherits2['default'](Client_MySQL, _client2['default']);

	_lodash.assign(Client_MySQL.prototype, {

	  dialect: 'mysql',

	  driverName: 'mysql',

	  _driver: function _driver() {
	    return __webpack_require__(100);
	  },

	  QueryCompiler: _queryCompiler2['default'],

	  SchemaCompiler: _schemaCompiler2['default'],

	  TableCompiler: _schemaTablecompiler2['default'],

	  ColumnCompiler: _schemaColumncompiler2['default'],

	  Transaction: _transaction2['default'],

	  wrapIdentifier: function wrapIdentifier(value) {
	    return value !== '*' ? '`' + value.replace(/`/g, '``') + '`' : '*';
	  },

	  // Get a raw connection, called by the `pool` whenever a new
	  // connection needs to be added to the pool.
	  acquireRawConnection: function acquireRawConnection() {
	    var client = this;
	    var connection = this.driver.createConnection(this.connectionSettings);
	    return new _promise2['default'](function (resolver, rejecter) {
	      connection.connect(function (err) {
	        if (err) return rejecter(err);
	        connection.on('error', client._connectionErrorHandler.bind(null, client, connection));
	        connection.on('end', client._connectionErrorHandler.bind(null, client, connection));
	        resolver(connection);
	      });
	    });
	  },

	  // Used to explicitly close a connection, called internally by the pool
	  // when a connection times out or the pool is shutdown.
	  destroyRawConnection: function destroyRawConnection(connection, cb) {
	    connection.end(cb);
	  },

	  // Grab a connection, run the query via the MySQL streaming interface,
	  // and pass that through to the stream we've sent back to the client.
	  _stream: function _stream(connection, obj, stream, options) {
	    options = options || {};
	    return new _promise2['default'](function (resolver, rejecter) {
	      stream.on('error', rejecter);
	      stream.on('end', resolver);
	      connection.query(obj.sql, obj.bindings).stream(options).pipe(stream);
	    });
	  },

	  // Runs the query on the specified connection, providing the bindings
	  // and any other necessary prep work.
	  _query: function _query(connection, obj) {
	    if (!obj || typeof obj === 'string') obj = { sql: obj };
	    return new _promise2['default'](function (resolver, rejecter) {
	      var _obj = obj;
	      var sql = _obj.sql;

	      if (!sql) return resolver();
	      if (obj.options) sql = _lodash.assign({ sql: sql }, obj.options);
	      connection.query(sql, obj.bindings, function (err, rows, fields) {
	        if (err) return rejecter(err);
	        obj.response = [rows, fields];
	        resolver(obj);
	      });
	    });
	  },

	  // Process the response as returned from the query.
	  processResponse: function processResponse(obj, runner) {
	    if (obj == null) return;
	    var response = obj.response;
	    var method = obj.method;

	    var rows = response[0];
	    var fields = response[1];
	    if (obj.output) return obj.output.call(runner, rows, fields);
	    switch (method) {
	      case 'select':
	      case 'pluck':
	      case 'first':
	        {
	          var resp = helpers.skim(rows);
	          if (method === 'pluck') return _lodash.map(resp, obj.pluck);
	          return method === 'first' ? resp[0] : resp;
	        }
	      case 'insert':
	        return [rows.insertId];
	      case 'del':
	      case 'update':
	      case 'counter':
	        return rows.affectedRows;
	      default:
	        return response;
	    }
	  },

	  // MySQL Specific error handler
	  _connectionErrorHandler: function _connectionErrorHandler(client, connection, err) {
	    if (connection && err && err.fatal && !connection.__knex__disposed) {
	      connection.__knex__disposed = true;
	      client.pool.destroy(connection);
	    }
	  },

	  ping: function ping(resource, callback) {
	    resource.query('SELECT 1', callback);
	  },

	  canCancelQuery: true,

	  cancelQuery: function cancelQuery(connectionToKill) {
	    var _this = this;

	    var acquiringConn = this.acquireConnection().completed;

	    // Error out if we can't acquire connection in time.
	    // Purposely not putting timeout on `KILL QUERY` execution because erroring
	    // early there would release the `connectionToKill` back to the pool with
	    // a `KILL QUERY` command yet to finish.
	    return acquiringConn.timeout(100).then(function (conn) {
	      return _this.query(conn, {
	        method: 'raw',
	        sql: 'KILL QUERY ?',
	        bindings: [connectionToKill.threadId],
	        options: {}
	      });
	    })['finally'](function () {
	      // NOT returning this promise because we want to release the connection
	      // in a non-blocking fashion
	      acquiringConn.then(function (conn) {
	        return _this.releaseConnection(conn);
	      });
	    });
	  }

	});

	exports['default'] = Client_MySQL;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy9teXNxbC9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozt3QkFHcUIsVUFBVTs7OztzQkFFWixjQUFjOzs7O3VCQUNiLGVBQWU7Ozs7dUJBQ1YsZUFBZTs7SUFBNUIsT0FBTzs7MkJBRUssZUFBZTs7Ozs2QkFDYixrQkFBa0I7Ozs7OEJBQ2pCLG1CQUFtQjs7OzttQ0FDcEIsd0JBQXdCOzs7O29DQUN2Qix5QkFBeUI7Ozs7c0JBRXhCLFFBQVE7Ozs7O0FBS3BDLFNBQVMsWUFBWSxDQUFDLE1BQU0sRUFBRTtBQUM1QixzQkFBTyxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0NBQzNCO0FBQ0Qsc0JBQVMsWUFBWSxzQkFBUyxDQUFDOztBQUUvQixlQUFPLFlBQVksQ0FBQyxTQUFTLEVBQUU7O0FBRTdCLFNBQU8sRUFBRSxPQUFPOztBQUVoQixZQUFVLEVBQUUsT0FBTzs7QUFFbkIsU0FBTyxFQUFBLG1CQUFHO0FBQ1IsV0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUE7R0FDeEI7O0FBRUQsZUFBYSw0QkFBQTs7QUFFYixnQkFBYyw2QkFBQTs7QUFFZCxlQUFhLGtDQUFBOztBQUViLGdCQUFjLG1DQUFBOztBQUVkLGFBQVcsMEJBQUE7O0FBRVgsZ0JBQWMsRUFBQSx3QkFBQyxLQUFLLEVBQUU7QUFDcEIsV0FBUSxLQUFLLEtBQUssR0FBRyxTQUFRLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFPLEdBQUcsQ0FBQztHQUNsRTs7OztBQUlELHNCQUFvQixFQUFBLGdDQUFHO0FBQ3JCLFFBQU0sTUFBTSxHQUFHLElBQUksQ0FBQTtBQUNuQixRQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFBO0FBQ3hFLFdBQU8seUJBQVksVUFBUyxRQUFRLEVBQUUsUUFBUSxF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YUFBYSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLFNBQVMsQ0FBQTs7Ozs7O0FBTXhELFdBQU8sYUFBYSxDQUNqQixPQUFPLENBQUMsR0FBRyxDQUFDLENBQ1osSUFBSSxDQUFDLFVBQUMsSUFBSTthQUFLLE1BQUssS0FBSyxDQUFDLElBQUksRUFBRTtBQUMvQixjQUFNLEVBQUUsS0FBSztBQUNiLFdBQUcsRUFBRSxjQUFjO0FBQ25CLGdCQUFRLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUM7QUFDckMsZUFBTyxFQUFFLEVBQUU7T0FDWixDQUFDO0tBQUEsQ0FBQyxXQUNLLENBQUMsWUFBTTs7O0FBR2IsbUJBQWEsQ0FDVixJQUFJLENBQUMsVUFBQyxJQUFJO2VBQUssTUFBSyxpQkFBaUIsQ0FBQyxJQUFJLENBQUM7T0FBQSxDQUFDLENBQUM7S0FDakQsQ0FBQyxDQUFDO0dBQ047O0NBRUYsQ0FBQyxDQUFBOztxQkFFYSxZQUFZIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBNeVNRTCBDbGllbnRcbi8vIC0tLS0tLS1cbmltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCBDbGllbnQgZnJvbSAnLi4vLi4vY2xpZW50JztcbmltcG9ydCBQcm9taXNlIGZyb20gJy4uLy4uL3Byb21pc2UnO1xuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuLi8uLi9oZWxwZXJzJztcblxuaW1wb3J0IFRyYW5zYWN0aW9uIGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IFF1ZXJ5Q29tcGlsZXIgZnJvbSAnLi9xdWVyeS9jb21waWxlcic7XG5pbXBvcnQgU2NoZW1hQ29tcGlsZXIgZnJvbSAnLi9zY2hlbWEvY29tcGlsZXInO1xuaW1wb3J0IFRhYmxlQ29tcGlsZXIgZnJvbSAnLi9zY2hlbWEvdGFibGVjb21waWxlcic7XG5pbXBvcnQgQ29sdW1uQ29tcGlsZXIgZnJvbSAnLi9zY2hlbWEvY29sdW1uY29tcGlsZXInO1xuXG5pbXBvcnQgeyBhc3NpZ24sIG1hcCB9IGZyb20gJ2xvZGFzaCdcblxuLy8gQWx3YXlzIGluaXRpYWxpemUgd2l0aCB0aGUgXCJRdWVyeUJ1aWxkZXJcIiBhbmQgXCJRdWVyeUNvbXBpbGVyXCJcbi8vIG9iamVjdHMsIHdoaWNoIGV4dGVuZCB0aGUgYmFzZSAnbGliL3F1ZXJ5L2J1aWxkZXInIGFuZFxuLy8gJ2xpYi9xdWVyeS9jb21waWxlcicsIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIENsaWVudF9NeVNRTChjb25maWcpIHtcbiAgQ2xpZW50LmNhbGwodGhpcywgY29uZmlnKTtcbn1cbmluaGVyaXRzKENsaWVudF9NeVNRTCwgQ2xpZW50KTtcblxuYXNzaWduKENsaWVudF9NeVNRTC5wcm90b3R5cGUsIHtcblxuICBkaWFsZWN0OiAnbXlzcWwnLFxuXG4gIGRyaXZlck5hbWU6ICdteXNxbCcsXG5cbiAgX2RyaXZlcigpIHtcbiAgICByZXR1cm4gcmVxdWlyZSgnbXlzcWwnKVxuICB9LFxuXG4gIFF1ZXJ5Q29tcGlsZXIsXG5cbiAgU2NoZW1hQ29tcGlsZXIsXG5cbiAgVGFibGVDb21waWxlcixcblxuICBDb2x1bW5Db21waWxlcixcblxuICBUcmFuc2FjdGlvbixcblxuICB3cmFwSWRlbnRpZmllcih2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgIT09ICcqJyA/IGBcXGAke3ZhbHVlLnJlcGxhY2UoL2AvZywgJ2BgJyl9XFxgYCA6ICcqJylcbiAgfSxcblxuICAvLyBHZXQgYSByYXcgY29ubmVjdGlvbiwgY2FsbGVkIGJ5IHRoZSBgcG9vbGAgd2hlbmV2ZXIgYSBuZXdcbiAgLy8gY29ubmVjdGlvbiBuZWVkcyB0byBiZSBhZGRlZCB0byB0aGUgcG9vbC5cbiAgYWNxdWlyZVJhd0Nvbm5lY3Rpb24oKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpc1xuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmRyaXZlci5jcmVhdGVDb25uZWN0aW9uKHRoaXMuY29ubmVjdGlvblNldHRpbmdzKVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlciwgcmVqZWN0ZXIpIHtcbiAgICAgIGNvbm5lY3Rpb24uY29ubmVjdChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdGVyKGVycilcbiAgICAgICAgY29ubmVjdGlvbi5vbignZXJyb3InLCBjbGllbnQuX2Nvbm5lY3Rpb25FcnJvckhhbmRsZXIuYmluZChudWxsLCBjbGllbnQsIGNvbm5lY3Rpb24pKVxuICAgICAgICBjb25uZWN0aW9uLm9uKCdlbmQnLCBjbGllbnQuX2Nvbm5lY3Rpb25FcnJvckhhbmRsZXIuYmluZChudWxsLCBjbGllbnQsIGNvbm5lY3Rpb24pKVxuICAgICAgICByZXNvbHZlcihjb25uZWN0aW9uKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLy8gVXNlZCB0byBleHBsaWNpdGx5IGNsb3NlIGEgY29ubmVjdGlvbiwgY2FsbGVkIGludGVybmFsbHkgYnkgdGhlIHBvb2xcbiAgLy8gd2hlbiBhIGNvbm5lY3Rpb24gdGltZXMgb3V0IG9yIHRoZSBwb29sIGlzIHNodXRkb3duLlxuICBkZXN0cm95UmF3Q29ubmVjdGlvbihjb25uZWN0aW9uLCBjYikge1xuICAgIGNvbm5lY3Rpb24uZW5kKGNiKTtcbiAgfSxcblxuICAvLyBHcmFiIGEgY29ubmVjdGlvbiwgcnVuIHRoZSBxdWVyeSB2aWEgdGhlIE15U1FMIHN0cmVhbWluZyBpbnRlcmZhY2UsXG4gIC8vIGFuZCBwYXNzIHRoYXQgdGhyb3VnaCB0byB0aGUgc3RyZWFtIHdlJ3ZlIHNlbnQgYmFjayB0byB0aGUgY2xpZW50LlxuICBfc3RyZWFtKGNvbm5lY3Rpb24sIG9iaiwgc3RyZWFtLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZXIsIHJlamVjdGVyKSB7XG4gICAgICBzdHJlYW0ub24oJ2Vycm9yJywgcmVqZWN0ZXIpXG4gICAgICBzdHJlYW0ub24oJ2VuZCcsIHJlc29sdmVyKVxuICAgICAgY29ubmVjdGlvbi5xdWVyeShvYmouc3FsLCBvYmouYmluZGluZ3MpLnN0cmVhbShvcHRpb25zKS5waXBlKHN0cmVhbSlcbiAgICB9KVxuICB9LFxuXG4gIC8vIFJ1bnMgdGhlIHF1ZXJ5IG9uIHRoZSBzcGVjaWZpZWQgY29ubmVjdGlvbiwgcHJvdmlkaW5nIHRoZSBiaW5kaW5nc1xuICAvLyBhbmQgYW55IG90aGVyIG5lY2Vzc2FyeSBwcmVwIHdvcmsuXG4gIF9xdWVyeShjb25uZWN0aW9uLCBvYmopIHtcbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykgb2JqID0ge3NxbDogb2JqfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlciwgcmVqZWN0ZXIpIHtcbiAgICAgIGxldCB7IHNxbCB9ID0gb2JqXG4gICAgICBpZiAoIXNxbCkgcmV0dXJuIHJlc29sdmVyKClcbiAgICAgIGlmIChvYmoub3B0aW9ucykgc3FsID0gYXNzaWduKHtzcWx9LCBvYmoub3B0aW9ucylcbiAgICAgIGNvbm5lY3Rpb24ucXVlcnkoc3FsLCBvYmouYmluZGluZ3MsIGZ1bmN0aW9uKGVyciwgcm93cywgZmllbGRzKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3RlcihlcnIpXG4gICAgICAgIG9iai5yZXNwb25zZSA9IFtyb3dzLCBmaWVsZHNdXG4gICAgICAgIHJlc29sdmVyKG9iailcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcblxuICAvLyBQcm9jZXNzIHRoZSByZXNwb25zZSBhcyByZXR1cm5lZCBmcm9tIHRoZSBxdWVyeS5cbiAgcHJvY2Vzc1Jlc3BvbnNlKG9iaiwgcnVubmVyKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm47XG4gICAgY29uc3QgeyByZXNwb25zZSB9ID0gb2JqXG4gICAgY29uc3QgeyBtZXRob2QgfSA9IG9ialxuICAgIGNvbnN0IHJvd3MgPSByZXNwb25zZVswXVxuICAgIGNvbnN0IGZpZWxkcyA9IHJlc3BvbnNlWzFdXG4gICAgaWYgKG9iai5vdXRwdXQpIHJldHVybiBvYmoub3V0cHV0LmNhbGwocnVubmVyLCByb3dzLCBmaWVsZHMpXG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBjYXNlICdwbHVjayc6XG4gICAgICBjYXNlICdmaXJzdCc6IHtcbiAgICAgICAgY29uc3QgcmVzcCA9IGhlbHBlcnMuc2tpbShyb3dzKVxuICAgICAgICBpZiAobWV0aG9kID09PSAncGx1Y2snKSByZXR1cm4gbWFwKHJlc3AsIG9iai5wbHVjaylcbiAgICAgICAgcmV0dXJuIG1ldGhvZCA9PT0gJ2ZpcnN0JyA/IHJlc3BbMF0gOiByZXNwXG4gICAgICB9XG4gICAgICBjYXNlICdpbnNlcnQnOlxuICAgICAgICByZXR1cm4gW3Jvd3MuaW5zZXJ0SWRdXG4gICAgICBjYXNlICdkZWwnOlxuICAgICAgY2FzZSAndXBkYXRlJzpcbiAgICAgIGNhc2UgJ2NvdW50ZXInOlxuICAgICAgICByZXR1cm4gcm93cy5hZmZlY3RlZFJvd3NcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiByZXNwb25zZVxuICAgIH1cbiAgfSxcblxuICAvLyBNeVNRTCBTcGVjaWZpYyBlcnJvciBoYW5kbGVyXG4gIF9jb25uZWN0aW9uRXJyb3JIYW5kbGVyOiAoY2xpZW50LCBjb25uZWN0aW9uLCBlcnIpID0+IHtcbiAgICBpZihjb25uZWN0aW9uICYmIGVyciAmJiBlcnIuZmF0YWwgJiYgIWNvbm5lY3Rpb24uX19rbmV4X19kaXNwb3NlZCkge1xuICAgICAgY29ubmVjdGlvbi5fX2tuZXhfX2Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIGNsaWVudC5wb29sLmRlc3Ryb3koY29ubmVjdGlvbik7XG4gICAgfVxuICB9LFxuXG4gIHBpbmcocmVzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgcmVzb3VyY2UucXVlcnkoJ1NFTEVDVCAxJywgY2FsbGJhY2spO1xuICB9LFxuXG4gIGNhbkNhbmNlbFF1ZXJ5OiB0cnVlLFxuXG4gIGNhbmNlbFF1ZXJ5KGNvbm5lY3Rpb25Ub0tpbGwpIHtcbiAgICBjb25zdCBhY3F1aXJpbmdDb25uID0gdGhpcy5hY3F1aXJlQ29ubmVjdGlvbigpLmNvbXBsZXRlZFxuXG4gICAgLy8gRXJyb3Igb3V0IGlmIHdlIGNhbid0IGFjcXVpcmUgY29ubmVjdGlvbiBpbiB0aW1lLlxuICAgIC8vIFB1cnBvc2VseSBub3QgcHV0dGluZyB0aW1lb3V0IG9uIGBLSUxMIFFVRVJZYCBleGVjdXRpb24gYmVjYXVzZSBlcnJvcmluZ1xuICAgIC8vIGVhcmx5IHRoZXJlIHdvdWxkIHJlbGVhc2UgdGhlIGBjb25uZWN0aW9uVG9LaWxsYCBiYWNrIHRvIHRoZSBwb29sIHdpdGhcbiAgICAvLyBhIGBLSUxMIFFVRVJZYCBjb21tYW5kIHlldCB0byBmaW5pc2guXG4gICAgcmV0dXJuIGFjcXVpcmluZ0Nvbm5cbiAgICAgIC50aW1lb3V0KDEwMClcbiAgICAgIC50aGVuKChjb25uKSA9PiB0aGlzLnF1ZXJ5KGNvbm4sIHtcbiAgICAgICAgbWV0aG9kOiAncmF3JyxcbiAgICAgICAgc3FsOiAnS0lMTCBRVUVSWSA/JyxcbiAgICAgICAgYmluZGluZ3M6IFtjb25uZWN0aW9uVG9LaWxsLnRocmVhZElkXSxcbiAgICAgICAgb3B0aW9uczoge30sXG4gICAgICB9KSlcbiAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgLy8gTk9UIHJldHVybmluZyB0aGlzIHByb21pc2UgYmVjYXVzZSB3ZSB3YW50IHRvIHJlbGVhc2UgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgLy8gaW4gYSBub24tYmxvY2tpbmcgZmFzaGlvblxuICAgICAgICBhY3F1aXJpbmdDb25uXG4gICAgICAgICAgLnRoZW4oKGNvbm4pID0+IHRoaXMucmVsZWFzZUNvbm5lY3Rpb24oY29ubikpO1xuICAgICAgfSk7XG4gIH1cblxufSlcblxuZXhwb3J0IGRlZmF1bHQgQ2xpZW50X015U1FMXG4iXX0=

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _transaction = __webpack_require__(65);

	var _transaction2 = _interopRequireDefault(_transaction);

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _debug = __webpack_require__(66);

	var _debug2 = _interopRequireDefault(_debug);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _lodash = __webpack_require__(5);

	var debug = _debug2['default']('knex:tx');

	function Transaction_MySQL() {
	  _transaction2['default'].apply(this, arguments);
	}
	_inherits2['default'](Transaction_MySQL, _transaction2['default']);

	_lodash.assign(Transaction_MySQL.prototype, {

	  query: function query(conn, sql, status, value) {
	    var t = this;
	    var q = this.trxClient.query(conn, sql)['catch'](function (err) {
	      return err.errno === 1305;
	    }, function () {
	      helpers.warn('Transaction was implicitly committed, do not mix transactions and ' + 'DDL with MySQL (#805)');
	    })['catch'](function (err) {
	      status = 2;
	      value = err;
	      t._completed = true;
	      debug('%s error running transaction query', t.txid);
	    }).tap(function () {
	      if (status === 1) t._resolver(value);
	      if (status === 2) t._rejecter(value);
	    });
	    if (status === 1 || status === 2) {
	      t._completed = true;
	    }
	    return q;
	  }

	});

	exports['default'] = Transaction_MySQL;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy9teXNxbC90cmFuc2FjdGlvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OzsyQkFDd0IsbUJBQW1COzs7O3dCQUN0QixVQUFVOzs7O3FCQUNiLE9BQU87Ozs7dUJBQ0EsZUFBZTs7SUFBNUIsT0FBTzs7c0JBQ0ksUUFBUTs7QUFFL0IsSUFBTSxLQUFLLEdBQUcsbUJBQU0sU0FBUyxDQUFDLENBQUM7O0FBRS9CLFNBQVMsaUJBQWlCLEdBQUc7QUFDM0IsMkJBQVksS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQTtDQUNuQztBQUNELHNCQUFTLGlCQUFpQiwyQkFBYyxDQUFBOztBQUV4QyxlQUFPLGlCQUFpQixDQUFDLFNBQVMsRUFBRTs7QUFFbEMsT0FBSyxFQUFBLGVBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFO0FBQzlCLFFBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQTtBQUNkLFFBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsU0FDakMsQ0FBQyxVQUFBLEdBQUc7YUFBSSxHQUFHLENBQUMsS0FBSyxLQUFLLElBQUk7S0FBQSxFQUFFLFlBQVc7QUFDM0MsYUFBTyxDQUFDLElBQUksQ0FDVixvRUFBb0UsR0FDcEUsdUJBQXVCLENBQ3hCLENBQUE7S0FDRixDQUFDLFNBQ0ksQ0FBQyxVQUFTLEdBQUcsRUFBRTtBQUNuQixZQUFNLEdBQUcsQ0FBQyxDQUFBO0FBQ1YsV0FBSyxHQUFHLEdBQUcsQ0FBQTtBQUNYLE9BQUMsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFBO0FBQ25CLFdBQUssQ0FBQyxvQ0FBb0MsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUE7S0FDcEQsQ0FBQyxDQUNELEdBQUcsQ0FBQyxZQUFXO0FBQ2QsVUFBSSxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUE7QUFDcEMsVUFBSSxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUE7S0FDckMsQ0FBQyxDQUFBO0FBQ0osUUFBSSxNQUFNLEtBQUssQ0FBQyxJQUFJLE1BQU0sS0FBSyxDQUFDLEVBQUU7QUFDaEMsT0FBQyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUE7S0FDcEI7QUFDRCxXQUFPLENBQUMsQ0FBQztHQUNWOztDQUVGLENBQUMsQ0FBQTs7cUJBRWEsaUJBQWlCIiwiZmlsZSI6InRyYW5zYWN0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgVHJhbnNhY3Rpb24gZnJvbSAnLi4vLi4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcbmltcG9ydCBEZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgKiBhcyBoZWxwZXJzIGZyb20gJy4uLy4uL2hlbHBlcnMnO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnbG9kYXNoJ1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKCdrbmV4OnR4Jyk7XG5cbmZ1bmN0aW9uIFRyYW5zYWN0aW9uX015U1FMKCkge1xuICBUcmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5pbmhlcml0cyhUcmFuc2FjdGlvbl9NeVNRTCwgVHJhbnNhY3Rpb24pXG5cbmFzc2lnbihUcmFuc2FjdGlvbl9NeVNRTC5wcm90b3R5cGUsIHtcblxuICBxdWVyeShjb25uLCBzcWwsIHN0YXR1cywgdmFsdWUpIHtcbiAgICBjb25zdCB0ID0gdGhpc1xuICAgIGNvbnN0IHEgPSB0aGlzLnRyeENsaWVudC5xdWVyeShjb25uLCBzcWwpXG4gICAgICAuY2F0Y2goZXJyID0+IGVyci5lcnJubyA9PT0gMTMwNSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGhlbHBlcnMud2FybihcbiAgICAgICAgICAnVHJhbnNhY3Rpb24gd2FzIGltcGxpY2l0bHkgY29tbWl0dGVkLCBkbyBub3QgbWl4IHRyYW5zYWN0aW9ucyBhbmQgJyArXG4gICAgICAgICAgJ0RETCB3aXRoIE15U1FMICgjODA1KSdcbiAgICAgICAgKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgc3RhdHVzID0gMlxuICAgICAgICB2YWx1ZSA9IGVyclxuICAgICAgICB0Ll9jb21wbGV0ZWQgPSB0cnVlXG4gICAgICAgIGRlYnVnKCclcyBlcnJvciBydW5uaW5nIHRyYW5zYWN0aW9uIHF1ZXJ5JywgdC50eGlkKVxuICAgICAgfSlcbiAgICAgIC50YXAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEpIHQuX3Jlc29sdmVyKHZhbHVlKVxuICAgICAgICBpZiAoc3RhdHVzID09PSAyKSB0Ll9yZWplY3Rlcih2YWx1ZSlcbiAgICAgIH0pXG4gICAgaWYgKHN0YXR1cyA9PT0gMSB8fCBzdGF0dXMgPT09IDIpIHtcbiAgICAgIHQuX2NvbXBsZXRlZCA9IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIHE7XG4gIH1cblxufSlcblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNhY3Rpb25fTXlTUUxcbiJdfQ==

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	
	// MySQL Query Compiler
	// ------
	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _queryCompiler = __webpack_require__(75);

	var _queryCompiler2 = _interopRequireDefault(_queryCompiler);

	var _lodash = __webpack_require__(5);

	function QueryCompiler_MySQL(client, builder) {
	  _queryCompiler2['default'].call(this, client, builder);
	}
	_inherits2['default'](QueryCompiler_MySQL, _queryCompiler2['default']);

	_lodash.assign(QueryCompiler_MySQL.prototype, {

	  _emptyInsertValue: '() values ()',

	  // Update method, including joins, wheres, order & limits.
	  update: function update() {
	    var join = this.join();
	    var updates = this._prepUpdate(this.single.update);
	    var where = this.where();
	    var order = this.order();
	    var limit = this.limit();
	    return 'update ' + this.tableName + (join ? ' ' + join : '') + ' set ' + updates.join(', ') + (where ? ' ' + where : '') + (order ? ' ' + order : '') + (limit ? ' ' + limit : '');
	  },

	  forUpdate: function forUpdate() {
	    return 'for update';
	  },

	  forShare: function forShare() {
	    return 'lock in share mode';
	  },

	  // Compiles a `columnInfo` query.
	  columnInfo: function columnInfo() {
	    var column = this.single.columnInfo;
	    return {
	      sql: 'select * from information_schema.columns where table_name = ? and table_schema = ?',
	      bindings: [this.single.table, this.client.database()],
	      output: function output(resp) {
	        var out = resp.reduce(function (columns, val) {
	          columns[val.COLUMN_NAME] = {
	            defaultValue: val.COLUMN_DEFAULT,
	            type: val.DATA_TYPE,
	            maxLength: val.CHARACTER_MAXIMUM_LENGTH,
	            nullable: val.IS_NULLABLE === 'YES'
	          };
	          return columns;
	        }, {});
	        return column && out[column] || out;
	      }
	    };
	  },

	  limit: function limit() {
	    var noLimit = !this.single.limit && this.single.limit !== 0;
	    if (noLimit && !this.single.offset) return '';

	    // Workaround for offset only.
	    // see: http://stackoverflow.com/questions/255517/mysql-offset-infinite-rows
	    var limit = this.single.offset && noLimit ? '18446744073709551615' : this.formatter.parameter(this.single.limit);
	    return 'limit ' + limit;
	  }

	});

	// Set the QueryBuilder & QueryCompiler on the client object,
	// in case anyone wants to modify things to suit their own purposes.
	exports['default'] = QueryCompiler_MySQL;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9teXNxbC9xdWVyeS9jb21waWxlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7d0JBR3FCLFVBQVU7Ozs7NkJBQ0wseUJBQXlCOzs7O3NCQUU1QixRQUFROztBQUUvQixTQUFTLG1CQUFtQixDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUU7QUFDNUMsNkJBQWMsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUE7Q0FDMUM7QUFDRCxzQkFBUyxtQkFBbUIsNkJBQWdCLENBQUE7O0FBRTVDLGVBQU8sbUJBQW1CLENBQUMsU0FBUyxFQUFFOztBQUVwQyxtQkFBaUIsRUFBRSxjQUFjOzs7QUFHakMsUUFBTSxFQUFBLGtCQUFHO0FBQ1AsUUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0FBQ3pCLFFBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNyRCxRQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDM0IsUUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO0FBQzNCLFFBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztBQUMzQixXQUFPLFlBQVUsSUFBSSxDQUFDLFNBQVMsSUFDNUIsSUFBSSxTQUFPLElBQUksR0FBSyxFQUFFLENBQUEsQUFBQyxHQUN4QixPQUFPLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFDM0IsS0FBSyxTQUFPLEtBQUssR0FBSyxFQUFFLENBQUEsQUFBQyxJQUN6QixLQUFLLFNBQU8sS0FBSyxHQUFLLEVBQUUsQ0FBQSxBQUFDLElBQ3pCLEtBQUssU0FBTyxLQUFLLEdBQUssRUFBRSxDQUFBLEFBQUMsQ0FBQztHQUM5Qjs7QUFFRCxXQUFTLEVBQUEscUJBQUc7QUFDVixXQUFPLFlBQVksQ0FBQztHQUNyQjs7QUFFRCxVQUFRLEVBQUEsb0JBQUc7QUFDVCxXQUFPLG9CQUFvQixDQUFDO0dBQzdCOzs7QUFHRCxZQUFVLEVBQUEsc0JBQUc7QUFDWCxRQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQztBQUN0QyxXQUFPO0FBQ0wsU0FBRyxFQUFFLG9GQUFvRjtBQUN6RixjQUFRLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO0FBQ3JELFlBQU0sRUFBQSxnQkFBQyxJQUFJLEVBQUU7QUFDWCxZQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVMsT0FBTyxFQUFFLEdBQUcsRUFBRTtBQUM3QyxpQkFBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsR0FBRztBQUN6Qix3QkFBWSxFQUFFLEdBQUcsQ0FBQyxjQUFjO0FBQ2hDLGdCQUFJLEVBQUUsR0FBRyxDQUFDLFNBQVM7QUFDbkIscUJBQVMsRUFBRSxHQUFHLENBQUMsd0JBQXdCO0FBQ3ZDLG9CQUFRLEVBQUcsR0FBRyxDQUFDLFdBQVcsS0FBSyxLQUFLLEFBQUM7V0FDdEMsQ0FBQztBQUNGLGlCQUFPLE9BQU8sQ0FBQTtTQUNmLEVBQUUsRUFBRSxDQUFDLENBQUE7QUFDTixlQUFPLE1BQU0sSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksR0FBRyxDQUFDO09BQ3JDO0tBQ0YsQ0FBQztHQUNIOztBQUVELE9BQUssRUFBQSxpQkFBRztBQUNOLFFBQU0sT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDO0FBQzlELFFBQUksT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLENBQUM7Ozs7QUFJOUMsUUFBTSxLQUFLLEdBQUcsQUFBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sSUFBSSxPQUFPLEdBQ3hDLHNCQUFzQixHQUN0QixJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFBO0FBQy9DLHNCQUFnQixLQUFLLENBQUc7R0FDekI7O0NBRUYsQ0FBQyxDQUFBOzs7O3FCQUlhLG1CQUFtQiIsImZpbGUiOiJjb21waWxlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLy8gTXlTUUwgUXVlcnkgQ29tcGlsZXJcbi8vIC0tLS0tLVxuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcbmltcG9ydCBRdWVyeUNvbXBpbGVyIGZyb20gJy4uLy4uLy4uL3F1ZXJ5L2NvbXBpbGVyJztcblxuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnbG9kYXNoJ1xuXG5mdW5jdGlvbiBRdWVyeUNvbXBpbGVyX015U1FMKGNsaWVudCwgYnVpbGRlcikge1xuICBRdWVyeUNvbXBpbGVyLmNhbGwodGhpcywgY2xpZW50LCBidWlsZGVyKVxufVxuaW5oZXJpdHMoUXVlcnlDb21waWxlcl9NeVNRTCwgUXVlcnlDb21waWxlcilcblxuYXNzaWduKFF1ZXJ5Q29tcGlsZXJfTXlTUUwucHJvdG90eXBlLCB7XG5cbiAgX2VtcHR5SW5zZXJ0VmFsdWU6ICcoKSB2YWx1ZXMgKCknLFxuXG4gIC8vIFVwZGF0ZSBtZXRob2QsIGluY2x1ZGluZyBqb2lucywgd2hlcmVzLCBvcmRlciAmIGxpbWl0cy5cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IGpvaW4gPSB0aGlzLmpvaW4oKTtcbiAgICBjb25zdCB1cGRhdGVzID0gdGhpcy5fcHJlcFVwZGF0ZSh0aGlzLnNpbmdsZS51cGRhdGUpO1xuICAgIGNvbnN0IHdoZXJlID0gdGhpcy53aGVyZSgpO1xuICAgIGNvbnN0IG9yZGVyID0gdGhpcy5vcmRlcigpO1xuICAgIGNvbnN0IGxpbWl0ID0gdGhpcy5saW1pdCgpO1xuICAgIHJldHVybiBgdXBkYXRlICR7dGhpcy50YWJsZU5hbWV9YCArXG4gICAgICAoam9pbiA/IGAgJHtqb2lufWAgOiAnJykgK1xuICAgICAgJyBzZXQgJyArIHVwZGF0ZXMuam9pbignLCAnKSArXG4gICAgICAod2hlcmUgPyBgICR7d2hlcmV9YCA6ICcnKSArXG4gICAgICAob3JkZXIgPyBgICR7b3JkZXJ9YCA6ICcnKSArXG4gICAgICAobGltaXQgPyBgICR7bGltaXR9YCA6ICcnKTtcbiAgfSxcblxuICBmb3JVcGRhdGUoKSB7XG4gICAgcmV0dXJuICdmb3IgdXBkYXRlJztcbiAgfSxcblxuICBmb3JTaGFyZSgpIHtcbiAgICByZXR1cm4gJ2xvY2sgaW4gc2hhcmUgbW9kZSc7XG4gIH0sXG5cbiAgLy8gQ29tcGlsZXMgYSBgY29sdW1uSW5mb2AgcXVlcnkuXG4gIGNvbHVtbkluZm8oKSB7XG4gICAgY29uc3QgY29sdW1uID0gdGhpcy5zaW5nbGUuY29sdW1uSW5mbztcbiAgICByZXR1cm4ge1xuICAgICAgc3FsOiAnc2VsZWN0ICogZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEuY29sdW1ucyB3aGVyZSB0YWJsZV9uYW1lID0gPyBhbmQgdGFibGVfc2NoZW1hID0gPycsXG4gICAgICBiaW5kaW5nczogW3RoaXMuc2luZ2xlLnRhYmxlLCB0aGlzLmNsaWVudC5kYXRhYmFzZSgpXSxcbiAgICAgIG91dHB1dChyZXNwKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IHJlc3AucmVkdWNlKGZ1bmN0aW9uKGNvbHVtbnMsIHZhbCkge1xuICAgICAgICAgIGNvbHVtbnNbdmFsLkNPTFVNTl9OQU1FXSA9IHtcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsLkNPTFVNTl9ERUZBVUxULFxuICAgICAgICAgICAgdHlwZTogdmFsLkRBVEFfVFlQRSxcbiAgICAgICAgICAgIG1heExlbmd0aDogdmFsLkNIQVJBQ1RFUl9NQVhJTVVNX0xFTkdUSCxcbiAgICAgICAgICAgIG51bGxhYmxlOiAodmFsLklTX05VTExBQkxFID09PSAnWUVTJylcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBjb2x1bW5zXG4gICAgICAgIH0sIHt9KVxuICAgICAgICByZXR1cm4gY29sdW1uICYmIG91dFtjb2x1bW5dIHx8IG91dDtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIGxpbWl0KCkge1xuICAgIGNvbnN0IG5vTGltaXQgPSAhdGhpcy5zaW5nbGUubGltaXQgJiYgdGhpcy5zaW5nbGUubGltaXQgIT09IDA7XG4gICAgaWYgKG5vTGltaXQgJiYgIXRoaXMuc2luZ2xlLm9mZnNldCkgcmV0dXJuICcnO1xuXG4gICAgLy8gV29ya2Fyb3VuZCBmb3Igb2Zmc2V0IG9ubHkuXG4gICAgLy8gc2VlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI1NTUxNy9teXNxbC1vZmZzZXQtaW5maW5pdGUtcm93c1xuICAgIGNvbnN0IGxpbWl0ID0gKHRoaXMuc2luZ2xlLm9mZnNldCAmJiBub0xpbWl0KVxuICAgICAgPyAnMTg0NDY3NDQwNzM3MDk1NTE2MTUnXG4gICAgICA6IHRoaXMuZm9ybWF0dGVyLnBhcmFtZXRlcih0aGlzLnNpbmdsZS5saW1pdClcbiAgICByZXR1cm4gYGxpbWl0ICR7bGltaXR9YDtcbiAgfVxuXG59KVxuXG4vLyBTZXQgdGhlIFF1ZXJ5QnVpbGRlciAmIFF1ZXJ5Q29tcGlsZXIgb24gdGhlIGNsaWVudCBvYmplY3QsXG4vLyBpbiBjYXNlIGFueW9uZSB3YW50cyB0byBtb2RpZnkgdGhpbmdzIHRvIHN1aXQgdGhlaXIgb3duIHB1cnBvc2VzLlxuZXhwb3J0IGRlZmF1bHQgUXVlcnlDb21waWxlcl9NeVNRTDtcbiJdfQ==

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	
	// MySQL Schema Compiler
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _schemaCompiler = __webpack_require__(77);

	var _schemaCompiler2 = _interopRequireDefault(_schemaCompiler);

	var _lodash = __webpack_require__(5);

	function SchemaCompiler_MySQL(client, builder) {
	  _schemaCompiler2['default'].call(this, client, builder);
	}
	_inherits2['default'](SchemaCompiler_MySQL, _schemaCompiler2['default']);

	_lodash.assign(SchemaCompiler_MySQL.prototype, {

	  // Rename a table on the schema.
	  renameTable: function renameTable(tableName, to) {
	    this.pushQuery('rename table ' + this.formatter.wrap(tableName) + ' to ' + this.formatter.wrap(to));
	  },

	  // Check whether a table exists on the query.
	  hasTable: function hasTable(tableName) {
	    this.pushQuery({
	      sql: 'show tables like ' + this.formatter.parameter(tableName),
	      output: function output(resp) {
	        return resp.length > 0;
	      }
	    });
	  },

	  // Check whether a column exists on the schema.
	  hasColumn: function hasColumn(tableName, column) {
	    this.pushQuery({
	      sql: 'show columns from ' + this.formatter.wrap(tableName) + ' like ' + this.formatter.parameter(column),
	      output: function output(resp) {
	        return resp.length > 0;
	      }
	    });
	  }

	});

	exports['default'] = SchemaCompiler_MySQL;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9teXNxbC9zY2hlbWEvY29tcGlsZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O3dCQUdxQixVQUFVOzs7OzhCQUNKLDBCQUEwQjs7OztzQkFFOUIsUUFBUTs7QUFFL0IsU0FBUyxvQkFBb0IsQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFO0FBQzdDLDhCQUFlLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFBO0NBQzNDO0FBQ0Qsc0JBQVMsb0JBQW9CLDhCQUFpQixDQUFBOztBQUU5QyxlQUFPLG9CQUFvQixDQUFDLFNBQVMsRUFBRTs7O0FBR3JDLGFBQVcsRUFBQSxxQkFBQyxTQUFTLEVBQUUsRUFBRSxFQUFFO0FBQ3pCLFFBQUksQ0FBQyxTQUFTLG1CQUFpQixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsWUFBTyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBRyxDQUFDO0dBQ2hHOzs7QUFHRCxVQUFRLEVBQUEsa0JBQUMsU0FBUyxFQUFFO0FBQ2xCLFFBQUksQ0FBQyxTQUFTLENBQUM7QUFDYixTQUFHLHdCQUFzQixJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQUFBRTtBQUM5RCxZQUFNLEVBQUEsZ0JBQUMsSUFBSSxFQUFFO0FBQ1gsZUFBTyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztPQUN4QjtLQUNGLENBQUMsQ0FBQztHQUNKOzs7QUFHRCxXQUFTLEVBQUEsbUJBQUMsU0FBUyxFQUFFLE1BQU0sRUFBRTtBQUMzQixRQUFJLENBQUMsU0FBUyxDQUFDO0FBQ2IsU0FBRyxFQUFFLHVCQUFxQixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FDdEQsUUFBUSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQztBQUM3QyxZQUFNLEVBQUEsZ0JBQUMsSUFBSSxFQUFFO0FBQ1gsZUFBTyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztPQUN4QjtLQUNGLENBQUMsQ0FBQztHQUNKOztDQUVGLENBQUMsQ0FBQTs7cUJBRWEsb0JBQW9CIiwiZmlsZSI6ImNvbXBpbGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBNeVNRTCBTY2hlbWEgQ29tcGlsZXJcbi8vIC0tLS0tLS1cbmltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5pbXBvcnQgU2NoZW1hQ29tcGlsZXIgZnJvbSAnLi4vLi4vLi4vc2NoZW1hL2NvbXBpbGVyJztcblxuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnbG9kYXNoJ1xuXG5mdW5jdGlvbiBTY2hlbWFDb21waWxlcl9NeVNRTChjbGllbnQsIGJ1aWxkZXIpIHtcbiAgU2NoZW1hQ29tcGlsZXIuY2FsbCh0aGlzLCBjbGllbnQsIGJ1aWxkZXIpXG59XG5pbmhlcml0cyhTY2hlbWFDb21waWxlcl9NeVNRTCwgU2NoZW1hQ29tcGlsZXIpXG5cbmFzc2lnbihTY2hlbWFDb21waWxlcl9NeVNRTC5wcm90b3R5cGUsIHtcblxuICAvLyBSZW5hbWUgYSB0YWJsZSBvbiB0aGUgc2NoZW1hLlxuICByZW5hbWVUYWJsZSh0YWJsZU5hbWUsIHRvKSB7XG4gICAgdGhpcy5wdXNoUXVlcnkoYHJlbmFtZSB0YWJsZSAke3RoaXMuZm9ybWF0dGVyLndyYXAodGFibGVOYW1lKX0gdG8gJHt0aGlzLmZvcm1hdHRlci53cmFwKHRvKX1gKTtcbiAgfSxcblxuICAvLyBDaGVjayB3aGV0aGVyIGEgdGFibGUgZXhpc3RzIG9uIHRoZSBxdWVyeS5cbiAgaGFzVGFibGUodGFibGVOYW1lKSB7XG4gICAgdGhpcy5wdXNoUXVlcnkoe1xuICAgICAgc3FsOiBgc2hvdyB0YWJsZXMgbGlrZSAke3RoaXMuZm9ybWF0dGVyLnBhcmFtZXRlcih0YWJsZU5hbWUpfWAsXG4gICAgICBvdXRwdXQocmVzcCkge1xuICAgICAgICByZXR1cm4gcmVzcC5sZW5ndGggPiAwO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8vIENoZWNrIHdoZXRoZXIgYSBjb2x1bW4gZXhpc3RzIG9uIHRoZSBzY2hlbWEuXG4gIGhhc0NvbHVtbih0YWJsZU5hbWUsIGNvbHVtbikge1xuICAgIHRoaXMucHVzaFF1ZXJ5KHtcbiAgICAgIHNxbDogYHNob3cgY29sdW1ucyBmcm9tICR7dGhpcy5mb3JtYXR0ZXIud3JhcCh0YWJsZU5hbWUpfWAgK1xuICAgICAgICAnIGxpa2UgJyArIHRoaXMuZm9ybWF0dGVyLnBhcmFtZXRlcihjb2x1bW4pLFxuICAgICAgb3V0cHV0KHJlc3ApIHtcbiAgICAgICAgcmV0dXJuIHJlc3AubGVuZ3RoID4gMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59KVxuXG5leHBvcnQgZGVmYXVsdCBTY2hlbWFDb21waWxlcl9NeVNRTDtcbiJdfQ==

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint max-len:0 no-console:0*/

	// MySQL Table Builder & Compiler
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _schemaTablecompiler = __webpack_require__(80);

	var _schemaTablecompiler2 = _interopRequireDefault(_schemaTablecompiler);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _promise = __webpack_require__(43);

	var _promise2 = _interopRequireDefault(_promise);

	var _lodash = __webpack_require__(5);

	// Table Compiler
	// ------

	function TableCompiler_MySQL() {
	  _schemaTablecompiler2['default'].apply(this, arguments);
	}
	_inherits2['default'](TableCompiler_MySQL, _schemaTablecompiler2['default']);

	_lodash.assign(TableCompiler_MySQL.prototype, {

	  createQuery: function createQuery(columns, ifNot) {
	    var createStatement = ifNot ? 'create table if not exists ' : 'create table ';
	    var client = this.client;

	    var conn = {};
	    var sql = createStatement + this.tableName() + ' (' + columns.sql.join(', ') + ')';

	    // Check if the connection settings are set.
	    if (client.connectionSettings) {
	      conn = client.connectionSettings;
	    }

	    var charset = this.single.charset || conn.charset || '';
	    var collation = this.single.collate || conn.collate || '';
	    var engine = this.single.engine || '';

	    // var conn = builder.client.connectionSettings;
	    if (charset) sql += ' default character set ' + charset;
	    if (collation) sql += ' collate ' + collation;
	    if (engine) sql += ' engine = ' + engine;

	    if (this.single.comment) {
	      var comment = this.single.comment || '';
	      if (comment.length > 60) helpers.warn('The max length for a table comment is 60 characters');
	      sql += ' comment = \'' + comment + '\'';
	    }

	    this.pushQuery(sql);
	  },

	  addColumnsPrefix: 'add ',

	  dropColumnPrefix: 'drop ',

	  // Compiles the comment on the table.
	  comment: function comment(_comment) {
	    this.pushQuery('alter table ' + this.tableName() + ' comment = \'' + _comment + '\'');
	  },

	  changeType: function changeType() {
	    // alter table + table + ' modify ' + wrapped + '// type';
	  },

	  // Renames a column on the table.
	  renameColumn: function renameColumn(from, to) {
	    var compiler = this;
	    var table = this.tableName();
	    var wrapped = this.formatter.wrap(from) + ' ' + this.formatter.wrap(to);

	    this.pushQuery({
	      sql: 'show fields from ' + table + ' where field = ' + this.formatter.parameter(from),
	      output: function output(resp) {
	        var column = resp[0];
	        var runner = this;
	        return compiler.getFKRefs(runner).get(0).then(function (refs) {
	          return _promise2['default']['try'](function () {
	            if (!refs.length) {
	              return;
	            }
	            return compiler.dropFKRefs(runner, refs);
	          }).then(function () {
	            var sql = 'alter table ' + table + ' change ' + wrapped + ' ' + column.Type;

	            if (String(column.Null).toUpperCase() !== 'YES') {
	              sql += ' NOT NULL';
	            }
	            if (column.Default !== void 0 && column.Default !== null) {
	              sql += ' DEFAULT \'' + column.Default + '\'';
	            }

	            return runner.query({
	              sql: sql
	            });
	          }).then(function () {
	            if (!refs.length) {
	              return;
	            }
	            return compiler.createFKRefs(runner, refs.map(function (ref) {
	              if (ref.REFERENCED_COLUMN_NAME === from) {
	                ref.REFERENCED_COLUMN_NAME = to;
	              }
	              if (ref.COLUMN_NAME === from) {
	                ref.COLUMN_NAME = to;
	              }
	              return ref;
	            }));
	          });
	        });
	      }
	    });
	  },

	  getFKRefs: function getFKRefs(runner) {
	    var formatter = this.client.formatter();
	    var sql = 'SELECT KCU.CONSTRAINT_NAME, KCU.TABLE_NAME, KCU.COLUMN_NAME, ' + '       KCU.REFERENCED_TABLE_NAME, KCU.REFERENCED_COLUMN_NAME, ' + '       RC.UPDATE_RULE, RC.DELETE_RULE ' + 'FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS KCU ' + 'JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS RC ' + '       USING(CONSTRAINT_NAME)' + 'WHERE KCU.REFERENCED_TABLE_NAME = ' + formatter.parameter(this.tableNameRaw) + ' ' + '  AND KCU.CONSTRAINT_SCHEMA = ' + formatter.parameter(this.client.database()) + ' ' + '  AND RC.CONSTRAINT_SCHEMA = ' + formatter.parameter(this.client.database());

	    return runner.query({
	      sql: sql,
	      bindings: formatter.bindings
	    });
	  },

	  dropFKRefs: function dropFKRefs(runner, refs) {
	    var formatter = this.client.formatter();

	    return _promise2['default'].all(refs.map(function (ref) {
	      var constraintName = formatter.wrap(ref.CONSTRAINT_NAME);
	      var tableName = formatter.wrap(ref.TABLE_NAME);
	      return runner.query({
	        sql: 'alter table ' + tableName + ' drop foreign key ' + constraintName
	      });
	    }));
	  },
	  createFKRefs: function createFKRefs(runner, refs) {
	    var formatter = this.client.formatter();

	    return _promise2['default'].all(refs.map(function (ref) {
	      var tableName = formatter.wrap(ref.TABLE_NAME);
	      var keyName = formatter.wrap(ref.CONSTRAINT_NAME);
	      var column = formatter.columnize(ref.COLUMN_NAME);
	      var references = formatter.columnize(ref.REFERENCED_COLUMN_NAME);
	      var inTable = formatter.wrap(ref.REFERENCED_TABLE_NAME);
	      var onUpdate = ' ON UPDATE ' + ref.UPDATE_RULE;
	      var onDelete = ' ON DELETE ' + ref.DELETE_RULE;

	      return runner.query({
	        sql: 'alter table ' + tableName + ' add constraint ' + keyName + ' ' + 'foreign key (' + column + ') references ' + inTable + ' (' + references + ')' + onUpdate + onDelete
	      });
	    }));
	  },
	  index: function index(columns, indexName) {
	    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);
	    this.pushQuery('alter table ' + this.tableName() + ' add index ' + indexName + '(' + this.formatter.columnize(columns) + ')');
	  },

	  primary: function primary(columns, constraintName) {
	    constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(this.tableNameRaw + '_pkey');
	    this.pushQuery('alter table ' + this.tableName() + ' add primary key ' + constraintName + '(' + this.formatter.columnize(columns) + ')');
	  },

	  unique: function unique(columns, indexName) {
	    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, columns);
	    this.pushQuery('alter table ' + this.tableName() + ' add unique ' + indexName + '(' + this.formatter.columnize(columns) + ')');
	  },

	  // Compile a drop index command.
	  dropIndex: function dropIndex(columns, indexName) {
	    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);
	    this.pushQuery('alter table ' + this.tableName() + ' drop index ' + indexName);
	  },

	  // Compile a drop foreign key command.
	  dropForeign: function dropForeign(columns, indexName) {
	    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('foreign', this.tableNameRaw, columns);
	    this.pushQuery('alter table ' + this.tableName() + ' drop foreign key ' + indexName);
	  },

	  // Compile a drop primary key command.
	  dropPrimary: function dropPrimary() {
	    this.pushQuery('alter table ' + this.tableName() + ' drop primary key');
	  },

	  // Compile a drop unique key command.
	  dropUnique: function dropUnique(column, indexName) {
	    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, column);
	    this.pushQuery('alter table ' + this.tableName() + ' drop index ' + indexName);
	  }

	});

	exports['default'] = TableCompiler_MySQL;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9teXNxbC9zY2hlbWEvdGFibGVjb21waWxlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7d0JBSXFCLFVBQVU7Ozs7bUNBQ0wsK0JBQStCOzs7O3VCQUNoQyxrQkFBa0I7O0lBQS9CLE9BQU87O3VCQUNDLGtCQUFrQjs7OztzQkFFZixRQUFROzs7OztBQUsvQixTQUFTLG1CQUFtQixHQUFHO0FBQzdCLG1DQUFjLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7Q0FDdEM7QUFDRCxzQkFBUyxtQkFBbUIsbUNBQWdCLENBQUM7O0FBRTdDLGVBQU8sbUJBQW1CLENBQUMsU0FBUyxFQUFFOztBQUVwQyxhQUFXLEVBQUEscUJBQUMsT0FBTyxFQUFFLEtBQUssRUFBRTtBQUMxQixRQUFNLGVBQWUsR0FBRyxLQUFLLEdBQUcsNkJBQTZCLEdBQUcsZUFBZSxDQUFDO1FBQ3hFLE1BQU0sR0FBSyxJQUFJLENBQWYsTUFBTTs7QUFDZCxRQUFJLElBQUksR0FBRyxFQUFFLENBQUM7QUFDZCxRQUFJLEdBQUcsR0FBRyxlQUFlLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRSxHQUFHLElBQUksR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUM7OztBQUduRixRQUFJLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRTtBQUM3QixVQUFJLEdBQUcsTUFBTSxDQUFDLGtCQUFrQixDQUFDO0tBQ2xDOztBQUVELFFBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDO0FBQzFELFFBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDO0FBQzVELFFBQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFN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QUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ2pILFFBQUksQ0FBQyxTQUFTLGtCQUFnQixJQUFJLENBQUMsU0FBUyxFQUFFLG9CQUFlLFNBQVMsQ0FBRyxDQUFDO0dBQzNFOztDQUVGLENBQUMsQ0FBQTs7cUJBRWEsbUJBQW1CIiwiZmlsZSI6InRhYmxlY29tcGlsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbWF4LWxlbjowIG5vLWNvbnNvbGU6MCovXG5cbi8vIE15U1FMIFRhYmxlIEJ1aWxkZXIgJiBDb21waWxlclxuLy8gLS0tLS0tLVxuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcbmltcG9ydCBUYWJsZUNvbXBpbGVyIGZyb20gJy4uLy4uLy4uL3NjaGVtYS90YWJsZWNvbXBpbGVyJztcbmltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSAnLi4vLi4vLi4vaGVscGVycyc7XG5pbXBvcnQgUHJvbWlzZSBmcm9tICcuLi8uLi8uLi9wcm9taXNlJztcblxuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnbG9kYXNoJ1xuXG4vLyBUYWJsZSBDb21waWxlclxuLy8gLS0tLS0tXG5cbmZ1bmN0aW9uIFRhYmxlQ29tcGlsZXJfTXlTUUwoKSB7XG4gIFRhYmxlQ29tcGlsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmluaGVyaXRzKFRhYmxlQ29tcGlsZXJfTXlTUUwsIFRhYmxlQ29tcGlsZXIpO1xuXG5hc3NpZ24oVGFibGVDb21waWxlcl9NeVNRTC5wcm90b3R5cGUsIHtcblxuICBjcmVhdGVRdWVyeShjb2x1bW5zLCBpZk5vdCkge1xuICAgIGNvbnN0IGNyZWF0ZVN0YXRlbWVudCA9IGlmTm90ID8gJ2NyZWF0ZSB0YWJsZSBpZiBub3QgZXhpc3RzICcgOiAnY3JlYXRlIHRhYmxlICc7XG4gICAgY29uc3QgeyBjbGllbnQgfSA9IHRoaXM7XG4gICAgbGV0IGNvbm4gPSB7fTtcbiAgICBsZXQgc3FsID0gY3JlYXRlU3RhdGVtZW50ICsgdGhpcy50YWJsZU5hbWUoKSArICcgKCcgKyBjb2x1bW5zLnNxbC5qb2luKCcsICcpICsgJyknO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNvbm5lY3Rpb24gc2V0dGluZ3MgYXJlIHNldC5cbiAgICBpZiAoY2xpZW50LmNvbm5lY3Rpb25TZXR0aW5ncykge1xuICAgICAgY29ubiA9IGNsaWVudC5jb25uZWN0aW9uU2V0dGluZ3M7XG4gICAgfVxuXG4gICAgY29uc3QgY2hhcnNldCA9IHRoaXMuc2luZ2xlLmNoYXJzZXQgfHwgY29ubi5jaGFyc2V0IHx8ICcnO1xuICAgIGNvbnN0IGNvbGxhdGlvbiA9IHRoaXMuc2luZ2xlLmNvbGxhdGUgfHwgY29ubi5jb2xsYXRlIHx8ICcnO1xuICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuc2luZ2xlLmVuZ2luZSAgfHwgJyc7XG5cbiAgICAvLyB2YXIgY29ubiA9IGJ1aWxkZXIuY2xpZW50LmNvbm5lY3Rpb25TZXR0aW5ncztcbiAgICBpZiAoY2hhcnNldCkgICBzcWwgKz0gYCBkZWZhdWx0IGNoYXJhY3RlciBzZXQgJHtjaGFyc2V0fWA7XG4gICAgaWYgKGNvbGxhdGlvbikgc3FsICs9IGAgY29sbGF0ZSAke2NvbGxhdGlvbn1gO1xuICAgIGlmIChlbmdpbmUpICAgIHNxbCArPSBgIGVuZ2luZSA9ICR7ZW5naW5lfWA7XG5cbiAgICBpZiAodGhpcy5zaW5nbGUuY29tbWVudCkge1xuICAgICAgY29uc3QgY29tbWVudCA9ICh0aGlzLnNpbmdsZS5jb21tZW50IHx8ICcnKTtcbiAgICAgIGlmIChjb21tZW50Lmxlbmd0aCA+IDYwKSBoZWxwZXJzLndhcm4oJ1RoZSBtYXggbGVuZ3RoIGZvciBhIHRhYmxlIGNvbW1lbnQgaXMgNjAgY2hhcmFjdGVycycpO1xuICAgICAgc3FsICs9IGAgY29tbWVudCA9ICcke2NvbW1lbnR9J2A7XG4gICAgfVxuXG4gICAgdGhpcy5wdXNoUXVlcnkoc3FsKTtcbiAgfSxcblxuICBhZGRDb2x1bW5zUHJlZml4OiAnYWRkICcsXG5cbiAgZHJvcENvbHVtblByZWZpeDogJ2Ryb3AgJyxcblxuICAvLyBDb21waWxlcyB0aGUgY29tbWVudCBvbiB0aGUgdGFibGUuXG4gIGNvbW1lbnQoY29tbWVudCkge1xuICAgIHRoaXMucHVzaFF1ZXJ5KGBhbHRlciB0YWJsZSAke3RoaXMudGFibGVOYW1lKCl9IGNvbW1lbnQgPSAnJHtjb21tZW50fSdgKTtcbiAgfSxcblxuICBjaGFuZ2VUeXBlKCkge1xuICAgIC8vIGFsdGVyIHRhYmxlICsgdGFibGUgKyAnIG1vZGlmeSAnICsgd3JhcHBlZCArICcvLyB0eXBlJztcbiAgfSxcblxuICAvLyBSZW5hbWVzIGEgY29sdW1uIG9uIHRoZSB0YWJsZS5cbiAgcmVuYW1lQ29sdW1uKGZyb20sIHRvKSB7XG4gICAgY29uc3QgY29tcGlsZXIgPSB0aGlzO1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy50YWJsZU5hbWUoKTtcbiAgICBjb25zdCB3cmFwcGVkID0gdGhpcy5mb3JtYXR0ZXIud3JhcChmcm9tKSArICcgJyArIHRoaXMuZm9ybWF0dGVyLndyYXAodG8pO1xuXG4gICAgdGhpcy5wdXNoUXVlcnkoe1xuICAgICAgc3FsOiBgc2hvdyBmaWVsZHMgZnJvbSAke3RhYmxlfSB3aGVyZSBmaWVsZCA9IGAgK1xuICAgICAgICB0aGlzLmZvcm1hdHRlci5wYXJhbWV0ZXIoZnJvbSksXG4gICAgICBvdXRwdXQocmVzcCkge1xuICAgICAgICBjb25zdCBjb2x1bW4gPSByZXNwWzBdO1xuICAgICAgICBjb25zdCBydW5uZXIgPSB0aGlzO1xuICAgICAgICByZXR1cm4gY29tcGlsZXIuZ2V0RktSZWZzKHJ1bm5lcikuZ2V0KDApXG4gICAgICAgICAgLnRoZW4ocmVmcyA9PlxuICAgICAgICAgICAgUHJvbWlzZS50cnkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoIXJlZnMubGVuZ3RoKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICByZXR1cm4gY29tcGlsZXIuZHJvcEZLUmVmcyhydW5uZXIsIHJlZnMpO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGxldCBzcWwgPSBgYWx0ZXIgdGFibGUgJHt0YWJsZX0gY2hhbmdlICR7d3JhcHBlZH0gJHtjb2x1bW4uVHlwZX1gO1xuXG4gICAgICAgICAgICAgIGlmKFN0cmluZyhjb2x1bW4uTnVsbCkudG9VcHBlckNhc2UoKSAhPT0gJ1lFUycpIHtcbiAgICAgICAgICAgICAgICBzcWwgKz0gYCBOT1QgTlVMTGBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZihjb2x1bW4uRGVmYXVsdCAhPT0gdm9pZCAwICYmIGNvbHVtbi5EZWZhdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3FsICs9IGAgREVGQVVMVCAnJHtjb2x1bW4uRGVmYXVsdH0nYFxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHJ1bm5lci5xdWVyeSh7XG4gICAgICAgICAgICAgICAgc3FsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICghcmVmcy5sZW5ndGgpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgIHJldHVybiBjb21waWxlci5jcmVhdGVGS1JlZnMocnVubmVyLCByZWZzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZi5SRUZFUkVOQ0VEX0NPTFVNTl9OQU1FID09PSBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICByZWYuUkVGRVJFTkNFRF9DT0xVTU5fTkFNRSA9IHRvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVmLkNPTFVNTl9OQU1FID09PSBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICByZWYuQ09MVU1OX05BTUUgPSB0bztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIGdldEZLUmVmcyAocnVubmVyKSB7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gdGhpcy5jbGllbnQuZm9ybWF0dGVyKCk7XG4gICAgY29uc3Qgc3FsID0gJ1NFTEVDVCBLQ1UuQ09OU1RSQUlOVF9OQU1FLCBLQ1UuVEFCTEVfTkFNRSwgS0NVLkNPTFVNTl9OQU1FLCAnK1xuICAgICAgICAgICAgICAnICAgICAgIEtDVS5SRUZFUkVOQ0VEX1RBQkxFX05BTUUsIEtDVS5SRUZFUkVOQ0VEX0NPTFVNTl9OQU1FLCAnK1xuICAgICAgICAgICAgICAnICAgICAgIFJDLlVQREFURV9SVUxFLCBSQy5ERUxFVEVfUlVMRSAnK1xuICAgICAgICAgICAgICAnRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuS0VZX0NPTFVNTl9VU0FHRSBBUyBLQ1UgJytcbiAgICAgICAgICAgICAgJ0pPSU4gSU5GT1JNQVRJT05fU0NIRU1BLlJFRkVSRU5USUFMX0NPTlNUUkFJTlRTIEFTIFJDICcrXG4gICAgICAgICAgICAgICcgICAgICAgVVNJTkcoQ09OU1RSQUlOVF9OQU1FKScgK1xuICAgICAgICAgICAgICAnV0hFUkUgS0NVLlJFRkVSRU5DRURfVEFCTEVfTkFNRSA9ICcgKyBmb3JtYXR0ZXIucGFyYW1ldGVyKHRoaXMudGFibGVOYW1lUmF3KSArICcgJytcbiAgICAgICAgICAgICAgJyAgQU5EIEtDVS5DT05TVFJBSU5UX1NDSEVNQSA9ICcgKyBmb3JtYXR0ZXIucGFyYW1ldGVyKHRoaXMuY2xpZW50LmRhdGFiYXNlKCkpICsgJyAnK1xuICAgICAgICAgICAgICAnICBBTkQgUkMuQ09OU1RSQUlOVF9TQ0hFTUEgPSAnICsgZm9ybWF0dGVyLnBhcmFtZXRlcih0aGlzLmNsaWVudC5kYXRhYmFzZSgpKTtcblxuICAgIHJldHVybiBydW5uZXIucXVlcnkoe1xuICAgICAgc3FsLFxuICAgICAgYmluZGluZ3M6IGZvcm1hdHRlci5iaW5kaW5nc1xuICAgIH0pO1xuICB9LFxuXG4gIGRyb3BGS1JlZnMgKHJ1bm5lciwgcmVmcykge1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IHRoaXMuY2xpZW50LmZvcm1hdHRlcigpO1xuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHJlZnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnROYW1lID0gZm9ybWF0dGVyLndyYXAocmVmLkNPTlNUUkFJTlRfTkFNRSk7XG4gICAgICBjb25zdCB0YWJsZU5hbWUgPSBmb3JtYXR0ZXIud3JhcChyZWYuVEFCTEVfTkFNRSk7XG4gICAgICByZXR1cm4gcnVubmVyLnF1ZXJ5KHtcbiAgICAgICAgc3FsOiBgYWx0ZXIgdGFibGUgJHt0YWJsZU5hbWV9IGRyb3AgZm9yZWlnbiBrZXkgJHtjb25zdHJhaW50TmFtZX1gXG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH0sXG4gIGNyZWF0ZUZLUmVmcyAocnVubmVyLCByZWZzKSB7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gdGhpcy5jbGllbnQuZm9ybWF0dGVyKCk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocmVmcy5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgY29uc3QgdGFibGVOYW1lID0gZm9ybWF0dGVyLndyYXAocmVmLlRBQkxFX05BTUUpO1xuICAgICAgY29uc3Qga2V5TmFtZSA9IGZvcm1hdHRlci53cmFwKHJlZi5DT05TVFJBSU5UX05BTUUpO1xuICAgICAgY29uc3QgY29sdW1uID0gZm9ybWF0dGVyLmNvbHVtbml6ZShyZWYuQ09MVU1OX05BTUUpO1xuICAgICAgY29uc3QgcmVmZXJlbmNlcyA9IGZvcm1hdHRlci5jb2x1bW5pemUocmVmLlJFRkVSRU5DRURfQ09MVU1OX05BTUUpO1xuICAgICAgY29uc3QgaW5UYWJsZSA9IGZvcm1hdHRlci53cmFwKHJlZi5SRUZFUkVOQ0VEX1RBQkxFX05BTUUpO1xuICAgICAgY29uc3Qgb25VcGRhdGUgPSBgIE9OIFVQREFURSAke3JlZi5VUERBVEVfUlVMRX1gO1xuICAgICAgY29uc3Qgb25EZWxldGUgPSBgIE9OIERFTEVURSAke3JlZi5ERUxFVEVfUlVMRX1gO1xuXG4gICAgICByZXR1cm4gcnVubmVyLnF1ZXJ5KHtcbiAgICAgICAgc3FsOiBgYWx0ZXIgdGFibGUgJHt0YWJsZU5hbWV9IGFkZCBjb25zdHJhaW50ICR7a2V5TmFtZX0gYCArXG4gICAgICAgICAgJ2ZvcmVpZ24ga2V5ICgnICsgY29sdW1uICsgJykgcmVmZXJlbmNlcyAnICsgaW5UYWJsZSArICcgKCcgKyByZWZlcmVuY2VzICsgJyknICsgb25VcGRhdGUgKyBvbkRlbGV0ZVxuICAgICAgfSk7XG4gICAgfSkpO1xuICB9LFxuICBpbmRleChjb2x1bW5zLCBpbmRleE5hbWUpIHtcbiAgICBpbmRleE5hbWUgPSBpbmRleE5hbWUgPyB0aGlzLmZvcm1hdHRlci53cmFwKGluZGV4TmFtZSkgOiB0aGlzLl9pbmRleENvbW1hbmQoJ2luZGV4JywgdGhpcy50YWJsZU5hbWVSYXcsIGNvbHVtbnMpO1xuICAgIHRoaXMucHVzaFF1ZXJ5KGBhbHRlciB0YWJsZSAke3RoaXMudGFibGVOYW1lKCl9IGFkZCBpbmRleCAke2luZGV4TmFtZX0oJHt0aGlzLmZvcm1hdHRlci5jb2x1bW5pemUoY29sdW1ucyl9KWApO1xuICB9LFxuXG4gIHByaW1hcnkoY29sdW1ucywgY29uc3RyYWludE5hbWUpIHtcbiAgICBjb25zdHJhaW50TmFtZSA9IGNvbnN0cmFpbnROYW1lID8gdGhpcy5mb3JtYXR0ZXIud3JhcChjb25zdHJhaW50TmFtZSkgOiB0aGlzLmZvcm1hdHRlci53cmFwKGAke3RoaXMudGFibGVOYW1lUmF3fV9wa2V5YCk7XG4gICAgdGhpcy5wdXNoUXVlcnkoYGFsdGVyIHRhYmxlICR7dGhpcy50YWJsZU5hbWUoKX0gYWRkIHByaW1hcnkga2V5ICR7Y29uc3RyYWludE5hbWV9KCR7dGhpcy5mb3JtYXR0ZXIuY29sdW1uaXplKGNvbHVtbnMpfSlgKTtcbiAgfSxcblxuICB1bmlxdWUoY29sdW1ucywgaW5kZXhOYW1lKSB7XG4gICAgaW5kZXhOYW1lID0gaW5kZXhOYW1lID8gdGhpcy5mb3JtYXR0ZXIud3JhcChpbmRleE5hbWUpIDogdGhpcy5faW5kZXhDb21tYW5kKCd1bmlxdWUnLCB0aGlzLnRhYmxlTmFtZVJhdywgY29sdW1ucyk7XG4gICAgdGhpcy5wdXNoUXVlcnkoYGFsdGVyIHRhYmxlICR7dGhpcy50YWJsZU5hbWUoKX0gYWRkIHVuaXF1ZSAke2luZGV4TmFtZX0oJHt0aGlzLmZvcm1hdHRlci5jb2x1bW5pemUoY29sdW1ucyl9KWApO1xuICB9LFxuXG4gIC8vIENvbXBpbGUgYSBkcm9wIGluZGV4IGNvbW1hbmQuXG4gIGRyb3BJbmRleChjb2x1bW5zLCBpbmRleE5hbWUpIHtcbiAgICBpbmRleE5hbWUgPSBpbmRleE5hbWUgPyB0aGlzLmZvcm1hdHRlci53cmFwKGluZGV4TmFtZSkgOiB0aGlzLl9pbmRleENvbW1hbmQoJ2luZGV4JywgdGhpcy50YWJsZU5hbWVSYXcsIGNvbHVtbnMpO1xuICAgIHRoaXMucHVzaFF1ZXJ5KGBhbHRlciB0YWJsZSAke3RoaXMudGFibGVOYW1lKCl9IGRyb3AgaW5kZXggJHtpbmRleE5hbWV9YCk7XG4gIH0sXG5cbiAgLy8gQ29tcGlsZSBhIGRyb3AgZm9yZWlnbiBrZXkgY29tbWFuZC5cbiAgZHJvcEZvcmVpZ24oY29sdW1ucywgaW5kZXhOYW1lKSB7XG4gICAgaW5kZXhOYW1lID0gaW5kZXhOYW1lID8gdGhpcy5mb3JtYXR0ZXIud3JhcChpbmRleE5hbWUpIDogdGhpcy5faW5kZXhDb21tYW5kKCdmb3JlaWduJywgdGhpcy50YWJsZU5hbWVSYXcsIGNvbHVtbnMpO1xuICAgIHRoaXMucHVzaFF1ZXJ5KGBhbHRlciB0YWJsZSAke3RoaXMudGFibGVOYW1lKCl9IGRyb3AgZm9yZWlnbiBrZXkgJHtpbmRleE5hbWV9YCk7XG4gIH0sXG5cbiAgLy8gQ29tcGlsZSBhIGRyb3AgcHJpbWFyeSBrZXkgY29tbWFuZC5cbiAgZHJvcFByaW1hcnkoKSB7XG4gICAgdGhpcy5wdXNoUXVlcnkoYGFsdGVyIHRhYmxlICR7dGhpcy50YWJsZU5hbWUoKX0gZHJvcCBwcmltYXJ5IGtleWApO1xuICB9LFxuXG4gIC8vIENvbXBpbGUgYSBkcm9wIHVuaXF1ZSBrZXkgY29tbWFuZC5cbiAgZHJvcFVuaXF1ZShjb2x1bW4sIGluZGV4TmFtZSkge1xuICAgIGluZGV4TmFtZSA9IGluZGV4TmFtZSA/IHRoaXMuZm9ybWF0dGVyLndyYXAoaW5kZXhOYW1lKSA6IHRoaXMuX2luZGV4Q29tbWFuZCgndW5pcXVlJywgdGhpcy50YWJsZU5hbWVSYXcsIGNvbHVtbik7XG4gICAgdGhpcy5wdXNoUXVlcnkoYGFsdGVyIHRhYmxlICR7dGhpcy50YWJsZU5hbWUoKX0gZHJvcCBpbmRleCAke2luZGV4TmFtZX1gKTtcbiAgfVxuXG59KVxuXG5leHBvcnQgZGVmYXVsdCBUYWJsZUNvbXBpbGVyX015U1FMO1xuIl19

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	
	// MySQL Column Compiler
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _schemaColumncompiler = __webpack_require__(82);

	var _schemaColumncompiler2 = _interopRequireDefault(_schemaColumncompiler);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _lodash = __webpack_require__(5);

	function ColumnCompiler_MySQL() {
	  _schemaColumncompiler2['default'].apply(this, arguments);
	  this.modifiers = ['unsigned', 'nullable', 'defaultTo', 'first', 'after', 'comment', 'collate'];
	}
	_inherits2['default'](ColumnCompiler_MySQL, _schemaColumncompiler2['default']);

	// Types
	// ------

	_lodash.assign(ColumnCompiler_MySQL.prototype, {

	  increments: 'int unsigned not null auto_increment primary key',

	  bigincrements: 'bigint unsigned not null auto_increment primary key',

	  bigint: 'bigint',

	  double: function double(precision, scale) {
	    if (!precision) return 'double';
	    return 'double(' + this._num(precision, 8) + ', ' + this._num(scale, 2) + ')';
	  },

	  integer: function integer(length) {
	    length = length ? '(' + this._num(length, 11) + ')' : '';
	    return 'int' + length;
	  },

	  mediumint: 'mediumint',

	  smallint: 'smallint',

	  tinyint: function tinyint(length) {
	    length = length ? '(' + this._num(length, 1) + ')' : '';
	    return 'tinyint' + length;
	  },

	  text: function text(column) {
	    switch (column) {
	      case 'medium':
	      case 'mediumtext':
	        return 'mediumtext';
	      case 'long':
	      case 'longtext':
	        return 'longtext';
	      default:
	        return 'text';
	    }
	  },

	  mediumtext: function mediumtext() {
	    return this.text('medium');
	  },

	  longtext: function longtext() {
	    return this.text('long');
	  },

	  enu: function enu(allowed) {
	    return 'enum(\'' + allowed.join("', '") + '\')';
	  },

	  datetime: 'datetime',

	  timestamp: 'timestamp',

	  bit: function bit(length) {
	    return length ? 'bit(' + this._num(length) + ')' : 'bit';
	  },

	  binary: function binary(length) {
	    return length ? 'varbinary(' + this._num(length) + ')' : 'blob';
	  },

	  // Modifiers
	  // ------

	  defaultTo: function defaultTo(value) {
	    var defaultVal = ColumnCompiler_MySQL.super_.prototype.defaultTo.apply(this, arguments);
	    if (this.type !== 'blob' && this.type.indexOf('text') === -1) {
	      return defaultVal;
	    }
	    return '';
	  },

	  unsigned: function unsigned() {
	    return 'unsigned';
	  },

	  first: function first() {
	    return 'first';
	  },

	  after: function after(column) {
	    return 'after ' + this.formatter.wrap(column);
	  },

	  comment: function comment(_comment) {
	    if (_comment && _comment.length > 255) {
	      helpers.warn('Your comment is longer than the max comment length for MySQL');
	    }
	    return _comment && 'comment \'' + _comment + '\'';
	  },

	  collate: function collate(collation) {
	    return collation && 'collate \'' + collation + '\'';
	  }

	});

	exports['default'] = ColumnCompiler_MySQL;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9teXNxbC9zY2hlbWEvY29sdW1uY29tcGlsZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7d0JBR3FCLFVBQVU7Ozs7b0NBQ0osZ0NBQWdDOzs7O3VCQUNsQyxrQkFBa0I7O0lBQS9CLE9BQU87O3NCQUVJLFFBQVE7O0FBRS9CLFNBQVMsb0JBQW9CLEdBQUc7QUFDOUIsb0NBQWUsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztBQUN0QyxNQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsVUFBVSxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUE7Q0FDL0Y7QUFDRCxzQkFBUyxvQkFBb0Isb0NBQWlCLENBQUM7Ozs7O0FBSy9DLGVBQU8sb0JBQW9CLENBQUMsU0FBUyxFQUFFOztBQUVyQyxZQUFVLEVBQUUsa0RBQWtEOztBQUU5RCxlQUFhLEVBQUUscURBQXFEOztBQUVwRSxRQUFNLEVBQUUsUUFBUTs7QUFFaEIsUUFBTSxFQUFBLGdCQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUU7QUFDdkIsUUFBSSxDQUFDLFNBQVMsRUFBRSxPQUFPLFFBQVEsQ0FBQTtBQUMvQix1QkFBaUIsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLFVBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLE9BQUc7R0FDcEU7O0FBRUQsU0FBTyxFQUFBLGlCQUFDLE1BQU0sRUFBRTtBQUNkLFVBQU0sR0FBRyxNQUFNLFNBQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLFNBQU0sRUFBRSxDQUFBO0FBQ25ELG1CQUFhLE1BQU0sQ0FBRTtHQUN0Qjs7QUFFRCxXQUFTLEVBQUUsV0FBVzs7QUFFdEIsVUFBUSxFQUFFLFVBQVU7O0FBRXBCLFNBQU8sRUFBQSxpQkFBQyxNQUFNLEVBQUU7QUFDZCxVQUFNLEdBQUcsTUFBTSxTQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxTQUFNLEVBQUUsQ0FBQTtBQUNsRCx1QkFBaUIsTUFBTSxDQUFFO0dBQzFCOztBQUVELE1BQUksRUFBQSxjQUFDLE1BQU0sRUFBRTtBQUNYLFlBQVEsTUFBTTtBQUNaLFdBQUssUUFBUSxDQUFDO0FBQ2QsV0FBSyxZQUFZO0FBQ2YsZUFBTyxZQUFZLENBQUM7QUFBQSxBQUN0QixXQUFLLE1BQU0sQ0FBQztBQUNaLFdBQUssVUFBVTtBQUNiLGVBQU8sVUFBVSxDQUFBO0FBQUEsQUFDbkI7QUFDRSxlQUFPLE1BQU0sQ0FBQztBQUFBLEtBQ2pCO0dBQ0Y7O0FBRUQsWUFBVSxFQUFBLHNCQUFHO0FBQ1gsV0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFBO0dBQzNCOztBQUVELFVBQVEsRUFBQSxvQkFBRztBQUNULFdBQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQTtHQUN6Qjs7QUFFRCxLQUFHLEVBQUEsYUFBQyxPQUFPLEVBQUU7QUFDWCx1QkFBZ0IsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBSTtHQUN6Qzs7QUFFRCxVQUFRLEVBQUUsVUFBVTs7QUFFcEIsV0FBUyxFQUFFLFdBQVc7O0FBRXRCLEtBQUcsRUFBQSxhQUFDLE1BQU0sRUFBRTtBQUNWLFdBQU8sTUFBTSxZQUFVLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQU0sS0FBSyxDQUFBO0dBQ3BEOztBQUVELFFBQU0sRUFBQSxnQkFBQyxNQUFNLEVBQUU7QUFDYixXQUFPLE1BQU0sa0JBQWdCLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQU0sTUFBTSxDQUFBO0dBQzNEOzs7OztBQUtELFdBQVMsRUFBQSxtQkFBQyxLQUFLLEVBQUU7QUFDZixRQUFNLFVBQVUsR0FBRyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQzFGLFFBQUksSUFBSSxDQUFDLElBQUksS0FBSyxNQUFNLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7QUFDNUQsYUFBTyxVQUFVLENBQUE7S0FDbEI7QUFDRCxXQUFPLEVBQUUsQ0FBQTtHQUNWOztBQUVELFVBQVEsRUFBQSxvQkFBRztBQUNULFdBQU8sVUFBVSxDQUFBO0dBQ2xCOztBQUVELE9BQUssRUFBQSxpQkFBRztBQUNOLFdBQU8sT0FBTyxDQUFBO0dBQ2Y7O0FBRUQsT0FBSyxFQUFBLGVBQUMsTUFBTSxFQUFFO0FBQ1osc0JBQWdCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFFO0dBQzlDOztBQUVELFNBQU8sRUFBQSxpQkFBQyxRQUFPLEVBQUU7QUFDZixRQUFJLFFBQU8sSUFBSSxRQUFPLENBQUMsTUFBTSxHQUFHLEdBQUcsRUFBRTtBQUNuQyxhQUFPLENBQUMsSUFBSSxDQUFDLDhEQUE4RCxDQUFDLENBQUE7S0FDN0U7QUFDRCxXQUFPLFFBQU8sbUJBQWdCLFFBQU8sT0FBRyxDQUFBO0dBQ3pDOztBQUVELFNBQU8sRUFBQSxpQkFBQyxTQUFTLEVBQUU7QUFDakIsV0FBTyxTQUFTLG1CQUFnQixTQUFTLE9BQUcsQ0FBQTtHQUM3Qzs7Q0FFRixDQUFDLENBQUE7O3FCQUVhLG9CQUFvQiIsImZpbGUiOiJjb2x1bW5jb21waWxlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLy8gTXlTUUwgQ29sdW1uIENvbXBpbGVyXG4vLyAtLS0tLS0tXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuaW1wb3J0IENvbHVtbkNvbXBpbGVyIGZyb20gJy4uLy4uLy4uL3NjaGVtYS9jb2x1bW5jb21waWxlcic7XG5pbXBvcnQgKiBhcyBoZWxwZXJzIGZyb20gJy4uLy4uLy4uL2hlbHBlcnMnO1xuXG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICdsb2Rhc2gnXG5cbmZ1bmN0aW9uIENvbHVtbkNvbXBpbGVyX015U1FMKCkge1xuICBDb2x1bW5Db21waWxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB0aGlzLm1vZGlmaWVycyA9IFsndW5zaWduZWQnLCAnbnVsbGFibGUnLCAnZGVmYXVsdFRvJywgJ2ZpcnN0JywgJ2FmdGVyJywgJ2NvbW1lbnQnLCAnY29sbGF0ZSddXG59XG5pbmhlcml0cyhDb2x1bW5Db21waWxlcl9NeVNRTCwgQ29sdW1uQ29tcGlsZXIpO1xuXG4vLyBUeXBlc1xuLy8gLS0tLS0tXG5cbmFzc2lnbihDb2x1bW5Db21waWxlcl9NeVNRTC5wcm90b3R5cGUsIHtcblxuICBpbmNyZW1lbnRzOiAnaW50IHVuc2lnbmVkIG5vdCBudWxsIGF1dG9faW5jcmVtZW50IHByaW1hcnkga2V5JyxcblxuICBiaWdpbmNyZW1lbnRzOiAnYmlnaW50IHVuc2lnbmVkIG5vdCBudWxsIGF1dG9faW5jcmVtZW50IHByaW1hcnkga2V5JyxcblxuICBiaWdpbnQ6ICdiaWdpbnQnLFxuXG4gIGRvdWJsZShwcmVjaXNpb24sIHNjYWxlKSB7XG4gICAgaWYgKCFwcmVjaXNpb24pIHJldHVybiAnZG91YmxlJ1xuICAgIHJldHVybiBgZG91YmxlKCR7dGhpcy5fbnVtKHByZWNpc2lvbiwgOCl9LCAke3RoaXMuX251bShzY2FsZSwgMil9KWBcbiAgfSxcblxuICBpbnRlZ2VyKGxlbmd0aCkge1xuICAgIGxlbmd0aCA9IGxlbmd0aCA/IGAoJHt0aGlzLl9udW0obGVuZ3RoLCAxMSl9KWAgOiAnJ1xuICAgIHJldHVybiBgaW50JHtsZW5ndGh9YFxuICB9LFxuXG4gIG1lZGl1bWludDogJ21lZGl1bWludCcsXG5cbiAgc21hbGxpbnQ6ICdzbWFsbGludCcsXG5cbiAgdGlueWludChsZW5ndGgpIHtcbiAgICBsZW5ndGggPSBsZW5ndGggPyBgKCR7dGhpcy5fbnVtKGxlbmd0aCwgMSl9KWAgOiAnJ1xuICAgIHJldHVybiBgdGlueWludCR7bGVuZ3RofWBcbiAgfSxcblxuICB0ZXh0KGNvbHVtbikge1xuICAgIHN3aXRjaCAoY29sdW1uKSB7XG4gICAgICBjYXNlICdtZWRpdW0nOlxuICAgICAgY2FzZSAnbWVkaXVtdGV4dCc6XG4gICAgICAgIHJldHVybiAnbWVkaXVtdGV4dCc7XG4gICAgICBjYXNlICdsb25nJzpcbiAgICAgIGNhc2UgJ2xvbmd0ZXh0JzpcbiAgICAgICAgcmV0dXJuICdsb25ndGV4dCdcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAndGV4dCc7XG4gICAgfVxuICB9LFxuXG4gIG1lZGl1bXRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dCgnbWVkaXVtJylcbiAgfSxcblxuICBsb25ndGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0KCdsb25nJylcbiAgfSxcblxuICBlbnUoYWxsb3dlZCkge1xuICAgIHJldHVybiBgZW51bSgnJHthbGxvd2VkLmpvaW4oXCInLCAnXCIpfScpYFxuICB9LFxuXG4gIGRhdGV0aW1lOiAnZGF0ZXRpbWUnLFxuXG4gIHRpbWVzdGFtcDogJ3RpbWVzdGFtcCcsXG5cbiAgYml0KGxlbmd0aCkge1xuICAgIHJldHVybiBsZW5ndGggPyBgYml0KCR7dGhpcy5fbnVtKGxlbmd0aCl9KWAgOiAnYml0J1xuICB9LFxuXG4gIGJpbmFyeShsZW5ndGgpIHtcbiAgICByZXR1cm4gbGVuZ3RoID8gYHZhcmJpbmFyeSgke3RoaXMuX251bShsZW5ndGgpfSlgIDogJ2Jsb2InXG4gIH0sXG5cbiAgLy8gTW9kaWZpZXJzXG4gIC8vIC0tLS0tLVxuXG4gIGRlZmF1bHRUbyh2YWx1ZSkge1xuICAgIGNvbnN0IGRlZmF1bHRWYWwgPSBDb2x1bW5Db21waWxlcl9NeVNRTC5zdXBlcl8ucHJvdG90eXBlLmRlZmF1bHRUby5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh0aGlzLnR5cGUgIT09ICdibG9iJyAmJiB0aGlzLnR5cGUuaW5kZXhPZigndGV4dCcpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWxcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH0sXG5cbiAgdW5zaWduZWQoKSB7XG4gICAgcmV0dXJuICd1bnNpZ25lZCdcbiAgfSxcblxuICBmaXJzdCgpIHtcbiAgICByZXR1cm4gJ2ZpcnN0J1xuICB9LFxuXG4gIGFmdGVyKGNvbHVtbikge1xuICAgIHJldHVybiBgYWZ0ZXIgJHt0aGlzLmZvcm1hdHRlci53cmFwKGNvbHVtbil9YFxuICB9LFxuXG4gIGNvbW1lbnQoY29tbWVudCkge1xuICAgIGlmIChjb21tZW50ICYmIGNvbW1lbnQubGVuZ3RoID4gMjU1KSB7XG4gICAgICBoZWxwZXJzLndhcm4oJ1lvdXIgY29tbWVudCBpcyBsb25nZXIgdGhhbiB0aGUgbWF4IGNvbW1lbnQgbGVuZ3RoIGZvciBNeVNRTCcpXG4gICAgfVxuICAgIHJldHVybiBjb21tZW50ICYmIGBjb21tZW50ICcke2NvbW1lbnR9J2BcbiAgfSxcblxuICBjb2xsYXRlKGNvbGxhdGlvbikge1xuICAgIHJldHVybiBjb2xsYXRpb24gJiYgYGNvbGxhdGUgJyR7Y29sbGF0aW9ufSdgXG4gIH1cblxufSlcblxuZXhwb3J0IGRlZmF1bHQgQ29sdW1uQ29tcGlsZXJfTXlTUUw7XG4iXX0=

/***/ },
/* 100 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _debug = __webpack_require__(66);

	var _debug2 = _interopRequireDefault(_debug);

	var _lodash = __webpack_require__(5);

	var _transaction = __webpack_require__(65);

	var _transaction2 = _interopRequireDefault(_transaction);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var debug = _debug2['default']('knex:tx');

	function Transaction_Maria() {
	  _transaction2['default'].apply(this, arguments);
	}
	_inherits2['default'](Transaction_Maria, _transaction2['default']);

	_lodash.assign(Transaction_Maria.prototype, {

	  query: function query(conn, sql, status, value) {
	    var t = this;
	    var q = this.trxClient.query(conn, sql)['catch'](function (err) {
	      return err.code === 1305;
	    }, function () {
	      helpers.warn('Transaction was implicitly committed, do not mix transactions and ' + 'DDL with MariaDB (#805)');
	    })['catch'](function (err) {
	      status = 2;
	      value = err;
	      t._completed = true;
	      debug('%s error running transaction query', t.txid);
	    }).tap(function () {
	      if (status === 1) t._resolver(value);
	      if (status === 2) t._rejecter(value);
	    });
	    if (status === 1 || status === 2) {
	      t._completed = true;
	    }
	    return q;
	  }

	});

	exports['default'] = Transaction_Maria;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy9tYXJpYS90cmFuc2FjdGlvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozt3QkFDcUIsVUFBVTs7OztxQkFDYixPQUFPOzs7O3NCQUNGLFFBQVE7OzJCQUNQLG1CQUFtQjs7Ozt1QkFDbEIsZUFBZTs7SUFBNUIsT0FBTzs7QUFFbkIsSUFBTSxLQUFLLEdBQUcsbUJBQU0sU0FBUyxDQUFDLENBQUM7O0FBRS9CLFNBQVMsaUJBQWlCLEdBQUc7QUFDM0IsMkJBQVksS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQTtDQUNuQztBQUNELHNCQUFTLGlCQUFpQiwyQkFBYyxDQUFBOztBQUV4QyxlQUFPLGlCQUFpQixDQUFDLFNBQVMsRUFBRTs7QUFFbEMsT0FBSyxFQUFBLGVBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFO0FBQzlCLFFBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQTtBQUNkLFFBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsU0FDakMsQ0FBQyxVQUFBLEdBQUc7YUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLElBQUk7S0FBQSxFQUFFLFlBQU07QUFDckMsYUFBTyxDQUFDLElBQUksQ0FDVixvRUFBb0UsR0FDcEUseUJBQXlCLENBQzFCLENBQUM7S0FDSCxDQUFDLFNBQ0ksQ0FBQyxVQUFTLEdBQUcsRUFBRTtBQUNuQixZQUFNLEdBQUcsQ0FBQyxDQUFBO0FBQ1YsV0FBSyxHQUFHLEdBQUcsQ0FBQTtBQUNYLE9BQUMsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFBO0FBQ25CLFdBQUssQ0FBQyxvQ0FBb0MsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUE7S0FDcEQsQ0FBQyxDQUNELEdBQUcsQ0FBQyxZQUFXO0FBQ2QsVUFBSSxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUE7QUFDcEMsVUFBSSxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUE7S0FDckMsQ0FBQyxDQUFBO0FBQ0osUUFBSSxNQUFNLEtBQUssQ0FBQyxJQUFJLE1BQU0sS0FBSyxDQUFDLEVBQUU7QUFDaEMsT0FBQyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUE7S0FDcEI7QUFDRCxXQUFPLENBQUMsQ0FBQztHQUNWOztDQUVGLENBQUMsQ0FBQTs7cUJBRWEsaUJBQWlCIiwiZmlsZSI6InRyYW5zYWN0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuaW1wb3J0IERlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJ2xvZGFzaCdcbmltcG9ydCBUcmFuc2FjdGlvbiBmcm9tICcuLi8uLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgKiBhcyBoZWxwZXJzIGZyb20gJy4uLy4uL2hlbHBlcnMnO1xuXG5jb25zdCBkZWJ1ZyA9IERlYnVnKCdrbmV4OnR4Jyk7XG5cbmZ1bmN0aW9uIFRyYW5zYWN0aW9uX01hcmlhKCkge1xuICBUcmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5pbmhlcml0cyhUcmFuc2FjdGlvbl9NYXJpYSwgVHJhbnNhY3Rpb24pXG5cbmFzc2lnbihUcmFuc2FjdGlvbl9NYXJpYS5wcm90b3R5cGUsIHtcblxuICBxdWVyeShjb25uLCBzcWwsIHN0YXR1cywgdmFsdWUpIHtcbiAgICBjb25zdCB0ID0gdGhpc1xuICAgIGNvbnN0IHEgPSB0aGlzLnRyeENsaWVudC5xdWVyeShjb25uLCBzcWwpXG4gICAgICAuY2F0Y2goZXJyID0+IGVyci5jb2RlID09PSAxMzA1LCAoKSA9PiB7XG4gICAgICAgIGhlbHBlcnMud2FybihcbiAgICAgICAgICAnVHJhbnNhY3Rpb24gd2FzIGltcGxpY2l0bHkgY29tbWl0dGVkLCBkbyBub3QgbWl4IHRyYW5zYWN0aW9ucyBhbmQgJyArXG4gICAgICAgICAgJ0RETCB3aXRoIE1hcmlhREIgKCM4MDUpJ1xuICAgICAgICApO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgc3RhdHVzID0gMlxuICAgICAgICB2YWx1ZSA9IGVyclxuICAgICAgICB0Ll9jb21wbGV0ZWQgPSB0cnVlXG4gICAgICAgIGRlYnVnKCclcyBlcnJvciBydW5uaW5nIHRyYW5zYWN0aW9uIHF1ZXJ5JywgdC50eGlkKVxuICAgICAgfSlcbiAgICAgIC50YXAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEpIHQuX3Jlc29sdmVyKHZhbHVlKVxuICAgICAgICBpZiAoc3RhdHVzID09PSAyKSB0Ll9yZWplY3Rlcih2YWx1ZSlcbiAgICAgIH0pXG4gICAgaWYgKHN0YXR1cyA9PT0gMSB8fCBzdGF0dXMgPT09IDIpIHtcbiAgICAgIHQuX2NvbXBsZXRlZCA9IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIHE7XG4gIH1cblxufSlcblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNhY3Rpb25fTWFyaWFcbiJdfQ==

/***/ },
/* 102 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	
	// MSSQL Client
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _lodash = __webpack_require__(5);

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _formatter = __webpack_require__(104);

	var _formatter2 = _interopRequireDefault(_formatter);

	var _client = __webpack_require__(42);

	var _client2 = _interopRequireDefault(_client);

	var _promise = __webpack_require__(43);

	var _promise2 = _interopRequireDefault(_promise);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _transaction = __webpack_require__(105);

	var _transaction2 = _interopRequireDefault(_transaction);

	var _queryCompiler = __webpack_require__(106);

	var _queryCompiler2 = _interopRequireDefault(_queryCompiler);

	var _schemaCompiler = __webpack_require__(107);

	var _schemaCompiler2 = _interopRequireDefault(_schemaCompiler);

	var _schemaTablecompiler = __webpack_require__(108);

	var _schemaTablecompiler2 = _interopRequireDefault(_schemaTablecompiler);

	var _schemaColumncompiler = __webpack_require__(109);

	var _schemaColumncompiler2 = _interopRequireDefault(_schemaColumncompiler);

	var isArray = Array.isArray;

	var SQL_INT4 = { MIN: -2147483648, MAX: 2147483647 };
	var SQL_BIGINT_SAFE = { MIN: -9007199254740991, MAX: 9007199254740991 };

	// Always initialize with the "QueryBuilder" and "QueryCompiler" objects, which
	// extend the base 'lib/query/builder' and 'lib/query/compiler', respectively.
	function Client_MSSQL(config) {
	  // #1235 mssql module wants 'server', not 'host'. This is to enforce the same
	  // options object across all dialects.
	  if (config && config.connection && config.connection.host) {
	    config.connection.server = config.connection.host;
	  }
	  _client2['default'].call(this, config);
	}
	_inherits2['default'](Client_MSSQL, _client2['default']);

	_lodash.assign(Client_MSSQL.prototype, {

	  dialect: 'mssql',

	  driverName: 'mssql',

	  _driver: function _driver() {
	    return __webpack_require__(110);
	  },

	  Transaction: _transaction2['default'],

	  Formatter: _formatter2['default'],

	  QueryCompiler: _queryCompiler2['default'],

	  SchemaCompiler: _schemaCompiler2['default'],

	  TableCompiler: _schemaTablecompiler2['default'],

	  ColumnCompiler: _schemaColumncompiler2['default'],

	  wrapIdentifier: function wrapIdentifier(value) {
	    return value !== '*' ? '[' + value.replace(/\[/g, '\[') + ']' : '*';
	  },

	  // Get a raw connection, called by the `pool` whenever a new
	  // connection needs to be added to the pool.
	  acquireRawConnection: function acquireRawConnection() {
	    var client = this;
	    var connection = new this.driver.Connection(this.connectionSettings);
	    return new _promise2['default'](function (resolver, rejecter) {
	      connection.connect(function (err) {
	        if (err) return rejecter(err);
	        connection.on('error', connectionErrorHandler.bind(null, client, connection));
	        connection.on('end', connectionErrorHandler.bind(null, client, connection));
	        resolver(connection);
	      });
	    });
	  },

	  // Used to explicitly close a connection, called internally by the pool
	  // when a connection times out or the pool is shutdown.
	  destroyRawConnection: function destroyRawConnection(connection, cb) {
	    connection.close(cb);
	  },

	  // Position the bindings for the query.
	  positionBindings: function positionBindings(sql) {
	    var questionCount = -1;
	    return sql.replace(/\?/g, function () {
	      questionCount += 1;
	      return '@p' + questionCount;
	    });
	  },

	  // Grab a connection, run the query via the MSSQL streaming interface,
	  // and pass that through to the stream we've sent back to the client.
	  _stream: function _stream(connection, obj, stream, options) {
	    var client = this;
	    options = options || {};
	    if (!obj || typeof obj === 'string') obj = { sql: obj };
	    // convert ? params into positional bindings (@p1)
	    obj.sql = this.positionBindings(obj.sql);
	    return new _promise2['default'](function (resolver, rejecter) {
	      stream.on('error', rejecter);
	      stream.on('end', resolver);
	      var _obj = obj;
	      var sql = _obj.sql;

	      if (!sql) return resolver();
	      if (obj.options) {
	        ;

	        var _assign = _lodash.assign({ sql: sql }, obj.options);

	        sql = _assign.sql;
	      }var req = (connection.tx_ || connection).request();
	      //req.verbose = true;
	      req.multiple = true;
	      req.stream = true;
	      if (obj.bindings) {
	        for (var i = 0; i < obj.bindings.length; i++) {
	          client._setReqInput(req, i, obj.bindings[i]);
	        }
	      }
	      req.pipe(stream);
	      req.query(sql);
	    });
	  },

	  // Runs the query on the specified connection, providing the bindings
	  // and any other necessary prep work.
	  _query: function _query(connection, obj) {
	    var client = this;
	    if (!obj || typeof obj === 'string') obj = { sql: obj };
	    // convert ? params into positional bindings (@p1)
	    obj.sql = this.positionBindings(obj.sql);
	    return new _promise2['default'](function (resolver, rejecter) {
	      var _obj2 = obj;
	      var sql = _obj2.sql;

	      if (!sql) return resolver();
	      if (obj.options) {
	        ;

	        var _assign2 = _lodash.assign({ sql: sql }, obj.options);

	        sql = _assign2.sql;
	      }var req = (connection.tx_ || connection).request();
	      // req.verbose = true;
	      req.multiple = true;
	      if (obj.bindings) {
	        for (var i = 0; i < obj.bindings.length; i++) {
	          client._setReqInput(req, i, obj.bindings[i]);
	        }
	      }
	      req.query(sql, function (err, recordset) {
	        if (err) return rejecter(err);
	        obj.response = recordset[0];
	        resolver(obj);
	      });
	    });
	  },

	  // sets a request input parameter. Detects bigints and sets type appropriately.
	  _setReqInput: function _setReqInput(req, i, binding) {
	    if (typeof binding == 'number' && (binding < SQL_INT4.MIN || binding > SQL_INT4.MAX)) {
	      if (binding < SQL_BIGINT_SAFE.MIN || binding > SQL_BIGINT_SAFE.MAX) {
	        throw new Error('Bigint must be safe integer or must be passed as string, saw ' + binding);
	      }
	      req.input('p' + i, this.driver.BigInt, binding);
	    } else {
	      req.input('p' + i, binding);
	    }
	  },

	  // Process the response as returned from the query.
	  processResponse: function processResponse(obj, runner) {
	    if (obj == null) return;
	    var response = obj.response;
	    var method = obj.method;

	    if (obj.output) return obj.output.call(runner, response);
	    switch (method) {
	      case 'select':
	      case 'pluck':
	      case 'first':
	        response = helpers.skim(response);
	        if (method === 'pluck') return _lodash.map(response, obj.pluck);
	        return method === 'first' ? response[0] : response;
	      case 'insert':
	      case 'del':
	      case 'update':
	      case 'counter':
	        if (obj.returning) {
	          if (obj.returning === '@@rowcount') {
	            return response[0][''];
	          }

	          if (isArray(obj.returning) && obj.returning.length > 1 || obj.returning[0] === '*') {
	            return response;
	          }
	          // return an array with values if only one returning value was specified
	          return _lodash.flatten(_lodash.map(response, _lodash.values));
	        }
	        return response;
	      default:
	        return response;
	    }
	  },

	  ping: function ping(resource, callback) {
	    resource.request().query('SELECT 1', callback);
	  }

	});

	// MSSQL Specific error handler
	function connectionErrorHandler(client, connection, err) {
	  if (connection && err && err.fatal) {
	    if (connection.__knex__disposed) return;
	    connection.__knex__disposed = true;
	    client.pool.destroy(connection);
	  }
	}

	exports['default'] = Client_MSSQL;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy9tc3NxbC9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztzQkFHNkMsUUFBUTs7d0JBQ2hDLFVBQVU7Ozs7eUJBRVQsYUFBYTs7OztzQkFDaEIsY0FBYzs7Ozt1QkFDYixlQUFlOzs7O3VCQUNWLGVBQWU7O0lBQTVCLE9BQU87OzJCQUVLLGVBQWU7Ozs7NkJBQ2Isa0JBQWtCOzs7OzhCQUNqQixtQkFBbUI7Ozs7bUNBQ3BCLHdCQUF3Qjs7OztvQ0FDdkIseUJBQXlCOzs7O0lBRTVDLE9BQU8sR0FBSyxLQUFLLENBQWpCLE9BQU87O0FBRWYsSUFBTSxRQUFRLEdBQUcsRUFBRSxHQUFHLEVBQUcsQ0FBQyxVQUFVLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBQyxDQUFBO0FBQ3RELElBQU0sZUFBZSxHQUFHLEVBQUUsR0FBRyxFQUFHLENBQUMsZ0JBQWdCLEVBQUUsR0FBRyxFQUFFLGdCQUFnQixFQUFDLENBQUE7Ozs7QUFJekUsU0FBUyxZQUFZLENBQUMsTUFBTSxFQUFFOzs7QUFHNUIsTUFBRyxNQUFNLElBQUksTUFBTSxDQUFDLFVBQVUsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRTtBQUN4RCxVQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQztHQUNuRDtBQUNELHNCQUFPLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7Q0FDM0I7QUFDRCxzQkFBUyxZQUFZLHNCQUFTLENBQUM7O0FBRS9CLGVBQU8sWUFBWSxDQUFDLFNBQVMsRUFBRTs7QUFFN0IsU0FBTyxFQUFFLE9BQU87O0FBRWhCLFlBQVUsRUFBRSxPQUFPOztBQUVuQixTQUFPLEVBQUEsbUJBQUc7QUFDUixXQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztHQUN6Qjs7QUFFRCxhQUFXLDBCQUFBOztBQUVYLFdBQVMsd0JBQUE7O0FBRVQs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LFFBQVEsaUJBQVMsQ0FBQyxDQUFDO1NBQ3ZDO0FBQ0QsZUFBTyxRQUFRLENBQUM7QUFBQSxBQUNsQjtBQUNFLGVBQU8sUUFBUSxDQUFBO0FBQUEsS0FDbEI7R0FDRjs7QUFFRCxNQUFJLEVBQUEsY0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFO0FBQ3ZCLFlBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0dBQ2hEOztDQUVGLENBQUMsQ0FBQTs7O0FBR0YsU0FBUyxzQkFBc0IsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLEdBQUcsRUFBRTtBQUN2RCxNQUFJLFVBQVUsSUFBSSxHQUFHLElBQUksR0FBRyxDQUFDLEtBQUssRUFBRTtBQUNsQyxRQUFJLFVBQVUsQ0FBQyxnQkFBZ0IsRUFBRSxPQUFPO0FBQ3hDLGNBQVUsQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7QUFDbkMsVUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7R0FDakM7Q0FDRjs7cUJBRWMsWUFBWSIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLy8gTVNTUUwgQ2xpZW50XG4vLyAtLS0tLS0tXG5pbXBvcnQgeyBhc3NpZ24sIG1hcCwgZmxhdHRlbiwgdmFsdWVzIH0gZnJvbSAnbG9kYXNoJ1xuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcblxuaW1wb3J0IEZvcm1hdHRlciBmcm9tICcuL2Zvcm1hdHRlcic7XG5pbXBvcnQgQ2xpZW50IGZyb20gJy4uLy4uL2NsaWVudCc7XG5pbXBvcnQgUHJvbWlzZSBmcm9tICcuLi8uLi9wcm9taXNlJztcbmltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSAnLi4vLi4vaGVscGVycyc7XG5cbmltcG9ydCBUcmFuc2FjdGlvbiBmcm9tICcuL3RyYW5zYWN0aW9uJztcbmltcG9ydCBRdWVyeUNvbXBpbGVyIGZyb20gJy4vcXVlcnkvY29tcGlsZXInO1xuaW1wb3J0IFNjaGVtYUNvbXBpbGVyIGZyb20gJy4vc2NoZW1hL2NvbXBpbGVyJztcbmltcG9ydCBUYWJsZUNvbXBpbGVyIGZyb20gJy4vc2NoZW1hL3RhYmxlY29tcGlsZXInO1xuaW1wb3J0IENvbHVtbkNvbXBpbGVyIGZyb20gJy4vc2NoZW1hL2NvbHVtbmNvbXBpbGVyJztcblxuY29uc3QgeyBpc0FycmF5IH0gPSBBcnJheTtcblxuY29uc3QgU1FMX0lOVDQgPSB7IE1JTiA6IC0yMTQ3NDgzNjQ4LCBNQVg6IDIxNDc0ODM2NDd9XG5jb25zdCBTUUxfQklHSU5UX1NBRkUgPSB7IE1JTiA6IC05MDA3MTk5MjU0NzQwOTkxLCBNQVg6IDkwMDcxOTkyNTQ3NDA5OTF9XG5cbi8vIEFsd2F5cyBpbml0aWFsaXplIHdpdGggdGhlIFwiUXVlcnlCdWlsZGVyXCIgYW5kIFwiUXVlcnlDb21waWxlclwiIG9iamVjdHMsIHdoaWNoXG4vLyBleHRlbmQgdGhlIGJhc2UgJ2xpYi9xdWVyeS9idWlsZGVyJyBhbmQgJ2xpYi9xdWVyeS9jb21waWxlcicsIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIENsaWVudF9NU1NRTChjb25maWcpIHtcbiAgLy8gIzEyMzUgbXNzcWwgbW9kdWxlIHdhbnRzICdzZXJ2ZXInLCBub3QgJ2hvc3QnLiBUaGlzIGlzIHRvIGVuZm9yY2UgdGhlIHNhbWVcbiAgLy8gb3B0aW9ucyBvYmplY3QgYWNyb3NzIGFsbCBkaWFsZWN0cy5cbiAgaWYoY29uZmlnICYmIGNvbmZpZy5jb25uZWN0aW9uICYmIGNvbmZpZy5jb25uZWN0aW9uLmhvc3QpIHtcbiAgICBjb25maWcuY29ubmVjdGlvbi5zZXJ2ZXIgPSBjb25maWcuY29ubmVjdGlvbi5ob3N0O1xuICB9XG4gIENsaWVudC5jYWxsKHRoaXMsIGNvbmZpZyk7XG59XG5pbmhlcml0cyhDbGllbnRfTVNTUUwsIENsaWVudCk7XG5cbmFzc2lnbihDbGllbnRfTVNTUUwucHJvdG90eXBlLCB7XG5cbiAgZGlhbGVjdDogJ21zc3FsJyxcblxuICBkcml2ZXJOYW1lOiAnbXNzcWwnLFxuXG4gIF9kcml2ZXIoKSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ21zc3FsJyk7XG4gIH0sXG5cbiAgVHJhbnNhY3Rpb24sXG5cbiAgRm9ybWF0dGVyLFxuXG4gIFF1ZXJ5Q29tcGlsZXIsXG5cbiAgU2NoZW1hQ29tcGlsZXIsXG5cbiAgVGFibGVDb21waWxlcixcblxuICBDb2x1bW5Db21waWxlcixcblxuICB3cmFwSWRlbnRpZmllcih2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgIT09ICcqJyA/IGBbJHt2YWx1ZS5yZXBsYWNlKC9cXFsvZywgJ1xcWycpfV1gIDogJyonKVxuICB9LFxuXG4gIC8vIEdldCBhIHJhdyBjb25uZWN0aW9uLCBjYWxsZWQgYnkgdGhlIGBwb29sYCB3aGVuZXZlciBhIG5ld1xuICAvLyBjb25uZWN0aW9uIG5lZWRzIHRvIGJlIGFkZGVkIHRvIHRoZSBwb29sLlxuICBhY3F1aXJlUmF3Q29ubmVjdGlvbigpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzO1xuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXcgdGhpcy5kcml2ZXIuQ29ubmVjdGlvbih0aGlzLmNvbm5lY3Rpb25TZXR0aW5ncyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmVyLCByZWplY3Rlcikge1xuICAgICAgY29ubmVjdGlvbi5jb25uZWN0KGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0ZXIoZXJyKTtcbiAgICAgICAgY29ubmVjdGlvbi5vbignZXJyb3InLCBjb25uZWN0aW9uRXJyb3JIYW5kbGVyLmJpbmQobnVsbCwgY2xpZW50LCBjb25uZWN0aW9uKSk7XG4gICAgICAgIGNvbm5lY3Rpb24ub24oJ2VuZCcsIGNvbm5lY3Rpb25FcnJvckhhbmRsZXIuYmluZChudWxsLCBjbGllbnQsIGNvbm5lY3Rpb24pKTtcbiAgICAgICAgcmVzb2x2ZXIoY29ubmVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICAvLyBVc2VkIHRvIGV4cGxpY2l0bHkgY2xvc2UgYSBjb25uZWN0aW9uLCBjYWxsZWQgaW50ZXJuYWxseSBieSB0aGUgcG9vbFxuICAvLyB3aGVuIGEgY29ubmVjdGlvbiB0aW1lcyBvdXQgb3IgdGhlIHBvb2wgaXMgc2h1dGRvd24uXG4gIGRlc3Ryb3lSYXdDb25uZWN0aW9uKGNvbm5lY3Rpb24sIGNiKSB7XG4gICAgY29ubmVjdGlvbi5jbG9zZShjYik7XG4gIH0sXG5cbiAgLy8gUG9zaXRpb24gdGhlIGJpbmRpbmdzIGZvciB0aGUgcXVlcnkuXG4gIHBvc2l0aW9uQmluZGluZ3Moc3FsKSB7XG4gICAgbGV0IHF1ZXN0aW9uQ291bnQgPSAtMVxuICAgIHJldHVybiBzcWwucmVwbGFjZSgvXFw/L2csIGZ1bmN0aW9uKCkge1xuICAgICAgcXVlc3Rpb25Db3VudCArPSAxXG4gICAgICByZXR1cm4gYEBwJHtxdWVzdGlvbkNvdW50fWBcbiAgICB9KVxuICB9LFxuXG4gIC8vIEdyYWIgYSBjb25uZWN0aW9uLCBydW4gdGhlIHF1ZXJ5IHZpYSB0aGUgTVNTUUwgc3RyZWFtaW5nIGludGVyZmFjZSxcbiAgLy8gYW5kIHBhc3MgdGhhdCB0aHJvdWdoIHRvIHRoZSBzdHJlYW0gd2UndmUgc2VudCBiYWNrIHRvIHRoZSBjbGllbnQuXG4gIF9zdHJlYW0oY29ubmVjdGlvbiwgb2JqLCBzdHJlYW0sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIG9iaiA9IHtzcWw6IG9ian1cbiAgICAvLyBjb252ZXJ0ID8gcGFyYW1zIGludG8gcG9zaXRpb25hbCBiaW5kaW5ncyAoQHAxKVxuICAgIG9iai5zcWwgPSB0aGlzLnBvc2l0aW9uQmluZGluZ3Mob2JqLnNxbCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmVyLCByZWplY3Rlcikge1xuICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIHJlamVjdGVyKTtcbiAgICAgIHN0cmVhbS5vbignZW5kJywgcmVzb2x2ZXIpO1xuICAgICAgbGV0IHsgc3FsIH0gPSBvYmpcbiAgICAgIGlmICghc3FsKSByZXR1cm4gcmVzb2x2ZXIoKVxuICAgICAgaWYgKG9iai5vcHRpb25zKSAoeyBzcWwgfSA9IGFzc2lnbih7c3FsfSwgb2JqLm9wdGlvbnMpKVxuICAgICAgY29uc3QgcmVxID0gKGNvbm5lY3Rpb24udHhfIHx8IGNvbm5lY3Rpb24pLnJlcXVlc3QoKTtcbiAgICAgIC8vcmVxLnZlcmJvc2UgPSB0cnVlO1xuICAgICAgcmVxLm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgIHJlcS5zdHJlYW0gPSB0cnVlO1xuICAgICAgaWYgKG9iai5iaW5kaW5ncykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5iaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNsaWVudC5fc2V0UmVxSW5wdXQocmVxLCBpLCBvYmouYmluZGluZ3NbaV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlcS5waXBlKHN0cmVhbSlcbiAgICAgIHJlcS5xdWVyeShzcWwpXG4gICAgfSlcbiAgfSxcblxuICAvLyBSdW5zIHRoZSBxdWVyeSBvbiB0aGUgc3BlY2lmaWVkIGNvbm5lY3Rpb24sIHByb3ZpZGluZyB0aGUgYmluZGluZ3NcbiAgLy8gYW5kIGFueSBvdGhlciBuZWNlc3NhcnkgcHJlcCB3b3JrLlxuICBfcXVlcnkoY29ubmVjdGlvbiwgb2JqKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcztcbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykgb2JqID0ge3NxbDogb2JqfVxuICAgIC8vIGNvbnZlcnQgPyBwYXJhbXMgaW50byBwb3NpdGlvbmFsIGJpbmRpbmdzIChAcDEpXG4gICAgb2JqLnNxbCA9IHRoaXMucG9zaXRpb25CaW5kaW5ncyhvYmouc3FsKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZXIsIHJlamVjdGVyKSB7XG4gICAgICBsZXQgeyBzcWwgfSA9IG9ialxuICAgICAgaWYgKCFzcWwpIHJldHVybiByZXNvbHZlcigpXG4gICAgICBpZiAob2JqLm9wdGlvbnMpICh7IHNxbCB9ID0gYXNzaWduKHtzcWx9LCBvYmoub3B0aW9ucykpXG4gICAgICBjb25zdCByZXEgPSAoY29ubmVjdGlvbi50eF8gfHwgY29ubmVjdGlvbikucmVxdWVzdCgpO1xuICAgICAgLy8gcmVxLnZlcmJvc2UgPSB0cnVlO1xuICAgICAgcmVxLm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgIGlmIChvYmouYmluZGluZ3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmouYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjbGllbnQuX3NldFJlcUlucHV0KHJlcSwgaSwgb2JqLmJpbmRpbmdzW2ldKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXEucXVlcnkoc3FsLCBmdW5jdGlvbihlcnIsIHJlY29yZHNldCkge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0ZXIoZXJyKVxuICAgICAgICBvYmoucmVzcG9uc2UgPSByZWNvcmRzZXRbMF1cbiAgICAgICAgcmVzb2x2ZXIob2JqKVxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuXG4gIC8vIHNldHMgYSByZXF1ZXN0IGlucHV0IHBhcmFtZXRlci4gRGV0ZWN0cyBiaWdpbnRzIGFuZCBzZXRzIHR5cGUgYXBwcm9wcmlhdGVseS5cbiAgX3NldFJlcUlucHV0KHJlcSwgaSwgYmluZGluZykge1xuICAgIGlmICh0eXBlb2YgYmluZGluZyA9PSAnbnVtYmVyJyAmJiAoYmluZGluZyA8IFNRTF9JTlQ0Lk1JTiB8fCBiaW5kaW5nID4gU1FMX0lOVDQuTUFYKSkge1xuICAgICAgaWYgKGJpbmRpbmcgPCBTUUxfQklHSU5UX1NBRkUuTUlOIHx8IGJpbmRpbmcgPiBTUUxfQklHSU5UX1NBRkUuTUFYKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQmlnaW50IG11c3QgYmUgc2FmZSBpbnRlZ2VyIG9yIG11c3QgYmUgcGFzc2VkIGFzIHN0cmluZywgc2F3ICR7YmluZGluZ31gKVxuICAgICAgfVxuICAgICAgcmVxLmlucHV0KGBwJHtpfWAsIHRoaXMuZHJpdmVyLkJpZ0ludCwgYmluZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxLmlucHV0KGBwJHtpfWAsIGJpbmRpbmcpXG4gICAgfVxuICB9LFxuXG4gIC8vIFByb2Nlc3MgdGhlIHJlc3BvbnNlIGFzIHJldHVybmVkIGZyb20gdGhlIHF1ZXJ5LlxuICBwcm9jZXNzUmVzcG9uc2Uob2JqLCBydW5uZXIpIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybjtcbiAgICBsZXQgeyByZXNwb25zZSB9ID0gb2JqXG4gICAgY29uc3QgeyBtZXRob2QgfSA9IG9ialxuICAgIGlmIChvYmoub3V0cHV0KSByZXR1cm4gb2JqLm91dHB1dC5jYWxsKHJ1bm5lciwgcmVzcG9uc2UpXG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBjYXNlICdwbHVjayc6XG4gICAgICBjYXNlICdmaXJzdCc6XG4gICAgICAgIHJlc3BvbnNlID0gaGVscGVycy5za2ltKHJlc3BvbnNlKVxuICAgICAgICBpZiAobWV0aG9kID09PSAncGx1Y2snKSByZXR1cm4gbWFwKHJlc3BvbnNlLCBvYmoucGx1Y2spXG4gICAgICAgIHJldHVybiBtZXRob2QgPT09ICdmaXJzdCcgPyByZXNwb25zZVswXSA6IHJlc3BvbnNlXG4gICAgICBjYXNlICdpbnNlcnQnOlxuICAgICAgY2FzZSAnZGVsJzpcbiAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICBjYXNlICdjb3VudGVyJzpcbiAgICAgICAgaWYgKG9iai5yZXR1cm5pbmcpIHtcbiAgICAgICAgICBpZiAob2JqLnJldHVybmluZyA9PT0gJ0BAcm93Y291bnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VbMF1bJyddXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGlzQXJyYXkob2JqLnJldHVybmluZykgJiYgb2JqLnJldHVybmluZy5sZW5ndGggPiAxKSB8fFxuICAgICAgICAgICAgb2JqLnJldHVybmluZ1swXSA9PT0gJyonXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHJldHVybiBhbiBhcnJheSB3aXRoIHZhbHVlcyBpZiBvbmx5IG9uZSByZXR1cm5pbmcgdmFsdWUgd2FzIHNwZWNpZmllZFxuICAgICAgICAgIHJldHVybiBmbGF0dGVuKG1hcChyZXNwb25zZSwgdmFsdWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgfVxuICB9LFxuXG4gIHBpbmcocmVzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgcmVzb3VyY2UucmVxdWVzdCgpLnF1ZXJ5KCdTRUxFQ1QgMScsIGNhbGxiYWNrKTtcbiAgfVxuXG59KVxuXG4vLyBNU1NRTCBTcGVjaWZpYyBlcnJvciBoYW5kbGVyXG5mdW5jdGlvbiBjb25uZWN0aW9uRXJyb3JIYW5kbGVyKGNsaWVudCwgY29ubmVjdGlvbiwgZXJyKSB7XG4gIGlmIChjb25uZWN0aW9uICYmIGVyciAmJiBlcnIuZmF0YWwpIHtcbiAgICBpZiAoY29ubmVjdGlvbi5fX2tuZXhfX2Rpc3Bvc2VkKSByZXR1cm47XG4gICAgY29ubmVjdGlvbi5fX2tuZXhfX2Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICBjbGllbnQucG9vbC5kZXN0cm95KGNvbm5lY3Rpb24pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENsaWVudF9NU1NRTFxuIl19

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _formatter = __webpack_require__(61);

	var _formatter2 = _interopRequireDefault(_formatter);

	var _lodash = __webpack_require__(5);

	function MSSQL_Formatter(client) {
	  _formatter2['default'].call(this, client);
	}
	_inherits2['default'](MSSQL_Formatter, _formatter2['default']);

	_lodash.assign(MSSQL_Formatter.prototype, {

	  // Accepts a string or array of columns to wrap as appropriate.
	  columnizeWithPrefix: function columnizeWithPrefix(prefix, target) {
	    var columns = typeof target === 'string' ? [target] : target;
	    var str = '',
	        i = -1;
	    while (++i < columns.length) {
	      if (i > 0) str += ', ';
	      str += prefix + this.wrap(columns[i]);
	    }
	    return str;
	  }

	});

	exports['default'] = MSSQL_Formatter;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy9tc3NxbC9mb3JtYXR0ZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O3dCQUNxQixVQUFVOzs7O3lCQUNULGlCQUFpQjs7OztzQkFFaEIsUUFBUTs7QUFFL0IsU0FBUyxlQUFlLENBQUMsTUFBTSxFQUFFO0FBQy9CLHlCQUFVLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUE7Q0FDN0I7QUFDRCxzQkFBUyxlQUFlLHlCQUFZLENBQUE7O0FBRXBDLGVBQU8sZUFBZSxDQUFDLFNBQVMsRUFBRTs7O0FBR2hDLHFCQUFtQixFQUFBLDZCQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUU7QUFDbEMsUUFBTSxPQUFPLEdBQUcsT0FBTyxNQUFNLEtBQUssUUFBUSxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFBO0FBQzlELFFBQUksR0FBRyxHQUFHLEVBQUU7UUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDckIsV0FBTyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFO0FBQzNCLFVBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLElBQUksSUFBSSxDQUFBO0FBQ3RCLFNBQUcsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtLQUN0QztBQUNELFdBQU8sR0FBRyxDQUFBO0dBQ1g7O0NBRUYsQ0FBQyxDQUFBOztxQkFFYSxlQUFlIiwiZmlsZSI6ImZvcm1hdHRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSAnLi4vLi4vZm9ybWF0dGVyJztcblxuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnbG9kYXNoJ1xuXG5mdW5jdGlvbiBNU1NRTF9Gb3JtYXR0ZXIoY2xpZW50KSB7XG4gIEZvcm1hdHRlci5jYWxsKHRoaXMsIGNsaWVudClcbn1cbmluaGVyaXRzKE1TU1FMX0Zvcm1hdHRlciwgRm9ybWF0dGVyKVxuXG5hc3NpZ24oTVNTUUxfRm9ybWF0dGVyLnByb3RvdHlwZSwge1xuXG4gIC8vIEFjY2VwdHMgYSBzdHJpbmcgb3IgYXJyYXkgb2YgY29sdW1ucyB0byB3cmFwIGFzIGFwcHJvcHJpYXRlLlxuICBjb2x1bW5pemVXaXRoUHJlZml4KHByZWZpeCwgdGFyZ2V0KSB7XG4gICAgY29uc3QgY29sdW1ucyA9IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gW3RhcmdldF0gOiB0YXJnZXRcbiAgICBsZXQgc3RyID0gJycsIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgIGlmIChpID4gMCkgc3RyICs9ICcsICdcbiAgICAgIHN0ciArPSBwcmVmaXggKyB0aGlzLndyYXAoY29sdW1uc1tpXSlcbiAgICB9XG4gICAgcmV0dXJuIHN0clxuICB9LFxuXG59KVxuXG5leHBvcnQgZGVmYXVsdCBNU1NRTF9Gb3JtYXR0ZXJcbiJdfQ==

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _promise = __webpack_require__(43);

	var _promise2 = _interopRequireDefault(_promise);

	var _transaction = __webpack_require__(65);

	var _transaction2 = _interopRequireDefault(_transaction);

	var _lodash = __webpack_require__(5);

	var debug = __webpack_require__(66)('knex:tx');

	function Transaction_MSSQL() {
	  _transaction2['default'].apply(this, arguments);
	}
	_inherits2['default'](Transaction_MSSQL, _transaction2['default']);

	_lodash.assign(Transaction_MSSQL.prototype, {

	  begin: function begin(conn) {
	    debug('%s: begin', this.txid);
	    return conn.tx_.begin().then(this._resolver, this._rejecter);
	  },

	  savepoint: function savepoint(conn) {
	    var _this = this;

	    debug('%s: savepoint at', this.txid);
	    return _promise2['default'].resolve().then(function () {
	      return _this.query(conn, 'SAVE TRANSACTION ' + _this.txid);
	    });
	  },

	  commit: function commit(conn, value) {
	    var _this2 = this;

	    this._completed = true;
	    debug('%s: commit', this.txid);
	    return conn.tx_.commit().then(function () {
	      return _this2._resolver(value);
	    }, this._rejecter);
	  },

	  release: function release(conn, value) {
	    return this._resolver(value);
	  },

	  rollback: function rollback(conn, error) {
	    var _this3 = this;

	    this._completed = true;
	    debug('%s: rolling back', this.txid);
	    return conn.tx_.rollback().then(function () {
	      return _this3._rejecter(error);
	    });
	  },

	  rollbackTo: function rollbackTo(conn, error) {
	    var _this4 = this;

	    debug('%s: rolling backTo', this.txid);
	    return _promise2['default'].resolve().then(function () {
	      return _this4.query(conn, 'ROLLBACK TRANSACTION ' + _this4.txid, 2, error);
	    }).then(function () {
	      return _this4._rejecter(error);
	    });
	  },

	  // Acquire a connection and create a disposer - either using the one passed
	  // via config or getting one off the client. The disposer will be called once
	  // the original promise is marked completed.
	  acquireConnection: function acquireConnection(config) {
	    var t = this;
	    var configConnection = config && config.connection;
	    return _promise2['default']['try'](function () {
	      return (t.outerTx ? t.outerTx.conn : null) || configConnection || t.client.acquireConnection().completed;
	    }).tap(function (conn) {
	      if (!t.outerTx) {
	        t.conn = conn;
	        conn.tx_ = conn.transaction();
	      }
	    }).disposer(function (conn) {
	      if (t.outerTx) return;
	      if (conn.tx_) {
	        if (!t._completed) {
	          debug('%s: unreleased transaction', t.txid);
	          conn.tx_.rollback();
	        }
	        conn.tx_ = null;
	      }
	      t.conn = null;
	      if (!configConnection) {
	        debug('%s: releasing connection', t.txid);
	        t.client.releaseConnection(conn);
	      } else {
	        debug('%s: not releasing external connection', t.txid);
	      }
	    });
	  }

	});

	exports['default'] = Transaction_MSSQL;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy9tc3NxbC90cmFuc2FjdGlvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7d0JBQ3FCLFVBQVU7Ozs7dUJBQ1gsZUFBZTs7OzsyQkFDWCxtQkFBbUI7Ozs7c0JBR3BCLFFBQVE7O0FBRi9CLElBQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQTs7QUFJekMsU0FBUyxpQkFBaUIsR0FBRztBQUMzQiwyQkFBWSxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFBO0NBQ25DO0FBQ0Qsc0JBQVMsaUJBQWlCLDJCQUFjLENBQUE7O0FBRXhDLGVBQU8saUJBQWlCLENBQUMsU0FBUyxFQUFFOztBQUVsQyxPQUFLLEVBQUEsZUFBQyxJQUFJLEVBQUU7QUFDVixTQUFLLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTtBQUM3QixXQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQTtHQUN4Qzs7QUFFRCxXQUFTLEVBQUEsbUJBQUMsSUFBSSxFQUFFOzs7QUFDZCxTQUFLLENBQUMsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBO0FBQ3BDLFdBQU8scUJBQVEsT0FBTyxFQUFFLENBQ3JCLElBQUksQ0FBQzthQUFNLE1BQUssS0FBSyxDQUFDLElBQUksd0JBQXNCLE1BQUssSUFBSSxDQUFHO0tBQUEsQ0FBQyxDQUFBO0dBQ2pFOztBQUVELFFBQU0sRUFBQSxnQkFBQyxJQUFJLEVBQUUsS0FBSyxFQUFFOzs7QUFDbEIsUUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUE7QUFDdEIsU0FBSyxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUE7QUFDOUIsV0FBTyxJQUFJLENBQUMsR0FB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cnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuaW1wb3J0IFByb21pc2UgZnJvbSAnLi4vLi4vcHJvbWlzZSc7XG5pbXBvcnQgVHJhbnNhY3Rpb24gZnJvbSAnLi4vLi4vdHJhbnNhY3Rpb24nO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdrbmV4OnR4JylcblxuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnbG9kYXNoJ1xuXG5mdW5jdGlvbiBUcmFuc2FjdGlvbl9NU1NRTCgpIHtcbiAgVHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuaW5oZXJpdHMoVHJhbnNhY3Rpb25fTVNTUUwsIFRyYW5zYWN0aW9uKVxuXG5hc3NpZ24oVHJhbnNhY3Rpb25fTVNTUUwucHJvdG90eXBlLCB7XG5cbiAgYmVnaW4oY29ubikge1xuICAgIGRlYnVnKCclczogYmVnaW4nLCB0aGlzLnR4aWQpXG4gICAgcmV0dXJuIGNvbm4udHhfLmJlZ2luKClcbiAgICAgIC50aGVuKHRoaXMuX3Jlc29sdmVyLCB0aGlzLl9yZWplY3RlcilcbiAgfSxcblxuICBzYXZlcG9pbnQoY29ubikge1xuICAgIGRlYnVnKCclczogc2F2ZXBvaW50IGF0JywgdGhpcy50eGlkKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgLnRoZW4oKCkgPT4gdGhpcy5xdWVyeShjb25uLCBgU0FWRSBUUkFOU0FDVElPTiAke3RoaXMudHhpZH1gKSlcbiAgfSxcblxuICBjb21taXQoY29ubiwgdmFsdWUpIHtcbiAgICB0aGlzLl9jb21wbGV0ZWQgPSB0cnVlXG4gICAgZGVidWcoJyVzOiBjb21taXQnLCB0aGlzLnR4aWQpXG4gICAgcmV0dXJuIGNvbm4udHhfLmNvbW1pdCgpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLl9yZXNvbHZlcih2YWx1ZSksIHRoaXMuX3JlamVjdGVyKVxuICB9LFxuXG4gIHJlbGVhc2UoY29ubiwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZXIodmFsdWUpXG4gIH0sXG5cbiAgcm9sbGJhY2soY29ubiwgZXJyb3IpIHtcbiAgICB0aGlzLl9jb21wbGV0ZWQgPSB0cnVlXG4gICAgZGVidWcoJyVzOiByb2xsaW5nIGJhY2snLCB0aGlzLnR4aWQpXG4gICAgcmV0dXJuIGNvbm4udHhfLnJvbGxiYWNrKClcbiAgICAgIC50aGVuKCgpID0+IHRoaXMuX3JlamVjdGVyKGVycm9yKSlcbiAgfSxcblxuICByb2xsYmFja1RvKGNvbm4sIGVycm9yKSB7XG4gICAgZGVidWcoJyVzOiByb2xsaW5nIGJhY2tUbycsIHRoaXMudHhpZClcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIC50aGVuKCgpID0+IHRoaXMucXVlcnkoY29ubiwgYFJPTExCQUNLIFRSQU5TQUNUSU9OICR7dGhpcy50eGlkfWAsIDIsIGVycm9yKSlcbiAgICAgIC50aGVuKCgpID0+IHRoaXMuX3JlamVjdGVyKGVycm9yKSlcbiAgfSxcblxuICAvLyBBY3F1aXJlIGEgY29ubmVjdGlvbiBhbmQgY3JlYXRlIGEgZGlzcG9zZXIgLSBlaXRoZXIgdXNpbmcgdGhlIG9uZSBwYXNzZWRcbiAgLy8gdmlhIGNvbmZpZyBvciBnZXR0aW5nIG9uZSBvZmYgdGhlIGNsaWVudC4gVGhlIGRpc3Bvc2VyIHdpbGwgYmUgY2FsbGVkIG9uY2VcbiAgLy8gdGhlIG9yaWdpbmFsIHByb21pc2UgaXMgbWFya2VkIGNvbXBsZXRlZC5cbiAgYWNxdWlyZUNvbm5lY3Rpb24oY29uZmlnKSB7XG4gICAgY29uc3QgdCA9IHRoaXNcbiAgICBjb25zdCBjb25maWdDb25uZWN0aW9uID0gY29uZmlnICYmIGNvbmZpZy5jb25uZWN0aW9uXG4gICAgcmV0dXJuIFByb21pc2UudHJ5KCgpID0+IHtcbiAgICAgIHJldHVybiAodC5vdXRlclR4ID8gdC5vdXRlclR4LmNvbm4gOiBudWxsKSB8fFxuICAgICAgICBjb25maWdDb25uZWN0aW9uIHx8XG4gICAgICAgIHQuY2xpZW50LmFjcXVpcmVDb25uZWN0aW9uKCkuY29tcGxldGVkO1xuICAgIH0pLnRhcChmdW5jdGlvbihjb25uKSB7XG4gICAgICBpZiAoIXQub3V0ZXJUeCkge1xuICAgICAgICB0LmNvbm4gPSBjb25uXG4gICAgICAgIGNvbm4udHhfID0gY29ubi50cmFuc2FjdGlvbigpXG4gICAgICB9XG4gICAgfSkuZGlzcG9zZXIoZnVuY3Rpb24oY29ubikge1xuICAgICAgaWYgKHQub3V0ZXJUeCkgcmV0dXJuO1xuICAgICAgaWYgKGNvbm4udHhfKSB7XG4gICAgICAgIGlmICghdC5fY29tcGxldGVkKSB7XG4gICAgICAgICAgZGVidWcoJyVzOiB1bnJlbGVhc2VkIHRyYW5zYWN0aW9uJywgdC50eGlkKVxuICAgICAgICAgIGNvbm4udHhfLnJvbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29ubi50eF8gPSBudWxsO1xuICAgICAgfVxuICAgICAgdC5jb25uID0gbnVsbFxuICAgICAgaWYgKCFjb25maWdDb25uZWN0aW9uKSB7XG4gICAgICAgIGRlYnVnKCclczogcmVsZWFzaW5nIGNvbm5lY3Rpb24nLCB0LnR4aWQpXG4gICAgICAgIHQuY2xpZW50LnJlbGVhc2VDb25uZWN0aW9uKGNvbm4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygnJXM6IG5vdCByZWxlYXNpbmcgZXh0ZXJuYWwgY29ubmVjdGlvbicsIHQudHhpZClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbn0pXG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zYWN0aW9uX01TU1FMXG4iXX0=

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	
	// MSSQL Query Compiler
	// ------
	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _queryCompiler = __webpack_require__(75);

	var _queryCompiler2 = _interopRequireDefault(_queryCompiler);

	var _lodash = __webpack_require__(5);

	function QueryCompiler_MSSQL(client, builder) {
	  _queryCompiler2['default'].call(this, client, builder);
	}
	_inherits2['default'](QueryCompiler_MSSQL, _queryCompiler2['default']);

	_lodash.assign(QueryCompiler_MSSQL.prototype, {

	  _emptyInsertValue: 'default values',

	  // Compiles an "insert" query, allowing for multiple
	  // inserts using a single query statement.
	  insert: function insert() {
	    var insertValues = this.single.insert || [];
	    var sql = 'insert into ' + this.tableName + ' ';
	    var returning = this.single.returning;

	    var returningSql = returning ? this._returning('insert', returning) + ' ' : '';

	    if (Array.isArray(insertValues)) {
	      if (insertValues.length === 0) {
	        return '';
	      }
	    } else if (typeof insertValues === 'object' && _lodash.isEmpty(insertValues)) {
	      return {
	        sql: sql + returningSql + this._emptyInsertValue,
	        returning: returning
	      };
	    }

	    var insertData = this._prepInsert(insertValues);
	    if (typeof insertData === 'string') {
	      sql += insertData;
	    } else {
	      if (insertData.columns.length) {
	        sql += '(' + this.formatter.columnize(insertData.columns);
	        sql += ') ' + returningSql + 'values (';
	        var i = -1;
	        while (++i < insertData.values.length) {
	          if (i !== 0) sql += '), (';
	          sql += this.formatter.parameterize(insertData.values[i], this.client.valueForUndefined);
	        }
	        sql += ')';
	      } else if (insertValues.length === 1 && insertValues[0]) {
	        sql += returningSql + this._emptyInsertValue;
	      } else {
	        sql = '';
	      }
	    }
	    return {
	      sql: sql,
	      returning: returning
	    };
	  },

	  // Compiles an `update` query, allowing for a return value.
	  update: function update() {
	    var updates = this._prepUpdate(this.single.update);
	    var join = this.join();
	    var where = this.where();
	    var order = this.order();
	    var top = this.top();
	    var returning = this.single.returning;

	    return {
	      sql: 'update ' + (top ? top + ' ' : '') + this.tableName + (join ? ' ' + join : '') + ' set ' + updates.join(', ') + (returning ? ' ' + this._returning('update', returning) : '') + (where ? ' ' + where : '') + (order ? ' ' + order : '') + (!returning ? this._returning('rowcount', '@@rowcount') : ''),
	      returning: returning || '@@rowcount'
	    };
	  },

	  // Compiles a `delete` query.
	  del: function del() {
	    // Make sure tableName is processed by the formatter first.
	    var tableName = this.tableName;

	    var wheres = this.where();
	    var returning = this.single.returning;

	    return {
	      sql: 'delete from ' + tableName + (returning ? ' ' + this._returning('del', returning) : '') + (wheres ? ' ' + wheres : '') + (!returning ? this._returning('rowcount', '@@rowcount') : ''),
	      returning: returning || '@@rowcount'
	    };
	  },

	  // Compiles the columns in the query, specifying if an item was distinct.
	  columns: function columns() {
	    var distinct = false;
	    if (this.onlyUnions()) return '';
	    var columns = this.grouped.columns || [];
	    var i = -1,
	        sql = [];
	    if (columns) {
	      while (++i < columns.length) {
	        var stmt = columns[i];
	        if (stmt.distinct) distinct = true;
	        if (stmt.type === 'aggregate') {
	          sql.push(this.aggregate(stmt));
	        } else if (stmt.value && stmt.value.length > 0) {
	          sql.push(this.formatter.columnize(stmt.value));
	        }
	      }
	    }
	    if (sql.length === 0) sql = ['*'];
	    var top = this.top();
	    return 'select ' + (distinct ? 'distinct ' : '') + (top ? top + ' ' : '') + sql.join(', ') + (this.tableName ? ' from ' + this.tableName : '');
	  },

	  _returning: function _returning(method, value) {
	    switch (method) {
	      case 'update':
	      case 'insert':
	        return value ? 'output ' + this.formatter.columnizeWithPrefix('inserted.', value) : '';
	      case 'del':
	        return value ? 'output ' + this.formatter.columnizeWithPrefix('deleted.', value) : '';
	      case 'rowcount':
	        return value ? ';select @@rowcount' : '';
	    }
	  },

	  // Compiles a `truncate` query.
	  truncate: function truncate() {
	    return 'truncate table ' + this.tableName;
	  },

	  forUpdate: function forUpdate() {
	    return 'with (READCOMMITTEDLOCK)';
	  },

	  forShare: function forShare() {
	    return 'with (NOLOCK)';
	  },

	  // Compiles a `columnInfo` query.
	  columnInfo: function columnInfo() {
	    var column = this.single.columnInfo;
	    var sql = 'select * from information_schema.columns where table_name = ? and table_schema = \'dbo\'';
	    return {
	      sql: sql,
	      bindings: [this.single.table],
	      output: function output(resp) {
	        var out = resp.reduce(function (columns, val) {
	          columns[val.COLUMN_NAME] = {
	            defaultValue: val.COLUMN_DEFAULT,
	            type: val.DATA_TYPE,
	            maxLength: val.CHARACTER_MAXIMUM_LENGTH,
	            nullable: val.IS_NULLABLE === 'YES'
	          };
	          return columns;
	        }, {});
	        return column && out[column] || out;
	      }
	    };
	  },

	  top: function top() {
	    var noLimit = !this.single.limit && this.single.limit !== 0;
	    var noOffset = !this.single.offset;
	    if (noLimit || !noOffset) return '';
	    return 'top (' + this.formatter.parameter(this.single.limit) + ')';
	  },

	  limit: function limit() {
	    return '';
	  },

	  offset: function offset() {
	    var noLimit = !this.single.limit && this.single.limit !== 0;
	    var noOffset = !this.single.offset;
	    if (noOffset) return '';
	    var offset = 'offset ' + (noOffset ? '0' : this.formatter.parameter(this.single.offset)) + ' rows';
	    if (!noLimit) {
	      offset += ' fetch next ' + this.formatter.parameter(this.single.limit) + ' rows only';
	    }
	    return offset;
	  }

	});

	// Set the QueryBuilder & QueryCompiler on the client object,
	// in case anyone wants to modify things to suit their own purposes.
	exports['default'] = QueryCompiler_MSSQL;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9tc3NxbC9xdWVyeS9jb21waWxlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7d0JBR3FCLFVBQVU7Ozs7NkJBQ0wseUJBQXlCOzs7O3NCQUVuQixRQUFROztBQUV4QyxTQUFTLG1CQUFtQixDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUU7QUFDNUMsNkJBQWMsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUE7Q0FDMUM7QUFDRCxzQkFBUyxtQkFBbUIsNkJBQWdCLENBQUE7O0FBRTVDLGVBQU8sbUJBQW1CLENBQUMsU0FBUyxFQUFFOztBQUVwQyxtQkFBaUIsRUFBRSxnQkFBZ0I7Ozs7QUFJbkMsUUFBTSxFQUFBLGtCQUFHO0FBQ1AsUUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDO0FBQzlDLFFBQUksR0FBRyxvQkFBa0IsSUFBSSxDQUFDLFNBQVMsTUFBRyxDQUFDO1FBQ25DLFNBQVMsR0FBSyxJQUFJLENBQUMsTUFBTSxDQUF6QixTQUFTOztBQUNqQixRQUFNLFlBQVksR0FBRyxTQUFTLEdBQzFCLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxHQUFHLEdBQUcsR0FDMUMsRUFBRSxDQUFDOztBQUVQLFFBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsRUFBRTtBQUMvQixVQUFJLFlBQVksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO0FBQzdCLGVBQU8sRUFBRSxDQUFBO09BQ1Y7S0FDRixNQUFNLElBQUksT0FBTyxZQUFZLEtBQUssUUFBUSxJQUFJLGdCQUFRLFlBQVksQ0FBQyxFQUFFO0FBQ3BFLGFBQU87QUFDTCxXQUFHLEVBQUUsR0FBRyxHQUFHLFlBQVksR0FBRyxJQUFJLENBQUMsaUJBQWlCO0FBQ2hELGlCQUFTLEVBQVQsU0FBUztPQUNWLENBQUM7S0FDSDs7QUFF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LFFBQU0sT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDO0FBQzlELFFBQU0sUUFBUSxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDckMsUUFBSSxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUM7QUFDeEIsUUFBSSxNQUFNLGdCQUFhLFFBQVEsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQSxVQUFPLENBQUM7QUFDNUYsUUFBSSxDQUFDLE9BQU8sRUFBRTtBQUNaLFlBQU0scUJBQW1CLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLGVBQVksQ0FBQztLQUNsRjtBQUNELFdBQU8sTUFBTSxDQUFDO0dBQ2Y7O0NBRUYsQ0FBQyxDQUFBOzs7O3FCQUlhLG1CQUFtQiIsImZpbGUiOiJjb21waWxlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLy8gTVNTUUwgUXVlcnkgQ29tcGlsZXJcbi8vIC0tLS0tLVxuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcbmltcG9ydCBRdWVyeUNvbXBpbGVyIGZyb20gJy4uLy4uLy4uL3F1ZXJ5L2NvbXBpbGVyJztcblxuaW1wb3J0IHsgYXNzaWduLCBpc0VtcHR5IH0gZnJvbSAnbG9kYXNoJ1xuXG5mdW5jdGlvbiBRdWVyeUNvbXBpbGVyX01TU1FMKGNsaWVudCwgYnVpbGRlcikge1xuICBRdWVyeUNvbXBpbGVyLmNhbGwodGhpcywgY2xpZW50LCBidWlsZGVyKVxufVxuaW5oZXJpdHMoUXVlcnlDb21waWxlcl9NU1NRTCwgUXVlcnlDb21waWxlcilcblxuYXNzaWduKFF1ZXJ5Q29tcGlsZXJfTVNTUUwucHJvdG90eXBlLCB7XG5cbiAgX2VtcHR5SW5zZXJ0VmFsdWU6ICdkZWZhdWx0IHZhbHVlcycsXG5cbiAgLy8gQ29tcGlsZXMgYW4gXCJpbnNlcnRcIiBxdWVyeSwgYWxsb3dpbmcgZm9yIG11bHRpcGxlXG4gIC8vIGluc2VydHMgdXNpbmcgYSBzaW5nbGUgcXVlcnkgc3RhdGVtZW50LlxuICBpbnNlcnQoKSB7XG4gICAgY29uc3QgaW5zZXJ0VmFsdWVzID0gdGhpcy5zaW5nbGUuaW5zZXJ0IHx8IFtdO1xuICAgIGxldCBzcWwgPSBgaW5zZXJ0IGludG8gJHt0aGlzLnRhYmxlTmFtZX0gYDtcbiAgICBjb25zdCB7IHJldHVybmluZyB9ID0gdGhpcy5zaW5nbGU7XG4gICAgY29uc3QgcmV0dXJuaW5nU3FsID0gcmV0dXJuaW5nXG4gICAgICA/IHRoaXMuX3JldHVybmluZygnaW5zZXJ0JywgcmV0dXJuaW5nKSArICcgJ1xuICAgICAgOiAnJztcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGluc2VydFZhbHVlcykpIHtcbiAgICAgIGlmIChpbnNlcnRWYWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc2VydFZhbHVlcyA9PT0gJ29iamVjdCcgJiYgaXNFbXB0eShpbnNlcnRWYWx1ZXMpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzcWw6IHNxbCArIHJldHVybmluZ1NxbCArIHRoaXMuX2VtcHR5SW5zZXJ0VmFsdWUsXG4gICAgICAgIHJldHVybmluZ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnNlcnREYXRhID0gdGhpcy5fcHJlcEluc2VydChpbnNlcnRWYWx1ZXMpO1xuICAgIGlmICh0eXBlb2YgaW5zZXJ0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNxbCArPSBpbnNlcnREYXRhO1xuICAgIH0gZWxzZSAge1xuICAgICAgaWYgKGluc2VydERhdGEuY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgc3FsICs9IGAoJHt0aGlzLmZvcm1hdHRlci5jb2x1bW5pemUoaW5zZXJ0RGF0YS5jb2x1bW5zKX1gXG4gICAgICAgIHNxbCArPSBgKSAke3JldHVybmluZ1NxbH12YWx1ZXMgKGBcbiAgICAgICAgbGV0IGkgPSAtMVxuICAgICAgICB3aGlsZSAoKytpIDwgaW5zZXJ0RGF0YS52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGkgIT09IDApIHNxbCArPSAnKSwgKCdcbiAgICAgICAgICBzcWwgKz0gdGhpcy5mb3JtYXR0ZXIucGFyYW1ldGVyaXplKFxuICAgICAgICAgICAgaW5zZXJ0RGF0YS52YWx1ZXNbaV0sIHRoaXMuY2xpZW50LnZhbHVlRm9yVW5kZWZpbmVkXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHNxbCArPSAnKSc7XG4gICAgICB9IGVsc2UgaWYgKGluc2VydFZhbHVlcy5sZW5ndGggPT09IDEgJiYgaW5zZXJ0VmFsdWVzWzBdKSB7XG4gICAgICAgIHNxbCArPSByZXR1cm5pbmdTcWwgKyB0aGlzLl9lbXB0eUluc2VydFZhbHVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcWwgPSAnJ1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3FsLFxuICAgICAgcmV0dXJuaW5nXG4gICAgfTtcbiAgfSxcblxuICAvLyBDb21waWxlcyBhbiBgdXBkYXRlYCBxdWVyeSwgYWxsb3dpbmcgZm9yIGEgcmV0dXJuIHZhbHVlLlxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgdXBkYXRlcyA9IHRoaXMuX3ByZXBVcGRhdGUodGhpcy5zaW5nbGUudXBkYXRlKTtcbiAgICBjb25zdCBqb2luID0gdGhpcy5qb2luKCk7XG4gICAgY29uc3Qgd2hlcmUgPSB0aGlzLndoZXJlKCk7XG4gICAgY29uc3Qgb3JkZXIgPSB0aGlzLm9yZGVyKCk7XG4gICAgY29uc3QgdG9wID0gdGhpcy50b3AoKTtcbiAgICBjb25zdCB7IHJldHVybmluZyB9ID0gdGhpcy5zaW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNxbDogYHVwZGF0ZSAke3RvcCA/IHRvcCArICcgJyA6ICcnfSR7dGhpcy50YWJsZU5hbWV9YCArXG4gICAgICAgIChqb2luID8gYCAke2pvaW59YCA6ICcnKSArXG4gICAgICAgICcgc2V0ICcgKyB1cGRhdGVzLmpvaW4oJywgJykgK1xuICAgICAgICAocmV0dXJuaW5nID8gYCAke3RoaXMuX3JldHVybmluZygndXBkYXRlJywgcmV0dXJuaW5nKX1gIDogJycpICtcbiAgICAgICAgKHdoZXJlID8gYCAke3doZXJlfWAgOiAnJykgK1xuICAgICAgICAob3JkZXIgPyBgICR7b3JkZXJ9YCA6ICcnKSArXG4gICAgICAgICghcmV0dXJuaW5nID8gdGhpcy5fcmV0dXJuaW5nKCdyb3djb3VudCcsICdAQHJvd2NvdW50JykgOiAnJyksXG4gICAgICByZXR1cm5pbmc6IHJldHVybmluZyB8fCAnQEByb3djb3VudCdcbiAgICB9O1xuICB9LFxuXG4gIC8vIENvbXBpbGVzIGEgYGRlbGV0ZWAgcXVlcnkuXG4gIGRlbCgpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGFibGVOYW1lIGlzIHByb2Nlc3NlZCBieSB0aGUgZm9ybWF0dGVyIGZpcnN0LlxuICAgIGNvbnN0IHsgdGFibGVOYW1lIH0gPSB0aGlzO1xuICAgIGNvbnN0IHdoZXJlcyA9IHRoaXMud2hlcmUoKTtcbiAgICBjb25zdCB7IHJldHVybmluZyB9ID0gdGhpcy5zaW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNxbDogYGRlbGV0ZSBmcm9tICR7dGFibGVOYW1lfWAgK1xuICAgICAgICAocmV0dXJuaW5nID8gYCAke3RoaXMuX3JldHVybmluZygnZGVsJywgcmV0dXJuaW5nKX1gIDogJycpICtcbiAgICAgICAgKHdoZXJlcyA/IGAgJHt3aGVyZXN9YCA6ICcnKSArXG4gICAgICAgICghcmV0dXJuaW5nID8gdGhpcy5fcmV0dXJuaW5nKCdyb3djb3VudCcsICdAQHJvd2NvdW50JykgOiAnJyksXG4gICAgICByZXR1cm5pbmc6IHJldHVybmluZyB8fCAnQEByb3djb3VudCdcbiAgICB9O1xuICB9LFxuXG5cbiAgLy8gQ29tcGlsZXMgdGhlIGNvbHVtbnMgaW4gdGhlIHF1ZXJ5LCBzcGVjaWZ5aW5nIGlmIGFuIGl0ZW0gd2FzIGRpc3RpbmN0LlxuICBjb2x1bW5zKCkge1xuICAgIGxldCBkaXN0aW5jdCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLm9ubHlVbmlvbnMoKSkgcmV0dXJuICcnXG4gICAgY29uc3QgY29sdW1ucyA9IHRoaXMuZ3JvdXBlZC5jb2x1bW5zIHx8IFtdXG4gICAgbGV0IGkgPSAtMSwgc3FsID0gW107XG4gICAgaWYgKGNvbHVtbnMpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBjb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBzdG10ID0gY29sdW1uc1tpXTtcbiAgICAgICAgaWYgKHN0bXQuZGlzdGluY3QpIGRpc3RpbmN0ID0gdHJ1ZVxuICAgICAgICBpZiAoc3RtdC50eXBlID09PSAnYWdncmVnYXRlJykge1xuICAgICAgICAgIHNxbC5wdXNoKHRoaXMuYWdncmVnYXRlKHN0bXQpKVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0bXQudmFsdWUgJiYgc3RtdC52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3FsLnB1c2godGhpcy5mb3JtYXR0ZXIuY29sdW1uaXplKHN0bXQudmFsdWUpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzcWwubGVuZ3RoID09PSAwKSBzcWwgPSBbJyonXTtcbiAgICBjb25zdCB0b3AgPSB0aGlzLnRvcCgpO1xuICAgIHJldHVybiBgc2VsZWN0ICR7ZGlzdGluY3QgPyAnZGlzdGluY3QgJyA6ICcnfWAgK1xuICAgICAgKHRvcCA/IHRvcCArICcgJyA6ICcnKSArXG4gICAgICBzcWwuam9pbignLCAnKSArICh0aGlzLnRhYmxlTmFtZSA/IGAgZnJvbSAke3RoaXMudGFibGVOYW1lfWAgOiAnJyk7XG4gIH0sXG5cbiAgX3JldHVybmluZyhtZXRob2QsIHZhbHVlKSB7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICBjYXNlICdpbnNlcnQnOlxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICA/IGBvdXRwdXQgJHt0aGlzLmZvcm1hdHRlci5jb2x1bW5pemVXaXRoUHJlZml4KCdpbnNlcnRlZC4nLCB2YWx1ZSl9YFxuICAgICAgICAgIDogJyc7XG4gICAgICBjYXNlICdkZWwnOlxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICA/IGBvdXRwdXQgJHt0aGlzLmZvcm1hdHRlci5jb2x1bW5pemVXaXRoUHJlZml4KCdkZWxldGVkLicsIHZhbHVlKX1gXG4gICAgICAgICAgOiAnJztcbiAgICAgIGNhc2UgJ3Jvd2NvdW50JzpcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgPyAnO3NlbGVjdCBAQHJvd2NvdW50J1xuICAgICAgICAgIDogJyc7XG4gICAgfVxuICB9LFxuXG4gIC8vIENvbXBpbGVzIGEgYHRydW5jYXRlYCBxdWVyeS5cbiAgdHJ1bmNhdGUoKSB7XG4gICAgcmV0dXJuIGB0cnVuY2F0ZSB0YWJsZSAke3RoaXMudGFibGVOYW1lfWA7XG4gIH0sXG5cbiAgZm9yVXBkYXRlKCkge1xuICAgIHJldHVybiAnd2l0aCAoUkVBRENPTU1JVFRFRExPQ0spJztcbiAgfSxcblxuICBmb3JTaGFyZSgpIHtcbiAgICByZXR1cm4gJ3dpdGggKE5PTE9DSyknO1xuICB9LFxuXG4gIC8vIENvbXBpbGVzIGEgYGNvbHVtbkluZm9gIHF1ZXJ5LlxuICBjb2x1bW5JbmZvKCkge1xuICAgIGNvbnN0IGNvbHVtbiA9IHRoaXMuc2luZ2xlLmNvbHVtbkluZm87XG4gICAgY29uc3Qgc3FsID1cbiAgICAgIGBzZWxlY3QgKiBmcm9tIGluZm9ybWF0aW9uX3NjaGVtYS5jb2x1bW5zIHdoZXJlIHRhYmxlX25hbWUgPSA/IGFuZCB0YWJsZV9zY2hlbWEgPSAnZGJvJ2A7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNxbCxcbiAgICAgIGJpbmRpbmdzOiBbdGhpcy5zaW5nbGUudGFibGVdLFxuICAgICAgb3V0cHV0KHJlc3ApIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gcmVzcC5yZWR1Y2UoZnVuY3Rpb24oY29sdW1ucywgdmFsKSB7XG4gICAgICAgICAgY29sdW1uc1t2YWwuQ09MVU1OX05BTUVdID0ge1xuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiB2YWwuQ09MVU1OX0RFRkFVTFQsXG4gICAgICAgICAgICB0eXBlOiB2YWwuREFUQV9UWVBFLFxuICAgICAgICAgICAgbWF4TGVuZ3RoOiB2YWwuQ0hBUkFDVEVSX01BWElNVU1fTEVOR1RILFxuICAgICAgICAgICAgbnVsbGFibGU6ICh2YWwuSVNfTlVMTEFCTEUgPT09ICdZRVMnKVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGNvbHVtbnNcbiAgICAgICAgfSwge30pXG4gICAgICAgIHJldHVybiBjb2x1bW4gJiYgb3V0W2NvbHVtbl0gfHwgb3V0O1xuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgdG9wKCkge1xuICAgIGNvbnN0IG5vTGltaXQgPSAhdGhpcy5zaW5nbGUubGltaXQgJiYgdGhpcy5zaW5nbGUubGltaXQgIT09IDA7XG4gICAgY29uc3Qgbm9PZmZzZXQgPSAhdGhpcy5zaW5nbGUub2Zmc2V0O1xuICAgIGlmIChub0xpbWl0IHx8ICFub09mZnNldCkgcmV0dXJuICcnO1xuICAgIHJldHVybiBgdG9wICgke3RoaXMuZm9ybWF0dGVyLnBhcmFtZXRlcih0aGlzLnNpbmdsZS5saW1pdCl9KWA7XG4gIH0sXG5cbiAgbGltaXQoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9LFxuXG4gIG9mZnNldCgpIHtcbiAgICBjb25zdCBub0xpbWl0ID0gIXRoaXMuc2luZ2xlLmxpbWl0ICYmIHRoaXMuc2luZ2xlLmxpbWl0ICE9PSAwO1xuICAgIGNvbnN0IG5vT2Zmc2V0ID0gIXRoaXMuc2luZ2xlLm9mZnNldDtcbiAgICBpZiAobm9PZmZzZXQpIHJldHVybiAnJztcbiAgICBsZXQgb2Zmc2V0ID0gYG9mZnNldCAke25vT2Zmc2V0ID8gJzAnIDogdGhpcy5mb3JtYXR0ZXIucGFyYW1ldGVyKHRoaXMuc2luZ2xlLm9mZnNldCl9IHJvd3NgO1xuICAgIGlmICghbm9MaW1pdCkge1xuICAgICAgb2Zmc2V0ICs9IGAgZmV0Y2ggbmV4dCAke3RoaXMuZm9ybWF0dGVyLnBhcmFtZXRlcih0aGlzLnNpbmdsZS5saW1pdCl9IHJvd3Mgb25seWA7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH0sXG5cbn0pXG5cbi8vIFNldCB0aGUgUXVlcnlCdWlsZGVyICYgUXVlcnlDb21waWxlciBvbiB0aGUgY2xpZW50IG9iamVjdCxcbi8vIGluIGNhc2UgYW55b25lIHdhbnRzIHRvIG1vZGlmeSB0aGluZ3MgdG8gc3VpdCB0aGVpciBvd24gcHVycG9zZXMuXG5leHBvcnQgZGVmYXVsdCBRdWVyeUNvbXBpbGVyX01TU1FMO1xuIl19

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	
	// MySQL Schema Compiler
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _schemaCompiler = __webpack_require__(77);

	var _schemaCompiler2 = _interopRequireDefault(_schemaCompiler);

	var _lodash = __webpack_require__(5);

	function SchemaCompiler_MSSQL(client, builder) {
	  _schemaCompiler2['default'].call(this, client, builder);
	}
	_inherits2['default'](SchemaCompiler_MSSQL, _schemaCompiler2['default']);

	_lodash.assign(SchemaCompiler_MSSQL.prototype, {

	  dropTablePrefix: 'DROP TABLE ',
	  dropTableIfExists: function dropTableIfExists(tableName) {
	    var name = this.formatter.wrap(prefixedTableName(this.schema, tableName));
	    this.pushQuery('if object_id(\'' + name + '\', \'U\') is not null DROP TABLE ' + name);
	  },

	  // Rename a table on the schema.
	  renameTable: function renameTable(tableName, to) {
	    this.pushQuery('exec sp_rename ' + this.formatter.parameter(tableName) + ', ' + this.formatter.parameter(to));
	  },

	  // Check whether a table exists on the query.
	  hasTable: function hasTable(tableName) {
	    var formattedTable = this.formatter.parameter(this.formatter.wrap(tableName));
	    var sql = 'select object_id from sys.tables ' + ('where object_id = object_id(' + formattedTable + ')');
	    this.pushQuery({ sql: sql, output: function output(resp) {
	        return resp.length > 0;
	      } });
	  },

	  // Check whether a column exists on the schema.
	  hasColumn: function hasColumn(tableName, column) {
	    var formattedColumn = this.formatter.parameter(column);
	    var formattedTable = this.formatter.parameter(this.formatter.wrap(tableName));
	    var sql = 'select object_id from sys.columns ' + ('where name = ' + formattedColumn + ' ') + ('and object_id = object_id(' + formattedTable + ')');
	    this.pushQuery({ sql: sql, output: function output(resp) {
	        return resp.length > 0;
	      } });
	  }

	});

	function prefixedTableName(prefix, table) {
	  return prefix ? prefix + '.' + table : table;
	}

	exports['default'] = SchemaCompiler_MSSQL;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9tc3NxbC9zY2hlbWEvY29tcGlsZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O3dCQUdxQixVQUFVOzs7OzhCQUNKLDBCQUEwQjs7OztzQkFFOUIsUUFBUTs7QUFFL0IsU0FBUyxvQkFBb0IsQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFO0FBQzdDLDhCQUFlLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFBO0NBQzNDO0FBQ0Qsc0JBQVMsb0JBQW9CLDhCQUFpQixDQUFBOztBQUU5QyxlQUFPLG9CQUFvQixDQUFDLFNBQVMsRUFBRTs7QUFFckMsaUJBQWUsRUFBRSxhQUFhO0FBQzlCLG1CQUFpQixFQUFBLDJCQUFDLFNBQVMsRUFBRTtBQUMzQixRQUFNLElBQUksR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUM7QUFDNUUsUUFBSSxDQUFDLFNBQVMscUJBQWtCLElBQUksMENBQWtDLElBQUksQ0FBRyxDQUFDO0dBQy9FOzs7QUFHRCxhQUFXLEVBQUEscUJBQUMsU0FBUyxFQUFFLEVBQUUsRUFBRTtBQUN6QixRQUFJLENBQUMsU0FBUyxxQkFDTSxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsVUFBSyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FDdkYsQ0FBQztHQUNIOzs7QUFHRCxVQUFRLEVBQUEsa0JBQUMsU0FBUyxFQUFFO0FBQ2xCLFFBQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7QUFDaEYsUUFBTSxHQUFHLEdBQ1Asd0VBQytCLGNBQWMsT0FBRyxDQUFDO0FBQ25ELFFBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxHQUFHLEVBQUgsR0FBRyxFQUFFLE1BQU0sRUFBRSxnQkFBQSxJQUFJO2VBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDO09BQUEsRUFBRSxDQUFDLENBQUM7R0FDMUQ7OztBQUdELFdBQVMsRUFBQSxtQkFBQyxTQUFTLEVBQUUsTUFBTSxFQUFFO0FBQzNCLFFBQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3pELFFBQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7QUFDaEYsUUFBTSxHQUFHLEdBQ1AsMERBQ2dCLGVBQWUsT0FBRyxtQ0FDTCxjQUFjLE9BQUcsQ0FBQztBQUNqRCxRQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsR0FBRyxFQUFILEdBQUcsRUFBRSxNQUFNLEVBQUUsZ0JBQUEsSUFBSTtlQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQztPQUFBLEVBQUUsQ0FBQyxDQUFDO0dBQzFEOztDQUVGLENBQUMsQ0FBQTs7QUFFRixTQUFTLGlCQUFpQixDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUU7QUFDeEMsU0FBTyxNQUFNLEdBQU0sTUFBTSxTQUFJLEtBQUssR0FBSyxLQUFLLENBQUM7Q0FDOUM7O3FCQUVjLG9CQUFvQiIsImZpbGUiOiJjb21waWxlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLy8gTXlTUUwgU2NoZW1hIENvbXBpbGVyXG4vLyAtLS0tLS0tXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuaW1wb3J0IFNjaGVtYUNvbXBpbGVyIGZyb20gJy4uLy4uLy4uL3NjaGVtYS9jb21waWxlcic7XG5cbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJ2xvZGFzaCdcblxuZnVuY3Rpb24gU2NoZW1hQ29tcGlsZXJfTVNTUUwoY2xpZW50LCBidWlsZGVyKSB7XG4gIFNjaGVtYUNvbXBpbGVyLmNhbGwodGhpcywgY2xpZW50LCBidWlsZGVyKVxufVxuaW5oZXJpdHMoU2NoZW1hQ29tcGlsZXJfTVNTUUwsIFNjaGVtYUNvbXBpbGVyKVxuXG5hc3NpZ24oU2NoZW1hQ29tcGlsZXJfTVNTUUwucHJvdG90eXBlLCB7XG5cbiAgZHJvcFRhYmxlUHJlZml4OiAnRFJPUCBUQUJMRSAnLFxuICBkcm9wVGFibGVJZkV4aXN0cyh0YWJsZU5hbWUpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5mb3JtYXR0ZXIud3JhcChwcmVmaXhlZFRhYmxlTmFtZSh0aGlzLnNjaGVtYSwgdGFibGVOYW1lKSk7XG4gICAgdGhpcy5wdXNoUXVlcnkoYGlmIG9iamVjdF9pZCgnJHtuYW1lfScsICdVJykgaXMgbm90IG51bGwgRFJPUCBUQUJMRSAke25hbWV9YCk7XG4gIH0sXG5cbiAgLy8gUmVuYW1lIGEgdGFibGUgb24gdGhlIHNjaGVtYS5cbiAgcmVuYW1lVGFibGUodGFibGVOYW1lLCB0bykge1xuICAgIHRoaXMucHVzaFF1ZXJ5KFxuICAgICAgYGV4ZWMgc3BfcmVuYW1lICR7dGhpcy5mb3JtYXR0ZXIucGFyYW1ldGVyKHRhYmxlTmFtZSl9LCAke3RoaXMuZm9ybWF0dGVyLnBhcmFtZXRlcih0byl9YFxuICAgICk7XG4gIH0sXG5cbiAgLy8gQ2hlY2sgd2hldGhlciBhIHRhYmxlIGV4aXN0cyBvbiB0aGUgcXVlcnkuXG4gIGhhc1RhYmxlKHRhYmxlTmFtZSkge1xuICAgIGNvbnN0IGZvcm1hdHRlZFRhYmxlID0gdGhpcy5mb3JtYXR0ZXIucGFyYW1ldGVyKHRoaXMuZm9ybWF0dGVyLndyYXAodGFibGVOYW1lKSk7XG4gICAgY29uc3Qgc3FsID1cbiAgICAgIGBzZWxlY3Qgb2JqZWN0X2lkIGZyb20gc3lzLnRhYmxlcyBgICtcbiAgICAgIGB3aGVyZSBvYmplY3RfaWQgPSBvYmplY3RfaWQoJHtmb3JtYXR0ZWRUYWJsZX0pYDtcbiAgICB0aGlzLnB1c2hRdWVyeSh7IHNxbCwgb3V0cHV0OiByZXNwID0+IHJlc3AubGVuZ3RoID4gMCB9KTtcbiAgfSxcblxuICAvLyBDaGVjayB3aGV0aGVyIGEgY29sdW1uIGV4aXN0cyBvbiB0aGUgc2NoZW1hLlxuICBoYXNDb2x1bW4odGFibGVOYW1lLCBjb2x1bW4pIHtcbiAgICBjb25zdCBmb3JtYXR0ZWRDb2x1bW4gPSB0aGlzLmZvcm1hdHRlci5wYXJhbWV0ZXIoY29sdW1uKTtcbiAgICBjb25zdCBmb3JtYXR0ZWRUYWJsZSA9IHRoaXMuZm9ybWF0dGVyLnBhcmFtZXRlcih0aGlzLmZvcm1hdHRlci53cmFwKHRhYmxlTmFtZSkpO1xuICAgIGNvbnN0IHNxbCA9XG4gICAgICBgc2VsZWN0IG9iamVjdF9pZCBmcm9tIHN5cy5jb2x1bW5zIGAgK1xuICAgICAgYHdoZXJlIG5hbWUgPSAke2Zvcm1hdHRlZENvbHVtbn0gYCArXG4gICAgICBgYW5kIG9iamVjdF9pZCA9IG9iamVjdF9pZCgke2Zvcm1hdHRlZFRhYmxlfSlgO1xuICAgIHRoaXMucHVzaFF1ZXJ5KHsgc3FsLCBvdXRwdXQ6IHJlc3AgPT4gcmVzcC5sZW5ndGggPiAwIH0pO1xuICB9XG5cbn0pXG5cbmZ1bmN0aW9uIHByZWZpeGVkVGFibGVOYW1lKHByZWZpeCwgdGFibGUpIHtcbiAgcmV0dXJuIHByZWZpeCA/IGAke3ByZWZpeH0uJHt0YWJsZX1gIDogdGFibGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNjaGVtYUNvbXBpbGVyX01TU1FMO1xuIl19

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint max-len:0 */

	// MSSQL Table Builder & Compiler
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _schemaTablecompiler = __webpack_require__(80);

	var _schemaTablecompiler2 = _interopRequireDefault(_schemaTablecompiler);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _promise = __webpack_require__(43);

	var _promise2 = _interopRequireDefault(_promise);

	var _lodash = __webpack_require__(5);

	// Table Compiler
	// ------

	function TableCompiler_MSSQL() {
	  _schemaTablecompiler2['default'].apply(this, arguments);
	}
	_inherits2['default'](TableCompiler_MSSQL, _schemaTablecompiler2['default']);

	_lodash.assign(TableCompiler_MSSQL.prototype, {

	  createAlterTableMethods: ['foreign', 'primary', 'unique'],
	  createQuery: function createQuery(columns, ifNot) {
	    var createStatement = ifNot ? 'if object_id(\'' + this.tableName() + '\', \'U\') is null CREATE TABLE ' : 'CREATE TABLE ';
	    var sql = createStatement + this.tableName() + (this._formatting ? ' (\n    ' : ' (') + columns.sql.join(this._formatting ? ',\n    ' : ', ') + ')';

	    if (this.single.comment) {
	      var comment = this.single.comment || '';
	      if (comment.length > 60) helpers.warn('The max length for a table comment is 60 characters');
	    }

	    this.pushQuery(sql);
	  },

	  lowerCase: false,

	  addColumnsPrefix: 'ADD ',

	  dropColumnPrefix: 'DROP COLUMN ',

	  // Compiles column add.  Multiple columns need only one ADD clause (not one ADD per column) so core addColumns doesn't work.  #1348
	  addColumns: function addColumns(columns) {
	    if (columns.sql.length > 0) {
	      this.pushQuery({
	        sql: (this.lowerCase ? 'alter table ' : 'ALTER TABLE ') + this.tableName() + ' ' + this.addColumnsPrefix + columns.sql.join(', '),
	        bindings: columns.bindings
	      });
	    }
	  },

	  // Compiles column drop.  Multiple columns need only one DROP clause (not one DROP per column) so core dropColumn doesn't work.  #1348
	  dropColumn: function dropColumn() {
	    var _this2 = this;
	    var columns = helpers.normalizeArr.apply(null, arguments);

	    var drops = (Array.isArray(columns) ? columns : [columns]).map(function (column) {
	      return _this2.formatter.wrap(column);
	    });
	    this.pushQuery((this.lowerCase ? 'alter table ' : 'ALTER TABLE ') + this.tableName() + ' ' + this.dropColumnPrefix + drops.join(', '));
	  },

	  // Compiles the comment on the table.
	  comment: function comment() {},

	  changeType: function changeType() {},

	  // Renames a column on the table.
	  renameColumn: function renameColumn(from, to) {
	    this.pushQuery('exec sp_rename ' + this.formatter.parameter(this.tableName() + '.' + from) + ', ' + this.formatter.parameter(to) + ', \'COLUMN\'');
	  },

	  dropFKRefs: function dropFKRefs(runner, refs) {
	    var formatter = this.client.formatter();
	    return _promise2['default'].all(refs.map(function (ref) {
	      var constraintName = formatter.wrap(ref.CONSTRAINT_NAME);
	      var tableName = formatter.wrap(ref.TABLE_NAME);
	      return runner.query({
	        sql: 'ALTER TABLE ' + tableName + ' DROP CONSTRAINT ' + constraintName
	      });
	    }));
	  },
	  createFKRefs: function createFKRefs(runner, refs) {
	    var formatter = this.client.formatter();

	    return _promise2['default'].all(refs.map(function (ref) {
	      var tableName = formatter.wrap(ref.TABLE_NAME);
	      var keyName = formatter.wrap(ref.CONSTRAINT_NAME);
	      var column = formatter.columnize(ref.COLUMN_NAME);
	      var references = formatter.columnize(ref.REFERENCED_COLUMN_NAME);
	      var inTable = formatter.wrap(ref.REFERENCED_TABLE_NAME);
	      var onUpdate = ' ON UPDATE ' + ref.UPDATE_RULE;
	      var onDelete = ' ON DELETE ' + ref.DELETE_RULE;

	      return runner.query({
	        sql: 'ALTER TABLE ' + tableName + ' ADD CONSTRAINT ' + keyName + ' FOREIGN KEY (' + column + ') REFERENCES ' + inTable + ' (' + references + ')' + onUpdate + onDelete
	      });
	    }));
	  },

	  index: function index(columns, indexName) {
	    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);
	    this.pushQuery('CREATE INDEX ' + indexName + ' ON ' + this.tableName() + ' (' + this.formatter.columnize(columns) + ')');
	  },

	  primary: function primary(columns, constraintName) {
	    constraintName = constraintName ? this.formatter.wrap(constraintName) : this._indexCommand('primary', this.tableNameRaw, columns);
	    if (!this.forCreate) {
	      this.pushQuery('ALTER TABLE ' + this.tableName() + ' ADD CONSTRAINT ' + constraintName + ' PRIMARY KEY (' + this.formatter.columnize(columns) + ')');
	    } else {
	      this.pushQuery('CONSTRAINT ' + constraintName + ' PRIMARY KEY (' + this.formatter.columnize(columns) + ')');
	    }
	  },

	  unique: function unique(columns, indexName) {
	    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, columns);
	    if (!this.forCreate) {
	      this.pushQuery('CREATE UNIQUE INDEX ' + indexName + ' ON ' + this.tableName() + ' (' + this.formatter.columnize(columns) + ')');
	    } else {
	      this.pushQuery('CONSTRAINT ' + indexName + ' UNIQUE (' + this.formatter.columnize(columns) + ')');
	    }
	  },

	  // Compile a drop index command.
	  dropIndex: function dropIndex(columns, indexName) {
	    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);
	    this.pushQuery('DROP INDEX ' + indexName + ' ON ' + this.tableName());
	  },

	  // Compile a drop foreign key command.
	  dropForeign: function dropForeign(columns, indexName) {
	    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('foreign', this.tableNameRaw, columns);
	    this.pushQuery('ALTER TABLE ' + this.tableName() + ' DROP CONSTRAINT ' + indexName);
	  },

	  // Compile a drop primary key command.
	  dropPrimary: function dropPrimary() {
	    this.pushQuery('ALTER TABLE ' + this.tableName() + ' DROP PRIMARY KEY');
	  },

	  // Compile a drop unique key command.
	  dropUnique: function dropUnique(column, indexName) {
	    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, column);
	    this.pushQuery('ALTER TABLE ' + this.tableName() + ' DROP CONSTRAINT ' + indexName);
	  }

	});

	exports['default'] = TableCompiler_MSSQL;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9tc3NxbC9zY2hlbWEvdGFibGVjb21waWxlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7d0JBSXFCLFVBQVU7Ozs7bUNBQ0wsK0JBQStCOzs7O3VCQUNoQyxrQkFBa0I7O0lBQS9CLE9BQU87O3VCQUNDLGtCQUFrQjs7OztzQkFFZixRQUFROzs7OztBQUsvQixTQUFTLG1CQUFtQixHQUFHO0FBQzdCLG1DQUFjLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7Q0FDdEM7QUFDRCxzQkFBUyxtQkFBbUIsbUNBQWdCLENBQUM7O0FBRTdDLGVBQU8sbUJBQW1CLENBQUMsU0FBUyxFQUFFOztBQUVwQyx5QkFBdUIsRUFBRSxDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsUUFBUSxDQUFDO0FBQ3pELGFBQVcsRUFBQyxxQkFBQyxPQUFPLEVBQUUsS0FBSyxFQUFFO0FBQzNCLFFBQU0sZUFBZSxHQUFHLEtBQUssdUJBQW9CLElBQUksQ0FBQyxTQUFTLEVBQUUsd0NBQWtDLGVBQWUsQ0FBQztBQUNuSCxRQUFNLEdBQUcsR0FBRyxlQUFlLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLElBQUksQ0FBQyxXQUFXLEdBQUcsVUFBVSxHQUFHLElBQUksQ0FBQSxBQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDOztBQUV0SixRQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFO0FBQ3ZCLFVBQU0sT0FBTyxHQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxJQUFJLEVBQUUsQUFBQyxDQUFDO0FBQzVDLFVBQUksT0FBTyxDQUFDLE1BQU0sR0FBRyxFQUFFLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxxREFBcUQsQ0FBQyxDQUFDO0tBQzlGOztBQUVE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YXgtbGVuOjAgKi9cblxuLy8gTVNTUUwgVGFibGUgQnVpbGRlciAmIENvbXBpbGVyXG4vLyAtLS0tLS0tXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuaW1wb3J0IFRhYmxlQ29tcGlsZXIgZnJvbSAnLi4vLi4vLi4vc2NoZW1hL3RhYmxlY29tcGlsZXInO1xuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuLi8uLi8uLi9oZWxwZXJzJztcbmltcG9ydCBQcm9taXNlIGZyb20gJy4uLy4uLy4uL3Byb21pc2UnO1xuXG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICdsb2Rhc2gnXG5cbi8vIFRhYmxlIENvbXBpbGVyXG4vLyAtLS0tLS1cblxuZnVuY3Rpb24gVGFibGVDb21waWxlcl9NU1NRTCgpIHtcbiAgVGFibGVDb21waWxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuaW5oZXJpdHMoVGFibGVDb21waWxlcl9NU1NRTCwgVGFibGVDb21waWxlcik7XG5cbmFzc2lnbihUYWJsZUNvbXBpbGVyX01TU1FMLnByb3RvdHlwZSwge1xuXG4gIGNyZWF0ZUFsdGVyVGFibGVNZXRob2RzOiBbJ2ZvcmVpZ24nLCAncHJpbWFyeScsICd1bmlxdWUnXSxcbiAgY3JlYXRlUXVlcnkgKGNvbHVtbnMsIGlmTm90KSB7XG4gICAgY29uc3QgY3JlYXRlU3RhdGVtZW50ID0gaWZOb3QgPyBgaWYgb2JqZWN0X2lkKCcke3RoaXMudGFibGVOYW1lKCl9JywgJ1UnKSBpcyBudWxsIENSRUFURSBUQUJMRSBgIDogJ0NSRUFURSBUQUJMRSAnO1xuICAgIGNvbnN0IHNxbCA9IGNyZWF0ZVN0YXRlbWVudCArIHRoaXMudGFibGVOYW1lKCkgKyAodGhpcy5fZm9ybWF0dGluZyA/ICcgKFxcbiAgICAnIDogJyAoJykgKyBjb2x1bW5zLnNxbC5qb2luKHRoaXMuX2Zvcm1hdHRpbmcgPyAnLFxcbiAgICAnIDogJywgJykgKyAnKSc7XG5cbiAgICBpZiAodGhpcy5zaW5nbGUuY29tbWVudCkge1xuICAgICAgY29uc3QgY29tbWVudCA9ICh0aGlzLnNpbmdsZS5jb21tZW50IHx8ICcnKTtcbiAgICAgIGlmIChjb21tZW50Lmxlbmd0aCA+IDYwKSBoZWxwZXJzLndhcm4oJ1RoZSBtYXggbGVuZ3RoIGZvciBhIHRhYmxlIGNvbW1lbnQgaXMgNjAgY2hhcmFjdGVycycpO1xuICAgIH1cblxuICAgIHRoaXMucHVzaFF1ZXJ5KHNxbCk7XG4gIH0sXG5cbiAgbG93ZXJDYXNlOiBmYWxzZSxcblxuICBhZGRDb2x1bW5zUHJlZml4OiAnQUREICcsXG5cbiAgZHJvcENvbHVtblByZWZpeDogJ0RST1AgQ09MVU1OICcsXG5cbiAgLy8gQ29tcGlsZXMgY29sdW1uIGFkZC4gIE11bHRpcGxlIGNvbHVtbnMgbmVlZCBvbmx5IG9uZSBBREQgY2xhdXNlIChub3Qgb25lIEFERCBwZXIgY29sdW1uKSBzbyBjb3JlIGFkZENvbHVtbnMgZG9lc24ndCB3b3JrLiAgIzEzNDhcbiAgYWRkQ29sdW1ucyAoY29sdW1ucykge1xuICAgIGlmIChjb2x1bW5zLnNxbC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnB1c2hRdWVyeSh7XG4gICAgICAgIHNxbDogKHRoaXMubG93ZXJDYXNlID8gJ2FsdGVyIHRhYmxlICcgOiAnQUxURVIgVEFCTEUgJykgKyB0aGlzLnRhYmxlTmFtZSgpICsgJyAnICsgdGhpcy5hZGRDb2x1bW5zUHJlZml4ICsgY29sdW1ucy5zcWwuam9pbignLCAnKSxcbiAgICAgICAgYmluZGluZ3M6IGNvbHVtbnMuYmluZGluZ3NcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvLyBDb21waWxlcyBjb2x1bW4gZHJvcC4gIE11bHRpcGxlIGNvbHVtbnMgbmVlZCBvbmx5IG9uZSBEUk9QIGNsYXVzZSAobm90IG9uZSBEUk9QIHBlciBjb2x1bW4pIHNvIGNvcmUgZHJvcENvbHVtbiBkb2Vzbid0IHdvcmsuICAjMTM0OFxuICBkcm9wQ29sdW1uICgpIHtcbiAgICBjb25zdCBfdGhpczIgPSB0aGlzO1xuICAgIGNvbnN0IGNvbHVtbnMgPSBoZWxwZXJzLm5vcm1hbGl6ZUFyci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXG4gICAgY29uc3QgZHJvcHMgPSAoQXJyYXkuaXNBcnJheShjb2x1bW5zKSA/IGNvbHVtbnMgOiBbY29sdW1uc10pLm1hcChjb2x1bW4gPT4gX3RoaXMyLmZvcm1hdHRlci53cmFwKGNvbHVtbikpO1xuICAgIHRoaXMucHVzaFF1ZXJ5KCh0aGlzLmxvd2VyQ2FzZSA/ICdhbHRlciB0YWJsZSAnIDogJ0FMVEVSIFRBQkxFICcpICsgdGhpcy50YWJsZU5hbWUoKSArICcgJyArIHRoaXMuZHJvcENvbHVtblByZWZpeCArIGRyb3BzLmpvaW4oJywgJykpO1xuICB9LFxuXG4gIC8vIENvbXBpbGVzIHRoZSBjb21tZW50IG9uIHRoZSB0YWJsZS5cbiAgY29tbWVudCAoKSB7XG4gIH0sXG5cbiAgY2hhbmdlVHlwZSAoKSB7XG4gIH0sXG5cbiAgLy8gUmVuYW1lcyBhIGNvbHVtbiBvbiB0aGUgdGFibGUuXG4gIHJlbmFtZUNvbHVtbiAoZnJvbSwgdG8pIHtcbiAgICB0aGlzLnB1c2hRdWVyeShgZXhlYyBzcF9yZW5hbWUgJHt0aGlzLmZvcm1hdHRlci5wYXJhbWV0ZXIodGhpcy50YWJsZU5hbWUoKSArICcuJyArIGZyb20pfSwgJHt0aGlzLmZvcm1hdHRlci5wYXJhbWV0ZXIodG8pfSwgJ0NPTFVNTidgKTtcbiAgfSxcblxuICBkcm9wRktSZWZzIChydW5uZXIsIHJlZnMpIHtcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSB0aGlzLmNsaWVudC5mb3JtYXR0ZXIoKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocmVmcy5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgY29uc3QgY29uc3RyYWludE5hbWUgPSBmb3JtYXR0ZXIud3JhcChyZWYuQ09OU1RSQUlOVF9OQU1FKTtcbiAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IGZvcm1hdHRlci53cmFwKHJlZi5UQUJMRV9OQU1FKTtcbiAgICAgIHJldHVybiBydW5uZXIucXVlcnkoe1xuICAgICAgICBzcWw6IGBBTFRFUiBUQUJMRSAke3RhYmxlTmFtZX0gRFJPUCBDT05TVFJBSU5UICR7Y29uc3RyYWludE5hbWV9YFxuICAgICAgfSk7XG4gICAgfSkpO1xuICB9LFxuICBjcmVhdGVGS1JlZnMgKHJ1bm5lciwgcmVmcykge1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IHRoaXMuY2xpZW50LmZvcm1hdHRlcigpO1xuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHJlZnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IGZvcm1hdHRlci53cmFwKHJlZi5UQUJMRV9OQU1FKTtcbiAgICAgIGNvbnN0IGtleU5hbWUgPSBmb3JtYXR0ZXIud3JhcChyZWYuQ09OU1RSQUlOVF9OQU1FKTtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IGZvcm1hdHRlci5jb2x1bW5pemUocmVmLkNPTFVNTl9OQU1FKTtcbiAgICAgIGNvbnN0IHJlZmVyZW5jZXMgPSBmb3JtYXR0ZXIuY29sdW1uaXplKHJlZi5SRUZFUkVOQ0VEX0NPTFVNTl9OQU1FKTtcbiAgICAgIGNvbnN0IGluVGFibGUgPSBmb3JtYXR0ZXIud3JhcChyZWYuUkVGRVJFTkNFRF9UQUJMRV9OQU1FKTtcbiAgICAgIGNvbnN0IG9uVXBkYXRlID0gYCBPTiBVUERBVEUgJHtyZWYuVVBEQVRFX1JVTEV9YDtcbiAgICAgIGNvbnN0IG9uRGVsZXRlID0gYCBPTiBERUxFVEUgJHtyZWYuREVMRVRFX1JVTEV9YDtcblxuICAgICAgcmV0dXJuIHJ1bm5lci5xdWVyeSh7XG4gICAgICAgIHNxbDogYEFMVEVSIFRBQkxFICR7dGFibGVOYW1lfSBBREQgQ09OU1RSQUlOVCAke2tleU5hbWV9YCArXG4gICAgICAgICcgRk9SRUlHTiBLRVkgKCcgKyBjb2x1bW4gKyAnKSBSRUZFUkVOQ0VTICcgKyBpblRhYmxlICsgJyAoJyArIHJlZmVyZW5jZXMgKyAnKScgKyBvblVwZGF0ZSArIG9uRGVsZXRlXG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH0sXG5cbiAgaW5kZXggKGNvbHVtbnMsIGluZGV4TmFtZSkge1xuICAgIGluZGV4TmFtZSA9IGluZGV4TmFtZSA/IHRoaXMuZm9ybWF0dGVyLndyYXAoaW5kZXhOYW1lKSA6IHRoaXMuX2luZGV4Q29tbWFuZCgnaW5kZXgnLCB0aGlzLnRhYmxlTmFtZVJhdywgY29sdW1ucyk7XG4gICAgdGhpcy5wdXNoUXVlcnkoYENSRUFURSBJTkRFWCAke2luZGV4TmFtZX0gT04gJHt0aGlzLnRhYmxlTmFtZSgpfSAoJHt0aGlzLmZvcm1hdHRlci5jb2x1bW5pemUoY29sdW1ucyl9KWApO1xuICB9LFxuXG4gIHByaW1hcnkgKGNvbHVtbnMsIGNvbnN0cmFpbnROYW1lKSB7XG4gICAgY29uc3RyYWludE5hbWUgPSBjb25zdHJhaW50TmFtZSA/IHRoaXMuZm9ybWF0dGVyLndyYXAoY29uc3RyYWludE5hbWUpIDogdGhpcy5faW5kZXhDb21tYW5kKCdwcmltYXJ5JywgdGhpcy50YWJsZU5hbWVSYXcsIGNvbHVtbnMpO1xuICAgIGlmICghdGhpcy5mb3JDcmVhdGUpIHtcbiAgICAgIHRoaXMucHVzaFF1ZXJ5KGBBTFRFUiBUQUJMRSAke3RoaXMudGFibGVOYW1lKCl9IEFERCBDT05TVFJBSU5UICR7Y29uc3RyYWludE5hbWV9IFBSSU1BUlkgS0VZICgke3RoaXMuZm9ybWF0dGVyLmNvbHVtbml6ZShjb2x1bW5zKX0pYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaFF1ZXJ5KGBDT05TVFJBSU5UICR7Y29uc3RyYWludE5hbWV9IFBSSU1BUlkgS0VZICgke3RoaXMuZm9ybWF0dGVyLmNvbHVtbml6ZShjb2x1bW5zKX0pYCk7XG4gICAgfVxuICB9LFxuXG4gIHVuaXF1ZSAoY29sdW1ucywgaW5kZXhOYW1lKSB7XG4gICAgaW5kZXhOYW1lID0gaW5kZXhOYW1lID8gdGhpcy5mb3JtYXR0ZXIud3JhcChpbmRleE5hbWUpIDogdGhpcy5faW5kZXhDb21tYW5kKCd1bmlxdWUnLCB0aGlzLnRhYmxlTmFtZVJhdywgY29sdW1ucyk7XG4gICAgaWYgKCF0aGlzLmZvckNyZWF0ZSkge1xuICAgICAgdGhpcy5wdXNoUXVlcnkoYENSRUFURSBVTklRVUUgSU5ERVggJHtpbmRleE5hbWV9IE9OICR7dGhpcy50YWJsZU5hbWUoKX0gKCR7dGhpcy5mb3JtYXR0ZXIuY29sdW1uaXplKGNvbHVtbnMpfSlgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoUXVlcnkoYENPTlNUUkFJTlQgJHtpbmRleE5hbWV9IFVOSVFVRSAoJHt0aGlzLmZvcm1hdHRlci5jb2x1bW5pemUoY29sdW1ucyl9KWApO1xuICAgIH1cbiAgfSxcblxuICAvLyBDb21waWxlIGEgZHJvcCBpbmRleCBjb21tYW5kLlxuICBkcm9wSW5kZXggKGNvbHVtbnMsIGluZGV4TmFtZSkge1xuICAgIGluZGV4TmFtZSA9IGluZGV4TmFtZSA/IHRoaXMuZm9ybWF0dGVyLndyYXAoaW5kZXhOYW1lKSA6IHRoaXMuX2luZGV4Q29tbWFuZCgnaW5kZXgnLCB0aGlzLnRhYmxlTmFtZVJhdywgY29sdW1ucyk7XG4gICAgdGhpcy5wdXNoUXVlcnkoYERST1AgSU5ERVggJHtpbmRleE5hbWV9IE9OICR7dGhpcy50YWJsZU5hbWUoKX1gKTtcbiAgfSxcblxuICAvLyBDb21waWxlIGEgZHJvcCBmb3JlaWduIGtleSBjb21tYW5kLlxuICBkcm9wRm9yZWlnbiAoY29sdW1ucywgaW5kZXhOYW1lKSB7XG4gICAgaW5kZXhOYW1lID0gaW5kZXhOYW1lID8gdGhpcy5mb3JtYXR0ZXIud3JhcChpbmRleE5hbWUpIDogdGhpcy5faW5kZXhDb21tYW5kKCdmb3JlaWduJywgdGhpcy50YWJsZU5hbWVSYXcsIGNvbHVtbnMpO1xuICAgIHRoaXMucHVzaFF1ZXJ5KGBBTFRFUiBUQUJMRSAke3RoaXMudGFibGVOYW1lKCl9IERST1AgQ09OU1RSQUlOVCAke2luZGV4TmFtZX1gKTtcbiAgfSxcblxuICAvLyBDb21waWxlIGEgZHJvcCBwcmltYXJ5IGtleSBjb21tYW5kLlxuICBkcm9wUHJpbWFyeSAoKSB7XG4gICAgdGhpcy5wdXNoUXVlcnkoYEFMVEVSIFRBQkxFICR7dGhpcy50YWJsZU5hbWUoKX0gRFJPUCBQUklNQVJZIEtFWWApO1xuICB9LFxuXG4gIC8vIENvbXBpbGUgYSBkcm9wIHVuaXF1ZSBrZXkgY29tbWFuZC5cbiAgZHJvcFVuaXF1ZSAoY29sdW1uLCBpbmRleE5hbWUpIHtcbiAgICBpbmRleE5hbWUgPSBpbmRleE5hbWUgPyB0aGlzLmZvcm1hdHRlci53cmFwKGluZGV4TmFtZSkgOiB0aGlzLl9pbmRleENvbW1hbmQoJ3VuaXF1ZScsIHRoaXMudGFibGVOYW1lUmF3LCBjb2x1bW4pO1xuICAgIHRoaXMucHVzaFF1ZXJ5KGBBTFRFUiBUQUJMRSAke3RoaXMudGFibGVOYW1lKCl9IERST1AgQ09OU1RSQUlOVCAke2luZGV4TmFtZX1gKTtcbiAgfVxuXG59KVxuXG5leHBvcnQgZGVmYXVsdCBUYWJsZUNvbXBpbGVyX01TU1FMO1xuIl19

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	
	// MySQL Column Compiler
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _schemaColumncompiler = __webpack_require__(82);

	var _schemaColumncompiler2 = _interopRequireDefault(_schemaColumncompiler);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _lodash = __webpack_require__(5);

	function ColumnCompiler_MSSQL() {
	  _schemaColumncompiler2['default'].apply(this, arguments);
	  this.modifiers = ['nullable', 'defaultTo', 'first', 'after', 'comment'];
	}
	_inherits2['default'](ColumnCompiler_MSSQL, _schemaColumncompiler2['default']);

	// Types
	// ------

	_lodash.assign(ColumnCompiler_MSSQL.prototype, {

	  increments: 'int identity(1,1) not null primary key',

	  bigincrements: 'bigint identity(1,1) not null primary key',

	  bigint: 'bigint',

	  double: function double(precision, scale) {
	    if (!precision) return 'double';
	    return 'double(' + this._num(precision, 8) + ', ' + this._num(scale, 2) + ')';
	  },

	  integer: function integer(length) {
	    length = length ? '(' + this._num(length, 11) + ')' : '';
	    return 'int' + length;
	  },

	  mediumint: 'mediumint',

	  smallint: 'smallint',

	  tinyint: function tinyint(length) {
	    length = length ? '(' + this._num(length, 1) + ')' : '';
	    return 'tinyint' + length;
	  },

	  varchar: function varchar(length) {
	    return 'nvarchar(' + this._num(length, 255) + ')';
	  },

	  text: 'nvarchar(max)',

	  mediumtext: 'nvarchar(max)',

	  longtext: 'nvarchar(max)',

	  enu: 'nvarchar(100)',

	  uuid: 'uniqueidentifier',

	  datetime: 'datetime',

	  timestamp: 'datetime',

	  bit: function bit(length) {
	    return length ? 'bit(' + this._num(length) + ')' : 'bit';
	  },

	  binary: function binary(length) {
	    return length ? 'varbinary(' + this._num(length) + ')' : 'varbinary(max)';
	  },

	  bool: 'bit',

	  // Modifiers
	  // ------

	  defaultTo: function defaultTo(value) {
	    var defaultVal = ColumnCompiler_MSSQL.super_.prototype.defaultTo.apply(this, arguments);
	    if (this.type !== 'blob' && this.type.indexOf('text') === -1) {
	      return defaultVal;
	    }
	    return '';
	  },

	  first: function first() {
	    return 'first';
	  },

	  after: function after(column) {
	    return 'after ' + this.formatter.wrap(column);
	  },

	  comment: function comment(_comment) {
	    if (_comment && _comment.length > 255) {
	      helpers.warn('Your comment is longer than the max comment length for MSSQL');
	    }
	    return '';
	  }

	});

	exports['default'] = ColumnCompiler_MSSQL;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9tc3NxbC9zY2hlbWEvY29sdW1uY29tcGlsZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7d0JBR3FCLFVBQVU7Ozs7b0NBQ0osZ0NBQWdDOzs7O3VCQUNsQyxrQkFBa0I7O0lBQS9CLE9BQU87O3NCQUVJLFFBQVE7O0FBRS9CLFNBQVMsb0JBQW9CLEdBQUc7QUFDOUIsb0NBQWUsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztBQUN0QyxNQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsVUFBVSxFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFBO0NBQ3hFO0FBQ0Qsc0JBQVMsb0JBQW9CLG9DQUFpQixDQUFDOzs7OztBQUsvQyxlQUFPLG9CQUFvQixDQUFDLFNBQVMsRUFBRTs7QUFFckMsWUFBVSxFQUFFLHdDQUF3Qzs7QUFFcEQsZUFBYSxFQUFFLDJDQUEyQzs7QUFFMUQsUUFBTSxFQUFFLFFBQVE7O0FBRWhCLFFBQU0sRUFBQSxnQkFBQyxTQUFTLEVBQUUsS0FBSyxFQUFFO0FBQ3ZCLFFBQUksQ0FBQyxTQUFTLEVBQUUsT0FBTyxRQUFRLENBQUE7QUFDL0IsdUJBQWlCLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxVQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxPQUFHO0dBQ3BFOztBQUVELFNBQU8sRUFBQSxpQkFBQyxNQUFNLEVBQUU7QUFDZCxVQUFNLEdBQUcsTUFBTSxTQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxTQUFNLEVBQUUsQ0FBQTtBQUNuRCxtQkFBYSxNQUFNLENBQUU7R0FDdEI7O0FBRUQsV0FBUyxFQUFFLFdBQVc7O0FBRXRCLFVBQVEsRUFBRSxVQUFVOztBQUVwQixTQUFPLEVBQUEsaUJBQUMsTUFBTSxFQUFFO0FBQ2QsVUFBTSxHQUFHLE1BQU0sU0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsU0FBTSxFQUFFLENBQUE7QUFDbEQsdUJBQWlCLE1BQU0sQ0FBRTtHQUMxQjs7QUFFRCxTQUFPLEVBQUEsaUJBQUMsTUFBTSxFQUFFO0FBQ2QseUJBQW1CLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxPQUFJO0dBQzlDOztBQUVELE1BQUksRUFBRSxlQUFlOztBQUVyQixZQUFVLEVBQUUsZUFBZTs7QUFFM0IsVUFBUSxFQUFFLGVBQWU7O0FBRXpCLEtBQUcsRUFBRSxlQUFlOztBQUVwQixNQUFJLEVBQUUsa0JBQWtCOztBQUV4QixVQUFRLEVBQUUsVUFBVTs7QUFFcEIsV0FBUyxFQUFFLFVBQVU7O0FBRXJCLEtBQUcsRUFBQSxhQUFDLE1BQU0sRUFBRTtBQUNWLFdBQU8sTUFBTSxZQUFVLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQU0sS0FBSyxDQUFBO0dBQ3BEOztBQUVELFFBQU0sRUFBQSxnQkFBQyxNQUFNLEVBQUU7QUFDYixXQUFPLE1BQU0sa0JBQWdCLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQU0sZ0JBQWdCLENBQUE7R0FDckU7O0FBRUQsTUFBSSxFQUFFLEtBQUs7Ozs7O0FBS1gsV0FBUyxFQUFBLG1CQUFDLEtBQUssRUFBRTtBQUNmLFFBQU0sVUFBVSxHQUFHLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDMUYsUUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtBQUM1RCxhQUFPLFVBQVUsQ0FBQTtLQUNsQjtBQUNELFdBQU8sRUFBRSxDQUFBO0dBQ1Y7O0FBRUQsT0FBSyxFQUFBLGlCQUFHO0FBQ04sV0FBTyxPQUFPLENBQUE7R0FDZjs7QUFFRCxPQUFLLEVBQUEsZUFBQyxNQUFNLEVBQUU7QUFDWixzQkFBZ0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUU7R0FDOUM7O0FBRUQsU0FBTyxFQUFBLGlCQUFDLFFBQU8sRUFBRTtBQUNmLFFBQUksUUFBTyxJQUFJLFFBQU8sQ0FBQyxNQUFNLEdBQUcsR0FBRyxFQUFFO0FBQ25DLGFBQU8sQ0FBQyxJQUFJLENBQUMsOERBQThELENBQUMsQ0FBQTtLQUM3RTtBQUNELFdBQU8sRUFBRSxDQUFBO0dBQ1Y7O0NBRUYsQ0FBQyxDQUFBOztxQkFFYSxvQkFBb0IiLCJmaWxlIjoiY29sdW1uY29tcGlsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8vIE15U1FMIENvbHVtbiBDb21waWxlclxuLy8gLS0tLS0tLVxuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcbmltcG9ydCBDb2x1bW5Db21waWxlciBmcm9tICcuLi8uLi8uLi9zY2hlbWEvY29sdW1uY29tcGlsZXInO1xuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuLi8uLi8uLi9oZWxwZXJzJztcblxuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnbG9kYXNoJ1xuXG5mdW5jdGlvbiBDb2x1bW5Db21waWxlcl9NU1NRTCgpIHtcbiAgQ29sdW1uQ29tcGlsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdGhpcy5tb2RpZmllcnMgPSBbJ251bGxhYmxlJywgJ2RlZmF1bHRUbycsICdmaXJzdCcsICdhZnRlcicsICdjb21tZW50J11cbn1cbmluaGVyaXRzKENvbHVtbkNvbXBpbGVyX01TU1FMLCBDb2x1bW5Db21waWxlcik7XG5cbi8vIFR5cGVzXG4vLyAtLS0tLS1cblxuYXNzaWduKENvbHVtbkNvbXBpbGVyX01TU1FMLnByb3RvdHlwZSwge1xuXG4gIGluY3JlbWVudHM6ICdpbnQgaWRlbnRpdHkoMSwxKSBub3QgbnVsbCBwcmltYXJ5IGtleScsXG5cbiAgYmlnaW5jcmVtZW50czogJ2JpZ2ludCBpZGVudGl0eSgxLDEpIG5vdCBudWxsIHByaW1hcnkga2V5JyxcblxuICBiaWdpbnQ6ICdiaWdpbnQnLFxuXG4gIGRvdWJsZShwcmVjaXNpb24sIHNjYWxlKSB7XG4gICAgaWYgKCFwcmVjaXNpb24pIHJldHVybiAnZG91YmxlJ1xuICAgIHJldHVybiBgZG91YmxlKCR7dGhpcy5fbnVtKHByZWNpc2lvbiwgOCl9LCAke3RoaXMuX251bShzY2FsZSwgMil9KWBcbiAgfSxcblxuICBpbnRlZ2VyKGxlbmd0aCkge1xuICAgIGxlbmd0aCA9IGxlbmd0aCA/IGAoJHt0aGlzLl9udW0obGVuZ3RoLCAxMSl9KWAgOiAnJ1xuICAgIHJldHVybiBgaW50JHtsZW5ndGh9YFxuICB9LFxuXG4gIG1lZGl1bWludDogJ21lZGl1bWludCcsXG5cbiAgc21hbGxpbnQ6ICdzbWFsbGludCcsXG5cbiAgdGlueWludChsZW5ndGgpIHtcbiAgICBsZW5ndGggPSBsZW5ndGggPyBgKCR7dGhpcy5fbnVtKGxlbmd0aCwgMSl9KWAgOiAnJ1xuICAgIHJldHVybiBgdGlueWludCR7bGVuZ3RofWBcbiAgfSxcblxuICB2YXJjaGFyKGxlbmd0aCkge1xuICAgIHJldHVybiBgbnZhcmNoYXIoJHt0aGlzLl9udW0obGVuZ3RoLCAyNTUpfSlgO1xuICB9LFxuXG4gIHRleHQ6ICdudmFyY2hhcihtYXgpJyxcblxuICBtZWRpdW10ZXh0OiAnbnZhcmNoYXIobWF4KScsXG5cbiAgbG9uZ3RleHQ6ICdudmFyY2hhcihtYXgpJyxcblxuICBlbnU6ICdudmFyY2hhcigxMDApJyxcblxuICB1dWlkOiAndW5pcXVlaWRlbnRpZmllcicsXG5cbiAgZGF0ZXRpbWU6ICdkYXRldGltZScsXG5cbiAgdGltZXN0YW1wOiAnZGF0ZXRpbWUnLFxuXG4gIGJpdChsZW5ndGgpIHtcbiAgICByZXR1cm4gbGVuZ3RoID8gYGJpdCgke3RoaXMuX251bShsZW5ndGgpfSlgIDogJ2JpdCdcbiAgfSxcblxuICBiaW5hcnkobGVuZ3RoKSB7XG4gICAgcmV0dXJuIGxlbmd0aCA/IGB2YXJiaW5hcnkoJHt0aGlzLl9udW0obGVuZ3RoKX0pYCA6ICd2YXJiaW5hcnkobWF4KSdcbiAgfSxcblxuICBib29sOiAnYml0JyxcblxuICAvLyBNb2RpZmllcnNcbiAgLy8gLS0tLS0tXG5cbiAgZGVmYXVsdFRvKHZhbHVlKSB7XG4gICAgY29uc3QgZGVmYXVsdFZhbCA9IENvbHVtbkNvbXBpbGVyX01TU1FMLnN1cGVyXy5wcm90b3R5cGUuZGVmYXVsdFRvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ2Jsb2InICYmIHRoaXMudHlwZS5pbmRleE9mKCd0ZXh0JykgPT09IC0xKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbFxuICAgIH1cbiAgICByZXR1cm4gJydcbiAgfSxcblxuICBmaXJzdCgpIHtcbiAgICByZXR1cm4gJ2ZpcnN0J1xuICB9LFxuXG4gIGFmdGVyKGNvbHVtbikge1xuICAgIHJldHVybiBgYWZ0ZXIgJHt0aGlzLmZvcm1hdHRlci53cmFwKGNvbHVtbil9YFxuICB9LFxuXG4gIGNvbW1lbnQoY29tbWVudCkge1xuICAgIGlmIChjb21tZW50ICYmIGNvbW1lbnQubGVuZ3RoID4gMjU1KSB7XG4gICAgICBoZWxwZXJzLndhcm4oJ1lvdXIgY29tbWVudCBpcyBsb25nZXIgdGhhbiB0aGUgbWF4IGNvbW1lbnQgbGVuZ3RoIGZvciBNU1NRTCcpXG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9XG5cbn0pXG5cbmV4cG9ydCBkZWZhdWx0IENvbHVtbkNvbXBpbGVyX01TU1FMO1xuIl19

/***/ },
/* 110 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	
	// MySQL2 Client
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _mysql = __webpack_require__(94);

	var _mysql2 = _interopRequireDefault(_mysql);

	var _promise = __webpack_require__(43);

	var _promise2 = _interopRequireDefault(_promise);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _lodash = __webpack_require__(5);

	var _transaction = __webpack_require__(112);

	var _transaction2 = _interopRequireDefault(_transaction);

	var configOptions = ['isServer', 'stream', 'host', 'port', 'localAddress', 'socketPath', 'user', 'password', 'passwordSha1', 'database', 'connectTimeout', 'insecureAuth', 'supportBigNumbers', 'bigNumberStrings', 'decimalNumbers', 'dateStrings', 'debug', 'trace', 'stringifyObjects', 'timezone', 'flags', 'queryFormat', 'pool', 'ssl', 'multipleStatements', 'namedPlaceholders', 'typeCast', 'charsetNumber', 'compress'];

	// Always initialize with the "QueryBuilder" and "QueryCompiler"
	// objects, which extend the base 'lib/query/builder' and
	// 'lib/query/compiler', respectively.
	function Client_MySQL2(config) {
	  _mysql2['default'].call(this, config);
	}
	_inherits2['default'](Client_MySQL2, _mysql2['default']);

	_lodash.assign(Client_MySQL2.prototype, {

	  // The "dialect", for reference elsewhere.
	  driverName: 'mysql2',

	  Transaction: _transaction2['default'],

	  _driver: function _driver() {
	    return __webpack_require__(113);
	  },

	  // Get a raw connection, called by the `pool` whenever a new
	  // connection needs to be added to the pool.
	  acquireRawConnection: function acquireRawConnection() {
	    var client = this;
	    var connection = this.driver.createConnection(_lodash.pick(this.connectionSettings, configOptions));
	    return new _promise2['default'](function (resolver, rejecter) {
	      connection.connect(function (err) {
	        if (err) return rejecter(err);
	        connection.on('error', client._connectionErrorHandler.bind(null, client, connection));
	        resolver(connection);
	      });
	    });
	  },

	  processResponse: function processResponse(obj, runner) {
	    var response = obj.response;
	    var method = obj.method;

	    var rows = response[0];
	    var fields = response[1];
	    if (obj.output) return obj.output.call(runner, rows, fields);
	    switch (method) {
	      case 'select':
	      case 'pluck':
	      case 'first':
	        {
	          var resp = helpers.skim(rows);
	          if (method === 'pluck') return _lodash.map(resp, obj.pluck);
	          return method === 'first' ? resp[0] : resp;
	        }
	      case 'insert':
	        return [rows.insertId];
	      case 'del':
	      case 'update':
	      case 'counter':
	        return rows.affectedRows;
	      default:
	        return response;
	    }
	  },

	  ping: function ping(resource, callback) {
	    resource.query('SELECT 1', callback);
	  }

	});

	exports['default'] = Client_MySQL2;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy9teXNxbDIvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7d0JBR3FCLFVBQVU7Ozs7cUJBQ04sVUFBVTs7Ozt1QkFDZixlQUFlOzs7O3VCQUNWLGVBQWU7O0lBQTVCLE9BQU87O3NCQUNlLFFBQVE7OzJCQUNsQixlQUFlOzs7O0FBRXZDLElBQU0sYUFBYSxHQUFHLENBQ3BCLFVBQVUsRUFDVixRQUFRLEVBQ1IsTUFBTSxFQUNOLE1BQU0sRUFDTixjQUFjLEVBQ2QsWUFBWSxFQUNaLE1BQU0sRUFDTixVQUFVLEVBQ1YsY0FBYyxFQUNkLFVBQVUsRUFDVixnQkFBZ0IsRUFDaEIsY0FBYyxFQUNkLG1CQUFtQixFQUNuQixrQkFBa0IsRUFDbEIsZ0JBQWdCLEVBQ2hCLGFBQWEsRUFDYixPQUFPLEVBQ1AsT0FBTyxFQUNQLGtCQUFrQixFQUNsQixVQUFVLEVBQ1YsT0FBTyxFQUNQLGFBQWEsRUFDYixNQUFNLEVBQ04sS0FBSyxFQUNMLG9CQUFvQixFQUNwQixtQkFBbUIsRUFDbkIsVUFBVSxFQUNWLGVBQWUsRUFDZixVQUFVLENBQ1gsQ0FBQzs7Ozs7QUFLRixTQUFTLGFBQWEsQ0FBQyxNQUFNLEVBQUU7QUFDN0IscUJBQWEsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQTtDQUNoQztBQUNELHNCQUFTLGFBQWEscUJBQWUsQ0FBQTs7QUFFckMsZUFBTyxhQUFhLENBQUMsU0FBUyxFQUFFOzs7QUFHOUIsWUFBVSxFQUFFLFFBQVE7O0FBRXBCLGFBQVcsMEJBQUE7O0FBRVgsU0FBTyxFQUFBLG1CQUFHO0FBQ1IsV0FBTyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUE7R0FDekI7Ozs7QUFJRCxzQkFBb0IsRUFBQSxnQ0FBRztBQUNyQixRQUFNLE1BQU0sR0FBRyxJQUFJLENBQUM7QUFDcEIsUUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFLLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxhQUFhLENBQUMsQ0FBQyxDQUFBO0FBQzdGLFdBQU8seUJBQVksVUFBUyxRQUFRLEVBQUUsUUFBUSxFQUFFO0FBQzlDLGdCQUFVLENBQUMsT0FBTyxDQUFDLFVBQVMsR0FBRyxFQUFFO0FBQy9CLFlBQUksR0FBRyxFQUFFLE9BQU8sUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFBO0FBQzdCLGtCQUFVLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQTtBQUNyRixnQkFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFBO09BQ3JCLENBQUMsQ0FBQTtLQUNILENBQUMsQ0FBQTtHQUNIOztBQUVELGlCQUFlLEVBQUEseUJBQUMsR0FBRyxFQUFFLE1BQU0sRUFBRTtRQUNuQixRQUFRLEdBQUssR0FBRyxDQUFoQixRQUFRO1FBQ1IsTUFBTSxHQUFLLEdBQUcsQ0FBZCxNQUFNOztBQUNkLFFBQU0sSUFBSSxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQTtBQUN4QixRQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUE7QUFDMUIsUUFBSSxHQUFHLENBQUMsTUFBTSxFQUFFLE9BQU8sR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQTtBQUM1RCxZQUFRLE1BQU07QUFDWixXQUFLLFFBQVEsQ0FBQztBQUNkLFdBQUssT0FBTyxDQUFDO0FBQ2IsV0FBSyxPQUFPO0FBQUU7QUFDWixjQUFNLElBQUksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBO0FBQy9CLGNBQUksTUFBTSxLQUFLLE9BQU8sRUFBRSxPQUFPLFlBQUksSUFBSSxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQTtBQUNuRCxpQkFBTyxNQUFNLEtBQUssT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUE7U0FDM0M7QUFBQSxBQUNELFdBQUssUUFBUTtBQUNYLGVBQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUE7QUFBQSxBQUN4QixXQUFLLEtBQUssQ0FBQztBQUNYLFdBQUssUUFBUSxDQUFDO0FBQ2QsV0FBSyxTQUFTO0FBQ1osZUFBTyxJQUFJLENBQUMsWUFBWSxDQUFBO0FBQUEsQUFDMUI7QUFDRSxlQUFPLFFBQVEsQ0FBQTtBQUFBLEtBQ2xCO0dBQ0Y7O0FBRUQsTUFBSSxFQUFBLGNBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRTtBQUN2QixZQUFRLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxRQUFRLENBQUMsQ0FBQztHQUN0Qzs7Q0FFRixDQUFDLENBQUE7O3FCQUVhLGFBQWEiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8vIE15U1FMMiBDbGllbnRcbi8vIC0tLS0tLS1cbmltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5pbXBvcnQgQ2xpZW50X015U1FMIGZyb20gJy4uL215c3FsJztcbmltcG9ydCBQcm9taXNlIGZyb20gJy4uLy4uL3Byb21pc2UnO1xuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuLi8uLi9oZWxwZXJzJztcbmltcG9ydCB7IHBpY2ssIG1hcCwgYXNzaWduIH0gZnJvbSAnbG9kYXNoJ1xuaW1wb3J0IFRyYW5zYWN0aW9uIGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuXG5jb25zdCBjb25maWdPcHRpb25zID0gW1xuICAnaXNTZXJ2ZXInLFxuICAnc3RyZWFtJyxcbiAgJ2hvc3QnLFxuICAncG9ydCcsXG4gICdsb2NhbEFkZHJlc3MnLFxuICAnc29ja2V0UGF0aCcsXG4gICd1c2VyJyxcbiAgJ3Bhc3N3b3JkJyxcbiAgJ3Bhc3N3b3JkU2hhMScsXG4gICdkYXRhYmFzZScsXG4gICdjb25uZWN0VGltZW91dCcsXG4gICdpbnNlY3VyZUF1dGgnLFxuICAnc3VwcG9ydEJpZ051bWJlcnMnLFxuICAnYmlnTnVtYmVyU3RyaW5ncycsXG4gICdkZWNpbWFsTnVtYmVycycsXG4gICdkYXRlU3RyaW5ncycsXG4gICdkZWJ1ZycsXG4gICd0cmFjZScsXG4gICdzdHJpbmdpZnlPYmplY3RzJyxcbiAgJ3RpbWV6b25lJyxcbiAgJ2ZsYWdzJyxcbiAgJ3F1ZXJ5Rm9ybWF0JyxcbiAgJ3Bvb2wnLFxuICAnc3NsJyxcbiAgJ211bHRpcGxlU3RhdGVtZW50cycsXG4gICduYW1lZFBsYWNlaG9sZGVycycsXG4gICd0eXBlQ2FzdCcsXG4gICdjaGFyc2V0TnVtYmVyJyxcbiAgJ2NvbXByZXNzJ1xuXTtcblxuLy8gQWx3YXlzIGluaXRpYWxpemUgd2l0aCB0aGUgXCJRdWVyeUJ1aWxkZXJcIiBhbmQgXCJRdWVyeUNvbXBpbGVyXCJcbi8vIG9iamVjdHMsIHdoaWNoIGV4dGVuZCB0aGUgYmFzZSAnbGliL3F1ZXJ5L2J1aWxkZXInIGFuZFxuLy8gJ2xpYi9xdWVyeS9jb21waWxlcicsIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIENsaWVudF9NeVNRTDIoY29uZmlnKSB7XG4gIENsaWVudF9NeVNRTC5jYWxsKHRoaXMsIGNvbmZpZylcbn1cbmluaGVyaXRzKENsaWVudF9NeVNRTDIsIENsaWVudF9NeVNRTClcblxuYXNzaWduKENsaWVudF9NeVNRTDIucHJvdG90eXBlLCB7XG5cbiAgLy8gVGhlIFwiZGlhbGVjdFwiLCBmb3IgcmVmZXJlbmNlIGVsc2V3aGVyZS5cbiAgZHJpdmVyTmFtZTogJ215c3FsMicsXG5cbiAgVHJhbnNhY3Rpb24sXG5cbiAgX2RyaXZlcigpIHtcbiAgICByZXR1cm4gcmVxdWlyZSgnbXlzcWwyJylcbiAgfSxcblxuICAvLyBHZXQgYSByYXcgY29ubmVjdGlvbiwgY2FsbGVkIGJ5IHRoZSBgcG9vbGAgd2hlbmV2ZXIgYSBuZXdcbiAgLy8gY29ubmVjdGlvbiBuZWVkcyB0byBiZSBhZGRlZCB0byB0aGUgcG9vbC5cbiAgYWNxdWlyZVJhd0Nvbm5lY3Rpb24oKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcztcbiAgICBjb25zdCBjb25uZWN0aW9uID0gdGhpcy5kcml2ZXIuY3JlYXRlQ29ubmVjdGlvbihwaWNrKHRoaXMuY29ubmVjdGlvblNldHRpbmdzLCBjb25maWdPcHRpb25zKSlcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZXIsIHJlamVjdGVyKSB7XG4gICAgICBjb25uZWN0aW9uLmNvbm5lY3QoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3RlcihlcnIpXG4gICAgICAgIGNvbm5lY3Rpb24ub24oJ2Vycm9yJywgY2xpZW50Ll9jb25uZWN0aW9uRXJyb3JIYW5kbGVyLmJpbmQobnVsbCwgY2xpZW50LCBjb25uZWN0aW9uKSlcbiAgICAgICAgcmVzb2x2ZXIoY29ubmVjdGlvbilcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcblxuICBwcm9jZXNzUmVzcG9uc2Uob2JqLCBydW5uZXIpIHtcbiAgICBjb25zdCB7IHJlc3BvbnNlIH0gPSBvYmpcbiAgICBjb25zdCB7IG1ldGhvZCB9ID0gb2JqXG4gICAgY29uc3Qgcm93cyA9IHJlc3BvbnNlWzBdXG4gICAgY29uc3QgZmllbGRzID0gcmVzcG9uc2VbMV1cbiAgICBpZiAob2JqLm91dHB1dCkgcmV0dXJuIG9iai5vdXRwdXQuY2FsbChydW5uZXIsIHJvd3MsIGZpZWxkcylcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGNhc2UgJ3BsdWNrJzpcbiAgICAgIGNhc2UgJ2ZpcnN0Jzoge1xuICAgICAgICBjb25zdCByZXNwID0gaGVscGVycy5za2ltKHJvd3MpXG4gICAgICAgIGlmIChtZXRob2QgPT09ICdwbHVjaycpIHJldHVybiBtYXAocmVzcCwgb2JqLnBsdWNrKVxuICAgICAgICByZXR1cm4gbWV0aG9kID09PSAnZmlyc3QnID8gcmVzcFswXSA6IHJlc3BcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2luc2VydCc6XG4gICAgICAgIHJldHVybiBbcm93cy5pbnNlcnRJZF1cbiAgICAgIGNhc2UgJ2RlbCc6XG4gICAgICBjYXNlICd1cGRhdGUnOlxuICAgICAgY2FzZSAnY291bnRlcic6XG4gICAgICAgIHJldHVybiByb3dzLmFmZmVjdGVkUm93c1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgfVxuICB9LFxuXG4gIHBpbmcocmVzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgcmVzb3VyY2UucXVlcnkoJ1NFTEVDVCAxJywgY2FsbGJhY2spO1xuICB9XG5cbn0pXG5cbmV4cG9ydCBkZWZhdWx0IENsaWVudF9NeVNRTDI7XG4iXX0=

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _transaction = __webpack_require__(65);

	var _transaction2 = _interopRequireDefault(_transaction);

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _lodash = __webpack_require__(5);

	var debug = __webpack_require__(66)('knex:tx');

	function Transaction_MySQL2() {
	  _transaction2['default'].apply(this, arguments);
	}
	_inherits2['default'](Transaction_MySQL2, _transaction2['default']);

	_lodash.assign(Transaction_MySQL2.prototype, {

	  query: function query(conn, sql, status, value) {
	    var t = this;
	    var q = this.trxClient.query(conn, sql)['catch'](function (err) {
	      return err.code === 'ER_SP_DOES_NOT_EXIST';
	    }, function () {
	      helpers.warn('Transaction was implicitly committed, do not mix transactions and' + 'DDL with MySQL (#805)');
	    })['catch'](function (err) {
	      status = 2;
	      value = err;
	      t._completed = true;
	      debug('%s error running transaction query', t.txid);
	    }).tap(function () {
	      if (status === 1) t._resolver(value);
	      if (status === 2) t._rejecter(value);
	    });
	    if (status === 1 || status === 2) {
	      t._completed = true;
	    }
	    return q;
	  }

	});

	exports['default'] = Transaction_MySQL2;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy9teXNxbDIvdHJhbnNhY3Rpb24uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7MkJBQ3dCLG1CQUFtQjs7Ozt3QkFDdEIsVUFBVTs7Ozt1QkFFTixlQUFlOztJQUE1QixPQUFPOztzQkFFSSxRQUFROztBQUgvQixJQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUE7O0FBS3pDLFNBQVMsa0JBQWtCLEdBQUc7QUFDNUIsMkJBQVksS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQTtDQUNuQztBQUNELHNCQUFTLGtCQUFrQiwyQkFBYyxDQUFBOztBQUV6QyxlQUFPLGtCQUFrQixDQUFDLFNBQVMsRUFBRTs7QUFFbkMsT0FBSyxFQUFBLGVBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFO0FBQzlCLFFBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQTtBQUNkLFFBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsU0FDakMsQ0FBQyxVQUFBLEdBQUc7YUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLHNCQUFzQjtLQUFBLEVBQUUsWUFBVztBQUM1RCxhQUFPLENBQUMsSUFBSSxDQUNWLG1FQUFtRSxHQUNuRSx1QkFBdUIsQ0FDeEIsQ0FBQTtLQUNGLENBQUMsU0FDSSxDQUFDLFVBQVMsR0FBRyxFQUFFO0FBQ25CLFlBQU0sR0FBRyxDQUFDLENBQUE7QUFDVixXQUFLLEdBQUcsR0FBRyxDQUFBO0FBQ1gsT0FBQyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUE7QUFDbkIsV0FBSyxDQUFDLG9DQUFvQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQTtLQUNwRCxDQUFDLENBQ0QsR0FBRyxDQUFDLFlBQVc7QUFDZCxVQUFJLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQTtBQUNwQyxVQUFJLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQTtLQUNyQyxDQUFDLENBQUE7QUFDSixRQUFJLE1BQU0sS0FBSyxDQUFDLElBQUksTUFBTSxLQUFLLENBQUMsRUFBRTtBQUNoQyxPQUFDLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQTtLQUNwQjtBQUNELFdBQU8sQ0FBQyxDQUFDO0dBQ1Y7O0NBRUYsQ0FBQyxDQUFBOztxQkFFYSxrQkFBa0IiLCJmaWxlIjoidHJhbnNhY3Rpb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBUcmFuc2FjdGlvbiBmcm9tICcuLi8uLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdrbmV4OnR4JylcbmltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSAnLi4vLi4vaGVscGVycyc7XG5cbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJ2xvZGFzaCdcblxuZnVuY3Rpb24gVHJhbnNhY3Rpb25fTXlTUUwyKCkge1xuICBUcmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5pbmhlcml0cyhUcmFuc2FjdGlvbl9NeVNRTDIsIFRyYW5zYWN0aW9uKVxuXG5hc3NpZ24oVHJhbnNhY3Rpb25fTXlTUUwyLnByb3RvdHlwZSwge1xuXG4gIHF1ZXJ5KGNvbm4sIHNxbCwgc3RhdHVzLCB2YWx1ZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzXG4gICAgY29uc3QgcSA9IHRoaXMudHJ4Q2xpZW50LnF1ZXJ5KGNvbm4sIHNxbClcbiAgICAgIC5jYXRjaChlcnIgPT4gZXJyLmNvZGUgPT09ICdFUl9TUF9ET0VTX05PVF9FWElTVCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBoZWxwZXJzLndhcm4oXG4gICAgICAgICAgJ1RyYW5zYWN0aW9uIHdhcyBpbXBsaWNpdGx5IGNvbW1pdHRlZCwgZG8gbm90IG1peCB0cmFuc2FjdGlvbnMgYW5kJyArXG4gICAgICAgICAgJ0RETCB3aXRoIE15U1FMICgjODA1KSdcbiAgICAgICAgKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgc3RhdHVzID0gMlxuICAgICAgICB2YWx1ZSA9IGVyclxuICAgICAgICB0Ll9jb21wbGV0ZWQgPSB0cnVlXG4gICAgICAgIGRlYnVnKCclcyBlcnJvciBydW5uaW5nIHRyYW5zYWN0aW9uIHF1ZXJ5JywgdC50eGlkKVxuICAgICAgfSlcbiAgICAgIC50YXAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEpIHQuX3Jlc29sdmVyKHZhbHVlKVxuICAgICAgICBpZiAoc3RhdHVzID09PSAyKSB0Ll9yZWplY3Rlcih2YWx1ZSlcbiAgICAgIH0pXG4gICAgaWYgKHN0YXR1cyA9PT0gMSB8fCBzdGF0dXMgPT09IDIpIHtcbiAgICAgIHQuX2NvbXBsZXRlZCA9IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIHE7XG4gIH1cblxufSlcblxuZXhwb3J0IGRlZmF1bHQgVHJhbnNhY3Rpb25fTXlTUUwyXG4iXX0=

/***/ },
/* 113 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	// Oracle Client
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _lodash = __webpack_require__(5);

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _formatter = __webpack_require__(115);

	var _formatter2 = _interopRequireDefault(_formatter);

	var _client = __webpack_require__(42);

	var _client2 = _interopRequireDefault(_client);

	var _promise = __webpack_require__(43);

	var _promise2 = _interopRequireDefault(_promise);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _queryString = __webpack_require__(83);

	var _queryString2 = _interopRequireDefault(_queryString);

	var _transaction = __webpack_require__(117);

	var _transaction2 = _interopRequireDefault(_transaction);

	var _queryCompiler = __webpack_require__(118);

	var _queryCompiler2 = _interopRequireDefault(_queryCompiler);

	var _schemaCompiler = __webpack_require__(119);

	var _schemaCompiler2 = _interopRequireDefault(_schemaCompiler);

	var _schemaColumnbuilder = __webpack_require__(120);

	var _schemaColumnbuilder2 = _interopRequireDefault(_schemaColumnbuilder);

	var _schemaColumncompiler = __webpack_require__(121);

	var _schemaColumncompiler2 = _interopRequireDefault(_schemaColumncompiler);

	var _schemaTablecompiler = __webpack_require__(122);

	var _schemaTablecompiler2 = _interopRequireDefault(_schemaTablecompiler);

	var _stream2 = __webpack_require__(123);

	var _stream3 = _interopRequireDefault(_stream2);

	var _utils = __webpack_require__(116);

	// Always initialize with the "QueryBuilder" and "QueryCompiler"
	// objects, which extend the base 'lib/query/builder' and
	// 'lib/query/compiler', respectively.
	function Client_Oracle(config) {
	  _client2['default'].call(this, config);
	}
	_inherits2['default'](Client_Oracle, _client2['default']);

	_lodash.assign(Client_Oracle.prototype, {

	  dialect: 'oracle',

	  driverName: 'oracle',

	  _driver: function _driver() {
	    return __webpack_require__(124);
	  },

	  Transaction: _transaction2['default'],

	  Formatter: _formatter2['default'],

	  QueryCompiler: _queryCompiler2['default'],

	  SchemaCompiler: _schemaCompiler2['default'],

	  ColumnBuilder: _schemaColumnbuilder2['default'],

	  ColumnCompiler: _schemaColumncompiler2['default'],

	  TableCompiler: _schemaTablecompiler2['default'],

	  prepBindings: function prepBindings(bindings) {
	    var _this = this;

	    return _lodash.map(bindings, function (value) {
	      // returning helper uses always ROWID as string
	      if (value instanceof _utils.ReturningHelper && _this.driver) {
	        return new _this.driver.OutParam(_this.driver.OCCISTRING);
	      } else if (typeof value === 'boolean') {
	        return value ? 1 : 0;
	      } else if (Buffer.isBuffer(value)) {
	        return _queryString2['default'].bufferToString(value);
	      }
	      return value;
	    });
	  },

	  // Get a raw connection, called by the `pool` whenever a new
	  // connection needs to be added to the pool.
	  acquireRawConnection: function acquireRawConnection() {
	    var client = this;
	    return new _promise2['default'](function (resolver, rejecter) {
	      client.driver.connect(client.connectionSettings, function (err, connection) {
	        if (err) return rejecter(err);
	        _promise2['default'].promisifyAll(connection);
	        if (client.connectionSettings.prefetchRowCount) {
	          connection.setPrefetchRowCount(client.connectionSettings.prefetchRowCount);
	        }
	        resolver(connection);
	      });
	    });
	  },

	  // Used to explicitly close a connection, called internally by the pool
	  // when a connection times out or the pool is shutdown.
	  destroyRawConnection: function destroyRawConnection(connection, cb) {
	    connection.close();
	    cb();
	  },

	  // Return the database for the Oracle client.
	  database: function database() {
	    return this.connectionSettings.database;
	  },

	  // Position the bindings for the query.
	  positionBindings: function positionBindings(sql) {
	    var questionCount = 0;
	    return sql.replace(/\?/g, function () {
	      questionCount += 1;
	      return ':' + questionCount;
	    });
	  },

	  _stream: function _stream(connection, obj, stream, options) {
	    obj.sql = this.positionBindings(obj.sql);
	    return new _promise2['default'](function (resolver, rejecter) {
	      stream.on('error', rejecter);
	      stream.on('end', resolver);
	      var queryStream = new _stream3['default'](connection, obj.sql, obj.bindings, options);
	      queryStream.pipe(stream);
	    });
	  },

	  // Runs the query on the specified connection, providing the bindings
	  // and any other necessary prep work.
	  _query: function _query(connection, obj) {

	    // convert ? params into positional bindings (:1)
	    obj.sql = this.positionBindings(obj.sql);

	    if (!obj.sql) throw new Error('The query is empty');

	    return connection.executeAsync(obj.sql, obj.bindings).then(function (response) {
	      if (!obj.returning) return response;
	      var rowIds = obj.outParams.map(function (v, i) {
	        return response['returnParam' + (i ? i : '')];
	      });
	      return connection.executeAsync(obj.returningSql, rowIds);
	    }).then(function (response) {
	      obj.response = response;
	      return obj;
	    });
	  },

	  // Process the response as returned from the query.
	  processResponse: function processResponse(obj, runner) {
	    var response = obj.response;
	    var method = obj.method;

	    if (obj.output) return obj.output.call(runner, response);
	    switch (method) {
	      case 'select':
	      case 'pluck':
	      case 'first':
	        response = helpers.skim(response);
	        if (obj.method === 'pluck') response = _lodash.map(response, obj.pluck);
	        return obj.method === 'first' ? response[0] : response;
	      case 'insert':
	      case 'del':
	      case 'update':
	      case 'counter':
	        if (obj.returning) {
	          if (obj.returning.length > 1 || obj.returning[0] === '*') {
	            return response;
	          }
	          // return an array with values if only one returning value was specified
	          return _lodash.flatten(_lodash.map(response, _lodash.values));
	        }
	        return response.updateCount;
	      default:
	        return response;
	    }
	  },

	  ping: function ping(resource, callback) {
	    resource.execute('SELECT 1 FROM DUAL', [], callback);
	  }

	});

	exports['default'] = Client_Oracle;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy9vcmFjbGUvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7c0JBRzZDLFFBQVE7O3dCQUVoQyxVQUFVOzs7O3lCQUNULGFBQWE7Ozs7c0JBQ2hCLGNBQWM7Ozs7dUJBQ2IsZUFBZTs7Ozt1QkFDVixlQUFlOztJQUE1QixPQUFPOzsyQkFDRyxvQkFBb0I7Ozs7MkJBRWxCLGVBQWU7Ozs7NkJBQ2Isa0JBQWtCOzs7OzhCQUNqQixtQkFBbUI7Ozs7bUNBQ3BCLHdCQUF3Qjs7OztvQ0FDdkIseUJBQXlCOzs7O21DQUMxQix3QkFBd0I7Ozs7dUJBQ3BCLFVBQVU7Ozs7cUJBQ1IsU0FBUzs7Ozs7QUFLekMsU0FBUyxhQUFhLENBQUMsTUFBTSxFQUFFO0FBQzdCLHNCQUFPLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUE7Q0FDMUI7QUFDRCxzQkFBUyxhQUFhLHNCQUFTLENBQUE7O0FBRS9CLGVBQU8sYUFBYSxDQUFDLFNBQVMsRUFBRTs7QUFFOUIsU0FBTyxFQUFFLFFBQVE7O0FBRWpCLFlBQVUsRUFBRSxRQUFROztBQUVwQixTQUFPLEVBQUEsbUJBQUc7QUFDUixXQUFPLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQTtHQUN6Qjs7QUFFRCxhQUFXLDBCQUFBOztBQUVYLFdBQVMsd0JBQUE7O0FBRVQsZUFBYSw0QkFBQTs7QUFFYixnQkFBYyw2QkFBQTs7QUFFZCxlQUFhLGtDQUFBOztBQUViLGdCQUFjLG1DQUFBOztBQUVkLGVBQWEsa0NBQUE7O0FBRWIsY0FBWSxFQUFBLHNCQUFDLFFBQVEsRUFBRTs7O0FBQ3JCLFdBQU8sWUFBSSxRQUFRLEVBQUUsVUFBQyxLQUFLLEVBQUs7O0FBRTlCLFVBQUksS0FBSyxrQ0FBMkIsSUFBSSxNQUFLLE1BQU0sRUFBRTtBQUNuRCxlQUFPLElBQUksTUFBSyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQUssTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFB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QUFTO0FBQ1osWUFBSSxHQUFHLENBQUMsU0FBUyxFQUFFO0FBQ2pCLGNBQUksR0FBRyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxFQUFFO0FBQ3hELG1CQUFPLFFBQVEsQ0FBQztXQUNqQjs7QUFFRCxpQkFBTyxnQkFBUSxZQUFJLFFBQVEsaUJBQVMsQ0FBQyxDQUFDO1NBQ3ZDO0FBQ0QsZUFBTyxRQUFRLENBQUMsV0FBVyxDQUFDO0FBQUEsQUFDOUI7QUFDRSxlQUFPLFFBQVEsQ0FBQztBQUFBLEtBQ25CO0dBQ0Y7O0FBRUQsTUFBSSxFQUFBLGNBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRTtBQUN2QixZQUFRLENBQUMsT0FBTyxDQUFDLG9CQUFvQixFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztHQUN0RDs7Q0FFRixDQUFDLENBQUE7O3FCQUVhLGFBQWEiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8vIE9yYWNsZSBDbGllbnRcbi8vIC0tLS0tLS1cbmltcG9ydCB7IGFzc2lnbiwgbWFwLCBmbGF0dGVuLCB2YWx1ZXMgfSBmcm9tICdsb2Rhc2gnXG5cbmltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gJy4vZm9ybWF0dGVyJztcbmltcG9ydCBDbGllbnQgZnJvbSAnLi4vLi4vY2xpZW50JztcbmltcG9ydCBQcm9taXNlIGZyb20gJy4uLy4uL3Byb21pc2UnO1xuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuLi8uLi9oZWxwZXJzJztcbmltcG9ydCBTcWxTdHJpbmcgZnJvbSAnLi4vLi4vcXVlcnkvc3RyaW5nJztcblxuaW1wb3J0IFRyYW5zYWN0aW9uIGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IFF1ZXJ5Q29tcGlsZXIgZnJvbSAnLi9xdWVyeS9jb21waWxlcic7XG5pbXBvcnQgU2NoZW1hQ29tcGlsZXIgZnJvbSAnLi9zY2hlbWEvY29tcGlsZXInO1xuaW1wb3J0IENvbHVtbkJ1aWxkZXIgZnJvbSAnLi9zY2hlbWEvY29sdW1uYnVpbGRlcic7XG5pbXBvcnQgQ29sdW1uQ29tcGlsZXIgZnJvbSAnLi9zY2hlbWEvY29sdW1uY29tcGlsZXInO1xuaW1wb3J0IFRhYmxlQ29tcGlsZXIgZnJvbSAnLi9zY2hlbWEvdGFibGVjb21waWxlcic7XG5pbXBvcnQgT3JhY2xlUXVlcnlTdHJlYW0gZnJvbSAnLi9zdHJlYW0nO1xuaW1wb3J0IHsgUmV0dXJuaW5nSGVscGVyIH0gZnJvbSAnLi91dGlscyc7XG5cbi8vIEFsd2F5cyBpbml0aWFsaXplIHdpdGggdGhlIFwiUXVlcnlCdWlsZGVyXCIgYW5kIFwiUXVlcnlDb21waWxlclwiXG4vLyBvYmplY3RzLCB3aGljaCBleHRlbmQgdGhlIGJhc2UgJ2xpYi9xdWVyeS9idWlsZGVyJyBhbmRcbi8vICdsaWIvcXVlcnkvY29tcGlsZXInLCByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiBDbGllbnRfT3JhY2xlKGNvbmZpZykge1xuICBDbGllbnQuY2FsbCh0aGlzLCBjb25maWcpXG59XG5pbmhlcml0cyhDbGllbnRfT3JhY2xlLCBDbGllbnQpXG5cbmFzc2lnbihDbGllbnRfT3JhY2xlLnByb3RvdHlwZSwge1xuXG4gIGRpYWxlY3Q6ICdvcmFjbGUnLFxuXG4gIGRyaXZlck5hbWU6ICdvcmFjbGUnLFxuXG4gIF9kcml2ZXIoKSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ29yYWNsZScpXG4gIH0sXG5cbiAgVHJhbnNhY3Rpb24sXG5cbiAgRm9ybWF0dGVyLFxuXG4gIFF1ZXJ5Q29tcGlsZXIsXG5cbiAgU2NoZW1hQ29tcGlsZXIsXG5cbiAgQ29sdW1uQnVpbGRlcixcblxuICBDb2x1bW5Db21waWxlcixcblxuICBUYWJsZUNvbXBpbGVyLFxuXG4gIHByZXBCaW5kaW5ncyhiaW5kaW5ncykge1xuICAgIHJldHVybiBtYXAoYmluZGluZ3MsICh2YWx1ZSkgPT4ge1xuICAgICAgLy8gcmV0dXJuaW5nIGhlbHBlciB1c2VzIGFsd2F5cyBST1dJRCBhcyBzdHJpbmdcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJldHVybmluZ0hlbHBlciAmJiB0aGlzLmRyaXZlcikge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuZHJpdmVyLk91dFBhcmFtKHRoaXMuZHJpdmVyLk9DQ0lTVFJJTkcpXG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPyAxIDogMFxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gU3FsU3RyaW5nLmJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSlcbiAgfSxcblxuICAvLyBHZXQgYSByYXcgY29ubmVjdGlvbiwgY2FsbGVkIGJ5IHRoZSBgcG9vbGAgd2hlbmV2ZXIgYSBuZXdcbiAgLy8gY29ubmVjdGlvbiBuZWVkcyB0byBiZSBhZGRlZCB0byB0aGUgcG9vbC5cbiAgYWNxdWlyZVJhd0Nvbm5lY3Rpb24oKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpc1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlciwgcmVqZWN0ZXIpIHtcbiAgICAgIGNsaWVudC5kcml2ZXIuY29ubmVjdChjbGllbnQuY29ubmVjdGlvblNldHRpbmdzLFxuICAgICAgICBmdW5jdGlvbihlcnIsIGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0ZXIoZXJyKVxuICAgICAgICAgIFByb21pc2UucHJvbWlzaWZ5QWxsKGNvbm5lY3Rpb24pXG4gICAgICAgICAgaWYgKGNsaWVudC5jb25uZWN0aW9uU2V0dGluZ3MucHJlZmV0Y2hSb3dDb3VudCkge1xuICAgICAgICAgICAgY29ubmVjdGlvbi5zZXRQcmVmZXRjaFJvd0NvdW50KGNsaWVudC5jb25uZWN0aW9uU2V0dGluZ3MucHJlZmV0Y2hSb3dDb3VudClcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZXIoY29ubmVjdGlvbilcbiAgICAgICAgfSlcbiAgICB9KVxuICB9LFxuXG4gIC8vIFVzZWQgdG8gZXhwbGljaXRseSBjbG9zZSBhIGNvbm5lY3Rpb24sIGNhbGxlZCBpbnRlcm5hbGx5IGJ5IHRoZSBwb29sXG4gIC8vIHdoZW4gYSBjb25uZWN0aW9uIHRpbWVzIG91dCBvciB0aGUgcG9vbCBpcyBzaHV0ZG93bi5cbiAgZGVzdHJveVJhd0Nvbm5lY3Rpb24oY29ubmVjdGlvbiwgY2IpIHtcbiAgICBjb25uZWN0aW9uLmNsb3NlKClcbiAgICBjYigpXG4gIH0sXG5cbiAgLy8gUmV0dXJuIHRoZSBkYXRhYmFzZSBmb3IgdGhlIE9yYWNsZSBjbGllbnQuXG4gIGRhdGFiYXNlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25TZXR0aW5ncy5kYXRhYmFzZVxuICB9LFxuXG4gIC8vIFBvc2l0aW9uIHRoZSBiaW5kaW5ncyBmb3IgdGhlIHF1ZXJ5LlxuICBwb3NpdGlvbkJpbmRpbmdzKHNxbCkge1xuICAgIGxldCBxdWVzdGlvbkNvdW50ID0gMFxuICAgIHJldHVybiBzcWwucmVwbGFjZSgvXFw/L2csIGZ1bmN0aW9uKCkge1xuICAgICAgcXVlc3Rpb25Db3VudCArPSAxXG4gICAgICByZXR1cm4gYDoke3F1ZXN0aW9uQ291bnR9YFxuICAgIH0pXG4gIH0sXG5cbiAgX3N0cmVhbShjb25uZWN0aW9uLCBvYmosIHN0cmVhbSwgb3B0aW9ucykge1xuICAgIG9iai5zcWwgPSB0aGlzLnBvc2l0aW9uQmluZGluZ3Mob2JqLnNxbCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlciwgcmVqZWN0ZXIpIHtcbiAgICAgIHN0cmVhbS5vbignZXJyb3InLCByZWplY3Rlcik7XG4gICAgICBzdHJlYW0ub24oJ2VuZCcsIHJlc29sdmVyKTtcbiAgICAgIGNvbnN0IHF1ZXJ5U3RyZWFtID0gbmV3IE9yYWNsZVF1ZXJ5U3RyZWFtKGNvbm5lY3Rpb24sIG9iai5zcWwsIG9iai5iaW5kaW5ncywgb3B0aW9ucyk7XG4gICAgICBxdWVyeVN0cmVhbS5waXBlKHN0cmVhbSlcbiAgICB9KTtcbiAgfSxcblxuICAvLyBSdW5zIHRoZSBxdWVyeSBvbiB0aGUgc3BlY2lmaWVkIGNvbm5lY3Rpb24sIHByb3ZpZGluZyB0aGUgYmluZGluZ3NcbiAgLy8gYW5kIGFueSBvdGhlciBuZWNlc3NhcnkgcHJlcCB3b3JrLlxuICBfcXVlcnkoY29ubmVjdGlvbiwgb2JqKSB7XG5cbiAgICAvLyBjb252ZXJ0ID8gcGFyYW1zIGludG8gcG9zaXRpb25hbCBiaW5kaW5ncyAoOjEpXG4gICAgb2JqLnNxbCA9IHRoaXMucG9zaXRpb25CaW5kaW5ncyhvYmouc3FsKTtcblxuICAgIGlmICghb2JqLnNxbCkgdGhyb3cgbmV3IEVycm9yKCdUaGUgcXVlcnkgaXMgZW1wdHknKTtcblxuICAgIHJldHVybiBjb25uZWN0aW9uLmV4ZWN1dGVBc3luYyhvYmouc3FsLCBvYmouYmluZGluZ3MpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIGlmICghb2JqLnJldHVybmluZykgcmV0dXJuIHJlc3BvbnNlXG4gICAgICBjb25zdCByb3dJZHMgPSBvYmoub3V0UGFyYW1zLm1hcCgodiwgaSkgPT4gcmVzcG9uc2VbYHJldHVyblBhcmFtJHtpID8gaSA6ICcnfWBdKTtcbiAgICAgIHJldHVybiBjb25uZWN0aW9uLmV4ZWN1dGVBc3luYyhvYmoucmV0dXJuaW5nU3FsLCByb3dJZHMpXG4gICAgfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgb2JqLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICByZXR1cm4gb2JqXG4gICAgfSlcblxuICB9LFxuXG4gIC8vIFByb2Nlc3MgdGhlIHJlc3BvbnNlIGFzIHJldHVybmVkIGZyb20gdGhlIHF1ZXJ5LlxuICBwcm9jZXNzUmVzcG9uc2Uob2JqLCBydW5uZXIpIHtcbiAgICBsZXQgeyByZXNwb25zZSB9ID0gb2JqO1xuICAgIGNvbnN0IHsgbWV0aG9kIH0gPSBvYmo7XG4gICAgaWYgKG9iai5vdXRwdXQpIHJldHVybiBvYmoub3V0cHV0LmNhbGwocnVubmVyLCByZXNwb25zZSk7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBjYXNlICdwbHVjayc6XG4gICAgICBjYXNlICdmaXJzdCc6XG4gICAgICAgIHJlc3BvbnNlID0gaGVscGVycy5za2ltKHJlc3BvbnNlKTtcbiAgICAgICAgaWYgKG9iai5tZXRob2QgPT09ICdwbHVjaycpIHJlc3BvbnNlID0gbWFwKHJlc3BvbnNlLCBvYmoucGx1Y2spO1xuICAgICAgICByZXR1cm4gb2JqLm1ldGhvZCA9PT0gJ2ZpcnN0JyA/IHJlc3BvbnNlWzBdIDogcmVzcG9uc2U7XG4gICAgICBjYXNlICdpbnNlcnQnOlxuICAgICAgY2FzZSAnZGVsJzpcbiAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICBjYXNlICdjb3VudGVyJzpcbiAgICAgICAgaWYgKG9iai5yZXR1cm5pbmcpIHtcbiAgICAgICAgICBpZiAob2JqLnJldHVybmluZy5sZW5ndGggPiAxIHx8IG9iai5yZXR1cm5pbmdbMF0gPT09ICcqJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyByZXR1cm4gYW4gYXJyYXkgd2l0aCB2YWx1ZXMgaWYgb25seSBvbmUgcmV0dXJuaW5nIHZhbHVlIHdhcyBzcGVjaWZpZWRcbiAgICAgICAgICByZXR1cm4gZmxhdHRlbihtYXAocmVzcG9uc2UsIHZhbHVlcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZS51cGRhdGVDb3VudDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gIH0sXG5cbiAgcGluZyhyZXNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICByZXNvdXJjZS5leGVjdXRlKCdTRUxFQ1QgMSBGUk9NIERVQUwnLCBbXSwgY2FsbGJhY2spO1xuICB9XG5cbn0pXG5cbmV4cG9ydCBkZWZhdWx0IENsaWVudF9PcmFjbGVcbiJdfQ==
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20).Buffer))

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _formatter = __webpack_require__(61);

	var _formatter2 = _interopRequireDefault(_formatter);

	var _utils = __webpack_require__(116);

	var _lodash = __webpack_require__(5);

	function Oracle_Formatter(client) {
	  _formatter2['default'].call(this, client);
	}
	_inherits2['default'](Oracle_Formatter, _formatter2['default']);

	_lodash.assign(Oracle_Formatter.prototype, {

	  alias: function alias(first, second) {
	    return first + ' ' + second;
	  },

	  parameter: function parameter(value, notSetValue) {
	    // Returning helper uses always ROWID as string
	    if (value instanceof _utils.ReturningHelper && this.client.driver) {
	      value = new this.client.driver.OutParam(this.client.driver.OCCISTRING);
	    } else if (typeof value === 'boolean') {
	      value = value ? 1 : 0;
	    }
	    return _formatter2['default'].prototype.parameter.call(this, value, notSetValue);
	  }

	});

	exports['default'] = Oracle_Formatter;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy9vcmFjbGUvZm9ybWF0dGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozt3QkFDcUIsVUFBVTs7Ozt5QkFDVCxpQkFBaUI7Ozs7cUJBQ1AsU0FBUzs7c0JBRWxCLFFBQVE7O0FBRS9CLFNBQVMsZ0JBQWdCLENBQUMsTUFBTSxFQUFFO0FBQ2hDLHlCQUFVLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUE7Q0FDN0I7QUFDRCxzQkFBUyxnQkFBZ0IseUJBQVksQ0FBQTs7QUFFckMsZUFBTyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUU7O0FBRWpDLE9BQUssRUFBQSxlQUFDLEtBQUssRUFBRSxNQUFNLEVBQUU7QUFDbkIsV0FBTyxLQUFLLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQztHQUM3Qjs7QUFFRCxXQUFTLEVBQUEsbUJBQUMsS0FBSyxFQUFFLFdBQVcsRUFBRTs7QUFFNUIsUUFBSSxLQUFLLGtDQUEyQixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFO0FBQzFELFdBQUssR0FBRyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQTtLQUN2RSxNQUNJLElBQUksT0FBTyxLQUFLLEtBQUssU0FBUyxFQUFFO0FBQ25DLFdBQUssR0FBRyxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQTtLQUN0QjtBQUNELFdBQU8sdUJBQVUsU0FBUyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQTtHQUNwRTs7Q0FFRixDQUFDLENBQUE7O3FCQUVhLGdCQUFnQiIsImZpbGUiOiJmb3JtYXR0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5pbXBvcnQgRm9ybWF0dGVyIGZyb20gJy4uLy4uL2Zvcm1hdHRlcic7XG5pbXBvcnQgeyBSZXR1cm5pbmdIZWxwZXIgfSBmcm9tICcuL3V0aWxzJztcblxuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnbG9kYXNoJ1xuXG5mdW5jdGlvbiBPcmFjbGVfRm9ybWF0dGVyKGNsaWVudCkge1xuICBGb3JtYXR0ZXIuY2FsbCh0aGlzLCBjbGllbnQpXG59XG5pbmhlcml0cyhPcmFjbGVfRm9ybWF0dGVyLCBGb3JtYXR0ZXIpXG5cbmFzc2lnbihPcmFjbGVfRm9ybWF0dGVyLnByb3RvdHlwZSwge1xuXG4gIGFsaWFzKGZpcnN0LCBzZWNvbmQpIHtcbiAgICByZXR1cm4gZmlyc3QgKyAnICcgKyBzZWNvbmQ7XG4gIH0sXG5cbiAgcGFyYW1ldGVyKHZhbHVlLCBub3RTZXRWYWx1ZSkge1xuICAgIC8vIFJldHVybmluZyBoZWxwZXIgdXNlcyBhbHdheXMgUk9XSUQgYXMgc3RyaW5nXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmV0dXJuaW5nSGVscGVyICYmIHRoaXMuY2xpZW50LmRyaXZlcikge1xuICAgICAgdmFsdWUgPSBuZXcgdGhpcy5jbGllbnQuZHJpdmVyLk91dFBhcmFtKHRoaXMuY2xpZW50LmRyaXZlci5PQ0NJU1RSSU5HKVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSA/IDEgOiAwXG4gICAgfVxuICAgIHJldHVybiBGb3JtYXR0ZXIucHJvdG90eXBlLnBhcmFtZXRlci5jYWxsKHRoaXMsIHZhbHVlLCBub3RTZXRWYWx1ZSlcbiAgfVxuXG59KVxuXG5leHBvcnQgZGVmYXVsdCBPcmFjbGVfRm9ybWF0dGVyXG4iXX0=

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	function generateCombinedName(postfix, name, subNames) {
	  var crypto = __webpack_require__(24);
	  var limit = 30;
	  if (!Array.isArray(subNames)) subNames = subNames ? [subNames] : [];
	  var table = name.replace(/\.|-/g, '_');
	  var subNamesPart = subNames.join('_');
	  var result = (table + '_' + (subNamesPart.length ? subNamesPart + '_' : '') + postfix).toLowerCase();
	  if (result.length > limit) {
	    helpers.warn('Automatically generated name "' + result + '" exceeds ' + limit + ' character ' + 'limit for Oracle. Using base64 encoded sha1 of that name instead.');
	    // generates the sha1 of the name and encode it with base64
	    result = crypto.createHash('sha1').update(result).digest('base64').replace('=', '');
	  }
	  return result;
	}

	function wrapSqlWithCatch(sql, errorNumberToCatch) {
	  return 'begin execute immediate \'' + sql.replace(/'/g, "''") + '\'; ' + ('exception when others then if sqlcode != ' + errorNumberToCatch + ' then raise; ') + 'end if; ' + 'end;';
	}

	function ReturningHelper(columnName) {
	  this.columnName = columnName;
	}

	ReturningHelper.prototype.toString = function () {
	  return '[object ReturningHelper:' + this.columnName + ']';
	};

	exports.generateCombinedName = generateCombinedName;
	exports.wrapSqlWithCatch = wrapSqlWithCatch;
	exports.ReturningHelper = ReturningHelper;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy9vcmFjbGUvdXRpbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O3VCQUN5QixlQUFlOztJQUE1QixPQUFPOztBQUVuQixTQUFTLG9CQUFvQixDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFO0FBQ3JELE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUNqQyxNQUFNLEtBQUssR0FBRyxFQUFFLENBQUM7QUFDakIsTUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUUsUUFBUSxHQUFHLFFBQVEsR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNwRSxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQztBQUN6QyxNQUFNLFlBQVksR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3hDLE1BQUksTUFBTSxHQUFHLENBQUcsS0FBSyxVQUFJLFlBQVksQ0FBQyxNQUFNLEdBQUcsWUFBWSxHQUFHLEdBQUcsR0FBRSxFQUFFLENBQUEsR0FBRyxPQUFPLEVBQUcsV0FBVyxFQUFFLENBQUM7QUFDaEcsTUFBSSxNQUFNLENBQUMsTUFBTSxHQUFHLEtBQUssRUFBRTtBQUN6QixXQUFPLENBQUMsSUFBSSxDQUNWLG1DQUFpQyxNQUFNLGtCQUFhLEtBQUssc0ZBQ1UsQ0FDcEUsQ0FBQzs7QUFFRixVQUFNLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FDL0IsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUNkLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FDaEIsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztHQUNyQjtBQUNELFNBQU8sTUFBTSxDQUFDO0NBQ2Y7O0FBRUQsU0FBUyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsa0JBQWtCLEVBQUU7QUFDakQsU0FDRSwrQkFBNEIsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLDJEQUNQLGtCQUFrQixtQkFBZSxhQUNuRSxTQUNKLENBQ047Q0FDSDs7QUFFRCxTQUFTLGVBQWUsQ0FBQyxVQUFVLEVBQUU7QUFDbkMsTUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7Q0FDOUI7O0FBRUQsZUFBZSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsWUFBWTtBQUMvQyxzQ0FBa0MsSUFBSSxDQUFDLFVBQVUsT0FBSTtDQUN0RCxDQUFBOztRQUVRLG9CQUFvQixHQUFwQixvQkFBb0I7UUFBRSxnQkFBZ0IsR0FBaEIsZ0JBQWdCO1FBQUUsZUFBZSxHQUFmLGVBQWUiLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSAnLi4vLi4vaGVscGVycyc7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ29tYmluZWROYW1lKHBvc3RmaXgsIG5hbWUsIHN1Yk5hbWVzKSB7XG4gIGNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICBjb25zdCBsaW1pdCA9IDMwO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoc3ViTmFtZXMpKSBzdWJOYW1lcyA9IHN1Yk5hbWVzID8gW3N1Yk5hbWVzXSA6IFtdO1xuICBjb25zdCB0YWJsZSA9IG5hbWUucmVwbGFjZSgvXFwufC0vZywgJ18nKTtcbiAgY29uc3Qgc3ViTmFtZXNQYXJ0ID0gc3ViTmFtZXMuam9pbignXycpO1xuICBsZXQgcmVzdWx0ID0gYCR7dGFibGV9XyR7c3ViTmFtZXNQYXJ0Lmxlbmd0aCA/IHN1Yk5hbWVzUGFydCArICdfJzogJyd9JHtwb3N0Zml4fWAudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHJlc3VsdC5sZW5ndGggPiBsaW1pdCkge1xuICAgIGhlbHBlcnMud2FybihcbiAgICAgIGBBdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBuYW1lIFwiJHtyZXN1bHR9XCIgZXhjZWVkcyAke2xpbWl0fSBjaGFyYWN0ZXIgYCArXG4gICAgICBgbGltaXQgZm9yIE9yYWNsZS4gVXNpbmcgYmFzZTY0IGVuY29kZWQgc2hhMSBvZiB0aGF0IG5hbWUgaW5zdGVhZC5gXG4gICAgKTtcbiAgICAvLyBnZW5lcmF0ZXMgdGhlIHNoYTEgb2YgdGhlIG5hbWUgYW5kIGVuY29kZSBpdCB3aXRoIGJhc2U2NFxuICAgIHJlc3VsdCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJylcbiAgICAgIC51cGRhdGUocmVzdWx0KVxuICAgICAgLmRpZ2VzdCgnYmFzZTY0JylcbiAgICAgIC5yZXBsYWNlKCc9JywgJycpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHdyYXBTcWxXaXRoQ2F0Y2goc3FsLCBlcnJvck51bWJlclRvQ2F0Y2gpIHtcbiAgcmV0dXJuIChcbiAgICBgYmVnaW4gZXhlY3V0ZSBpbW1lZGlhdGUgJyR7c3FsLnJlcGxhY2UoLycvZywgXCInJ1wiKX0nOyBgICtcbiAgICBgZXhjZXB0aW9uIHdoZW4gb3RoZXJzIHRoZW4gaWYgc3FsY29kZSAhPSAke2Vycm9yTnVtYmVyVG9DYXRjaH0gdGhlbiByYWlzZTsgYCArXG4gICAgYGVuZCBpZjsgYCArXG4gICAgYGVuZDtgXG4gICk7XG59XG5cbmZ1bmN0aW9uIFJldHVybmluZ0hlbHBlcihjb2x1bW5OYW1lKSB7XG4gIHRoaXMuY29sdW1uTmFtZSA9IGNvbHVtbk5hbWU7XG59XG5cblJldHVybmluZ0hlbHBlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBgW29iamVjdCBSZXR1cm5pbmdIZWxwZXI6JHt0aGlzLmNvbHVtbk5hbWV9XWA7XG59XG5cbmV4cG9ydCB7IGdlbmVyYXRlQ29tYmluZWROYW1lLCB3cmFwU3FsV2l0aENhdGNoLCBSZXR1cm5pbmdIZWxwZXIgfTtcbiJdfQ==

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _promise = __webpack_require__(43);

	var _promise2 = _interopRequireDefault(_promise);

	var _transaction = __webpack_require__(65);

	var _transaction2 = _interopRequireDefault(_transaction);

	var _lodash = __webpack_require__(5);

	var debugTx = __webpack_require__(66)('knex:tx');

	function Oracle_Transaction(client, container, config, outerTx) {
	  _transaction2['default'].call(this, client, container, config, outerTx);
	}
	_inherits2['default'](Oracle_Transaction, _transaction2['default']);

	_lodash.assign(Oracle_Transaction.prototype, {

	  // disable autocommit to allow correct behavior (default is true)
	  begin: function begin() {
	    return _promise2['default'].resolve();
	  },

	  commit: function commit(conn, value) {
	    this._completed = true;
	    return conn.commitAsync()['return'](value).then(this._resolver, this._rejecter);
	  },

	  release: function release(conn, value) {
	    return this._resolver(value);
	  },

	  rollback: function rollback(conn, err) {
	    this._completed = true;
	    debugTx('%s: rolling back', this.txid);
	    return conn.rollbackAsync()['throw'](err)['catch'](this._rejecter);
	  },

	  acquireConnection: function acquireConnection(config) {
	    var t = this;
	    return _promise2['default']['try'](function () {
	      return config.connection || t.client.acquireConnection().completed;
	    }).tap(function (connection) {
	      if (!t.outerTx) {
	        connection.setAutoCommit(false);
	      }
	    }).disposer(function (connection) {
	      debugTx('%s: releasing connection', t.txid);
	      connection.setAutoCommit(true);
	      if (!config.connection) {
	        t.client.releaseConnection(connection);
	      } else {
	        debugTx('%s: not releasing external connection', t.txid);
	      }
	    });
	  }

	});

	exports['default'] = Oracle_Transaction;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy9vcmFjbGUvdHJhbnNhY3Rpb24uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O3dCQUNxQixVQUFVOzs7O3VCQUNYLGVBQWU7Ozs7MkJBQ1gsbUJBQW1COzs7O3NCQUdwQixRQUFROztBQUYvQixJQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUE7O0FBSTNDLFNBQVMsa0JBQWtCLENBQUMsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFO0FBQzlELDJCQUFZLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUE7Q0FDM0Q7QUFDRCxzQkFBUyxrQkFBa0IsMkJBQWMsQ0FBQTs7QUFFekMsZUFBTyxrQkFBa0IsQ0FBQyxTQUFTLEVBQUU7OztBQUduQyxPQUFLLEVBQUEsaUJBQUc7QUFDTixXQUFPLHFCQUFRLE9BQU8sRUFBRSxDQUFBO0dBQ3pCOztBQUVELFFBQU0sRUFBQSxnQkFBQyxJQUFJLEVBQUUsS0FBSyxFQUFFO0FBQ2xCLFFBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFBO0FBQ3RCLFdBQU8sSUFBSSxDQUFDLFdBQVcsRUFBRSxVQUNoQixDQUFDLEtBQUssQ0FBQyxDQUNiLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQTtHQUN4Qzs7QUFFRCxTQUFPLEVBQUEsaUJBQUMsSUFBSSxFQUFFLEtBQUssRUFBRTtBQUNuQixXQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUE7R0FDN0I7O0FBRUQsVUFBUSxFQUFBLGtCQUFDLElBQUksRUFBRSxHQUFHLEVBQUU7QUFDbEIsUUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUE7QUFDdEIsV0FBTyxDQUFDLGtCQUFrQixFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTtBQUN0QyxXQUFPLElBQUksQ0FBQyxhQUFhLEVBQUUsU0FDbkIsQ0FBQyxHQUFHLENBQUMsU0FDTCxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQTtHQUN6Qjs7QUFFRCxtQkFBaUIsRUFBQSwyQkFBQyxNQUFNLEVBQUU7QUFDeEIsUUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFBO0FBQ2QsV0FBTywyQkFBVyxDQUFDO2FBQ2pCLE1BQU0sQ0FBQyxVQUFVLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLFNBQVM7S0FBQSxDQUM1RCxDQUFDLEdBQUcsQ0FBQyxVQUFBLFVBQVUsRUFBSTtBQUNsQixVQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRTtBQUNkLGtCQUFVLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFBO09BQ2hDO0tBQ0YsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxVQUFBLFVBQVUsRUFBSTtBQUN4QixhQUFPLENBQUMsMEJBQTBCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFBO0FBQzNDLGdCQUFVLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFBO0FBQzlCLFVBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFO0FBQ3RCLFNBQUMsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUE7T0FDdkMsTUFBTTtBQUNMLGVBQU8sQ0FBQyx1Q0FBdUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUE7T0FDekQ7S0FDRixDQUFDLENBQUE7R0FDSDs7Q0FFRixDQUFDLENBQUE7O3FCQUVhLGtCQUFrQiIsImZpbGUiOiJ0cmFuc2FjdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcbmltcG9ydCBQcm9taXNlIGZyb20gJy4uLy4uL3Byb21pc2UnO1xuaW1wb3J0IFRyYW5zYWN0aW9uIGZyb20gJy4uLy4uL3RyYW5zYWN0aW9uJztcbmNvbnN0IGRlYnVnVHggPSByZXF1aXJlKCdkZWJ1ZycpKCdrbmV4OnR4JylcblxuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnbG9kYXNoJ1xuXG5mdW5jdGlvbiBPcmFjbGVfVHJhbnNhY3Rpb24oY2xpZW50LCBjb250YWluZXIsIGNvbmZpZywgb3V0ZXJUeCkge1xuICBUcmFuc2FjdGlvbi5jYWxsKHRoaXMsIGNsaWVudCwgY29udGFpbmVyLCBjb25maWcsIG91dGVyVHgpXG59XG5pbmhlcml0cyhPcmFjbGVfVHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uKVxuXG5hc3NpZ24oT3JhY2xlX1RyYW5zYWN0aW9uLnByb3RvdHlwZSwge1xuXG4gIC8vIGRpc2FibGUgYXV0b2NvbW1pdCB0byBhbGxvdyBjb3JyZWN0IGJlaGF2aW9yIChkZWZhdWx0IGlzIHRydWUpXG4gIGJlZ2luKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICB9LFxuXG4gIGNvbW1pdChjb25uLCB2YWx1ZSkge1xuICAgIHRoaXMuX2NvbXBsZXRlZCA9IHRydWVcbiAgICByZXR1cm4gY29ubi5jb21taXRBc3luYygpXG4gICAgICAucmV0dXJuKHZhbHVlKVxuICAgICAgLnRoZW4odGhpcy5fcmVzb2x2ZXIsIHRoaXMuX3JlamVjdGVyKVxuICB9LFxuXG4gIHJlbGVhc2UoY29ubiwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZXIodmFsdWUpXG4gIH0sXG5cbiAgcm9sbGJhY2soY29ubiwgZXJyKSB7XG4gICAgdGhpcy5fY29tcGxldGVkID0gdHJ1ZVxuICAgIGRlYnVnVHgoJyVzOiByb2xsaW5nIGJhY2snLCB0aGlzLnR4aWQpXG4gICAgcmV0dXJuIGNvbm4ucm9sbGJhY2tBc3luYygpXG4gICAgICAudGhyb3coZXJyKVxuICAgICAgLmNhdGNoKHRoaXMuX3JlamVjdGVyKVxuICB9LFxuXG4gIGFjcXVpcmVDb25uZWN0aW9uKGNvbmZpZykge1xuICAgIGNvbnN0IHQgPSB0aGlzXG4gICAgcmV0dXJuIFByb21pc2UudHJ5KCgpID0+XG4gICAgICBjb25maWcuY29ubmVjdGlvbiB8fCB0LmNsaWVudC5hY3F1aXJlQ29ubmVjdGlvbigpLmNvbXBsZXRlZFxuICAgICkudGFwKGNvbm5lY3Rpb24gPT4ge1xuICAgICAgaWYgKCF0Lm91dGVyVHgpIHtcbiAgICAgICAgY29ubmVjdGlvbi5zZXRBdXRvQ29tbWl0KGZhbHNlKVxuICAgICAgfVxuICAgIH0pLmRpc3Bvc2VyKGNvbm5lY3Rpb24gPT4ge1xuICAgICAgZGVidWdUeCgnJXM6IHJlbGVhc2luZyBjb25uZWN0aW9uJywgdC50eGlkKVxuICAgICAgY29ubmVjdGlvbi5zZXRBdXRvQ29tbWl0KHRydWUpXG4gICAgICBpZiAoIWNvbmZpZy5jb25uZWN0aW9uKSB7XG4gICAgICAgIHQuY2xpZW50LnJlbGVhc2VDb25uZWN0aW9uKGNvbm5lY3Rpb24pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1Z1R4KCclczogbm90IHJlbGVhc2luZyBleHRlcm5hbCBjb25uZWN0aW9uJywgdC50eGlkKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxufSlcblxuZXhwb3J0IGRlZmF1bHQgT3JhY2xlX1RyYW5zYWN0aW9uXG4iXX0=

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint max-len:0 */

	// Oracle Query Builder & Compiler
	// ------
	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _lodash = __webpack_require__(5);

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _queryCompiler = __webpack_require__(75);

	var _queryCompiler2 = _interopRequireDefault(_queryCompiler);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _utils = __webpack_require__(116);

	var components = ['columns', 'join', 'where', 'union', 'group', 'having', 'order', 'lock'];

	// Query Compiler
	// -------

	// Set the "Formatter" to use for the queries,
	// ensuring that all parameterized values (even across sub-queries)
	// are properly built into the same query.
	function QueryCompiler_Oracle(client, builder) {
	  _queryCompiler2['default'].call(this, client, builder);
	}
	_inherits2['default'](QueryCompiler_Oracle, _queryCompiler2['default']);

	_lodash.assign(QueryCompiler_Oracle.prototype, {

	  // Compiles an "insert" query, allowing for multiple
	  // inserts using a single query statement.
	  insert: function insert() {
	    var _this = this;

	    var insertValues = this.single.insert || [];
	    var returning = this.single.returning;

	    if (!Array.isArray(insertValues) && _lodash.isPlainObject(this.single.insert)) {
	      insertValues = [this.single.insert];
	    }

	    // always wrap returning argument in array
	    if (returning && !Array.isArray(returning)) {
	      returning = [returning];
	    }

	    if (Array.isArray(insertValues) && insertValues.length === 1 && _lodash.isEmpty(insertValues[0])) {
	      return this._addReturningToSqlAndConvert('insert into ' + this.tableName + ' (' + this.formatter.wrap(this.single.returning) + ') values (default)', returning, this.tableName);
	    }

	    if (_lodash.isEmpty(this.single.insert) && typeof this.single.insert !== 'function') {
	      return '';
	    }

	    var insertData = this._prepInsert(insertValues);

	    var sql = {};

	    if (_lodash.isString(insertData)) {
	      return this._addReturningToSqlAndConvert('insert into ' + this.tableName + ' ' + insertData, returning);
	    }

	    if (insertData.values.length === 1) {
	      return this._addReturningToSqlAndConvert('insert into ' + this.tableName + ' (' + this.formatter.columnize(insertData.columns) + ') values (' + this.formatter.parameterize(insertData.values[0]) + ')', returning, this.tableName);
	    }

	    var insertDefaultsOnly = insertData.columns.length === 0;

	    sql.sql = 'begin ' + _lodash.map(insertData.values, function (value) {
	      var returningHelper = undefined;
	      var parameterizedValues = !insertDefaultsOnly ? _this.formatter.parameterize(value, _this.client.valueForUndefined) : '';
	      var returningValues = Array.isArray(returning) ? returning : [returning];
	      var subSql = 'insert into ' + _this.tableName + ' ';

	      if (returning) {
	        returningHelper = new _utils.ReturningHelper(returningValues.join(':'));
	        sql.outParams = (sql.outParams || []).concat(returningHelper);
	      }

	      if (insertDefaultsOnly) {
	        // no columns given so only the default value
	        subSql += '(' + _this.formatter.wrap(_this.single.returning) + ') values (default)';
	      } else {
	        subSql += '(' + _this.formatter.columnize(insertData.columns) + ') values (' + parameterizedValues + ')';
	      }
	      subSql += returning ? ' returning ROWID into ' + _this.formatter.parameter(returningHelper) : '';

	      // pre bind position because subSql is an execute immediate parameter
	      // later position binding will only convert the ? params

	      subSql = _this.formatter.client.positionBindings(subSql);

	      var parameterizedValuesWithoutDefault = parameterizedValues.replace('DEFAULT, ', '').replace(', DEFAULT', '');
	      return 'execute immediate \'' + subSql.replace(/'/g, "''") + (parameterizedValuesWithoutDefault || returning ? '\' using ' : '') + parameterizedValuesWithoutDefault + (parameterizedValuesWithoutDefault && returning ? ', ' : '') + (returning ? 'out ?' : '') + ';';
	    }).join(' ') + 'end;';

	    if (returning) {
	      sql.returning = returning;
	      // generate select statement with special order by to keep the order because 'in (..)' may change the order
	      sql.returningSql = 'select ' + this.formatter.columnize(returning) + ' from ' + this.tableName + ' where ROWID in (' + sql.outParams.map(function (v, i) {
	        return ':' + (i + 1);
	      }).join(', ') + ')' + ' order by case ROWID ' + sql.outParams.map(function (v, i) {
	        return 'when CHARTOROWID(:' + (i + 1) + ') then ' + i;
	      }).join(' ') + ' end';
	    }

	    return sql;
	  },

	  // Update method, including joins, wheres, order & limits.
	  update: function update() {
	    var updates = this._prepUpdate(this.single.update);
	    var where = this.where();
	    var returning = this.single.returning;

	    var sql = 'update ' + this.tableName + ' set ' + updates.join(', ') + (where ? ' ' + where : '');

	    if (!returning) {
	      return sql;
	    }

	    // always wrap returning argument in array
	    if (returning && !Array.isArray(returning)) {
	      returning = [returning];
	    }

	    return this._addReturningToSqlAndConvert(sql, returning, this.tableName);
	  },

	  // Compiles a `truncate` query.
	  truncate: function truncate() {
	    return 'truncate table ' + this.tableName;
	  },

	  forUpdate: function forUpdate() {
	    return 'for update';
	  },

	  forShare: function forShare() {
	    // lock for share is not directly supported by oracle
	    // use LOCK TABLE .. IN SHARE MODE; instead
	    helpers.warn('lock for share is not supported by oracle dialect');
	    return '';
	  },

	  // Compiles a `columnInfo` query.
	  columnInfo: function columnInfo() {
	    var column = this.single.columnInfo;
	    return {
	      sql: 'select COLUMN_NAME, DATA_TYPE, CHAR_COL_DECL_LENGTH, NULLABLE from USER_TAB_COLS where TABLE_NAME = :1',
	      bindings: [this.single.table],
	      output: function output(resp) {
	        var out = _lodash.reduce(resp, function (columns, val) {
	          columns[val.COLUMN_NAME] = {
	            type: val.DATA_TYPE,
	            maxLength: val.CHAR_COL_DECL_LENGTH,
	            nullable: val.NULLABLE === 'Y'
	          };
	          return columns;
	        }, {});
	        return column && out[column] || out;
	      }
	    };
	  },

	  select: function select() {
	    var _this2 = this;

	    var statements = _lodash.map(components, function (component) {
	      return _this2[component]();
	    });
	    var query = _lodash.compact(statements).join(' ');
	    return this._surroundQueryWithLimitAndOffset(query);
	  },

	  aggregate: function aggregate(stmt) {
	    var val = stmt.value;
	    var splitOn = val.toLowerCase().indexOf(' as ');
	    var distinct = stmt.aggregateDistinct ? 'distinct ' : '';
	    // Allows us to speciy an alias for the aggregate types.
	    if (splitOn !== -1) {
	      var col = val.slice(0, splitOn);
	      var alias = val.slice(splitOn + 4);
	      return stmt.method + '(' + distinct + this.formatter.wrap(col) + ') ' + this.formatter.wrap(alias);
	    }
	    return stmt.method + '(' + distinct + this.formatter.wrap(val) + ')';
	  },

	  // for single commands only
	  _addReturningToSqlAndConvert: function _addReturningToSqlAndConvert(sql, returning, tableName) {
	    var res = {
	      sql: sql
	    };

	    if (!returning) {
	      return res;
	    }

	    var returningValues = Array.isArray(returning) ? returning : [returning];
	    var returningHelper = new _utils.ReturningHelper(returningValues.join(':'));
	    res.sql = sql + ' returning ROWID into ' + this.formatter.parameter(returningHelper);
	    res.returningSql = 'select ' + this.formatter.columnize(returning) + ' from ' + tableName + ' where ROWID = :1';
	    res.outParams = [returningHelper];
	    res.returning = returning;
	    return res;
	  },

	  _surroundQueryWithLimitAndOffset: function _surroundQueryWithLimitAndOffset(query) {
	    var limit = this.single.limit;
	    var offset = this.single.offset;

	    var hasLimit = limit || limit === 0 || limit === '0';
	    limit = +limit;

	    if (!hasLimit && !offset) return query;
	    query = query || "";

	    if (hasLimit && !offset) {
	      return 'select * from (' + query + ') where rownum <= ' + this.formatter.parameter(limit);
	    }

	    var endRow = +offset + (hasLimit ? limit : 10000000000000);

	    return "select * from " + "(select row_.*, ROWNUM rownum_ from (" + query + ") row_ " + "where rownum <= " + this.formatter.parameter(endRow) + ") " + "where rownum_ > " + this.formatter.parameter(offset);
	  }

	});

	// Compiles the `select` statement, or nested sub-selects
	// by calling each of the component compilers, trimming out
	// the empties, and returning a generated query string.
	QueryCompiler_Oracle.prototype.first = QueryCompiler_Oracle.prototype.select;

	exports['default'] = QueryCompiler_Oracle;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9vcmFjbGUvcXVlcnkvY29tcGlsZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O3NCQUkrRSxRQUFROzt3QkFDbEUsVUFBVTs7Ozs2QkFDTCx5QkFBeUI7Ozs7dUJBQzFCLGtCQUFrQjs7SUFBL0IsT0FBTzs7cUJBQ2EsVUFBVTs7QUFFMUMsSUFBTSxVQUFVLEdBQUcsQ0FDakIsU0FBUyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLE1BQU0sQ0FDeEUsQ0FBQzs7Ozs7Ozs7QUFRRixTQUFTLG9CQUFvQixDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUU7QUFDN0MsNkJBQWMsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUE7Q0FDMUM7QUFDRCxzQkFBUyxvQkFBb0IsNkJBQWdCLENBQUE7O0FBRTdDLGVBQU8sb0JBQW9CLENBQUMsU0FBUyxFQUFFOzs7O0FBSXJDLFFBQU0sRUFBQSxrQkFBRzs7O0FBQ1AsUUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFBO1FBQ3JDLFNBQVMsR0FBSyxJQUFJLENBQUMsTUFBTSxDQUF6QixTQUFTOztBQUVmLFFBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxJQUFJLHNCQUFjLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUU7QUFDckUsa0JBQVksR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUE7S0FDcEM7OztBQUdELFFBQUksU0FBUyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsRUFBRTtBQUMxQyxlQUFTLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztLQUN6Qjs7QUFFRCxRQUFJLEtBQUssQ0FBQyxPQUFPLENB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Iiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG1heC1sZW46MCAqL1xuXG4vLyBPcmFjbGUgUXVlcnkgQnVpbGRlciAmIENvbXBpbGVyXG4vLyAtLS0tLS1cbmltcG9ydCB7IGFzc2lnbiwgaXNQbGFpbk9iamVjdCwgaXNFbXB0eSwgaXNTdHJpbmcsIG1hcCwgcmVkdWNlLCBjb21wYWN0IH0gZnJvbSAnbG9kYXNoJ1xuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcbmltcG9ydCBRdWVyeUNvbXBpbGVyIGZyb20gJy4uLy4uLy4uL3F1ZXJ5L2NvbXBpbGVyJztcbmltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSAnLi4vLi4vLi4vaGVscGVycyc7XG5pbXBvcnQgeyBSZXR1cm5pbmdIZWxwZXIgfSBmcm9tICcuLi91dGlscyc7XG5cbmNvbnN0IGNvbXBvbmVudHMgPSBbXG4gICdjb2x1bW5zJywgJ2pvaW4nLCAnd2hlcmUnLCAndW5pb24nLCAnZ3JvdXAnLCAnaGF2aW5nJywgJ29yZGVyJywgJ2xvY2snXG5dO1xuXG4vLyBRdWVyeSBDb21waWxlclxuLy8gLS0tLS0tLVxuXG4vLyBTZXQgdGhlIFwiRm9ybWF0dGVyXCIgdG8gdXNlIGZvciB0aGUgcXVlcmllcyxcbi8vIGVuc3VyaW5nIHRoYXQgYWxsIHBhcmFtZXRlcml6ZWQgdmFsdWVzIChldmVuIGFjcm9zcyBzdWItcXVlcmllcylcbi8vIGFyZSBwcm9wZXJseSBidWlsdCBpbnRvIHRoZSBzYW1lIHF1ZXJ5LlxuZnVuY3Rpb24gUXVlcnlDb21waWxlcl9PcmFjbGUoY2xpZW50LCBidWlsZGVyKSB7XG4gIFF1ZXJ5Q29tcGlsZXIuY2FsbCh0aGlzLCBjbGllbnQsIGJ1aWxkZXIpXG59XG5pbmhlcml0cyhRdWVyeUNvbXBpbGVyX09yYWNsZSwgUXVlcnlDb21waWxlcilcblxuYXNzaWduKFF1ZXJ5Q29tcGlsZXJfT3JhY2xlLnByb3RvdHlwZSwge1xuXG4gIC8vIENvbXBpbGVzIGFuIFwiaW5zZXJ0XCIgcXVlcnksIGFsbG93aW5nIGZvciBtdWx0aXBsZVxuICAvLyBpbnNlcnRzIHVzaW5nIGEgc2luZ2xlIHF1ZXJ5IHN0YXRlbWVudC5cbiAgaW5zZXJ0KCkge1xuICAgIGxldCBpbnNlcnRWYWx1ZXMgPSB0aGlzLnNpbmdsZS5pbnNlcnQgfHwgW11cbiAgICBsZXQgeyByZXR1cm5pbmcgfSA9IHRoaXMuc2luZ2xlO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGluc2VydFZhbHVlcykgJiYgaXNQbGFpbk9iamVjdCh0aGlzLnNpbmdsZS5pbnNlcnQpKSB7XG4gICAgICBpbnNlcnRWYWx1ZXMgPSBbdGhpcy5zaW5nbGUuaW5zZXJ0XVxuICAgIH1cblxuICAgIC8vIGFsd2F5cyB3cmFwIHJldHVybmluZyBhcmd1bWVudCBpbiBhcnJheVxuICAgIGlmIChyZXR1cm5pbmcgJiYgIUFycmF5LmlzQXJyYXkocmV0dXJuaW5nKSkge1xuICAgICAgcmV0dXJuaW5nID0gW3JldHVybmluZ107XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5zZXJ0VmFsdWVzKSAmJiBpbnNlcnRWYWx1ZXMubGVuZ3RoID09PSAxICYmIGlzRW1wdHkoaW5zZXJ0VmFsdWVzWzBdKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZFJldHVybmluZ1RvU3FsQW5kQ29udmVydChgaW5zZXJ0IGludG8gJHt0aGlzLnRhYmxlTmFtZX0gKCR7dGhpcy5mb3JtYXR0ZXIud3JhcCh0aGlzLnNpbmdsZS5yZXR1cm5pbmcpfSkgdmFsdWVzIChkZWZhdWx0KWAsIHJldHVybmluZywgdGhpcy50YWJsZU5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpc0VtcHR5KHRoaXMuc2luZ2xlLmluc2VydCkgJiYgdHlwZW9mIHRoaXMuc2luZ2xlLmluc2VydCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGNvbnN0IGluc2VydERhdGEgPSB0aGlzLl9wcmVwSW5zZXJ0KGluc2VydFZhbHVlcyk7XG5cbiAgICBjb25zdCBzcWwgPSB7fTtcblxuICAgIGlmIChpc1N0cmluZyhpbnNlcnREYXRhKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZFJldHVybmluZ1RvU3FsQW5kQ29udmVydChgaW5zZXJ0IGludG8gJHt0aGlzLnRhYmxlTmFtZX0gJHtpbnNlcnREYXRhfWAsIHJldHVybmluZyk7XG4gICAgfVxuXG4gICAgaWYgKGluc2VydERhdGEudmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZFJldHVybmluZ1RvU3FsQW5kQ29udmVydChgaW5zZXJ0IGludG8gJHt0aGlzLnRhYmxlTmFtZX0gKCR7dGhpcy5mb3JtYXR0ZXIuY29sdW1uaXplKGluc2VydERhdGEuY29sdW1ucyl9KSB2YWx1ZXMgKCR7dGhpcy5mb3JtYXR0ZXIucGFyYW1ldGVyaXplKGluc2VydERhdGEudmFsdWVzWzBdKX0pYCwgcmV0dXJuaW5nLCB0aGlzLnRhYmxlTmFtZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5zZXJ0RGVmYXVsdHNPbmx5ID0gKGluc2VydERhdGEuY29sdW1ucy5sZW5ndGggPT09IDApO1xuXG4gICAgc3FsLnNxbCA9ICdiZWdpbiAnICsgbWFwKGluc2VydERhdGEudmFsdWVzLCAodmFsdWUpID0+IHtcbiAgICAgIGxldCByZXR1cm5pbmdIZWxwZXI7XG4gICAgICBjb25zdCBwYXJhbWV0ZXJpemVkVmFsdWVzID0gIWluc2VydERlZmF1bHRzT25seSA/IHRoaXMuZm9ybWF0dGVyLnBhcmFtZXRlcml6ZSh2YWx1ZSwgdGhpcy5jbGllbnQudmFsdWVGb3JVbmRlZmluZWQpIDogJyc7XG4gICAgICBjb25zdCByZXR1cm5pbmdWYWx1ZXMgPSBBcnJheS5pc0FycmF5KHJldHVybmluZykgPyByZXR1cm5pbmcgOiBbcmV0dXJuaW5nXTtcbiAgICAgIGxldCBzdWJTcWwgPSBgaW5zZXJ0IGludG8gJHt0aGlzLnRhYmxlTmFtZX0gYDtcblxuICAgICAgaWYgKHJldHVybmluZykge1xuICAgICAgICByZXR1cm5pbmdIZWxwZXIgPSBuZXcgUmV0dXJuaW5nSGVscGVyKHJldHVybmluZ1ZhbHVlcy5qb2luKCc6JykpO1xuICAgICAgICBzcWwub3V0UGFyYW1zID0gKHNxbC5vdXRQYXJhbXMgfHwgW10pLmNvbmNhdChyZXR1cm5pbmdIZWxwZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5zZXJ0RGVmYXVsdHNPbmx5KSB7XG4gICAgICAgIC8vIG5vIGNvbHVtbnMgZ2l2ZW4gc28gb25seSB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgICAgICBzdWJTcWwgKz0gYCgke3RoaXMuZm9ybWF0dGVyLndyYXAodGhpcy5zaW5nbGUucmV0dXJuaW5nKX0pIHZhbHVlcyAoZGVmYXVsdClgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ViU3FsICs9IGAoJHt0aGlzLmZvcm1hdHRlci5jb2x1bW5pemUoaW5zZXJ0RGF0YS5jb2x1bW5zKX0pIHZhbHVlcyAoJHtwYXJhbWV0ZXJpemVkVmFsdWVzfSlgO1xuICAgICAgfVxuICAgICAgc3ViU3FsICs9IChyZXR1cm5pbmcgPyBgIHJldHVybmluZyBST1dJRCBpbnRvICR7dGhpcy5mb3JtYXR0ZXIucGFyYW1ldGVyKHJldHVybmluZ0hlbHBlcil9YCA6ICcnKTtcblxuICAgICAgLy8gcHJlIGJpbmQgcG9zaXRpb24gYmVjYXVzZSBzdWJTcWwgaXMgYW4gZXhlY3V0ZSBpbW1lZGlhdGUgcGFyYW1ldGVyXG4gICAgICAvLyBsYXRlciBwb3NpdGlvbiBiaW5kaW5nIHdpbGwgb25seSBjb252ZXJ0IHRoZSA/IHBhcmFtc1xuXG4gICAgICBzdWJTcWwgPSB0aGlzLmZvcm1hdHRlci5jbGllbnQucG9zaXRpb25CaW5kaW5ncyhzdWJTcWwpO1xuXG4gICAgICBjb25zdCBwYXJhbWV0ZXJpemVkVmFsdWVzV2l0aG91dERlZmF1bHQgPSBwYXJhbWV0ZXJpemVkVmFsdWVzLnJlcGxhY2UoJ0RFRkFVTFQsICcsICcnKS5yZXBsYWNlKCcsIERFRkFVTFQnLCAnJyk7XG4gICAgICByZXR1cm4gYGV4ZWN1dGUgaW1tZWRpYXRlICcke3N1YlNxbC5yZXBsYWNlKC8nL2csIFwiJydcIil9YCArXG4gICAgICAgICgocGFyYW1ldGVyaXplZFZhbHVlc1dpdGhvdXREZWZhdWx0IHx8IHJldHVybmluZykgPyAnXFwnIHVzaW5nICcgOiAnJykgK1xuICAgICAgICBwYXJhbWV0ZXJpemVkVmFsdWVzV2l0aG91dERlZmF1bHQgK1xuICAgICAgICAoKHBhcmFtZXRlcml6ZWRWYWx1ZXNXaXRob3V0RGVmYXVsdCAmJiByZXR1cm5pbmcpID8gJywgJyA6ICcnKSArXG4gICAgICAgIChyZXR1cm5pbmcgPyAnb3V0ID8nIDogJycpICsgJzsnO1xuICAgIH0pLmpvaW4oJyAnKSArICdlbmQ7JztcblxuICAgIGlmIChyZXR1cm5pbmcpIHtcbiAgICAgIHNxbC5yZXR1cm5pbmcgPSByZXR1cm5pbmc7XG4gICAgICAvLyBnZW5lcmF0ZSBzZWxlY3Qgc3RhdGVtZW50IHdpdGggc3BlY2lhbCBvcmRlciBieSB0byBrZWVwIHRoZSBvcmRlciBiZWNhdXNlICdpbiAoLi4pJyBtYXkgY2hhbmdlIHRoZSBvcmRlclxuICAgICAgc3FsLnJldHVybmluZ1NxbCA9IGBzZWxlY3QgJHt0aGlzLmZvcm1hdHRlci5jb2x1bW5pemUocmV0dXJuaW5nKX1gICtcbiAgICAgICAgJyBmcm9tICcgKyB0aGlzLnRhYmxlTmFtZSArXG4gICAgICAgICcgd2hlcmUgUk9XSUQgaW4gKCcgKyBzcWwub3V0UGFyYW1zLm1hcCgodiwgaSkgPT4gYDoke2kgKyAxfWApLmpvaW4oJywgJykgKyAnKScgK1xuICAgICAgICAnIG9yZGVyIGJ5IGNhc2UgUk9XSUQgJyArIHNxbC5vdXRQYXJhbXMubWFwKCh2LCBpKSA9PiBgd2hlbiBDSEFSVE9ST1dJRCg6JHtpICsgMX0pIHRoZW4gJHtpfWApLmpvaW4oJyAnKSArICcgZW5kJztcbiAgICB9XG5cbiAgICByZXR1cm4gc3FsO1xuICB9LFxuXG4gIC8vIFVwZGF0ZSBtZXRob2QsIGluY2x1ZGluZyBqb2lucywgd2hlcmVzLCBvcmRlciAmIGxpbWl0cy5cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IHVwZGF0ZXMgPSB0aGlzLl9wcmVwVXBkYXRlKHRoaXMuc2luZ2xlLnVwZGF0ZSk7XG4gICAgY29uc3Qgd2hlcmUgPSB0aGlzLndoZXJlKCk7XG4gICAgbGV0IHsgcmV0dXJuaW5nIH0gPSB0aGlzLnNpbmdsZTtcbiAgICBjb25zdCBzcWwgPSBgdXBkYXRlICR7dGhpcy50YWJsZU5hbWV9YCArXG4gICAgICAnIHNldCAnICsgdXBkYXRlcy5qb2luKCcsICcpICtcbiAgICAgICh3aGVyZSA/IGAgJHt3aGVyZX1gIDogJycpO1xuXG4gICAgaWYgKCFyZXR1cm5pbmcpIHtcbiAgICAgIHJldHVybiBzcWw7XG4gICAgfVxuXG4gICAgLy8gYWx3YXlzIHdyYXAgcmV0dXJuaW5nIGFyZ3VtZW50IGluIGFycmF5XG4gICAgaWYgKHJldHVybmluZyAmJiAhQXJyYXkuaXNBcnJheShyZXR1cm5pbmcpKSB7XG4gICAgICByZXR1cm5pbmcgPSBbcmV0dXJuaW5nXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fYWRkUmV0dXJuaW5nVG9TcWxBbmRDb252ZXJ0KHNxbCwgcmV0dXJuaW5nLCB0aGlzLnRhYmxlTmFtZSk7XG4gIH0sXG5cbiAgLy8gQ29tcGlsZXMgYSBgdHJ1bmNhdGVgIHF1ZXJ5LlxuICB0cnVuY2F0ZSgpIHtcbiAgICByZXR1cm4gYHRydW5jYXRlIHRhYmxlICR7dGhpcy50YWJsZU5hbWV9YDtcbiAgfSxcblxuICBmb3JVcGRhdGUoKSB7XG4gICAgcmV0dXJuICdmb3IgdXBkYXRlJztcbiAgfSxcblxuICBmb3JTaGFyZSgpIHtcbiAgICAvLyBsb2NrIGZvciBzaGFyZSBpcyBub3QgZGlyZWN0bHkgc3VwcG9ydGVkIGJ5IG9yYWNsZVxuICAgIC8vIHVzZSBMT0NLIFRBQkxFIC4uIElOIFNIQVJFIE1PREU7IGluc3RlYWRcbiAgICBoZWxwZXJzLndhcm4oJ2xvY2sgZm9yIHNoYXJlIGlzIG5vdCBzdXBwb3J0ZWQgYnkgb3JhY2xlIGRpYWxlY3QnKTtcbiAgICByZXR1cm4gJyc7XG4gIH0sXG5cbiAgLy8gQ29tcGlsZXMgYSBgY29sdW1uSW5mb2AgcXVlcnkuXG4gIGNvbHVtbkluZm8oKSB7XG4gICAgY29uc3QgY29sdW1uID0gdGhpcy5zaW5nbGUuY29sdW1uSW5mbztcbiAgICByZXR1cm4ge1xuICAgICAgc3FsOiAnc2VsZWN0IENPTFVNTl9OQU1FLCBEQVRBX1RZUEUsIENIQVJfQ09MX0RFQ0xfTEVOR1RILCBOVUxMQUJMRSBmcm9tIFVTRVJfVEFCX0NPTFMgd2hlcmUgVEFCTEVfTkFNRSA9IDoxJyxcbiAgICAgIGJpbmRpbmdzOiBbdGhpcy5zaW5nbGUudGFibGVdLFxuICAgICAgb3V0cHV0KHJlc3ApIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gcmVkdWNlKHJlc3AsIGZ1bmN0aW9uKGNvbHVtbnMsIHZhbCkge1xuICAgICAgICAgIGNvbHVtbnNbdmFsLkNPTFVNTl9OQU1FXSA9IHtcbiAgICAgICAgICAgIHR5cGU6IHZhbC5EQVRBX1RZUEUsXG4gICAgICAgICAgICBtYXhMZW5ndGg6IHZhbC5DSEFSX0NPTF9ERUNMX0xFTkdUSCxcbiAgICAgICAgICAgIG51bGxhYmxlOiAodmFsLk5VTExBQkxFID09PSAnWScpXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gY29sdW1ucztcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gY29sdW1uICYmIG91dFtjb2x1bW5dIHx8IG91dDtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIHNlbGVjdCgpIHtcbiAgICBjb25zdCBzdGF0ZW1lbnRzID0gbWFwKGNvbXBvbmVudHMsIChjb21wb25lbnQpID0+IHtcbiAgICAgIHJldHVybiB0aGlzW2NvbXBvbmVudF0oKTtcbiAgICB9KTtcbiAgICBjb25zdCBxdWVyeSA9IGNvbXBhY3Qoc3RhdGVtZW50cykuam9pbignICcpO1xuICAgIHJldHVybiB0aGlzLl9zdXJyb3VuZFF1ZXJ5V2l0aExpbWl0QW5kT2Zmc2V0KHF1ZXJ5KTtcbiAgfSxcblxuICBhZ2dyZWdhdGUoc3RtdCkge1xuICAgIGNvbnN0IHZhbCA9IHN0bXQudmFsdWU7XG4gICAgY29uc3Qgc3BsaXRPbiA9IHZhbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJyBhcyAnKTtcbiAgICBjb25zdCBkaXN0aW5jdCA9IHN0bXQuYWdncmVnYXRlRGlzdGluY3QgPyAnZGlzdGluY3QgJyA6ICcnO1xuICAgIC8vIEFsbG93cyB1cyB0byBzcGVjaXkgYW4gYWxpYXMgZm9yIHRoZSBhZ2dyZWdhdGUgdHlwZXMuXG4gICAgaWYgKHNwbGl0T24gIT09IC0xKSB7XG4gICAgICBjb25zdCBjb2wgPSB2YWwuc2xpY2UoMCwgc3BsaXRPbik7XG4gICAgICBjb25zdCBhbGlhcyA9IHZhbC5zbGljZShzcGxpdE9uICsgNCk7XG4gICAgICByZXR1cm4gc3RtdC5tZXRob2QgKyAnKCcgKyBkaXN0aW5jdCArIHRoaXMuZm9ybWF0dGVyLndyYXAoY29sKSArICcpICcgKyB0aGlzLmZvcm1hdHRlci53cmFwKGFsaWFzKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0bXQubWV0aG9kICsgJygnICsgZGlzdGluY3QgKyB0aGlzLmZvcm1hdHRlci53cmFwKHZhbCkgKyAnKSc7XG4gIH0sXG5cbiAgLy8gZm9yIHNpbmdsZSBjb21tYW5kcyBvbmx5XG4gIF9hZGRSZXR1cm5pbmdUb1NxbEFuZENvbnZlcnQoc3FsLCByZXR1cm5pbmcsIHRhYmxlTmFtZSkge1xuICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgIHNxbFxuICAgIH07XG5cbiAgICBpZiAoIXJldHVybmluZykge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBjb25zdCByZXR1cm5pbmdWYWx1ZXMgPSBBcnJheS5pc0FycmF5KHJldHVybmluZykgPyByZXR1cm5pbmcgOiBbcmV0dXJuaW5nXTtcbiAgICBjb25zdCByZXR1cm5pbmdIZWxwZXIgPSBuZXcgUmV0dXJuaW5nSGVscGVyKHJldHVybmluZ1ZhbHVlcy5qb2luKCc6JykpO1xuICAgIHJlcy5zcWwgPSBzcWwgKyAnIHJldHVybmluZyBST1dJRCBpbnRvICcgKyB0aGlzLmZvcm1hdHRlci5wYXJhbWV0ZXIocmV0dXJuaW5nSGVscGVyKTtcbiAgICByZXMucmV0dXJuaW5nU3FsID0gYHNlbGVjdCAke3RoaXMuZm9ybWF0dGVyLmNvbHVtbml6ZShyZXR1cm5pbmcpfSBmcm9tICR7dGFibGVOYW1lfSB3aGVyZSBST1dJRCA9IDoxYDtcbiAgICByZXMub3V0UGFyYW1zID0gW3JldHVybmluZ0hlbHBlcl07XG4gICAgcmVzLnJldHVybmluZyA9IHJldHVybmluZztcbiAgICByZXR1cm4gcmVzO1xuICB9LFxuXG4gIF9zdXJyb3VuZFF1ZXJ5V2l0aExpbWl0QW5kT2Zmc2V0KHF1ZXJ5KSB7XG4gICAgbGV0IHsgbGltaXQgfSA9IHRoaXMuc2luZ2xlXG4gICAgY29uc3QgeyBvZmZzZXQgfSA9IHRoaXMuc2luZ2xlXG4gICAgY29uc3QgaGFzTGltaXQgPSAobGltaXQgfHwgbGltaXQgPT09IDAgfHwgbGltaXQgPT09ICcwJyk7XG4gICAgbGltaXQgPSArbGltaXQ7XG5cbiAgICBpZiAoIWhhc0xpbWl0ICYmICFvZmZzZXQpIHJldHVybiBxdWVyeTtcbiAgICBxdWVyeSA9IHF1ZXJ5IHx8IFwiXCI7XG5cbiAgICBpZiAoaGFzTGltaXQgJiYgIW9mZnNldCkge1xuICAgICAgcmV0dXJuIGBzZWxlY3QgKiBmcm9tICgke3F1ZXJ5fSkgd2hlcmUgcm93bnVtIDw9ICR7dGhpcy5mb3JtYXR0ZXIucGFyYW1ldGVyKGxpbWl0KX1gO1xuICAgIH1cblxuICAgIGNvbnN0IGVuZFJvdyA9ICsob2Zmc2V0KSArIChoYXNMaW1pdCA/IGxpbWl0IDogMTAwMDAwMDAwMDAwMDApO1xuXG4gICAgcmV0dXJuIFwic2VsZWN0ICogZnJvbSBcIiArXG4gICAgICAgICAgIFwiKHNlbGVjdCByb3dfLiosIFJPV05VTSByb3dudW1fIGZyb20gKFwiICsgcXVlcnkgKyBcIikgcm93XyBcIiArXG4gICAgICAgICAgIFwid2hlcmUgcm93bnVtIDw9IFwiICsgdGhpcy5mb3JtYXR0ZXIucGFyYW1ldGVyKGVuZFJvdykgKyBcIikgXCIgK1xuICAgICAgICAgICBcIndoZXJlIHJvd251bV8gPiBcIiArIHRoaXMuZm9ybWF0dGVyLnBhcmFtZXRlcihvZmZzZXQpO1xuICB9XG5cbn0pXG5cbi8vIENvbXBpbGVzIHRoZSBgc2VsZWN0YCBzdGF0ZW1lbnQsIG9yIG5lc3RlZCBzdWItc2VsZWN0c1xuLy8gYnkgY2FsbGluZyBlYWNoIG9mIHRoZSBjb21wb25lbnQgY29tcGlsZXJzLCB0cmltbWluZyBvdXRcbi8vIHRoZSBlbXB0aWVzLCBhbmQgcmV0dXJuaW5nIGEgZ2VuZXJhdGVkIHF1ZXJ5IHN0cmluZy5cblF1ZXJ5Q29tcGlsZXJfT3JhY2xlLnByb3RvdHlwZS5maXJzdCA9IFF1ZXJ5Q29tcGlsZXJfT3JhY2xlLnByb3RvdHlwZS5zZWxlY3RcblxuZXhwb3J0IGRlZmF1bHQgUXVlcnlDb21waWxlcl9PcmFjbGU7XG4iXX0=

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	
	// Oracle Schema Compiler
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _schemaCompiler = __webpack_require__(77);

	var _schemaCompiler2 = _interopRequireDefault(_schemaCompiler);

	var _utils = __webpack_require__(116);

	var utils = _interopRequireWildcard(_utils);

	function SchemaCompiler_Oracle() {
	  _schemaCompiler2['default'].apply(this, arguments);
	}
	_inherits2['default'](SchemaCompiler_Oracle, _schemaCompiler2['default']);

	// Rename a table on the schema.
	SchemaCompiler_Oracle.prototype.renameTable = function (tableName, to) {
	  this.pushQuery('rename ' + this.formatter.wrap(tableName) + ' to ' + this.formatter.wrap(to));
	};

	// Check whether a table exists on the query.
	SchemaCompiler_Oracle.prototype.hasTable = function (tableName) {
	  this.pushQuery({
	    sql: 'select TABLE_NAME from USER_TABLES where TABLE_NAME = ' + this.formatter.parameter(tableName),
	    output: function output(resp) {
	      return resp.length > 0;
	    }
	  });
	};

	// Check whether a column exists on the schema.
	SchemaCompiler_Oracle.prototype.hasColumn = function (tableName, column) {
	  var sql = 'select COLUMN_NAME from USER_TAB_COLUMNS ' + ('where TABLE_NAME = ' + this.formatter.parameter(tableName) + ' ') + ('and COLUMN_NAME = ' + this.formatter.parameter(column));
	  this.pushQuery({ sql: sql, output: function output(resp) {
	      return resp.length > 0;
	    } });
	};

	SchemaCompiler_Oracle.prototype.dropSequenceIfExists = function (sequenceName) {
	  this.pushQuery(utils.wrapSqlWithCatch('drop sequence ' + this.formatter.wrap(sequenceName), -2289));
	};

	SchemaCompiler_Oracle.prototype._dropRelatedSequenceIfExists = function (tableName) {
	  // removing the sequence that was possibly generated by increments() column
	  var sequenceName = utils.generateCombinedName('seq', tableName);
	  this.dropSequenceIfExists(sequenceName);
	};

	SchemaCompiler_Oracle.prototype.dropTable = function (tableName) {
	  this.pushQuery('drop table ' + this.formatter.wrap(tableName));

	  // removing the sequence that was possibly generated by increments() column
	  this._dropRelatedSequenceIfExists(tableName);
	};

	SchemaCompiler_Oracle.prototype.dropTableIfExists = function (tableName) {
	  this.pushQuery(utils.wrapSqlWithCatch('drop table ' + this.formatter.wrap(tableName), -942));

	  // removing the sequence that was possibly generated by increments() column
	  this._dropRelatedSequenceIfExists(tableName);
	};

	exports['default'] = SchemaCompiler_Oracle;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9vcmFjbGUvc2NoZW1hL2NvbXBpbGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O3dCQUdxQixVQUFVOzs7OzhCQUNKLDBCQUEwQjs7OztxQkFDOUIsVUFBVTs7SUFBckIsS0FBSzs7QUFFakIsU0FBUyxxQkFBcUIsR0FBRztBQUMvQiw4QkFBZSxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0NBQ3ZDO0FBQ0Qsc0JBQVMscUJBQXFCLDhCQUFpQixDQUFDOzs7QUFHaEQscUJBQXFCLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxVQUFTLFNBQVMsRUFBRSxFQUFFLEVBQUU7QUFDcEUsTUFBSSxDQUFDLFNBQVMsYUFBVyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsWUFBTyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBRyxDQUFDO0NBQzFGLENBQUM7OztBQUdGLHFCQUFxQixDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsVUFBUyxTQUFTLEVBQUU7QUFDN0QsTUFBSSxDQUFDLFNBQVMsQ0FBQztBQUNiLE9BQUcsRUFBRSx3REFBd0QsR0FDM0QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDO0FBQ3JDLFVBQU0sRUFBQSxnQkFBQyxJQUFJLEVBQUU7QUFDWCxhQUFPLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0tBQ3hCO0dBQ0YsQ0FBQyxDQUFDO0NBQ0osQ0FBQzs7O0FBR0YscUJBQXFCLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxVQUFTLFNBQVMsRUFBRSxNQUFNLEVBQUU7QUFDdEUsTUFBTSxHQUFHLEdBQ1AsdUVBQ3NCLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxPQUFHLDJCQUN2QyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBRSxDQUFDO0FBQzFELE1BQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxHQUFHLEVBQUgsR0FBRyxFQUFFLE1BQU0sRUFBRSxnQkFBQSxJQUFJO2FBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDO0tBQUEsRUFBRSxDQUFDLENBQUM7Q0FDMUQsQ0FBQzs7QUFFRixxQkFBcUIsQ0FBQyxTQUFTLENBQUMsb0JBQW9CLEdBQUcsVUFBVSxZQUFZLEVBQUU7QUFDN0UsTUFBSSxDQUFDLFNBQVMsQ0FDWixLQUFLLENBQUMsZ0JBQWdCLG9CQUFrQixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBSSxDQUFDLElBQUksQ0FBQyxDQUNwRixDQUFDO0NBQ0gsQ0FBQzs7QUFFRixxQkFBcUIsQ0FBQyxTQUFTLENBQUMsNEJBQTRCLEdBQUcsVUFBVSxTQUFTLEVBQUU7O0FBRWxGLE1BQU0sWUFBWSxHQUFHLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDbEUsTUFBSSxDQUFDLG9CQUFvQixDQUFDLFlBQVksQ0FBQyxDQUFDO0NBQ3pDLENBQUM7O0FBRUYscUJBQXFCLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxVQUFVLFNBQVMsRUFBRTtBQUMvRCxNQUFJLENBQUMsU0FBUyxpQkFBZSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBRyxDQUFDOzs7QUFHL0QsTUFBSSxDQUFDLDRCQUE0QixDQUFDLFNBQVMsQ0FBQyxDQUFDO0NBQzlDLENBQUM7O0FBRUYscUJBQXFCLENBQUMsU0FBUyxDQUFDLGlCQUFpQixHQUFHLFVBQVMsU0FBUyxFQUFFO0FBQ3RFLE1BQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLGdCQUFnQixpQkFBZSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7OztBQUc3RixNQUFJLENBQUMsNEJBQTRCLENBQUMsU0FBUyxDQUFDLENBQUM7Q0FDOUMsQ0FBQzs7cUJBRWEscUJBQXFCIiwiZmlsZSI6ImNvbXBpbGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBPcmFjbGUgU2NoZW1hIENvbXBpbGVyXG4vLyAtLS0tLS0tXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuaW1wb3J0IFNjaGVtYUNvbXBpbGVyIGZyb20gJy4uLy4uLy4uL3NjaGVtYS9jb21waWxlcic7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscyc7XG5cbmZ1bmN0aW9uIFNjaGVtYUNvbXBpbGVyX09yYWNsZSgpIHtcbiAgU2NoZW1hQ29tcGlsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmluaGVyaXRzKFNjaGVtYUNvbXBpbGVyX09yYWNsZSwgU2NoZW1hQ29tcGlsZXIpO1xuXG4vLyBSZW5hbWUgYSB0YWJsZSBvbiB0aGUgc2NoZW1hLlxuU2NoZW1hQ29tcGlsZXJfT3JhY2xlLnByb3RvdHlwZS5yZW5hbWVUYWJsZSA9IGZ1bmN0aW9uKHRhYmxlTmFtZSwgdG8pIHtcbiAgdGhpcy5wdXNoUXVlcnkoYHJlbmFtZSAke3RoaXMuZm9ybWF0dGVyLndyYXAodGFibGVOYW1lKX0gdG8gJHt0aGlzLmZvcm1hdHRlci53cmFwKHRvKX1gKTtcbn07XG5cbi8vIENoZWNrIHdoZXRoZXIgYSB0YWJsZSBleGlzdHMgb24gdGhlIHF1ZXJ5LlxuU2NoZW1hQ29tcGlsZXJfT3JhY2xlLnByb3RvdHlwZS5oYXNUYWJsZSA9IGZ1bmN0aW9uKHRhYmxlTmFtZSkge1xuICB0aGlzLnB1c2hRdWVyeSh7XG4gICAgc3FsOiAnc2VsZWN0IFRBQkxFX05BTUUgZnJvbSBVU0VSX1RBQkxFUyB3aGVyZSBUQUJMRV9OQU1FID0gJyArXG4gICAgICB0aGlzLmZvcm1hdHRlci5wYXJhbWV0ZXIodGFibGVOYW1lKSxcbiAgICBvdXRwdXQocmVzcCkge1xuICAgICAgcmV0dXJuIHJlc3AubGVuZ3RoID4gMDtcbiAgICB9XG4gIH0pO1xufTtcblxuLy8gQ2hlY2sgd2hldGhlciBhIGNvbHVtbiBleGlzdHMgb24gdGhlIHNjaGVtYS5cblNjaGVtYUNvbXBpbGVyX09yYWNsZS5wcm90b3R5cGUuaGFzQ29sdW1uID0gZnVuY3Rpb24odGFibGVOYW1lLCBjb2x1bW4pIHtcbiAgY29uc3Qgc3FsID1cbiAgICBgc2VsZWN0IENPTFVNTl9OQU1FIGZyb20gVVNFUl9UQUJfQ09MVU1OUyBgICtcbiAgICBgd2hlcmUgVEFCTEVfTkFNRSA9ICR7dGhpcy5mb3JtYXR0ZXIucGFyYW1ldGVyKHRhYmxlTmFtZSl9IGAgK1xuICAgIGBhbmQgQ09MVU1OX05BTUUgPSAke3RoaXMuZm9ybWF0dGVyLnBhcmFtZXRlcihjb2x1bW4pfWA7XG4gIHRoaXMucHVzaFF1ZXJ5KHsgc3FsLCBvdXRwdXQ6IHJlc3AgPT4gcmVzcC5sZW5ndGggPiAwIH0pO1xufTtcblxuU2NoZW1hQ29tcGlsZXJfT3JhY2xlLnByb3RvdHlwZS5kcm9wU2VxdWVuY2VJZkV4aXN0cyA9IGZ1bmN0aW9uIChzZXF1ZW5jZU5hbWUpIHtcbiAgdGhpcy5wdXNoUXVlcnkoXG4gICAgdXRpbHMud3JhcFNxbFdpdGhDYXRjaChgZHJvcCBzZXF1ZW5jZSAke3RoaXMuZm9ybWF0dGVyLndyYXAoc2VxdWVuY2VOYW1lKX1gLCAtMjI4OSlcbiAgKTtcbn07XG5cblNjaGVtYUNvbXBpbGVyX09yYWNsZS5wcm90b3R5cGUuX2Ryb3BSZWxhdGVkU2VxdWVuY2VJZkV4aXN0cyA9IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgLy8gcmVtb3ZpbmcgdGhlIHNlcXVlbmNlIHRoYXQgd2FzIHBvc3NpYmx5IGdlbmVyYXRlZCBieSBpbmNyZW1lbnRzKCkgY29sdW1uXG4gIGNvbnN0IHNlcXVlbmNlTmFtZSA9IHV0aWxzLmdlbmVyYXRlQ29tYmluZWROYW1lKCdzZXEnLCB0YWJsZU5hbWUpO1xuICB0aGlzLmRyb3BTZXF1ZW5jZUlmRXhpc3RzKHNlcXVlbmNlTmFtZSk7XG59O1xuXG5TY2hlbWFDb21waWxlcl9PcmFjbGUucHJvdG90eXBlLmRyb3BUYWJsZSA9IGZ1bmN0aW9uICh0YWJsZU5hbWUpIHtcbiAgdGhpcy5wdXNoUXVlcnkoYGRyb3AgdGFibGUgJHt0aGlzLmZvcm1hdHRlci53cmFwKHRhYmxlTmFtZSl9YCk7XG5cbiAgLy8gcmVtb3ZpbmcgdGhlIHNlcXVlbmNlIHRoYXQgd2FzIHBvc3NpYmx5IGdlbmVyYXRlZCBieSBpbmNyZW1lbnRzKCkgY29sdW1uXG4gIHRoaXMuX2Ryb3BSZWxhdGVkU2VxdWVuY2VJZkV4aXN0cyh0YWJsZU5hbWUpO1xufTtcblxuU2NoZW1hQ29tcGlsZXJfT3JhY2xlLnByb3RvdHlwZS5kcm9wVGFibGVJZkV4aXN0cyA9IGZ1bmN0aW9uKHRhYmxlTmFtZSkge1xuICB0aGlzLnB1c2hRdWVyeSh1dGlscy53cmFwU3FsV2l0aENhdGNoKGBkcm9wIHRhYmxlICR7dGhpcy5mb3JtYXR0ZXIud3JhcCh0YWJsZU5hbWUpfWAsIC05NDIpKTtcblxuICAvLyByZW1vdmluZyB0aGUgc2VxdWVuY2UgdGhhdCB3YXMgcG9zc2libHkgZ2VuZXJhdGVkIGJ5IGluY3JlbWVudHMoKSBjb2x1bW5cbiAgdGhpcy5fZHJvcFJlbGF0ZWRTZXF1ZW5jZUlmRXhpc3RzKHRhYmxlTmFtZSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTY2hlbWFDb21waWxlcl9PcmFjbGU7XG4iXX0=

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _schemaColumnbuilder = __webpack_require__(81);

	var _schemaColumnbuilder2 = _interopRequireDefault(_schemaColumnbuilder);

	var _lodash = __webpack_require__(5);

	function ColumnBuilder_Oracle() {
	  _schemaColumnbuilder2['default'].apply(this, arguments);
	}
	_inherits2['default'](ColumnBuilder_Oracle, _schemaColumnbuilder2['default']);

	// checkIn added to the builder to allow the column compiler to change the
	// order via the modifiers ("check" must be after "default")
	ColumnBuilder_Oracle.prototype.checkIn = function () {
	  this._modifiers.checkIn = _lodash.toArray(arguments);
	  return this;
	};

	exports['default'] = ColumnBuilder_Oracle;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9vcmFjbGUvc2NoZW1hL2NvbHVtbmJ1aWxkZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O3dCQUNxQixVQUFVOzs7O21DQUNMLCtCQUErQjs7OztzQkFFakMsUUFBUTs7QUFFaEMsU0FBUyxvQkFBb0IsR0FBRztBQUM5QixtQ0FBYyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0NBQ3RDO0FBQ0Qsc0JBQVMsb0JBQW9CLG1DQUFnQixDQUFDOzs7O0FBSTlDLG9CQUFvQixDQUFDLFNBQVMsQ0FBQyxPQUFPLEdBQUcsWUFBWTtBQUNuRCxNQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sR0FBRyxnQkFBUSxTQUFTLENBQUMsQ0FBQztBQUM3QyxTQUFPLElBQUksQ0FBQztDQUNiLENBQUM7O3FCQUVhLG9CQUFvQiIsImZpbGUiOiJjb2x1bW5idWlsZGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuaW1wb3J0IENvbHVtbkJ1aWxkZXIgZnJvbSAnLi4vLi4vLi4vc2NoZW1hL2NvbHVtbmJ1aWxkZXInO1xuXG5pbXBvcnQgeyB0b0FycmF5IH0gZnJvbSAnbG9kYXNoJ1xuXG5mdW5jdGlvbiBDb2x1bW5CdWlsZGVyX09yYWNsZSgpIHtcbiAgQ29sdW1uQnVpbGRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuaW5oZXJpdHMoQ29sdW1uQnVpbGRlcl9PcmFjbGUsIENvbHVtbkJ1aWxkZXIpO1xuXG4vLyBjaGVja0luIGFkZGVkIHRvIHRoZSBidWlsZGVyIHRvIGFsbG93IHRoZSBjb2x1bW4gY29tcGlsZXIgdG8gY2hhbmdlIHRoZVxuLy8gb3JkZXIgdmlhIHRoZSBtb2RpZmllcnMgKFwiY2hlY2tcIiBtdXN0IGJlIGFmdGVyIFwiZGVmYXVsdFwiKVxuQ29sdW1uQnVpbGRlcl9PcmFjbGUucHJvdG90eXBlLmNoZWNrSW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX21vZGlmaWVycy5jaGVja0luID0gdG9BcnJheShhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENvbHVtbkJ1aWxkZXJfT3JhY2xlXG4iXX0=

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _lodash = __webpack_require__(5);

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _utils = __webpack_require__(116);

	var utils = _interopRequireWildcard(_utils);

	var _raw = __webpack_require__(2);

	var _raw2 = _interopRequireDefault(_raw);

	var _schemaColumncompiler = __webpack_require__(82);

	var _schemaColumncompiler2 = _interopRequireDefault(_schemaColumncompiler);

	// Column Compiler
	// -------

	function ColumnCompiler_Oracle() {
	  this.modifiers = ['defaultTo', 'checkIn', 'nullable', 'comment'];
	  _schemaColumncompiler2['default'].apply(this, arguments);
	}
	_inherits2['default'](ColumnCompiler_Oracle, _schemaColumncompiler2['default']);

	_lodash.assign(ColumnCompiler_Oracle.prototype, {

	  // helper function for pushAdditional in increments() and bigincrements()
	  _createAutoIncrementTriggerAndSequence: function _createAutoIncrementTriggerAndSequence() {
	    // TODO Add warning that sequence etc is created
	    this.pushAdditional(function () {
	      var sequenceName = this.tableCompiler._indexCommand('seq', this.tableCompiler.tableNameRaw);
	      var triggerName = this.tableCompiler._indexCommand('trg', this.tableCompiler.tableNameRaw, this.getColumnName());
	      var tableName = this.tableCompiler.tableName();
	      var columnName = this.formatter.wrap(this.getColumnName());
	      var createTriggerSQL = 'create or replace trigger ' + triggerName + ' before insert on ' + tableName + ' for each row' + (' when (new.' + columnName + ' is null) ') + ' begin' + (' select ' + sequenceName + '.nextval into :new.' + columnName + ' from dual;') + ' end;';
	      this.pushQuery(utils.wrapSqlWithCatch('create sequence ' + sequenceName, -955));
	      this.pushQuery(createTriggerSQL);
	    });
	  },

	  increments: function increments() {
	    this._createAutoIncrementTriggerAndSequence();
	    return 'integer not null primary key';
	  },

	  bigincrements: function bigincrements() {
	    this._createAutoIncrementTriggerAndSequence();
	    return 'number(20, 0) not null primary key';
	  },

	  floating: function floating(precision) {
	    var parsedPrecision = this._num(precision, 0);
	    return 'float' + (parsedPrecision ? '(' + parsedPrecision + ')' : '');
	  },

	  double: function double(precision, scale) {
	    // if (!precision) return 'number'; // TODO: Check If default is ok
	    return 'number(' + this._num(precision, 8) + ', ' + this._num(scale, 2) + ')';
	  },

	  integer: function integer(length) {
	    return length ? 'number(' + this._num(length, 11) + ')' : 'integer';
	  },

	  tinyint: 'smallint',

	  smallint: 'smallint',

	  mediumint: 'integer',

	  biginteger: 'number(20, 0)',

	  text: 'clob',

	  enu: function enu(allowed) {
	    allowed = _lodash.uniq(allowed);
	    var maxLength = (allowed || []).reduce(function (maxLength, name) {
	      return Math.max(maxLength, String(name).length);
	    }, 1);

	    // implicitly add the enum values as checked values
	    this.columnBuilder._modifiers.checkIn = [allowed];

	    return 'varchar2(' + maxLength + ')';
	  },

	  time: 'timestamp with time zone',

	  datetime: function datetime(without) {
	    return without ? 'timestamp' : 'timestamp with time zone';
	  },

	  timestamp: function timestamp(without) {
	    return without ? 'timestamp' : 'timestamp with time zone';
	  },

	  bit: 'clob',

	  json: 'clob',

	  bool: function bool() {
	    // implicitly add the check for 0 and 1
	    this.columnBuilder._modifiers.checkIn = [[0, 1]];
	    return 'number(1, 0)';
	  },

	  varchar: function varchar(length) {
	    return 'varchar2(' + this._num(length, 255) + ')';
	  },

	  // Modifiers
	  // ------

	  comment: function comment(_comment) {
	    this.pushAdditional(function () {
	      this.pushQuery('comment on column ' + this.tableCompiler.tableName() + '.' + this.formatter.wrap(this.args[0]) + " is '" + (_comment || '') + "'");
	    }, _comment);
	  },

	  checkIn: function checkIn(value) {
	    // TODO: Maybe accept arguments also as array
	    // TODO: value(s) should be escaped properly
	    if (value === undefined) {
	      return '';
	    } else if (value instanceof _raw2['default']) {
	      value = value.toQuery();
	    } else if (Array.isArray(value)) {
	      value = _lodash.map(value, function (v) {
	        return '\'' + v + '\'';
	      }).join(', ');
	    } else {
	      value = '\'' + value + '\'';
	    }
	    return 'check (' + this.formatter.wrap(this.args[0]) + ' in (' + value + '))';
	  }

	});

	exports['default'] = ColumnCompiler_Oracle;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9vcmFjbGUvc2NoZW1hL2NvbHVtbmNvbXBpbGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O3NCQUNrQyxRQUFROzt3QkFDckIsVUFBVTs7OztxQkFDUixVQUFVOztJQUFyQixLQUFLOzttQkFDRCxjQUFjOzs7O29DQUNILGdDQUFnQzs7Ozs7OztBQUszRCxTQUFTLHFCQUFxQixHQUFHO0FBQy9CLE1BQUksQ0FBQyxTQUFTLEdBQUcsQ0FBQyxXQUFXLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQztBQUNqRSxvQ0FBZSxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0NBQ3ZDO0FBQ0Qsc0JBQVMscUJBQXFCLG9DQUFpQixDQUFDOztBQUVoRCxlQUFPLHFCQUFxQixDQUFDLFNBQVMsRUFBRTs7O0FBR3RDLHdDQUFzQyxFQUFDLGtEQUFHOztBQUV4QyxRQUFJLENBQUMsY0FBYyxDQUFDLFlBQVk7QUFDOUIsVUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQ25ELEtBQUssRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FDdkMsQ0FBQztBQUNGLFVBQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUNsRCxLQUFLLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUM3RCxDQUFDO0FBQ0YsVUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUNqRCxVQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQztBQUM3RCxVQUFNLGdCQUFnQixHQUNwQiwrQkFBNkIsV0FBVywwQkFBcUIsU0FBUyxrQkFDdkQsb0JBQ0QsVUFBVSxnQkFB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QUFDLFNBQVMsRUFBRSxTQUNoRSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxJQUFJLFFBQU8sSUFBSSxFQUFFLENBQUEsQUFBQyxHQUFFLEdBQUcsQ0FBQyxDQUFDO0tBQ3ZFLEVBQUUsUUFBTyxDQUFDLENBQUM7R0FDYjs7QUFFRCxTQUFPLEVBQUMsaUJBQUMsS0FBSyxFQUFFOzs7QUFHZCxRQUFJLEtBQUssS0FBSyxTQUFTLEVBQUU7QUFDdkIsYUFBTyxFQUFFLENBQUM7S0FDWCxNQUFNLElBQUksS0FBSyw0QkFBZSxFQUFFO0FBQy9CLFdBQUssR0FBRyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7S0FDekIsTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDL0IsV0FBSyxHQUFHLFlBQUksS0FBSyxFQUFFLFVBQUEsQ0FBQztzQkFBUSxDQUFDO09BQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUM5QyxNQUFNO0FBQ0wsV0FBSyxVQUFPLEtBQUssT0FBRyxDQUFDO0tBQ3RCO0FBQ0QsdUJBQWlCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBUSxLQUFLLFFBQUs7R0FDckU7O0NBRUYsQ0FBQyxDQUFDOztxQkFFWSxxQkFBcUIiLCJmaWxlIjoiY29sdW1uY29tcGlsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IGFzc2lnbiwgdW5pcSwgbWFwIH0gZnJvbSAnbG9kYXNoJ1xuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBSYXcgZnJvbSAnLi4vLi4vLi4vcmF3JztcbmltcG9ydCBDb2x1bW5Db21waWxlciBmcm9tICcuLi8uLi8uLi9zY2hlbWEvY29sdW1uY29tcGlsZXInO1xuXG4vLyBDb2x1bW4gQ29tcGlsZXJcbi8vIC0tLS0tLS1cblxuZnVuY3Rpb24gQ29sdW1uQ29tcGlsZXJfT3JhY2xlKCkge1xuICB0aGlzLm1vZGlmaWVycyA9IFsnZGVmYXVsdFRvJywgJ2NoZWNrSW4nLCAnbnVsbGFibGUnLCAnY29tbWVudCddO1xuICBDb2x1bW5Db21waWxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuaW5oZXJpdHMoQ29sdW1uQ29tcGlsZXJfT3JhY2xlLCBDb2x1bW5Db21waWxlcik7XG5cbmFzc2lnbihDb2x1bW5Db21waWxlcl9PcmFjbGUucHJvdG90eXBlLCB7XG5cbiAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBwdXNoQWRkaXRpb25hbCBpbiBpbmNyZW1lbnRzKCkgYW5kIGJpZ2luY3JlbWVudHMoKVxuICBfY3JlYXRlQXV0b0luY3JlbWVudFRyaWdnZXJBbmRTZXF1ZW5jZSAoKSB7XG4gICAgLy8gVE9ETyBBZGQgd2FybmluZyB0aGF0IHNlcXVlbmNlIGV0YyBpcyBjcmVhdGVkXG4gICAgdGhpcy5wdXNoQWRkaXRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBzZXF1ZW5jZU5hbWUgPSB0aGlzLnRhYmxlQ29tcGlsZXIuX2luZGV4Q29tbWFuZChcbiAgICAgICAgJ3NlcScsIHRoaXMudGFibGVDb21waWxlci50YWJsZU5hbWVSYXdcbiAgICAgICk7XG4gICAgICBjb25zdCB0cmlnZ2VyTmFtZSA9IHRoaXMudGFibGVDb21waWxlci5faW5kZXhDb21tYW5kKFxuICAgICAgICAndHJnJywgdGhpcy50YWJsZUNvbXBpbGVyLnRhYmxlTmFtZVJhdywgdGhpcy5nZXRDb2x1bW5OYW1lKClcbiAgICAgICk7XG4gICAgICBjb25zdCB0YWJsZU5hbWUgPSB0aGlzLnRhYmxlQ29tcGlsZXIudGFibGVOYW1lKCk7XG4gICAgICBjb25zdCBjb2x1bW5OYW1lID0gdGhpcy5mb3JtYXR0ZXIud3JhcCh0aGlzLmdldENvbHVtbk5hbWUoKSk7XG4gICAgICBjb25zdCBjcmVhdGVUcmlnZ2VyU1FMID1cbiAgICAgICAgYGNyZWF0ZSBvciByZXBsYWNlIHRyaWdnZXIgJHt0cmlnZ2VyTmFtZX0gYmVmb3JlIGluc2VydCBvbiAke3RhYmxlTmFtZX1gICtcbiAgICAgICAgYCBmb3IgZWFjaCByb3dgICtcbiAgICAgICAgYCB3aGVuIChuZXcuJHtjb2x1bW5OYW1lfSBpcyBudWxsKSBgICtcbiAgICAgICAgYCBiZWdpbmAgK1xuICAgICAgICBgIHNlbGVjdCAke3NlcXVlbmNlTmFtZX0ubmV4dHZhbCBpbnRvIDpuZXcuJHtjb2x1bW5OYW1lfSBmcm9tIGR1YWw7YCArXG4gICAgICAgIGAgZW5kO2A7XG4gICAgICB0aGlzLnB1c2hRdWVyeSh1dGlscy53cmFwU3FsV2l0aENhdGNoKGBjcmVhdGUgc2VxdWVuY2UgJHtzZXF1ZW5jZU5hbWV9YCwgLTk1NSkpO1xuICAgICAgdGhpcy5wdXNoUXVlcnkoY3JlYXRlVHJpZ2dlclNRTCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgaW5jcmVtZW50cyAoKSB7XG4gICAgdGhpcy5fY3JlYXRlQXV0b0luY3JlbWVudFRyaWdnZXJBbmRTZXF1ZW5jZSgpO1xuICAgIHJldHVybiAnaW50ZWdlciBub3QgbnVsbCBwcmltYXJ5IGtleSc7XG4gIH0sXG5cbiAgYmlnaW5jcmVtZW50cyAoKSB7XG4gICAgdGhpcy5fY3JlYXRlQXV0b0luY3JlbWVudFRyaWdnZXJBbmRTZXF1ZW5jZSgpO1xuICAgIHJldHVybiAnbnVtYmVyKDIwLCAwKSBub3QgbnVsbCBwcmltYXJ5IGtleSc7XG4gIH0sXG5cbiAgZmxvYXRpbmcocHJlY2lzaW9uKSB7XG4gICAgY29uc3QgcGFyc2VkUHJlY2lzaW9uID0gdGhpcy5fbnVtKHByZWNpc2lvbiwgMCk7XG4gICAgcmV0dXJuIGBmbG9hdCR7cGFyc2VkUHJlY2lzaW9uID8gYCgke3BhcnNlZFByZWNpc2lvbn0pYCA6ICcnfWA7XG4gIH0sXG5cbiAgZG91YmxlKHByZWNpc2lvbiwgc2NhbGUpIHtcbiAgICAvLyBpZiAoIXByZWNpc2lvbikgcmV0dXJuICdudW1iZXInOyAvLyBUT0RPOiBDaGVjayBJZiBkZWZhdWx0IGlzIG9rXG4gICAgcmV0dXJuIGBudW1iZXIoJHt0aGlzLl9udW0ocHJlY2lzaW9uLCA4KX0sICR7dGhpcy5fbnVtKHNjYWxlLCAyKX0pYDtcbiAgfSxcblxuICBpbnRlZ2VyKGxlbmd0aCkge1xuICAgIHJldHVybiBsZW5ndGggPyBgbnVtYmVyKCR7dGhpcy5fbnVtKGxlbmd0aCwgMTEpfSlgIDogJ2ludGVnZXInO1xuICB9LFxuXG4gIHRpbnlpbnQ6ICdzbWFsbGludCcsXG5cbiAgc21hbGxpbnQ6ICdzbWFsbGludCcsXG5cbiAgbWVkaXVtaW50OiAnaW50ZWdlcicsXG5cbiAgYmlnaW50ZWdlcjogJ251bWJlcigyMCwgMCknLFxuXG4gIHRleHQ6ICdjbG9iJyxcblxuICBlbnUgKGFsbG93ZWQpIHtcbiAgICBhbGxvd2VkID0gdW5pcShhbGxvd2VkKTtcbiAgICBjb25zdCBtYXhMZW5ndGggPSAoYWxsb3dlZCB8fCBbXSkucmVkdWNlKChtYXhMZW5ndGgsIG5hbWUpID0+XG4gICAgICBNYXRoLm1heChtYXhMZW5ndGgsIFN0cmluZyhuYW1lKS5sZW5ndGgpXG4gICAgLCAxKTtcblxuICAgIC8vIGltcGxpY2l0bHkgYWRkIHRoZSBlbnVtIHZhbHVlcyBhcyBjaGVja2VkIHZhbHVlc1xuICAgIHRoaXMuY29sdW1uQnVpbGRlci5fbW9kaWZpZXJzLmNoZWNrSW4gPSBbYWxsb3dlZF07XG5cbiAgICByZXR1cm4gYHZhcmNoYXIyKCR7bWF4TGVuZ3RofSlgO1xuICB9LFxuXG4gIHRpbWU6ICd0aW1lc3RhbXAgd2l0aCB0aW1lIHpvbmUnLFxuXG4gIGRhdGV0aW1lKHdpdGhvdXQpIHtcbiAgICByZXR1cm4gd2l0aG91dCA/ICd0aW1lc3RhbXAnIDogJ3RpbWVzdGFtcCB3aXRoIHRpbWUgem9uZSc7XG4gIH0sXG5cbiAgdGltZXN0YW1wKHdpdGhvdXQpIHtcbiAgICByZXR1cm4gd2l0aG91dCA/ICd0aW1lc3RhbXAnIDogJ3RpbWVzdGFtcCB3aXRoIHRpbWUgem9uZSc7XG4gIH0sXG5cbiAgYml0OiAnY2xvYicsXG5cbiAganNvbjogJ2Nsb2InLFxuXG4gIGJvb2wgKCkge1xuICAgIC8vIGltcGxpY2l0bHkgYWRkIHRoZSBjaGVjayBmb3IgMCBhbmQgMVxuICAgIHRoaXMuY29sdW1uQnVpbGRlci5fbW9kaWZpZXJzLmNoZWNrSW4gPSBbWzAsIDFdXTtcbiAgICByZXR1cm4gJ251bWJlcigxLCAwKSc7XG4gIH0sXG5cbiAgdmFyY2hhcihsZW5ndGgpIHtcbiAgICByZXR1cm4gYHZhcmNoYXIyKCR7dGhpcy5fbnVtKGxlbmd0aCwgMjU1KX0pYDtcbiAgfSxcblxuICAvLyBNb2RpZmllcnNcbiAgLy8gLS0tLS0tXG5cbiAgY29tbWVudChjb21tZW50KSB7XG4gICAgdGhpcy5wdXNoQWRkaXRpb25hbChmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucHVzaFF1ZXJ5KGBjb21tZW50IG9uIGNvbHVtbiAke3RoaXMudGFibGVDb21waWxlci50YWJsZU5hbWUoKX0uYCArXG4gICAgICAgIHRoaXMuZm9ybWF0dGVyLndyYXAodGhpcy5hcmdzWzBdKSArIFwiIGlzICdcIiArIChjb21tZW50IHx8ICcnKSsgXCInXCIpO1xuICAgIH0sIGNvbW1lbnQpO1xuICB9LFxuXG4gIGNoZWNrSW4gKHZhbHVlKSB7XG4gICAgLy8gVE9ETzogTWF5YmUgYWNjZXB0IGFyZ3VtZW50cyBhbHNvIGFzIGFycmF5XG4gICAgLy8gVE9ETzogdmFsdWUocykgc2hvdWxkIGJlIGVzY2FwZWQgcHJvcGVybHlcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSYXcpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudG9RdWVyeSgpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gbWFwKHZhbHVlLCB2ID0+IGAnJHt2fSdgKS5qb2luKCcsICcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGAnJHt2YWx1ZX0nYDtcbiAgICB9XG4gICAgcmV0dXJuIGBjaGVjayAoJHt0aGlzLmZvcm1hdHRlci53cmFwKHRoaXMuYXJnc1swXSl9IGluICgke3ZhbHVlfSkpYDtcbiAgfVxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQ29sdW1uQ29tcGlsZXJfT3JhY2xlO1xuIl19

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint max-len:0 */

	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _utils = __webpack_require__(116);

	var utils = _interopRequireWildcard(_utils);

	var _schemaTablecompiler = __webpack_require__(80);

	var _schemaTablecompiler2 = _interopRequireDefault(_schemaTablecompiler);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _lodash = __webpack_require__(5);

	// Table Compiler
	// ------

	function TableCompiler_Oracle() {
	  _schemaTablecompiler2['default'].apply(this, arguments);
	}
	_inherits2['default'](TableCompiler_Oracle, _schemaTablecompiler2['default']);

	_lodash.assign(TableCompiler_Oracle.prototype, {

	  // Compile a rename column command.
	  renameColumn: function renameColumn(from, to) {
	    return this.pushQuery({
	      sql: 'alter table ' + this.tableName() + ' rename column ' + this.formatter.wrap(from) + ' to ' + this.formatter.wrap(to)
	    });
	  },

	  compileAdd: function compileAdd(builder) {
	    var table = this.formatter.wrap(builder);
	    var columns = this.prefixArray('add column', this.getColumns(builder));
	    return this.pushQuery({
	      sql: 'alter table ' + table + ' ' + columns.join(', ')
	    });
	  },

	  // Adds the "create" query to the query sequence.
	  createQuery: function createQuery(columns, ifNot) {
	    var sql = 'create table ' + this.tableName() + ' (' + columns.sql.join(', ') + ')';
	    this.pushQuery({
	      // catch "name is already used by an existing object" for workaround for "if not exists"
	      sql: ifNot ? utils.wrapSqlWithCatch(sql, -955) : sql,
	      bindings: columns.bindings
	    });
	    if (this.single.comment) this.comment(this.single.comment);
	  },

	  // Compiles the comment on the table.
	  comment: function comment(_comment) {
	    this.pushQuery('comment on table ' + this.tableName() + ' is \'' + (_comment || '') + '\'');
	  },

	  addColumnsPrefix: 'add ',

	  dropColumn: function dropColumn() {
	    var columns = helpers.normalizeArr.apply(null, arguments);
	    this.pushQuery('alter table ' + this.tableName() + ' drop (' + this.formatter.columnize(columns) + ')');
	  },

	  changeType: function changeType() {
	    // alter table + table + ' modify ' + wrapped + '// type';
	  },

	  _indexCommand: function _indexCommand(type, tableName, columns) {
	    return this.formatter.wrap(utils.generateCombinedName(type, tableName, columns));
	  },

	  primary: function primary(columns, constraintName) {
	    constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(this.tableNameRaw + '_pkey');
	    this.pushQuery('alter table ' + this.tableName() + ' add constraint ' + constraintName + ' primary key (' + this.formatter.columnize(columns) + ')');
	  },

	  dropPrimary: function dropPrimary(constraintName) {
	    constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(this.tableNameRaw + '_pkey');
	    this.pushQuery('alter table ' + this.tableName() + ' drop constraint ' + constraintName);
	  },

	  index: function index(columns, indexName) {
	    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);
	    this.pushQuery('create index ' + indexName + ' on ' + this.tableName() + ' (' + this.formatter.columnize(columns) + ')');
	  },

	  dropIndex: function dropIndex(columns, indexName) {
	    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);
	    this.pushQuery('drop index ' + indexName);
	  },

	  unique: function unique(columns, indexName) {
	    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, columns);
	    this.pushQuery('alter table ' + this.tableName() + ' add constraint ' + indexName + ' unique (' + this.formatter.columnize(columns) + ')');
	  },

	  dropUnique: function dropUnique(columns, indexName) {
	    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, columns);
	    this.pushQuery('alter table ' + this.tableName() + ' drop constraint ' + indexName);
	  },

	  dropForeign: function dropForeign(columns, indexName) {
	    indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('foreign', this.tableNameRaw, columns);
	    this.pushQuery('alter table ' + this.tableName() + ' drop constraint ' + indexName);
	  }

	});

	exports['default'] = TableCompiler_Oracle;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9vcmFjbGUvc2NoZW1hL3RhYmxlY29tcGlsZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozt3QkFFcUIsVUFBVTs7OztxQkFDUixVQUFVOztJQUFyQixLQUFLOzttQ0FDUywrQkFBK0I7Ozs7dUJBQ2hDLGtCQUFrQjs7SUFBL0IsT0FBTzs7c0JBRUksUUFBUTs7Ozs7QUFLL0IsU0FBUyxvQkFBb0IsR0FBRztBQUM5QixtQ0FBYyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0NBQ3RDO0FBQ0Qsc0JBQVMsb0JBQW9CLG1DQUFnQixDQUFDOztBQUU5QyxlQUFPLG9CQUFvQixDQUFDLFNBQVMsRUFBRTs7O0FBR3JDLGNBQVksRUFBQSxzQkFBQyxJQUFJLEVBQUUsRUFBRSxFQUFFO0FBQ3JCLFdBQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztBQUNwQixTQUFHLEVBQUUsaUJBQWUsSUFBSSxDQUFDLFNBQVMsRUFBRSx1QkFDbEMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztLQUMvRCxDQUFDLENBQUM7R0FDSjs7QUFFRCxZQUFVLEVBQUEsb0JBQUMsT0FBTyxFQUFFO0FBQ2xCLFFBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzNDLFFBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztBQUN6RSxXQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7QUFDcEIsU0FBRyxtQkFBaUIsS0FBSyxTQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEFBQUU7S0FDbEQsQ0FBQyxDQUFDO0dBQ0o7OztB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LENBQUMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ25ILFFBQUksQ0FBQyxTQUFTLGtCQUFnQixJQUFJLENBQUMsU0FBUyxFQUFFLHlCQUFvQixTQUFTLENBQUcsQ0FBQztHQUNoRjs7Q0FFRixDQUFDLENBQUE7O3FCQUVhLG9CQUFvQiIsImZpbGUiOiJ0YWJsZWNvbXBpbGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG1heC1sZW46MCAqL1xuXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IFRhYmxlQ29tcGlsZXIgZnJvbSAnLi4vLi4vLi4vc2NoZW1hL3RhYmxlY29tcGlsZXInO1xuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuLi8uLi8uLi9oZWxwZXJzJztcblxuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnbG9kYXNoJ1xuXG4vLyBUYWJsZSBDb21waWxlclxuLy8gLS0tLS0tXG5cbmZ1bmN0aW9uIFRhYmxlQ29tcGlsZXJfT3JhY2xlKCkge1xuICBUYWJsZUNvbXBpbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5pbmhlcml0cyhUYWJsZUNvbXBpbGVyX09yYWNsZSwgVGFibGVDb21waWxlcik7XG5cbmFzc2lnbihUYWJsZUNvbXBpbGVyX09yYWNsZS5wcm90b3R5cGUsIHtcblxuICAvLyBDb21waWxlIGEgcmVuYW1lIGNvbHVtbiBjb21tYW5kLlxuICByZW5hbWVDb2x1bW4oZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gdGhpcy5wdXNoUXVlcnkoe1xuICAgICAgc3FsOiBgYWx0ZXIgdGFibGUgJHt0aGlzLnRhYmxlTmFtZSgpfSByZW5hbWUgY29sdW1uIGAgK1xuICAgICAgICB0aGlzLmZvcm1hdHRlci53cmFwKGZyb20pICsgJyB0byAnICsgdGhpcy5mb3JtYXR0ZXIud3JhcCh0bylcbiAgICB9KTtcbiAgfSxcblxuICBjb21waWxlQWRkKGJ1aWxkZXIpIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMuZm9ybWF0dGVyLndyYXAoYnVpbGRlcik7XG4gICAgY29uc3QgY29sdW1ucyA9IHRoaXMucHJlZml4QXJyYXkoJ2FkZCBjb2x1bW4nLCB0aGlzLmdldENvbHVtbnMoYnVpbGRlcikpO1xuICAgIHJldHVybiB0aGlzLnB1c2hRdWVyeSh7XG4gICAgICBzcWw6IGBhbHRlciB0YWJsZSAke3RhYmxlfSAke2NvbHVtbnMuam9pbignLCAnKX1gXG4gICAgfSk7XG4gIH0sXG5cbiAgLy8gQWRkcyB0aGUgXCJjcmVhdGVcIiBxdWVyeSB0byB0aGUgcXVlcnkgc2VxdWVuY2UuXG4gIGNyZWF0ZVF1ZXJ5KGNvbHVtbnMsIGlmTm90KSB7XG4gICAgY29uc3Qgc3FsID0gYGNyZWF0ZSB0YWJsZSAke3RoaXMudGFibGVOYW1lKCl9ICgke2NvbHVtbnMuc3FsLmpvaW4oJywgJyl9KWA7XG4gICAgdGhpcy5wdXNoUXVlcnkoe1xuICAgICAgLy8gY2F0Y2ggXCJuYW1lIGlzIGFscmVhZHkgdXNlZCBieSBhbiBleGlzdGluZyBvYmplY3RcIiBmb3Igd29ya2Fyb3VuZCBmb3IgXCJpZiBub3QgZXhpc3RzXCJcbiAgICAgIHNxbDogaWZOb3QgPyB1dGlscy53cmFwU3FsV2l0aENhdGNoKHNxbCwgLTk1NSkgOiBzcWwsXG4gICAgICBiaW5kaW5nczogY29sdW1ucy5iaW5kaW5nc1xuICAgIH0pO1xuICAgIGlmICh0aGlzLnNpbmdsZS5jb21tZW50KSB0aGlzLmNvbW1lbnQodGhpcy5zaW5nbGUuY29tbWVudCk7XG4gIH0sXG5cbiAgLy8gQ29tcGlsZXMgdGhlIGNvbW1lbnQgb24gdGhlIHRhYmxlLlxuICBjb21tZW50KGNvbW1lbnQpIHtcbiAgICB0aGlzLnB1c2hRdWVyeShgY29tbWVudCBvbiB0YWJsZSAke3RoaXMudGFibGVOYW1lKCl9IGlzICcke2NvbW1lbnQgfHwgJyd9J2ApO1xuICB9LFxuXG4gIGFkZENvbHVtbnNQcmVmaXg6ICdhZGQgJyxcblxuICBkcm9wQ29sdW1uKCkge1xuICAgIGNvbnN0IGNvbHVtbnMgPSBoZWxwZXJzLm5vcm1hbGl6ZUFyci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIHRoaXMucHVzaFF1ZXJ5KGBhbHRlciB0YWJsZSAke3RoaXMudGFibGVOYW1lKCl9IGRyb3AgKCR7dGhpcy5mb3JtYXR0ZXIuY29sdW1uaXplKGNvbHVtbnMpfSlgKTtcbiAgfSxcblxuICBjaGFuZ2VUeXBlKCkge1xuICAgIC8vIGFsdGVyIHRhYmxlICsgdGFibGUgKyAnIG1vZGlmeSAnICsgd3JhcHBlZCArICcvLyB0eXBlJztcbiAgfSxcblxuICBfaW5kZXhDb21tYW5kKHR5cGUsIHRhYmxlTmFtZSwgY29sdW1ucykge1xuICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci53cmFwKHV0aWxzLmdlbmVyYXRlQ29tYmluZWROYW1lKHR5cGUsIHRhYmxlTmFtZSwgY29sdW1ucykpO1xuICB9LFxuXG4gIHByaW1hcnkoY29sdW1ucywgY29uc3RyYWludE5hbWUpIHtcbiAgICBjb25zdHJhaW50TmFtZSA9IGNvbnN0cmFpbnROYW1lID8gdGhpcy5mb3JtYXR0ZXIud3JhcChjb25zdHJhaW50TmFtZSkgOiB0aGlzLmZvcm1hdHRlci53cmFwKGAke3RoaXMudGFibGVOYW1lUmF3fV9wa2V5YCk7XG4gICAgdGhpcy5wdXNoUXVlcnkoYGFsdGVyIHRhYmxlICR7dGhpcy50YWJsZU5hbWUoKX0gYWRkIGNvbnN0cmFpbnQgJHtjb25zdHJhaW50TmFtZX0gcHJpbWFyeSBrZXkgKCR7dGhpcy5mb3JtYXR0ZXIuY29sdW1uaXplKGNvbHVtbnMpfSlgKTtcbiAgfSxcblxuICBkcm9wUHJpbWFyeShjb25zdHJhaW50TmFtZSkge1xuICAgIGNvbnN0cmFpbnROYW1lID0gY29uc3RyYWludE5hbWUgPyB0aGlzLmZvcm1hdHRlci53cmFwKGNvbnN0cmFpbnROYW1lKSA6IHRoaXMuZm9ybWF0dGVyLndyYXAodGhpcy50YWJsZU5hbWVSYXcgKyAnX3BrZXknKTtcbiAgICB0aGlzLnB1c2hRdWVyeShgYWx0ZXIgdGFibGUgJHt0aGlzLnRhYmxlTmFtZSgpfSBkcm9wIGNvbnN0cmFpbnQgJHtjb25zdHJhaW50TmFtZX1gKTtcbiAgfSxcblxuICBpbmRleChjb2x1bW5zLCBpbmRleE5hbWUpIHtcbiAgICBpbmRleE5hbWUgPSBpbmRleE5hbWUgPyB0aGlzLmZvcm1hdHRlci53cmFwKGluZGV4TmFtZSkgOiB0aGlzLl9pbmRleENvbW1hbmQoJ2luZGV4JywgdGhpcy50YWJsZU5hbWVSYXcsIGNvbHVtbnMpO1xuICAgIHRoaXMucHVzaFF1ZXJ5KGBjcmVhdGUgaW5kZXggJHtpbmRleE5hbWV9IG9uICR7dGhpcy50YWJsZU5hbWUoKX1gICtcbiAgICAgICcgKCcgKyB0aGlzLmZvcm1hdHRlci5jb2x1bW5pemUoY29sdW1ucykgKyAnKScpO1xuICB9LFxuXG4gIGRyb3BJbmRleChjb2x1bW5zLCBpbmRleE5hbWUpIHtcbiAgICBpbmRleE5hbWUgPSBpbmRleE5hbWUgPyB0aGlzLmZvcm1hdHRlci53cmFwKGluZGV4TmFtZSkgOiB0aGlzLl9pbmRleENvbW1hbmQoJ2luZGV4JywgdGhpcy50YWJsZU5hbWVSYXcsIGNvbHVtbnMpO1xuICAgIHRoaXMucHVzaFF1ZXJ5KGBkcm9wIGluZGV4ICR7aW5kZXhOYW1lfWApO1xuICB9LFxuXG4gIHVuaXF1ZShjb2x1bW5zLCBpbmRleE5hbWUpIHtcbiAgICBpbmRleE5hbWUgPSBpbmRleE5hbWUgPyB0aGlzLmZvcm1hdHRlci53cmFwKGluZGV4TmFtZSkgOiB0aGlzLl9pbmRleENvbW1hbmQoJ3VuaXF1ZScsIHRoaXMudGFibGVOYW1lUmF3LCBjb2x1bW5zKTtcbiAgICB0aGlzLnB1c2hRdWVyeShgYWx0ZXIgdGFibGUgJHt0aGlzLnRhYmxlTmFtZSgpfSBhZGQgY29uc3RyYWludCAke2luZGV4TmFtZX1gICtcbiAgICAgICcgdW5pcXVlICgnICsgdGhpcy5mb3JtYXR0ZXIuY29sdW1uaXplKGNvbHVtbnMpICsgJyknKTtcbiAgfSxcblxuICBkcm9wVW5pcXVlKGNvbHVtbnMsIGluZGV4TmFtZSkge1xuICAgIGluZGV4TmFtZSA9IGluZGV4TmFtZSA/IHRoaXMuZm9ybWF0dGVyLndyYXAoaW5kZXhOYW1lKSA6IHRoaXMuX2luZGV4Q29tbWFuZCgndW5pcXVlJywgdGhpcy50YWJsZU5hbWVSYXcsIGNvbHVtbnMpO1xuICAgIHRoaXMucHVzaFF1ZXJ5KGBhbHRlciB0YWJsZSAke3RoaXMudGFibGVOYW1lKCl9IGRyb3AgY29uc3RyYWludCAke2luZGV4TmFtZX1gKTtcbiAgfSxcblxuICBkcm9wRm9yZWlnbihjb2x1bW5zLCBpbmRleE5hbWUpIHtcbiAgICBpbmRleE5hbWUgPSBpbmRleE5hbWUgPyB0aGlzLmZvcm1hdHRlci53cmFwKGluZGV4TmFtZSkgOiB0aGlzLl9pbmRleENvbW1hbmQoJ2ZvcmVpZ24nLCB0aGlzLnRhYmxlTmFtZVJhdywgY29sdW1ucyk7XG4gICAgdGhpcy5wdXNoUXVlcnkoYGFsdGVyIHRhYmxlICR7dGhpcy50YWJsZU5hbWUoKX0gZHJvcCBjb25zdHJhaW50ICR7aW5kZXhOYW1lfWApO1xuICB9XG5cbn0pXG5cbmV4cG9ydCBkZWZhdWx0IFRhYmxlQ29tcGlsZXJfT3JhY2xlO1xuIl19

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {
	/*jslint node:true, nomen: true*/
	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _stream = __webpack_require__(49);

	var _lodash = __webpack_require__(5);

	function OracleQueryStream(connection, sql, bindings, options) {
	  _stream.Readable.call(this, _lodash.merge({}, {
	    objectMode: true,
	    highWaterMark: 1000
	  }, options));
	  this.oracleReader = connection.reader(sql, bindings || []);
	}
	_inherits2['default'](OracleQueryStream, _stream.Readable);

	OracleQueryStream.prototype._read = function () {
	  var _this = this;

	  var pushNull = function pushNull() {
	    process.nextTick(function () {
	      _this.push(null);
	    });
	  };
	  try {
	    this.oracleReader.nextRows(function (err, rows) {
	      if (err) return _this.emit('error', err);
	      if (rows.length === 0) {
	        pushNull();
	      } else {
	        for (var i = 0; i < rows.length; i++) {
	          if (rows[i]) {
	            _this.push(rows[i]);
	          } else {
	            pushNull();
	          }
	        }
	      }
	    });
	  } catch (e) {
	    // Catch Error: invalid state: reader is busy with another nextRows call
	    // and return false to rate limit stream.
	    if (e.message === 'invalid state: reader is busy with another nextRows call') {
	      return false;
	    } else {
	      this.emit('error', e);
	    }
	  }
	};

	exports['default'] = OracleQueryStream;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy9vcmFjbGUvc3RyZWFtLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O3dCQUVxQixVQUFVOzs7O3NCQUNOLFFBQVE7O3NCQUVYLFFBQVE7O0FBRTlCLFNBQVMsaUJBQWlCLENBQUMsVUFBVSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFO0FBQzdELG1CQUFTLElBQUksQ0FBQyxJQUFJLEVBQUUsY0FBTSxFQUFFLEVBQUU7QUFDNUIsY0FBVSxFQUFFLElBQUk7QUFDaEIsaUJBQWEsRUFBRSxJQUFJO0dBQ3BCLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQTtBQUNaLE1BQUksQ0FBQyxZQUFZLEdBQUcsVUFBVSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsUUFBUSxJQUFJLEVBQUUsQ0FBQyxDQUFBO0NBQzNEO0FBQ0Qsc0JBQVMsaUJBQWlCLG1CQUFXLENBQUE7O0FBRXJDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsWUFBVzs7O0FBQzdDLE1BQU0sUUFBUSxHQUFHLFNBQVgsUUFBUSxHQUFTO0FBQ3JCLFdBQU8sQ0FBQyxRQUFRLENBQUMsWUFBTTtBQUNyQixZQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTtLQUNoQixDQUFDLENBQUE7R0FDSCxDQUFBO0FBQ0QsTUFBSTtBQUNGLFFBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLFVBQUMsR0FBRyxFQUFFLElBQUksRUFBSztBQUN4QyxVQUFJLEdBQUcsRUFBRSxPQUFPLE1BQUssSUFBSSxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQTtBQUN2QyxVQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO0FBQ3JCLGdCQUFRLEVBQUUsQ0FBQTtPQUNYLE1BQU07QUFDTCxhQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUNwQyxjQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRTtBQUNYLGtCQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtXQUNuQixNQUFNO0FBQ0wsb0JBQVEsRUFBRSxDQUFBO1dBQ1g7U0FDRjtPQUNGO0tBQ0YsQ0FBQyxDQUFBO0dBQ0gsQ0FBQyxPQUFPLENBQUMsRUFBRTs7O0FBR1YsUUFBSSxDQUFDLENBQUMsT0FBTyxLQUNYLDBEQUEwRCxFQUFFO0FBQzVELGFBQU8sS0FBSyxDQUFBO0tBQ2IsTUFBTTtBQUNMLFVBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFBO0tBQ3RCO0dBQ0Y7Q0FDRixDQUFBOztxQkFFYyxpQkFBaUIiLCJmaWxlIjoic3RyZWFtLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKmpzbGludCBub2RlOnRydWUsIG5vbWVuOiB0cnVlKi9cbmltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5pbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gJ3N0cmVhbSc7XG5cbmltcG9ydCB7IG1lcmdlIH0gZnJvbSAnbG9kYXNoJ1xuXG5mdW5jdGlvbiBPcmFjbGVRdWVyeVN0cmVhbShjb25uZWN0aW9uLCBzcWwsIGJpbmRpbmdzLCBvcHRpb25zKSB7XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgbWVyZ2Uoe30sIHtcbiAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgIGhpZ2hXYXRlck1hcms6IDEwMDBcbiAgfSwgb3B0aW9ucykpXG4gIHRoaXMub3JhY2xlUmVhZGVyID0gY29ubmVjdGlvbi5yZWFkZXIoc3FsLCBiaW5kaW5ncyB8fCBbXSlcbn1cbmluaGVyaXRzKE9yYWNsZVF1ZXJ5U3RyZWFtLCBSZWFkYWJsZSlcblxuT3JhY2xlUXVlcnlTdHJlYW0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHB1c2hOdWxsID0gKCkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgdGhpcy5wdXNoKG51bGwpXG4gICAgfSlcbiAgfVxuICB0cnkge1xuICAgIHRoaXMub3JhY2xlUmVhZGVyLm5leHRSb3dzKChlcnIsIHJvd3MpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgaWYgKHJvd3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHB1c2hOdWxsKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChyb3dzW2ldKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2gocm93c1tpXSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHVzaE51bGwoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBDYXRjaCBFcnJvcjogaW52YWxpZCBzdGF0ZTogcmVhZGVyIGlzIGJ1c3kgd2l0aCBhbm90aGVyIG5leHRSb3dzIGNhbGxcbiAgICAvLyBhbmQgcmV0dXJuIGZhbHNlIHRvIHJhdGUgbGltaXQgc3RyZWFtLlxuICAgIGlmIChlLm1lc3NhZ2UgPT09XG4gICAgICAnaW52YWxpZCBzdGF0ZTogcmVhZGVyIGlzIGJ1c3kgd2l0aCBhbm90aGVyIG5leHRSb3dzIGNhbGwnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGUpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE9yYWNsZVF1ZXJ5U3RyZWFtXG4iXX0=
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 124 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {
	// PostgreSQL
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _lodash = __webpack_require__(5);

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _client = __webpack_require__(42);

	var _client2 = _interopRequireDefault(_client);

	var _promise = __webpack_require__(43);

	var _promise2 = _interopRequireDefault(_promise);

	var _utils = __webpack_require__(126);

	var utils = _interopRequireWildcard(_utils);

	var _queryCompiler = __webpack_require__(127);

	var _queryCompiler2 = _interopRequireDefault(_queryCompiler);

	var _schemaColumncompiler = __webpack_require__(128);

	var _schemaColumncompiler2 = _interopRequireDefault(_schemaColumncompiler);

	var _schemaTablecompiler = __webpack_require__(129);

	var _schemaTablecompiler2 = _interopRequireDefault(_schemaTablecompiler);

	var _schemaCompiler = __webpack_require__(130);

	var _schemaCompiler2 = _interopRequireDefault(_schemaCompiler);

	function Client_PG(config) {
	  _client2['default'].apply(this, arguments);
	  if (config.returning) {
	    this.defaultReturning = config.returning;
	  }

	  if (config.searchPath) {
	    this.searchPath = config.searchPath;
	  }
	}
	_inherits2['default'](Client_PG, _client2['default']);

	_lodash.assign(Client_PG.prototype, {

	  QueryCompiler: _queryCompiler2['default'],

	  ColumnCompiler: _schemaColumncompiler2['default'],

	  SchemaCompiler: _schemaCompiler2['default'],

	  TableCompiler: _schemaTablecompiler2['default'],

	  dialect: 'postgresql',

	  driverName: 'pg',

	  _driver: function _driver() {
	    return __webpack_require__(131);
	  },

	  wrapIdentifier: function wrapIdentifier(value) {
	    if (value === '*') return value;
	    var matched = value.match(/(.*?)(\[[0-9]\])/);
	    if (matched) return this.wrapIdentifier(matched[1]) + matched[2];
	    return '"' + value.replace(/"/g, '""') + '"';
	  },

	  // Prep the bindings as needed by PostgreSQL.
	  prepBindings: function prepBindings(bindings, tz) {
	    var _this = this;

	    return _lodash.map(bindings, function (binding) {
	      return utils.prepareValue(binding, tz, _this.valueForUndefined);
	    });
	  },

	  // Get a raw connection, called by the `pool` whenever a new
	  // connection needs to be added to the pool.
	  acquireRawConnection: function acquireRawConnection() {
	    var client = this;
	    return new _promise2['default'](function (resolver, rejecter) {
	      var connection = new client.driver.Client(client.connectionSettings);
	      connection.connect(function (err, connection) {
	        if (err) return rejecter(err);
	        connection.on('error', client.__endConnection.bind(client, connection));
	        connection.on('end', client.__endConnection.bind(client, connection));
	        if (!client.version) {
	          return client.checkVersion(connection).then(function (version) {
	            client.version = version;
	            resolver(connection);
	          });
	        }
	        resolver(connection);
	      });
	    }).tap(function setSearchPath(connection) {
	      return client.setSchemaSearchPath(connection);
	    });
	  },

	  // Used to explicitly close a connection, called internally by the pool
	  // when a connection times out or the pool is shutdown.
	  destroyRawConnection: function destroyRawConnection(connection, cb) {
	    connection.end();
	    cb();
	  },

	  // In PostgreSQL, we need to do a version check to do some feature
	  // checking on the database.
	  checkVersion: function checkVersion(connection) {
	    return new _promise2['default'](function (resolver, rejecter) {
	      connection.query('select version();', function (err, resp) {
	        if (err) return rejecter(err);
	        resolver(/^PostgreSQL (.*?)( |$)/.exec(resp.rows[0].version)[1]);
	      });
	    });
	  },

	  // Position the bindings for the query. The escape sequence for question mark
	  // is \? (e.g. knex.raw("\\?") since javascript requires '\' to be escaped too...)
	  positionBindings: function positionBindings(sql) {
	    var questionCount = 0;
	    return sql.replace(/(\\*)(\?)/g, function (match, escapes) {
	      if (escapes.length % 2) {
	        return '?';
	      } else {
	        questionCount++;
	        return '$' + questionCount;
	      }
	    });
	  },

	  setSchemaSearchPath: function setSchemaSearchPath(connection, searchPath) {
	    var path = searchPath || this.searchPath;

	    if (!path) return _promise2['default'].resolve(true);

	    return new _promise2['default'](function (resolver, rejecter) {
	      connection.query('set search_path to ' + path, function (err) {
	        if (err) return rejecter(err);
	        resolver(true);
	      });
	    });
	  },

	  _stream: function _stream(connection, obj, stream, options) {
	    var PGQueryStream = process.browser ? undefined : __webpack_require__(132);
	    var sql = obj.sql = this.positionBindings(obj.sql);
	    return new _promise2['default'](function (resolver, rejecter) {
	      var queryStream = connection.query(new PGQueryStream(sql, obj.bindings, options));
	      queryStream.on('error', rejecter);
	      // 'error' is not propagated by .pipe, but it breaks the pipe
	      stream.on('error', rejecter);
	      // 'end' IS propagated by .pipe, by default
	      stream.on('end', resolver);
	      queryStream.pipe(stream);
	    });
	  },

	  // Runs the query on the specified connection, providing the bindings
	  // and any other necessary prep work.
	  _query: function _query(connection, obj) {
	    var sql = obj.sql = this.positionBindings(obj.sql);
	    if (obj.options) sql = _lodash.extend({ text: sql }, obj.options);
	    return new _promise2['default'](function (resolver, rejecter) {
	      connection.query(sql, obj.bindings, function (err, response) {
	        if (err) return rejecter(err);
	        obj.response = response;
	        resolver(obj);
	      });
	    });
	  },

	  // Ensures the response is returned in the same format as other clients.
	  processResponse: function processResponse(obj, runner) {
	    var resp = obj.response;
	    if (obj.output) return obj.output.call(runner, resp);
	    if (obj.method === 'raw') return resp;
	    var returning = obj.returning;

	    if (resp.command === 'SELECT') {
	      if (obj.method === 'first') return resp.rows[0];
	      if (obj.method === 'pluck') return _lodash.map(resp.rows, obj.pluck);
	      return resp.rows;
	    }
	    if (returning) {
	      var returns = [];
	      for (var i = 0, l = resp.rows.length; i < l; i++) {
	        var row = resp.rows[i];
	        if (returning === '*' || Array.isArray(returning)) {
	          returns[i] = row;
	        } else {
	          returns[i] = row[returning];
	        }
	      }
	      return returns;
	    }
	    if (resp.command === 'UPDATE' || resp.command === 'DELETE') {
	      return resp.rowCount;
	    }
	    return resp;
	  },

	  __endConnection: function __endConnection(connection) {
	    if (!connection || connection.__knex__disposed) return;
	    if (this.pool) {
	      connection.__knex__disposed = true;
	      this.pool.destroy(connection);
	    }
	  },

	  ping: function ping(resource, callback) {
	    resource.query('SELECT 1', [], callback);
	  }

	});

	exports['default'] = Client_PG;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy9wb3N0Z3Jlcy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztzQkFHb0MsUUFBUTs7d0JBQ3ZCLFVBQVU7Ozs7c0JBQ1osY0FBYzs7Ozt1QkFDYixlQUFlOzs7O3FCQUNaLFNBQVM7O0lBQXBCLEtBQUs7OzZCQUVTLGtCQUFrQjs7OztvQ0FDakIseUJBQXlCOzs7O21DQUMxQix3QkFBd0I7Ozs7OEJBQ3ZCLG1CQUFtQjs7OztBQUU5QyxTQUFTLFNBQVMsQ0FBQyxNQUFNLEVBQUU7QUFDekIsc0JBQU8sS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQTtBQUM3QixNQUFJLE1BQU0sQ0FBQyxTQUFTLEVBQUU7QUFDcEIsUUFBSSxDQUFDLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7R0FDMUM7O0FBRUQsTUFBSSxNQUFNLENBQUMsVUFBVSxFQUFFO0FBQ3JCLFFBQUksQ0FBQyxVQUFVLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQztHQUNyQztDQUNGO0FBQ0Qsc0JBQVMsU0FBUyxzQkFBUyxDQUFBOztBQUUzQixlQUFPLFNBQVMsQ0FBQyxTQUFTLEVBQUU7O0FBRTFCLGVBQWEsNEJBQUE7O0FBRWIsZ0JBQWMsbUNBQUE7O0FBRWQsZ0JBQWMsNkJBQUE7O0FBRWQsZUFBYSxrQ0FBQTs7QUFFYixTQUFPLEVBQUUsWUFBWTs7QUFFckIsWUFBVSxFQUFFLElBQUk7O0FBRWhCLFNBQU8sRUFBQSxtQkFBRztBQUNSLFdBQU8sT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFBO0dBQ3JCOztBQUVELGdCQUFjLEVBQUEsd0JBQUMsS0FBSyxFQUFFO0FBQ3BCLFFBQUksS0FBSyxLQUFLLEdBQUcsRUFBRSxPQUFPLEtBQUssQ0FBQztBQUNoQyxRQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDaEQsUUFBSSxPQUFPLEVBQUUsT0FBTyxJ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QVUsQ0FBQyxnQkFBZ0IsRUFBRSxPQUFPO0FBQ3ZELFFBQUksSUFBSSxDQUFDLElBQUksRUFBRTtBQUNiLGdCQUFVLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDO0FBQ25DLFVBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0tBQy9CO0dBQ0Y7O0FBRUQsTUFBSSxFQUFBLGNBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRTtBQUN2QixZQUFRLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7R0FDMUM7O0NBR0YsQ0FBQyxDQUFBOztxQkFFYSxTQUFTIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBQb3N0Z3JlU1FMXG4vLyAtLS0tLS0tXG5pbXBvcnQgeyBhc3NpZ24sIG1hcCwgZXh0ZW5kIH0gZnJvbSAnbG9kYXNoJ1xuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcbmltcG9ydCBDbGllbnQgZnJvbSAnLi4vLi4vY2xpZW50JztcbmltcG9ydCBQcm9taXNlIGZyb20gJy4uLy4uL3Byb21pc2UnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscyc7XG5cbmltcG9ydCBRdWVyeUNvbXBpbGVyIGZyb20gJy4vcXVlcnkvY29tcGlsZXInO1xuaW1wb3J0IENvbHVtbkNvbXBpbGVyIGZyb20gJy4vc2NoZW1hL2NvbHVtbmNvbXBpbGVyJztcbmltcG9ydCBUYWJsZUNvbXBpbGVyIGZyb20gJy4vc2NoZW1hL3RhYmxlY29tcGlsZXInO1xuaW1wb3J0IFNjaGVtYUNvbXBpbGVyIGZyb20gJy4vc2NoZW1hL2NvbXBpbGVyJztcblxuZnVuY3Rpb24gQ2xpZW50X1BHKGNvbmZpZykge1xuICBDbGllbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICBpZiAoY29uZmlnLnJldHVybmluZykge1xuICAgIHRoaXMuZGVmYXVsdFJldHVybmluZyA9IGNvbmZpZy5yZXR1cm5pbmc7XG4gIH1cblxuICBpZiAoY29uZmlnLnNlYXJjaFBhdGgpIHtcbiAgICB0aGlzLnNlYXJjaFBhdGggPSBjb25maWcuc2VhcmNoUGF0aDtcbiAgfVxufVxuaW5oZXJpdHMoQ2xpZW50X1BHLCBDbGllbnQpXG5cbmFzc2lnbihDbGllbnRfUEcucHJvdG90eXBlLCB7XG5cbiAgUXVlcnlDb21waWxlcixcblxuICBDb2x1bW5Db21waWxlcixcblxuICBTY2hlbWFDb21waWxlcixcblxuICBUYWJsZUNvbXBpbGVyLFxuXG4gIGRpYWxlY3Q6ICdwb3N0Z3Jlc3FsJyxcblxuICBkcml2ZXJOYW1lOiAncGcnLFxuXG4gIF9kcml2ZXIoKSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ3BnJylcbiAgfSxcblxuICB3cmFwSWRlbnRpZmllcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gJyonKSByZXR1cm4gdmFsdWU7XG4gICAgY29uc3QgbWF0Y2hlZCA9IHZhbHVlLm1hdGNoKC8oLio/KShcXFtbMC05XVxcXSkvKTtcbiAgICBpZiAobWF0Y2hlZCkgcmV0dXJuIHRoaXMud3JhcElkZW50aWZpZXIobWF0Y2hlZFsxXSkgKyBtYXRjaGVkWzJdO1xuICAgIHJldHVybiBgXCIke3ZhbHVlLnJlcGxhY2UoL1wiL2csICdcIlwiJyl9XCJgO1xuICB9LFxuXG4gIC8vIFByZXAgdGhlIGJpbmRpbmdzIGFzIG5lZWRlZCBieSBQb3N0Z3JlU1FMLlxuICBwcmVwQmluZGluZ3MoYmluZGluZ3MsIHR6KSB7XG4gICAgcmV0dXJuIG1hcChiaW5kaW5ncywgKGJpbmRpbmcpID0+IHtcbiAgICAgIHJldHVybiB1dGlscy5wcmVwYXJlVmFsdWUoYmluZGluZywgdHosIHRoaXMudmFsdWVGb3JVbmRlZmluZWQpXG4gICAgfSk7XG4gIH0sXG5cbiAgLy8gR2V0IGEgcmF3IGNvbm5lY3Rpb24sIGNhbGxlZCBieSB0aGUgYHBvb2xgIHdoZW5ldmVyIGEgbmV3XG4gIC8vIGNvbm5lY3Rpb24gbmVlZHMgdG8gYmUgYWRkZWQgdG8gdGhlIHBvb2wuXG4gIGFjcXVpcmVSYXdDb25uZWN0aW9uKCkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmVyLCByZWplY3Rlcikge1xuICAgICAgY29uc3QgY29ubmVjdGlvbiA9IG5ldyBjbGllbnQuZHJpdmVyLkNsaWVudChjbGllbnQuY29ubmVjdGlvblNldHRpbmdzKTtcbiAgICAgIGNvbm5lY3Rpb24uY29ubmVjdChmdW5jdGlvbihlcnIsIGNvbm5lY3Rpb24pIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdGVyKGVycik7XG4gICAgICAgIGNvbm5lY3Rpb24ub24oJ2Vycm9yJywgY2xpZW50Ll9fZW5kQ29ubmVjdGlvbi5iaW5kKGNsaWVudCwgY29ubmVjdGlvbikpO1xuICAgICAgICBjb25uZWN0aW9uLm9uKCdlbmQnLCBjbGllbnQuX19lbmRDb25uZWN0aW9uLmJpbmQoY2xpZW50LCBjb25uZWN0aW9uKSk7XG4gICAgICAgIGlmICghY2xpZW50LnZlcnNpb24pIHtcbiAgICAgICAgICByZXR1cm4gY2xpZW50LmNoZWNrVmVyc2lvbihjb25uZWN0aW9uKS50aGVuKGZ1bmN0aW9uKHZlcnNpb24pIHtcbiAgICAgICAgICAgIGNsaWVudC52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgIHJlc29sdmVyKGNvbm5lY3Rpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmVyKGNvbm5lY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfSkudGFwKGZ1bmN0aW9uIHNldFNlYXJjaFBhdGgoY29ubmVjdGlvbikge1xuICAgICAgcmV0dXJuIGNsaWVudC5zZXRTY2hlbWFTZWFyY2hQYXRoKGNvbm5lY3Rpb24pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8vIFVzZWQgdG8gZXhwbGljaXRseSBjbG9zZSBhIGNvbm5lY3Rpb24sIGNhbGxlZCBpbnRlcm5hbGx5IGJ5IHRoZSBwb29sXG4gIC8vIHdoZW4gYSBjb25uZWN0aW9uIHRpbWVzIG91dCBvciB0aGUgcG9vbCBpcyBzaHV0ZG93bi5cbiAgZGVzdHJveVJhd0Nvbm5lY3Rpb24oY29ubmVjdGlvbiwgY2IpIHtcbiAgICBjb25uZWN0aW9uLmVuZCgpXG4gICAgY2IoKVxuICB9LFxuXG4gIC8vIEluIFBvc3RncmVTUUwsIHdlIG5lZWQgdG8gZG8gYSB2ZXJzaW9uIGNoZWNrIHRvIGRvIHNvbWUgZmVhdHVyZVxuICAvLyBjaGVja2luZyBvbiB0aGUgZGF0YWJhc2UuXG4gIGNoZWNrVmVyc2lvbihjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmVyLCByZWplY3Rlcikge1xuICAgICAgY29ubmVjdGlvbi5xdWVyeSgnc2VsZWN0IHZlcnNpb24oKTsnLCBmdW5jdGlvbihlcnIsIHJlc3ApIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdGVyKGVycik7XG4gICAgICAgIHJlc29sdmVyKC9eUG9zdGdyZVNRTCAoLio/KSggfCQpLy5leGVjKHJlc3Aucm93c1swXS52ZXJzaW9uKVsxXSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICAvLyBQb3NpdGlvbiB0aGUgYmluZGluZ3MgZm9yIHRoZSBxdWVyeS4gVGhlIGVzY2FwZSBzZXF1ZW5jZSBmb3IgcXVlc3Rpb24gbWFya1xuICAvLyBpcyBcXD8gKGUuZy4ga25leC5yYXcoXCJcXFxcP1wiKSBzaW5jZSBqYXZhc2NyaXB0IHJlcXVpcmVzICdcXCcgdG8gYmUgZXNjYXBlZCB0b28uLi4pXG4gIHBvc2l0aW9uQmluZGluZ3Moc3FsKSB7XG4gICAgbGV0IHF1ZXN0aW9uQ291bnQgPSAwO1xuICAgIHJldHVybiBzcWwucmVwbGFjZSgvKFxcXFwqKShcXD8pL2csIGZ1bmN0aW9uIChtYXRjaCwgZXNjYXBlcykge1xuICAgICAgaWYgKGVzY2FwZXMubGVuZ3RoICUgMikge1xuICAgICAgICByZXR1cm4gJz8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlc3Rpb25Db3VudCsrO1xuICAgICAgICByZXR1cm4gYCQke3F1ZXN0aW9uQ291bnR9YDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBzZXRTY2hlbWFTZWFyY2hQYXRoKGNvbm5lY3Rpb24sIHNlYXJjaFBhdGgpIHtcbiAgICBjb25zdCBwYXRoID0gKHNlYXJjaFBhdGggfHwgdGhpcy5zZWFyY2hQYXRoKTtcblxuICAgIGlmICghcGF0aCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlciwgcmVqZWN0ZXIpIHtcbiAgICAgIGNvbm5lY3Rpb24ucXVlcnkoYHNldCBzZWFyY2hfcGF0aCB0byAke3BhdGh9YCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3RlcihlcnIpO1xuICAgICAgICByZXNvbHZlcih0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIF9zdHJlYW0oY29ubmVjdGlvbiwgb2JqLCBzdHJlYW0sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBQR1F1ZXJ5U3RyZWFtID0gcHJvY2Vzcy5icm93c2VyID8gdW5kZWZpbmVkIDogcmVxdWlyZSgncGctcXVlcnktc3RyZWFtJyk7XG4gICAgY29uc3Qgc3FsID0gb2JqLnNxbCA9IHRoaXMucG9zaXRpb25CaW5kaW5ncyhvYmouc3FsKVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlciwgcmVqZWN0ZXIpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5U3RyZWFtID0gY29ubmVjdGlvbi5xdWVyeShuZXcgUEdRdWVyeVN0cmVhbShzcWwsIG9iai5iaW5kaW5ncywgb3B0aW9ucykpO1xuICAgICAgcXVlcnlTdHJlYW0ub24oJ2Vycm9yJywgcmVqZWN0ZXIpO1xuICAgICAgLy8gJ2Vycm9yJyBpcyBub3QgcHJvcGFnYXRlZCBieSAucGlwZSwgYnV0IGl0IGJyZWFrcyB0aGUgcGlwZVxuICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIHJlamVjdGVyKTtcbiAgICAgIC8vICdlbmQnIElTIHByb3BhZ2F0ZWQgYnkgLnBpcGUsIGJ5IGRlZmF1bHRcbiAgICAgIHN0cmVhbS5vbignZW5kJywgcmVzb2x2ZXIpO1xuICAgICAgcXVlcnlTdHJlYW0ucGlwZShzdHJlYW0pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8vIFJ1bnMgdGhlIHF1ZXJ5IG9uIHRoZSBzcGVjaWZpZWQgY29ubmVjdGlvbiwgcHJvdmlkaW5nIHRoZSBiaW5kaW5nc1xuICAvLyBhbmQgYW55IG90aGVyIG5lY2Vzc2FyeSBwcmVwIHdvcmsuXG4gIF9xdWVyeShjb25uZWN0aW9uLCBvYmopIHtcbiAgICBsZXQgc3FsID0gb2JqLnNxbCA9IHRoaXMucG9zaXRpb25CaW5kaW5ncyhvYmouc3FsKVxuICAgIGlmIChvYmoub3B0aW9ucykgc3FsID0gZXh0ZW5kKHt0ZXh0OiBzcWx9LCBvYmoub3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmVyLCByZWplY3Rlcikge1xuICAgICAgY29ubmVjdGlvbi5xdWVyeShzcWwsIG9iai5iaW5kaW5ncywgZnVuY3Rpb24oZXJyLCByZXNwb25zZSkge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0ZXIoZXJyKTtcbiAgICAgICAgb2JqLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHJlc29sdmVyKG9iaik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICAvLyBFbnN1cmVzIHRoZSByZXNwb25zZSBpcyByZXR1cm5lZCBpbiB0aGUgc2FtZSBmb3JtYXQgYXMgb3RoZXIgY2xpZW50cy5cbiAgcHJvY2Vzc1Jlc3BvbnNlKG9iaiwgcnVubmVyKSB7XG4gICAgY29uc3QgcmVzcCA9IG9iai5yZXNwb25zZTtcbiAgICBpZiAob2JqLm91dHB1dCkgcmV0dXJuIG9iai5vdXRwdXQuY2FsbChydW5uZXIsIHJlc3ApO1xuICAgIGlmIChvYmoubWV0aG9kID09PSAncmF3JykgcmV0dXJuIHJlc3A7XG4gICAgY29uc3QgeyByZXR1cm5pbmcgfSA9IG9iajtcbiAgICBpZiAocmVzcC5jb21tYW5kID09PSAnU0VMRUNUJykge1xuICAgICAgaWYgKG9iai5tZXRob2QgPT09ICdmaXJzdCcpIHJldHVybiByZXNwLnJvd3NbMF07XG4gICAgICBpZiAob2JqLm1ldGhvZCA9PT0gJ3BsdWNrJykgcmV0dXJuIG1hcChyZXNwLnJvd3MsIG9iai5wbHVjayk7XG4gICAgICByZXR1cm4gcmVzcC5yb3dzO1xuICAgIH1cbiAgICBpZiAocmV0dXJuaW5nKSB7XG4gICAgICBjb25zdCByZXR1cm5zID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHJlc3Aucm93cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3Qgcm93ID0gcmVzcC5yb3dzW2ldO1xuICAgICAgICBpZiAocmV0dXJuaW5nID09PSAnKicgfHwgQXJyYXkuaXNBcnJheShyZXR1cm5pbmcpKSB7XG4gICAgICAgICAgcmV0dXJuc1tpXSA9IHJvdztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm5zW2ldID0gcm93W3JldHVybmluZ107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXR1cm5zO1xuICAgIH1cbiAgICBpZiAocmVzcC5jb21tYW5kID09PSAnVVBEQVRFJyB8fCByZXNwLmNvbW1hbmQgPT09ICdERUxFVEUnKSB7XG4gICAgICByZXR1cm4gcmVzcC5yb3dDb3VudDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3A7XG4gIH0sXG5cbiAgX19lbmRDb25uZWN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICBpZiAoIWNvbm5lY3Rpb24gfHwgY29ubmVjdGlvbi5fX2tuZXhfX2Rpc3Bvc2VkKSByZXR1cm47XG4gICAgaWYgKHRoaXMucG9vbCkge1xuICAgICAgY29ubmVjdGlvbi5fX2tuZXhfX2Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMucG9vbC5kZXN0cm95KGNvbm5lY3Rpb24pO1xuICAgIH1cbiAgfSxcblxuICBwaW5nKHJlc291cmNlLCBjYWxsYmFjaykge1xuICAgIHJlc291cmNlLnF1ZXJ5KCdTRUxFQ1QgMScsIFtdLCBjYWxsYmFjayk7XG4gIH1cblxuXG59KVxuXG5leHBvcnQgZGVmYXVsdCBDbGllbnRfUEdcbiJdfQ==
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	exports.__esModule = true;

	function dateToString(date) {
	  function pad(number, digits) {
	    number = number.toString();
	    while (number.length < digits) {
	      number = '0' + number;
	    }
	    return number;
	  }

	  var offset = -date.getTimezoneOffset();
	  var ret = pad(date.getFullYear(), 4) + '-' + pad(date.getMonth() + 1, 2) + '-' + pad(date.getDate(), 2) + 'T' + pad(date.getHours(), 2) + ':' + pad(date.getMinutes(), 2) + ':' + pad(date.getSeconds(), 2) + '.' + pad(date.getMilliseconds(), 3);

	  if (offset < 0) {
	    ret += "-";
	    offset *= -1;
	  } else {
	    ret += "+";
	  }

	  return ret + pad(Math.floor(offset / 60), 2) + ":" + pad(offset % 60, 2);
	}

	var prepareObject = undefined;
	var arrayString = undefined;

	// converts values from javascript types
	// to their 'raw' counterparts for use as a postgres parameter
	// note: you can override this function to provide your own conversion mechanism
	// for complex types, etc...
	var prepareValue = function prepareValue(val, seen /*, valueForUndefined*/) {
	  if (val instanceof Buffer) {
	    return val;
	  }
	  if (val instanceof Date) {
	    return dateToString(val);
	  }
	  if (Array.isArray(val)) {
	    return arrayString(val);
	  }
	  if (val === null) {
	    return null;
	  }
	  if (typeof val === 'object') {
	    return prepareObject(val, seen);
	  }
	  return val.toString();
	};

	prepareObject = function prepareObject(val, seen) {
	  if (val && typeof val.toPostgres === 'function') {
	    seen = seen || [];
	    if (seen.indexOf(val) !== -1) {
	      throw new Error('circular reference detected while preparing "' + val + '" for query');
	    }
	    seen.push(val);

	    return prepareValue(val.toPostgres(prepareValue), seen);
	  }
	  return JSON.stringify(val);
	};

	// convert a JS array to a postgres array literal
	// uses comma separator so won't work for types like box that use
	// a different array separator.
	arrayString = function arrayString(val) {
	  return '{' + val.map(function (elem) {
	    if (elem === null || elem === undefined) {
	      return 'NULL';
	    }
	    if (Array.isArray(elem)) {
	      return arrayString(elem);
	    }
	    return JSON.stringify(prepareValue(elem));
	  }).join(',') + '}';
	};

	function normalizeQueryConfig(config, values, callback) {
	  //can take in strings or config objects
	  config = typeof config === 'string' ? { text: config } : config;
	  if (values) {
	    if (typeof values === 'function') {
	      config.callback = values;
	    } else {
	      config.values = values;
	    }
	  }
	  if (callback) {
	    config.callback = callback;
	  }
	  return config;
	}

	exports.prepareValue = prepareValue;
	exports.normalizeQueryConfig = normalizeQueryConfig;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy9wb3N0Z3Jlcy91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQ0EsU0FBUyxZQUFZLENBQUMsSUFBSSxFQUFFO0FBQzFCLFdBQVMsR0FBRyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUU7QUFDM0IsVUFBTSxHQUFHLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUMzQixXQUFPLE1BQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxFQUFFO0FBQzdCLFlBQU0sU0FBTyxNQUFNLEFBQUUsQ0FBQztLQUN2QjtBQUNELFdBQU8sTUFBTSxDQUFDO0dBQ2Y7O0FBRUQsTUFBSSxNQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztBQUN2QyxNQUFJLEdBQUcsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FDeEMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUNqQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FDNUIsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQzdCLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUMvQixHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FDL0IsR0FBRyxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQzs7QUFFakMsTUFBSSxNQUFNLEdBQUcsQ0FBQyxFQUFFO0FBQ2QsT0FBRyxJQUFJLEdBQUcsQ0FBQztBQUNYLFVBQU0sSUFBSSxDQUFDLENBQUMsQ0FBQztHQUNk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QUN4QjtHQUNGO0FBQ0QsTUFBSSxRQUFRLEVBQUU7QUFDWixVQUFNLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztHQUM1QjtBQUNELFNBQU8sTUFBTSxDQUFDO0NBQ2Y7O1FBRVEsWUFBWSxHQUFaLFlBQVk7UUFBRSxvQkFBb0IsR0FBcEIsb0JBQW9CIiwiZmlsZSI6InV0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5mdW5jdGlvbiBkYXRlVG9TdHJpbmcoZGF0ZSkge1xuICBmdW5jdGlvbiBwYWQobnVtYmVyLCBkaWdpdHMpIHtcbiAgICBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKTtcbiAgICB3aGlsZSAobnVtYmVyLmxlbmd0aCA8IGRpZ2l0cykge1xuICAgICAgbnVtYmVyID0gYDAke251bWJlcn1gO1xuICAgIH1cbiAgICByZXR1cm4gbnVtYmVyO1xuICB9XG5cbiAgbGV0IG9mZnNldCA9IC1kYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIGxldCByZXQgPSBwYWQoZGF0ZS5nZXRGdWxsWWVhcigpLCA0KSArICctJyArXG4gICAgcGFkKGRhdGUuZ2V0TW9udGgoKSArIDEsIDIpICsgJy0nICtcbiAgICBwYWQoZGF0ZS5nZXREYXRlKCksIDIpICsgJ1QnICtcbiAgICBwYWQoZGF0ZS5nZXRIb3VycygpLCAyKSArICc6JyArXG4gICAgcGFkKGRhdGUuZ2V0TWludXRlcygpLCAyKSArICc6JyArXG4gICAgcGFkKGRhdGUuZ2V0U2Vjb25kcygpLCAyKSArICcuJyArXG4gICAgcGFkKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksIDMpO1xuXG4gIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgcmV0ICs9IFwiLVwiO1xuICAgIG9mZnNldCAqPSAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXQgKz0gXCIrXCI7XG4gIH1cblxuICByZXR1cm4gcmV0ICsgcGFkKE1hdGguZmxvb3Iob2Zmc2V0IC8gNjApLCAyKSArIFwiOlwiICsgcGFkKG9mZnNldCAlIDYwLCAyKTtcbn1cblxubGV0IHByZXBhcmVPYmplY3Q7XG5sZXQgYXJyYXlTdHJpbmc7XG5cbi8vIGNvbnZlcnRzIHZhbHVlcyBmcm9tIGphdmFzY3JpcHQgdHlwZXNcbi8vIHRvIHRoZWlyICdyYXcnIGNvdW50ZXJwYXJ0cyBmb3IgdXNlIGFzIGEgcG9zdGdyZXMgcGFyYW1ldGVyXG4vLyBub3RlOiB5b3UgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gcHJvdmlkZSB5b3VyIG93biBjb252ZXJzaW9uIG1lY2hhbmlzbVxuLy8gZm9yIGNvbXBsZXggdHlwZXMsIGV0Yy4uLlxuY29uc3QgcHJlcGFyZVZhbHVlID0gZnVuY3Rpb24gKHZhbCwgc2VlbiAvKiwgdmFsdWVGb3JVbmRlZmluZWQqLykge1xuICBpZiAodmFsIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBkYXRlVG9TdHJpbmcodmFsKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIGFycmF5U3RyaW5nKHZhbCk7XG4gIH1cbiAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBwcmVwYXJlT2JqZWN0KHZhbCwgc2Vlbik7XG4gIH1cbiAgcmV0dXJuIHZhbC50b1N0cmluZygpO1xufTtcblxucHJlcGFyZU9iamVjdCA9IGZ1bmN0aW9uIHByZXBhcmVPYmplY3QodmFsLCBzZWVuKSB7XG4gIGlmICh2YWwgJiYgdHlwZW9mIHZhbC50b1Bvc3RncmVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2VlbiA9IHNlZW4gfHwgW107XG4gICAgaWYgKHNlZW4uaW5kZXhPZih2YWwpICE9PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0ZWQgd2hpbGUgcHJlcGFyaW5nIFwiJHt2YWx9XCIgZm9yIHF1ZXJ5YCk7XG4gICAgfVxuICAgIHNlZW4ucHVzaCh2YWwpO1xuXG4gICAgcmV0dXJuIHByZXBhcmVWYWx1ZSh2YWwudG9Qb3N0Z3JlcyhwcmVwYXJlVmFsdWUpLCBzZWVuKTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsKTtcbn07XG5cbi8vIGNvbnZlcnQgYSBKUyBhcnJheSB0byBhIHBvc3RncmVzIGFycmF5IGxpdGVyYWxcbi8vIHVzZXMgY29tbWEgc2VwYXJhdG9yIHNvIHdvbid0IHdvcmsgZm9yIHR5cGVzIGxpa2UgYm94IHRoYXQgdXNlXG4vLyBhIGRpZmZlcmVudCBhcnJheSBzZXBhcmF0b3IuXG5hcnJheVN0cmluZyA9IGZ1bmN0aW9uIGFycmF5U3RyaW5nKHZhbCkge1xuICByZXR1cm4gJ3snICsgdmFsLm1hcChmdW5jdGlvbiAoZWxlbSkge1xuICAgIGlmIChlbGVtID09PSBudWxsIHx8IGVsZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICdOVUxMJztcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbSkpIHtcbiAgICAgIHJldHVybiBhcnJheVN0cmluZyhlbGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByZXBhcmVWYWx1ZShlbGVtKSk7XG4gIH0pLmpvaW4oJywnKSArICd9Jztcbn07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVF1ZXJ5Q29uZmlnKGNvbmZpZywgdmFsdWVzLCBjYWxsYmFjaykge1xuICAvL2NhbiB0YWtlIGluIHN0cmluZ3Mgb3IgY29uZmlnIG9iamVjdHNcbiAgY29uZmlnID0gKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSA/IHsgdGV4dDogY29uZmlnIH0gOiBjb25maWc7XG4gIGlmICh2YWx1ZXMpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uZmlnLmNhbGxiYWNrID0gdmFsdWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWcudmFsdWVzID0gdmFsdWVzO1xuICAgIH1cbiAgfVxuICBpZiAoY2FsbGJhY2spIHtcbiAgICBjb25maWcuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICByZXR1cm4gY29uZmlnO1xufVxuXG5leHBvcnQgeyBwcmVwYXJlVmFsdWUsIG5vcm1hbGl6ZVF1ZXJ5Q29uZmlnIH07XG4iXX0=
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20).Buffer))

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	
	// PostgreSQL Query Builder & Compiler
	// ------
	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _queryCompiler = __webpack_require__(75);

	var _queryCompiler2 = _interopRequireDefault(_queryCompiler);

	var _lodash = __webpack_require__(5);

	function QueryCompiler_PG(client, builder) {
	  _queryCompiler2['default'].call(this, client, builder);
	}
	_inherits2['default'](QueryCompiler_PG, _queryCompiler2['default']);

	_lodash.assign(QueryCompiler_PG.prototype, {

	  // Compiles a truncate query.
	  truncate: function truncate() {
	    return 'truncate ' + this.tableName + ' restart identity';
	  },

	  // is used if the an array with multiple empty values supplied
	  _defaultInsertValue: 'default',

	  // Compiles an `insert` query, allowing for multiple
	  // inserts using a single query statement.
	  insert: function insert() {
	    var sql = _queryCompiler2['default'].prototype.insert.call(this);
	    if (sql === '') return sql;
	    var returning = this.single.returning;

	    return {
	      sql: sql + this._returning(returning),
	      returning: returning
	    };
	  },

	  // Compiles an `update` query, allowing for a return value.
	  update: function update() {
	    var updateData = this._prepUpdate(this.single.update);
	    var wheres = this.where();
	    var returning = this.single.returning;

	    return {
	      sql: 'update ' + this.tableName + ' set ' + updateData.join(', ') + (wheres ? ' ' + wheres : '') + this._returning(returning),
	      returning: returning
	    };
	  },

	  // Compiles an `update` query, allowing for a return value.
	  del: function del() {
	    var sql = _queryCompiler2['default'].prototype.del.apply(this, arguments);
	    var returning = this.single.returning;

	    return {
	      sql: sql + this._returning(returning),
	      returning: returning
	    };
	  },

	  _returning: function _returning(value) {
	    return value ? ' returning ' + this.formatter.columnize(value) : '';
	  },

	  forUpdate: function forUpdate() {
	    return 'for update';
	  },

	  forShare: function forShare() {
	    return 'for share';
	  },

	  // Compiles a columnInfo query
	  columnInfo: function columnInfo() {
	    var column = this.single.columnInfo;

	    var sql = 'select * from information_schema.columns where table_name = ? and table_catalog = ?';
	    var bindings = [this.single.table, this.client.database()];

	    if (this.single.schema) {
	      sql += ' and table_schema = ?';
	      bindings.push(this.single.schema);
	    } else {
	      sql += ' and table_schema = current_schema';
	    }

	    return {
	      sql: sql,
	      bindings: bindings,
	      output: function output(resp) {
	        var out = _lodash.reduce(resp.rows, function (columns, val) {
	          columns[val.column_name] = {
	            type: val.data_type,
	            maxLength: val.character_maximum_length,
	            nullable: val.is_nullable === 'YES',
	            defaultValue: val.column_default
	          };
	          return columns;
	        }, {});
	        return column && out[column] || out;
	      }
	    };
	  }

	});

	exports['default'] = QueryCompiler_PG;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9wb3N0Z3Jlcy9xdWVyeS9jb21waWxlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7d0JBR3FCLFVBQVU7Ozs7NkJBRUwseUJBQXlCOzs7O3NCQUVwQixRQUFROztBQUV2QyxTQUFTLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUU7QUFDekMsNkJBQWMsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7Q0FDM0M7QUFDRCxzQkFBUyxnQkFBZ0IsNkJBQWdCLENBQUM7O0FBRTFDLGVBQU8sZ0JBQWdCLENBQUMsU0FBUyxFQUFFOzs7QUFHakMsVUFBUSxFQUFBLG9CQUFHO0FBQ1QseUJBQW1CLElBQUksQ0FBQyxTQUFTLHVCQUFvQjtHQUN0RDs7O0FBR0QscUJBQW1CLEVBQUUsU0FBUzs7OztBQUk5QixRQUFNLEVBQUEsa0JBQUc7QUFDUCxRQUFNLEdBQUcsR0FBRywyQkFBYyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQTtBQUNyRCxRQUFJLEdBQUcsS0FBSyxFQUFFLEVBQUUsT0FBTyxHQUFHLENBQUM7UUFDbkIsU0FBUyxHQUFLLElBQUksQ0FBQyxNQUFNLENBQXpCLFNBQVM7O0FBQ2pCLFdBQU87QUFDTCxTQUFHLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDO0FBQ3JDLGVBQVMsRUFBVCxTQUFTO0tBQ1YsQ0FBQztHQUNIOzs7QUFHRCxRQUFNLEVBQUEsa0JBQUc7QUFDUCxRQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDeEQsUUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3BCLFNBQVMsR0FBSyxJQUFJLENBQUMsTUFBTSxDQUF6QixTQUFTOztBQUNqQixXQUFPO0FBQ0wsU0FBRyxFQUFFLFlBQVUsSUFBSSxDQUFDLFNBQVMsYUFBUSxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUN6RCxNQUFNLFNBQU8sTUFBTSxHQUFLLEVBQUUsQ0FBQSxBQUFDLEdBQzVCLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDO0FBQzFCLGVBQVMsRUFBVCxTQUFTO0tBQ1YsQ0FBQztHQUNIOzs7QUFHRCxLQUFHLEVBQUEsZUFBRztBQUNKLFFBQU0sR0FBRyxHQUFHLDJCQUFjLFNBQVMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztRQUN2RCxTQUFTLEdBQUssSUFBSSxDQUFDLE1BQU0sQ0FBekIsU0FBUzs7QUFDakIsV0FBTztBQUNMLFNBQUcsRUFBRSxHQUFHLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUM7QUFDckMsZUFBUyxFQUFULFNBQVM7S0FDVixDQUFDO0dBQ0g7O0FBRUQsWUFBVSxFQUFBLG9CQUFDLEtBQUssRUFBRTtBQUNoQixXQUFPLEtBQUssbUJBQWlCLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxHQUFLLEVBQUUsQ0FBQztHQUNyRTs7QUFFRCxXQUFTLEVBQUEscUJBQUc7QUFDVixXQUFPLFlBQVksQ0FBQztHQUNyQjs7QUFFRCxVQUFRLEVBQUEsb0JBQUc7QUFDVCxXQUFPLFdBQVcsQ0FBQztHQUNwQjs7O0FBR0QsWUFBVSxFQUFBLHNCQUFHO0FBQ1gsUUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUM7O0FBRXRDLFFBQUksR0FBRyxHQUFHLHFGQUFxRixDQUFDO0FBQ2hHLFFBQU0sUUFBUSxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDOztBQUU3RCxRQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFO0FBQ3RCLFNBQUcsSUFBSSx1QkFBdUIsQ0FBQztBQUMvQixjQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDbkMsTUFBTTtBQUNMLFNBQUcsSUFBSSxvQ0FBb0MsQ0FBQztLQUM3Qzs7QUFFRCxXQUFPO0FBQ0wsU0FBRyxFQUFILEdBQUc7QUFDSCxjQUFRLEVBQVIsUUFBUTtBQUNSLFlBQU0sRUFBQSxnQkFBQyxJQUFJLEVBQUU7QUFDWCxZQUFNLEdBQUcsR0FBRyxlQUFPLElBQUksQ0FBQyxJQUFJLEVBQUUsVUFBUyxPQUFPLEVBQUUsR0FBRyxFQUFFO0FBQ25ELGlCQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHO0FBQ3pCLGdCQUFJLEVBQUUsR0FBRyxDQUFDLFNBQVM7QUFDbkIscUJBQVMsRUFBRSxHQUFHLENBQUMsd0JBQXdCO0FBQ3ZDLG9CQUFRLEVBQUcsR0FBRyxDQUFDLFdBQVcsS0FBSyxLQUFLLEFBQUM7QUFDckMsd0JBQVksRUFBRSxHQUFHLENBQUMsY0FBYztXQUNqQyxDQUFDO0FBQ0YsaUJBQU8sT0FBTyxDQUFDO1NBQ2hCLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDUCxlQUFPLE1BQU0sSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksR0FBRyxDQUFDO09BQ3JDO0tBQ0YsQ0FBQztHQUNIOztDQUVGLENBQUMsQ0FBQTs7cUJBRWEsZ0JBQWdCIiwiZmlsZSI6ImNvbXBpbGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBQb3N0Z3JlU1FMIFF1ZXJ5IEJ1aWxkZXIgJiBDb21waWxlclxuLy8gLS0tLS0tXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuXG5pbXBvcnQgUXVlcnlDb21waWxlciBmcm9tICcuLi8uLi8uLi9xdWVyeS9jb21waWxlcic7XG5cbmltcG9ydCB7IGFzc2lnbiwgcmVkdWNlIH0gZnJvbSAnbG9kYXNoJ1xuXG5mdW5jdGlvbiBRdWVyeUNvbXBpbGVyX1BHKGNsaWVudCwgYnVpbGRlcikge1xuICBRdWVyeUNvbXBpbGVyLmNhbGwodGhpcywgY2xpZW50LCBidWlsZGVyKTtcbn1cbmluaGVyaXRzKFF1ZXJ5Q29tcGlsZXJfUEcsIFF1ZXJ5Q29tcGlsZXIpO1xuXG5hc3NpZ24oUXVlcnlDb21waWxlcl9QRy5wcm90b3R5cGUsIHtcblxuICAvLyBDb21waWxlcyBhIHRydW5jYXRlIHF1ZXJ5LlxuICB0cnVuY2F0ZSgpIHtcbiAgICByZXR1cm4gYHRydW5jYXRlICR7dGhpcy50YWJsZU5hbWV9IHJlc3RhcnQgaWRlbnRpdHlgO1xuICB9LFxuXG4gIC8vIGlzIHVzZWQgaWYgdGhlIGFuIGFycmF5IHdpdGggbXVsdGlwbGUgZW1wdHkgdmFsdWVzIHN1cHBsaWVkXG4gIF9kZWZhdWx0SW5zZXJ0VmFsdWU6ICdkZWZhdWx0JyxcblxuICAvLyBDb21waWxlcyBhbiBgaW5zZXJ0YCBxdWVyeSwgYWxsb3dpbmcgZm9yIG11bHRpcGxlXG4gIC8vIGluc2VydHMgdXNpbmcgYSBzaW5nbGUgcXVlcnkgc3RhdGVtZW50LlxuICBpbnNlcnQoKSB7XG4gICAgY29uc3Qgc3FsID0gUXVlcnlDb21waWxlci5wcm90b3R5cGUuaW5zZXJ0LmNhbGwodGhpcylcbiAgICBpZiAoc3FsID09PSAnJykgcmV0dXJuIHNxbDtcbiAgICBjb25zdCB7IHJldHVybmluZyB9ID0gdGhpcy5zaW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNxbDogc3FsICsgdGhpcy5fcmV0dXJuaW5nKHJldHVybmluZyksXG4gICAgICByZXR1cm5pbmdcbiAgICB9O1xuICB9LFxuXG4gIC8vIENvbXBpbGVzIGFuIGB1cGRhdGVgIHF1ZXJ5LCBhbGxvd2luZyBmb3IgYSByZXR1cm4gdmFsdWUuXG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCB1cGRhdGVEYXRhID0gdGhpcy5fcHJlcFVwZGF0ZSh0aGlzLnNpbmdsZS51cGRhdGUpO1xuICAgIGNvbnN0IHdoZXJlcyA9IHRoaXMud2hlcmUoKTtcbiAgICBjb25zdCB7IHJldHVybmluZyB9ID0gdGhpcy5zaW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNxbDogYHVwZGF0ZSAke3RoaXMudGFibGVOYW1lfSBzZXQgJHt1cGRhdGVEYXRhLmpvaW4oJywgJyl9YCArXG4gICAgICAod2hlcmVzID8gYCAke3doZXJlc31gIDogJycpICtcbiAgICAgIHRoaXMuX3JldHVybmluZyhyZXR1cm5pbmcpLFxuICAgICAgcmV0dXJuaW5nXG4gICAgfTtcbiAgfSxcblxuICAvLyBDb21waWxlcyBhbiBgdXBkYXRlYCBxdWVyeSwgYWxsb3dpbmcgZm9yIGEgcmV0dXJuIHZhbHVlLlxuICBkZWwoKSB7XG4gICAgY29uc3Qgc3FsID0gUXVlcnlDb21waWxlci5wcm90b3R5cGUuZGVsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgY29uc3QgeyByZXR1cm5pbmcgfSA9IHRoaXMuc2luZ2xlO1xuICAgIHJldHVybiB7XG4gICAgICBzcWw6IHNxbCArIHRoaXMuX3JldHVybmluZyhyZXR1cm5pbmcpLFxuICAgICAgcmV0dXJuaW5nXG4gICAgfTtcbiAgfSxcblxuICBfcmV0dXJuaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID8gYCByZXR1cm5pbmcgJHt0aGlzLmZvcm1hdHRlci5jb2x1bW5pemUodmFsdWUpfWAgOiAnJztcbiAgfSxcblxuICBmb3JVcGRhdGUoKSB7XG4gICAgcmV0dXJuICdmb3IgdXBkYXRlJztcbiAgfSxcblxuICBmb3JTaGFyZSgpIHtcbiAgICByZXR1cm4gJ2ZvciBzaGFyZSc7XG4gIH0sXG5cbiAgLy8gQ29tcGlsZXMgYSBjb2x1bW5JbmZvIHF1ZXJ5XG4gIGNvbHVtbkluZm8oKSB7XG4gICAgY29uc3QgY29sdW1uID0gdGhpcy5zaW5nbGUuY29sdW1uSW5mbztcblxuICAgIGxldCBzcWwgPSAnc2VsZWN0ICogZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEuY29sdW1ucyB3aGVyZSB0YWJsZV9uYW1lID0gPyBhbmQgdGFibGVfY2F0YWxvZyA9ID8nO1xuICAgIGNvbnN0IGJpbmRpbmdzID0gW3RoaXMuc2luZ2xlLnRhYmxlLCB0aGlzLmNsaWVudC5kYXRhYmFzZSgpXTtcblxuICAgIGlmICh0aGlzLnNpbmdsZS5zY2hlbWEpIHtcbiAgICAgIHNxbCArPSAnIGFuZCB0YWJsZV9zY2hlbWEgPSA/JztcbiAgICAgIGJpbmRpbmdzLnB1c2godGhpcy5zaW5nbGUuc2NoZW1hKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3FsICs9ICcgYW5kIHRhYmxlX3NjaGVtYSA9IGN1cnJlbnRfc2NoZW1hJztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3FsLFxuICAgICAgYmluZGluZ3MsXG4gICAgICBvdXRwdXQocmVzcCkge1xuICAgICAgICBjb25zdCBvdXQgPSByZWR1Y2UocmVzcC5yb3dzLCBmdW5jdGlvbihjb2x1bW5zLCB2YWwpIHtcbiAgICAgICAgICBjb2x1bW5zW3ZhbC5jb2x1bW5fbmFtZV0gPSB7XG4gICAgICAgICAgICB0eXBlOiB2YWwuZGF0YV90eXBlLFxuICAgICAgICAgICAgbWF4TGVuZ3RoOiB2YWwuY2hhcmFjdGVyX21heGltdW1fbGVuZ3RoLFxuICAgICAgICAgICAgbnVsbGFibGU6ICh2YWwuaXNfbnVsbGFibGUgPT09ICdZRVMnKSxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsLmNvbHVtbl9kZWZhdWx0XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gY29sdW1ucztcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gY29sdW1uICYmIG91dFtjb2x1bW5dIHx8IG91dDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbn0pXG5cbmV4cG9ydCBkZWZhdWx0IFF1ZXJ5Q29tcGlsZXJfUEc7XG4iXX0=

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	
	// PostgreSQL Column Compiler
	// -------

	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _schemaColumncompiler = __webpack_require__(82);

	var _schemaColumncompiler2 = _interopRequireDefault(_schemaColumncompiler);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _lodash = __webpack_require__(5);

	function ColumnCompiler_PG() {
	  _schemaColumncompiler2['default'].apply(this, arguments);
	  this.modifiers = ['nullable', 'defaultTo', 'comment'];
	}
	_inherits2['default'](ColumnCompiler_PG, _schemaColumncompiler2['default']);

	_lodash.assign(ColumnCompiler_PG.prototype, {

	  // Types
	  // ------
	  bigincrements: 'bigserial primary key',
	  bigint: 'bigint',
	  binary: 'bytea',

	  bit: function bit(column) {
	    return column.length !== false ? 'bit(' + column.length + ')' : 'bit';
	  },

	  bool: 'boolean',

	  // Create the column definition for an enum type.
	  // Using method "2" here: http://stackoverflow.com/a/10984951/525714
	  enu: function enu(allowed) {
	    return 'text check (' + this.formatter.wrap(this.args[0]) + ' in (\'' + allowed.join("', '") + '\'))';
	  },

	  double: 'double precision',
	  floating: 'real',
	  increments: 'serial primary key',
	  json: function json(jsonb) {
	    if (jsonb) helpers.deprecate('json(true)', 'jsonb()');
	    return jsonColumn(this.client, jsonb);
	  },
	  jsonb: function jsonb() {
	    return jsonColumn(this.client, true);
	  },
	  smallint: 'smallint',
	  tinyint: 'smallint',
	  datetime: function datetime(without) {
	    return without ? 'timestamp' : 'timestamptz';
	  },
	  timestamp: function timestamp(without) {
	    return without ? 'timestamp' : 'timestamptz';
	  },
	  uuid: 'uuid',

	  // Modifiers:
	  // ------
	  comment: function comment(_comment) {
	    this.pushAdditional(function () {
	      this.pushQuery('comment on column ' + this.tableCompiler.tableName() + '.' + this.formatter.wrap(this.args[0]) + " is " + (_comment ? '\'' + _comment + '\'' : 'NULL'));
	    }, _comment);
	  }

	});

	function jsonColumn(client, jsonb) {
	  if (!client.version || parseFloat(client.version) >= 9.2) return jsonb ? 'jsonb' : 'json';
	  return 'text';
	}

	exports['default'] = ColumnCompiler_PG;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9wb3N0Z3Jlcy9zY2hlbWEvY29sdW1uY29tcGlsZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O3dCQUlxQixVQUFVOzs7O29DQUNKLGdDQUFnQzs7Ozt1QkFDbEMsa0JBQWtCOztJQUEvQixPQUFPOztzQkFFSSxRQUFROztBQUUvQixTQUFTLGlCQUFpQixHQUFHO0FBQzNCLG9DQUFlLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDdEMsTUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLFVBQVUsRUFBRSxXQUFXLEVBQUUsU0FBUyxDQUFDLENBQUE7Q0FDdEQ7QUFDRCxzQkFBUyxpQkFBaUIsb0NBQWlCLENBQUM7O0FBRTVDLGVBQU8saUJBQWlCLENBQUMsU0FBUyxFQUFFOzs7O0FBSWxDLGVBQWEsRUFBRSx1QkFBdUI7QUFDdEMsUUFBTSxFQUFFLFFBQVE7QUFDaEIsUUFBTSxFQUFFLE9BQU87O0FBRWYsS0FBRyxFQUFBLGFBQUMsTUFBTSxFQUFFO0FBQ1YsV0FBTyxNQUFNLENBQUMsTUFBTSxLQUFLLEtBQUssWUFBVSxNQUFNLENBQUMsTUFBTSxTQUFNLEtBQUssQ0FBQztHQUNsRTs7QUFFRCxNQUFJLEVBQUUsU0FBUzs7OztBQUlmLEtBQUcsRUFBQSxhQUFDLE9BQU8sRUFBRTtBQUNYLDRCQUFzQixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQVMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBTTtHQUMzRjs7QUFFRCxRQUFNLEVBQUUsa0JBQWtCO0FBQzFCLFVBQVEsRUFBRSxNQUFNO0FBQ2hCLFlBQVUsRUFBRSxvQkFBb0I7QUFDaEMsTUFBSSxFQUFBLGNBQUMsS0FBSyxFQUFFO0FBQ1YsUUFBSSxLQUFLLEVBQUUsT0FBTyxDQUFDLFNBQVMsQ0FBQyxZQUFZLEVBQUUsU0FBUyxDQUFDLENBQUE7QUFDckQsV0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztHQUN2QztBQUNELE9BQUssRUFBQSxpQkFBRztBQUNOLFdBQU8sVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7R0FDdEM7QUFDRCxVQUFRLEVBQUUsVUFBVTtBQUNwQixTQUFPLEVBQUcsVUFBVTtBQUNwQixVQUFRLEVBQUEsa0JBQUMsT0FBTyxFQUFFO0FBQ2hCLFdBQU8sT0FBTyxHQUFHLFdBQVcsR0FBRyxhQUFhLENBQUM7R0FDOUM7QUFDRCxXQUFTLEVBQUEsbUJBQUMsT0FBTyxFQUFFO0FBQ2pCLFdBQU8sT0FBTyxHQUFHLFdBQVcsR0FBRyxhQUFhLENBQUM7R0FDOUM7QUFDRCxNQUFJLEVBQUUsTUFBTTs7OztBQUlaLFNBQU8sRUFBQSxpQkFBQyxRQUFPLEVBQUU7QUFDZixRQUFJLENBQUMsY0FBYyxDQUFDLFlBQVc7QUFDN0IsVUFBSSxDQUFDLFNBQVMsQ0FBQyx1QkFBcUIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLEVBQUUsU0FDaEUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sSUFBSSxRQUFPLFVBQU8sUUFBTyxVQUFNLE1BQU0sQ0FBQSxBQUFDLENBQUMsQ0FBQztLQUNyRixFQUFFLFFBQU8sQ0FBQyxDQUFDO0dBQ2I7O0NBRUYsQ0FBQyxDQUFBOztBQUVGLFNBQVMsVUFBVSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUU7QUFDakMsTUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLEVBQUUsT0FBTyxLQUFLLEdBQUcsT0FBTyxHQUFHLE1BQU0sQ0FBQztBQUMxRixTQUFPLE1BQU0sQ0FBQztDQUNmOztxQkFFYyxpQkFBaUIiLCJmaWxlIjoiY29sdW1uY29tcGlsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8vIFBvc3RncmVTUUwgQ29sdW1uIENvbXBpbGVyXG4vLyAtLS0tLS0tXG5cbmltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5pbXBvcnQgQ29sdW1uQ29tcGlsZXIgZnJvbSAnLi4vLi4vLi4vc2NoZW1hL2NvbHVtbmNvbXBpbGVyJztcbmltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSAnLi4vLi4vLi4vaGVscGVycyc7XG5cbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJ2xvZGFzaCdcblxuZnVuY3Rpb24gQ29sdW1uQ29tcGlsZXJfUEcoKSB7XG4gIENvbHVtbkNvbXBpbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHRoaXMubW9kaWZpZXJzID0gWydudWxsYWJsZScsICdkZWZhdWx0VG8nLCAnY29tbWVudCddXG59XG5pbmhlcml0cyhDb2x1bW5Db21waWxlcl9QRywgQ29sdW1uQ29tcGlsZXIpO1xuXG5hc3NpZ24oQ29sdW1uQ29tcGlsZXJfUEcucHJvdG90eXBlLCB7XG5cbiAgLy8gVHlwZXNcbiAgLy8gLS0tLS0tXG4gIGJpZ2luY3JlbWVudHM6ICdiaWdzZXJpYWwgcHJpbWFyeSBrZXknLFxuICBiaWdpbnQ6ICdiaWdpbnQnLFxuICBiaW5hcnk6ICdieXRlYScsXG5cbiAgYml0KGNvbHVtbikge1xuICAgIHJldHVybiBjb2x1bW4ubGVuZ3RoICE9PSBmYWxzZSA/IGBiaXQoJHtjb2x1bW4ubGVuZ3RofSlgIDogJ2JpdCc7XG4gIH0sXG5cbiAgYm9vbDogJ2Jvb2xlYW4nLFxuXG4gIC8vIENyZWF0ZSB0aGUgY29sdW1uIGRlZmluaXRpb24gZm9yIGFuIGVudW0gdHlwZS5cbiAgLy8gVXNpbmcgbWV0aG9kIFwiMlwiIGhlcmU6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEwOTg0OTUxLzUyNTcxNFxuICBlbnUoYWxsb3dlZCkge1xuICAgIHJldHVybiBgdGV4dCBjaGVjayAoJHt0aGlzLmZvcm1hdHRlci53cmFwKHRoaXMuYXJnc1swXSl9IGluICgnJHthbGxvd2VkLmpvaW4oXCInLCAnXCIpfScpKWA7XG4gIH0sXG5cbiAgZG91YmxlOiAnZG91YmxlIHByZWNpc2lvbicsXG4gIGZsb2F0aW5nOiAncmVhbCcsXG4gIGluY3JlbWVudHM6ICdzZXJpYWwgcHJpbWFyeSBrZXknLFxuICBqc29uKGpzb25iKSB7XG4gICAgaWYgKGpzb25iKSBoZWxwZXJzLmRlcHJlY2F0ZSgnanNvbih0cnVlKScsICdqc29uYigpJylcbiAgICByZXR1cm4ganNvbkNvbHVtbih0aGlzLmNsaWVudCwganNvbmIpO1xuICB9LFxuICBqc29uYigpIHtcbiAgICByZXR1cm4ganNvbkNvbHVtbih0aGlzLmNsaWVudCwgdHJ1ZSk7XG4gIH0sXG4gIHNtYWxsaW50OiAnc21hbGxpbnQnLFxuICB0aW55aW50OiAgJ3NtYWxsaW50JyxcbiAgZGF0ZXRpbWUod2l0aG91dCkge1xuICAgIHJldHVybiB3aXRob3V0ID8gJ3RpbWVzdGFtcCcgOiAndGltZXN0YW1wdHonO1xuICB9LFxuICB0aW1lc3RhbXAod2l0aG91dCkge1xuICAgIHJldHVybiB3aXRob3V0ID8gJ3RpbWVzdGFtcCcgOiAndGltZXN0YW1wdHonO1xuICB9LFxuICB1dWlkOiAndXVpZCcsXG5cbiAgLy8gTW9kaWZpZXJzOlxuICAvLyAtLS0tLS1cbiAgY29tbWVudChjb21tZW50KSB7XG4gICAgdGhpcy5wdXNoQWRkaXRpb25hbChmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucHVzaFF1ZXJ5KGBjb21tZW50IG9uIGNvbHVtbiAke3RoaXMudGFibGVDb21waWxlci50YWJsZU5hbWUoKX0uYCArXG4gICAgICAgIHRoaXMuZm9ybWF0dGVyLndyYXAodGhpcy5hcmdzWzBdKSArIFwiIGlzIFwiICsgKGNvbW1lbnQgPyBgJyR7Y29tbWVudH0nYCA6ICdOVUxMJykpO1xuICAgIH0sIGNvbW1lbnQpO1xuICB9XG5cbn0pXG5cbmZ1bmN0aW9uIGpzb25Db2x1bW4oY2xpZW50LCBqc29uYikge1xuICBpZiAoIWNsaWVudC52ZXJzaW9uIHx8IHBhcnNlRmxvYXQoY2xpZW50LnZlcnNpb24pID49IDkuMikgcmV0dXJuIGpzb25iID8gJ2pzb25iJyA6ICdqc29uJztcbiAgcmV0dXJuICd0ZXh0Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29sdW1uQ29tcGlsZXJfUEc7XG4iXX0=

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint max-len: 0 */

	// PostgreSQL Table Builder & Compiler
	// -------

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _schemaTablecompiler = __webpack_require__(80);

	var _schemaTablecompiler2 = _interopRequireDefault(_schemaTablecompiler);

	var _lodash = __webpack_require__(5);

	function TableCompiler_PG() {
	  _schemaTablecompiler2['default'].apply(this, arguments);
	}
	_inherits2['default'](TableCompiler_PG, _schemaTablecompiler2['default']);

	// Compile a rename column command.
	TableCompiler_PG.prototype.renameColumn = function (from, to) {
	  return this.pushQuery({
	    sql: 'alter table ' + this.tableName() + ' rename ' + this.formatter.wrap(from) + ' to ' + this.formatter.wrap(to)
	  });
	};

	TableCompiler_PG.prototype.compileAdd = function (builder) {
	  var table = this.formatter.wrap(builder);
	  var columns = this.prefixArray('add column', this.getColumns(builder));
	  return this.pushQuery({
	    sql: 'alter table ' + table + ' ' + columns.join(', ')
	  });
	};

	// Adds the "create" query to the query sequence.
	TableCompiler_PG.prototype.createQuery = function (columns, ifNot) {
	  var createStatement = ifNot ? 'create table if not exists ' : 'create table ';
	  var sql = createStatement + this.tableName() + ' (' + columns.sql.join(', ') + ')';
	  if (this.single.inherits) sql += ' inherits (' + this.formatter.wrap(this.single.inherits) + ')';
	  this.pushQuery({
	    sql: sql,
	    bindings: columns.bindings
	  });
	  var hasComment = _lodash.has(this.single, 'comment');
	  if (hasComment) this.comment(this.single.comment);
	};

	// Compiles the comment on the table.
	TableCompiler_PG.prototype.comment = function (comment) {
	  this.pushQuery('comment on table ' + this.tableName() + ' is \'' + (this.single.comment || '') + '\'');
	};

	// Indexes:
	// -------

	TableCompiler_PG.prototype.primary = function (columns, constraintName) {
	  constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(this.tableNameRaw + '_pkey');
	  this.pushQuery('alter table ' + this.tableName() + ' add constraint ' + constraintName + ' primary key (' + this.formatter.columnize(columns) + ')');
	};
	TableCompiler_PG.prototype.unique = function (columns, indexName) {
	  indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, columns);
	  this.pushQuery('alter table ' + this.tableName() + ' add constraint ' + indexName + ' unique (' + this.formatter.columnize(columns) + ')');
	};
	TableCompiler_PG.prototype.index = function (columns, indexName, indexType) {
	  indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);
	  this.pushQuery('create index ' + indexName + ' on ' + this.tableName() + (indexType && ' using ' + indexType || '') + ' (' + this.formatter.columnize(columns) + ')');
	};
	TableCompiler_PG.prototype.dropPrimary = function (constraintName) {
	  constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(this.tableNameRaw + '_pkey');
	  this.pushQuery('alter table ' + this.tableName() + ' drop constraint ' + constraintName);
	};
	TableCompiler_PG.prototype.dropIndex = function (columns, indexName) {
	  indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);
	  this.pushQuery('drop index ' + indexName);
	};
	TableCompiler_PG.prototype.dropUnique = function (columns, indexName) {
	  indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, columns);
	  this.pushQuery('alter table ' + this.tableName() + ' drop constraint ' + indexName);
	};
	TableCompiler_PG.prototype.dropForeign = function (columns, indexName) {
	  indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('foreign', this.tableNameRaw, columns);
	  this.pushQuery('alter table ' + this.tableName() + ' drop constraint ' + indexName);
	};

	exports['default'] = TableCompiler_PG;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9wb3N0Z3Jlcy9zY2hlbWEvdGFibGVjb21waWxlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozt3QkFLcUIsVUFBVTs7OzttQ0FDTCwrQkFBK0I7Ozs7c0JBRXJDLFFBQVE7O0FBRTVCLFNBQVMsZ0JBQWdCLEdBQUc7QUFDMUIsbUNBQWMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztDQUN0QztBQUNELHNCQUFTLGdCQUFnQixtQ0FBZ0IsQ0FBQzs7O0FBRzFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxZQUFZLEdBQUcsVUFBUyxJQUFJLEVBQUUsRUFBRSxFQUFFO0FBQzNELFNBQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztBQUNwQixPQUFHLG1CQUFpQixJQUFJLENBQUMsU0FBUyxFQUFFLGdCQUFXLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxBQUFFO0dBQ3pHLENBQUMsQ0FBQztDQUNKLENBQUM7O0FBRUYsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLFVBQVUsR0FBRyxVQUFTLE9BQU8sRUFBRTtBQUN4RCxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUMzQyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDekUsU0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO0FBQ3BCLE9BQUcsbUJBQWlCLEtBQUssU0FBSSxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxBQUFFO0dBQ2xELENBQUMsQ0FBQztDQUNKLENBQUM7OztBQUdGLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxXQUFXLEdBQUcsVUFBUyxP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SUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDbkgsTUFBSSxDQUFDLFNBQVMsa0JBQWdCLElBQUksQ0FBQyxTQUFTLEVBQUUseUJBQW9CLFNBQVMsQ0FBRyxDQUFDO0NBQ2hGLENBQUM7O3FCQUVhLGdCQUFnQiIsImZpbGUiOiJ0YWJsZWNvbXBpbGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG1heC1sZW46IDAgKi9cblxuLy8gUG9zdGdyZVNRTCBUYWJsZSBCdWlsZGVyICYgQ29tcGlsZXJcbi8vIC0tLS0tLS1cblxuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcbmltcG9ydCBUYWJsZUNvbXBpbGVyIGZyb20gJy4uLy4uLy4uL3NjaGVtYS90YWJsZWNvbXBpbGVyJztcblxuaW1wb3J0IHsgaGFzIH0gZnJvbSAnbG9kYXNoJ1xuXG5mdW5jdGlvbiBUYWJsZUNvbXBpbGVyX1BHKCkge1xuICBUYWJsZUNvbXBpbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5pbmhlcml0cyhUYWJsZUNvbXBpbGVyX1BHLCBUYWJsZUNvbXBpbGVyKTtcblxuLy8gQ29tcGlsZSBhIHJlbmFtZSBjb2x1bW4gY29tbWFuZC5cblRhYmxlQ29tcGlsZXJfUEcucHJvdG90eXBlLnJlbmFtZUNvbHVtbiA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIHJldHVybiB0aGlzLnB1c2hRdWVyeSh7XG4gICAgc3FsOiBgYWx0ZXIgdGFibGUgJHt0aGlzLnRhYmxlTmFtZSgpfSByZW5hbWUgJHt0aGlzLmZvcm1hdHRlci53cmFwKGZyb20pfSB0byAke3RoaXMuZm9ybWF0dGVyLndyYXAodG8pfWBcbiAgfSk7XG59O1xuXG5UYWJsZUNvbXBpbGVyX1BHLnByb3RvdHlwZS5jb21waWxlQWRkID0gZnVuY3Rpb24oYnVpbGRlcikge1xuICBjb25zdCB0YWJsZSA9IHRoaXMuZm9ybWF0dGVyLndyYXAoYnVpbGRlcik7XG4gIGNvbnN0IGNvbHVtbnMgPSB0aGlzLnByZWZpeEFycmF5KCdhZGQgY29sdW1uJywgdGhpcy5nZXRDb2x1bW5zKGJ1aWxkZXIpKTtcbiAgcmV0dXJuIHRoaXMucHVzaFF1ZXJ5KHtcbiAgICBzcWw6IGBhbHRlciB0YWJsZSAke3RhYmxlfSAke2NvbHVtbnMuam9pbignLCAnKX1gXG4gIH0pO1xufTtcblxuLy8gQWRkcyB0aGUgXCJjcmVhdGVcIiBxdWVyeSB0byB0aGUgcXVlcnkgc2VxdWVuY2UuXG5UYWJsZUNvbXBpbGVyX1BHLnByb3RvdHlwZS5jcmVhdGVRdWVyeSA9IGZ1bmN0aW9uKGNvbHVtbnMsIGlmTm90KSB7XG4gIGNvbnN0IGNyZWF0ZVN0YXRlbWVudCA9IGlmTm90ID8gJ2NyZWF0ZSB0YWJsZSBpZiBub3QgZXhpc3RzICcgOiAnY3JlYXRlIHRhYmxlICc7XG4gIGxldCBzcWwgPSBjcmVhdGVTdGF0ZW1lbnQgKyB0aGlzLnRhYmxlTmFtZSgpICsgJyAoJyArIGNvbHVtbnMuc3FsLmpvaW4oJywgJykgKyAnKSc7XG4gIGlmICh0aGlzLnNpbmdsZS5pbmhlcml0cykgc3FsICs9IGAgaW5oZXJpdHMgKCR7dGhpcy5mb3JtYXR0ZXIud3JhcCh0aGlzLnNpbmdsZS5pbmhlcml0cyl9KWA7XG4gIHRoaXMucHVzaFF1ZXJ5KHtcbiAgICBzcWwsXG4gICAgYmluZGluZ3M6IGNvbHVtbnMuYmluZGluZ3NcbiAgfSk7XG4gIGNvbnN0IGhhc0NvbW1lbnQgPSBoYXModGhpcy5zaW5nbGUsICdjb21tZW50Jyk7XG4gIGlmIChoYXNDb21tZW50KSB0aGlzLmNvbW1lbnQodGhpcy5zaW5nbGUuY29tbWVudCk7XG59O1xuXG4vLyBDb21waWxlcyB0aGUgY29tbWVudCBvbiB0aGUgdGFibGUuXG5UYWJsZUNvbXBpbGVyX1BHLnByb3RvdHlwZS5jb21tZW50ID0gZnVuY3Rpb24oY29tbWVudCkge1xuICB0aGlzLnB1c2hRdWVyeShgY29tbWVudCBvbiB0YWJsZSAke3RoaXMudGFibGVOYW1lKCl9IGlzICcke3RoaXMuc2luZ2xlLmNvbW1lbnQgfHwgJyd9J2ApO1xufTtcblxuLy8gSW5kZXhlczpcbi8vIC0tLS0tLS1cblxuVGFibGVDb21waWxlcl9QRy5wcm90b3R5cGUucHJpbWFyeSA9IGZ1bmN0aW9uKGNvbHVtbnMsIGNvbnN0cmFpbnROYW1lKSB7XG4gIGNvbnN0cmFpbnROYW1lID0gY29uc3RyYWludE5hbWUgPyB0aGlzLmZvcm1hdHRlci53cmFwKGNvbnN0cmFpbnROYW1lKSA6IHRoaXMuZm9ybWF0dGVyLndyYXAoYCR7dGhpcy50YWJsZU5hbWVSYXd9X3BrZXlgKTtcbiAgdGhpcy5wdXNoUXVlcnkoYGFsdGVyIHRhYmxlICR7dGhpcy50YWJsZU5hbWUoKX0gYWRkIGNvbnN0cmFpbnQgJHtjb25zdHJhaW50TmFtZX0gcHJpbWFyeSBrZXkgKCR7dGhpcy5mb3JtYXR0ZXIuY29sdW1uaXplKGNvbHVtbnMpfSlgKTtcbn07XG5UYWJsZUNvbXBpbGVyX1BHLnByb3RvdHlwZS51bmlxdWUgPSBmdW5jdGlvbihjb2x1bW5zLCBpbmRleE5hbWUpIHtcbiAgaW5kZXhOYW1lID0gaW5kZXhOYW1lID8gdGhpcy5mb3JtYXR0ZXIud3JhcChpbmRleE5hbWUpIDogdGhpcy5faW5kZXhDb21tYW5kKCd1bmlxdWUnLCB0aGlzLnRhYmxlTmFtZVJhdywgY29sdW1ucyk7XG4gIHRoaXMucHVzaFF1ZXJ5KGBhbHRlciB0YWJsZSAke3RoaXMudGFibGVOYW1lKCl9IGFkZCBjb25zdHJhaW50ICR7aW5kZXhOYW1lfWAgK1xuICAgICcgdW5pcXVlICgnICsgdGhpcy5mb3JtYXR0ZXIuY29sdW1uaXplKGNvbHVtbnMpICsgJyknKTtcbn07XG5UYWJsZUNvbXBpbGVyX1BHLnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uKGNvbHVtbnMsIGluZGV4TmFtZSwgaW5kZXhUeXBlKSB7XG4gIGluZGV4TmFtZSA9IGluZGV4TmFtZSA/IHRoaXMuZm9ybWF0dGVyLndyYXAoaW5kZXhOYW1lKSA6IHRoaXMuX2luZGV4Q29tbWFuZCgnaW5kZXgnLCB0aGlzLnRhYmxlTmFtZVJhdywgY29sdW1ucyk7XG4gIHRoaXMucHVzaFF1ZXJ5KGBjcmVhdGUgaW5kZXggJHtpbmRleE5hbWV9IG9uICR7dGhpcy50YWJsZU5hbWUoKX0ke2luZGV4VHlwZSAmJiAoYCB1c2luZyAke2luZGV4VHlwZX1gKSB8fCAnJ31gICtcbiAgICAnICgnICsgdGhpcy5mb3JtYXR0ZXIuY29sdW1uaXplKGNvbHVtbnMpICsgJyknKTtcbn07XG5UYWJsZUNvbXBpbGVyX1BHLnByb3RvdHlwZS5kcm9wUHJpbWFyeSA9IGZ1bmN0aW9uKGNvbnN0cmFpbnROYW1lKSB7XG4gIGNvbnN0cmFpbnROYW1lID0gY29uc3RyYWludE5hbWUgPyB0aGlzLmZvcm1hdHRlci53cmFwKGNvbnN0cmFpbnROYW1lKSA6IHRoaXMuZm9ybWF0dGVyLndyYXAodGhpcy50YWJsZU5hbWVSYXcgKyAnX3BrZXknKTtcbiAgdGhpcy5wdXNoUXVlcnkoYGFsdGVyIHRhYmxlICR7dGhpcy50YWJsZU5hbWUoKX0gZHJvcCBjb25zdHJhaW50ICR7Y29uc3RyYWludE5hbWV9YCk7XG59O1xuVGFibGVDb21waWxlcl9QRy5wcm90b3R5cGUuZHJvcEluZGV4ID0gZnVuY3Rpb24oY29sdW1ucywgaW5kZXhOYW1lKSB7XG4gIGluZGV4TmFtZSA9IGluZGV4TmFtZSA/IHRoaXMuZm9ybWF0dGVyLndyYXAoaW5kZXhOYW1lKSA6IHRoaXMuX2luZGV4Q29tbWFuZCgnaW5kZXgnLCB0aGlzLnRhYmxlTmFtZVJhdywgY29sdW1ucyk7XG4gIHRoaXMucHVzaFF1ZXJ5KGBkcm9wIGluZGV4ICR7aW5kZXhOYW1lfWApO1xufTtcblRhYmxlQ29tcGlsZXJfUEcucHJvdG90eXBlLmRyb3BVbmlxdWUgPSBmdW5jdGlvbihjb2x1bW5zLCBpbmRleE5hbWUpIHtcbiAgaW5kZXhOYW1lID0gaW5kZXhOYW1lID8gdGhpcy5mb3JtYXR0ZXIud3JhcChpbmRleE5hbWUpIDogdGhpcy5faW5kZXhDb21tYW5kKCd1bmlxdWUnLCB0aGlzLnRhYmxlTmFtZVJhdywgY29sdW1ucyk7XG4gIHRoaXMucHVzaFF1ZXJ5KGBhbHRlciB0YWJsZSAke3RoaXMudGFibGVOYW1lKCl9IGRyb3AgY29uc3RyYWludCAke2luZGV4TmFtZX1gKTtcbn07XG5UYWJsZUNvbXBpbGVyX1BHLnByb3RvdHlwZS5kcm9wRm9yZWlnbiA9IGZ1bmN0aW9uKGNvbHVtbnMsIGluZGV4TmFtZSkge1xuICBpbmRleE5hbWUgPSBpbmRleE5hbWUgPyB0aGlzLmZvcm1hdHRlci53cmFwKGluZGV4TmFtZSkgOiB0aGlzLl9pbmRleENvbW1hbmQoJ2ZvcmVpZ24nLCB0aGlzLnRhYmxlTmFtZVJhdywgY29sdW1ucyk7XG4gIHRoaXMucHVzaFF1ZXJ5KGBhbHRlciB0YWJsZSAke3RoaXMudGFibGVOYW1lKCl9IGRyb3AgY29uc3RyYWludCAke2luZGV4TmFtZX1gKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRhYmxlQ29tcGlsZXJfUEc7XG4iXX0=

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	// PostgreSQL Schema Compiler
	// -------

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _schemaCompiler = __webpack_require__(77);

	var _schemaCompiler2 = _interopRequireDefault(_schemaCompiler);

	function SchemaCompiler_PG() {
	  _schemaCompiler2['default'].apply(this, arguments);
	}
	_inherits2['default'](SchemaCompiler_PG, _schemaCompiler2['default']);

	// Check whether the current table
	SchemaCompiler_PG.prototype.hasTable = function (tableName) {
	  var sql = 'select * from information_schema.tables where table_name = ?';
	  var bindings = [tableName];

	  if (this.schema) {
	    sql += ' and table_schema = ?';
	    bindings.push(this.schema);
	  } else {
	    sql += ' and table_schema = current_schema';
	  }

	  this.pushQuery({
	    sql: sql,
	    bindings: bindings,
	    output: function output(resp) {
	      return resp.rows.length > 0;
	    }
	  });
	};

	// Compile the query to determine if a column exists in a table.
	SchemaCompiler_PG.prototype.hasColumn = function (tableName, columnName) {
	  var sql = 'select * from information_schema.columns where table_name = ? and column_name = ?';
	  var bindings = [tableName, columnName];

	  if (this.schema) {
	    sql += ' and table_schema = ?';
	    bindings.push(this.schema);
	  } else {
	    sql += ' and table_schema = current_schema';
	  }

	  this.pushQuery({
	    sql: sql,
	    bindings: bindings,
	    output: function output(resp) {
	      return resp.rows.length > 0;
	    }
	  });
	};

	SchemaCompiler_PG.prototype.qualifiedTableName = function (tableName) {
	  var name = this.schema ? this.schema + '.' + tableName : tableName;
	  return this.formatter.wrap(name);
	};

	// Compile a rename table command.
	SchemaCompiler_PG.prototype.renameTable = function (from, to) {
	  this.pushQuery('alter table ' + this.qualifiedTableName(from) + ' rename to ' + this.formatter.wrap(to));
	};

	SchemaCompiler_PG.prototype.createSchema = function (schemaName) {
	  this.pushQuery('create schema ' + this.formatter.wrap(schemaName));
	};

	SchemaCompiler_PG.prototype.createSchemaIfNotExists = function (schemaName) {
	  this.pushQuery('create schema if not exists ' + this.formatter.wrap(schemaName));
	};

	SchemaCompiler_PG.prototype.dropSchema = function (schemaName) {
	  this.pushQuery('drop schema ' + this.formatter.wrap(schemaName));
	};

	SchemaCompiler_PG.prototype.dropSchemaIfExists = function (schemaName) {
	  this.pushQuery('drop schema if exists ' + this.formatter.wrap(schemaName));
	};

	SchemaCompiler_PG.prototype.dropExtension = function (extensionName) {
	  this.pushQuery('drop extension ' + this.formatter.wrap(extensionName));
	};

	SchemaCompiler_PG.prototype.dropExtensionIfExists = function (extensionName) {
	  this.pushQuery('drop extension if exists ' + this.formatter.wrap(extensionName));
	};

	SchemaCompiler_PG.prototype.createExtension = function (extensionName) {
	  this.pushQuery('create extension ' + this.formatter.wrap(extensionName));
	};

	SchemaCompiler_PG.prototype.createExtensionIfNotExists = function (extensionName) {
	  this.pushQuery('create extension if not exists ' + this.formatter.wrap(extensionName));
	};

	exports['default'] = SchemaCompiler_PG;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9wb3N0Z3Jlcy9zY2hlbWEvY29tcGlsZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O3dCQUlxQixVQUFVOzs7OzhCQUNKLDBCQUEwQjs7OztBQUVyRCxTQUFTLGlCQUFpQixHQUFHO0FBQzNCLDhCQUFlLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7Q0FDdkM7QUFDRCxzQkFBUyxpQkFBaUIsOEJBQWlCLENBQUM7OztBQUc1QyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsUUFBUSxHQUFHLFVBQVMsU0FBUyxFQUFFO0FBQ3pELE1BQUksR0FBRyxHQUFHLDhEQUE4RCxDQUFDO0FBQ3pFLE1BQU0sUUFBUSxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7O0FBRTdCLE1BQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUNmLE9BQUcsSUFBSSx1QkFBdUIsQ0FBQztBQUMvQixZQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztHQUM1QixNQUFNO0FBQ0wsT0FBRyxJQUFJLG9DQUFvQyxDQUFDO0dBQzdDOztBQUVELE1BQUksQ0FBQyxTQUFTLENBQUM7QUFDYixPQUFHLEVBQUgsR0FBRztBQUNILFlBQVEsRUFBUixRQUFRO0FBQ1IsVUFBTSxFQUFBLGdCQUFDLElBQUksRUFBRTtBQUNYLGFBQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0tBQzdCO0dBQ0YsQ0FBQyxDQUFDO0NBQ0osQ0FBQzs7O0FBR0YsaUJBQWlCLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxVQUFTLFNBQVMsRUFBRSxVQUFVLEVBQUU7QUFDdEUsTUFBSSxHQUFHLEdBQUcsbUZBQW1GLENBQUM7QUFDOUYsTUFBTSxRQUFRLEdBQUcsQ0FBQyxTQUFTLEVBQUUsVUFBVSxDQUFDLENBQUM7O0FBRXpDLE1BQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUNmLE9BQUcs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LENBQUMsQ0FBRyxDQUFDO0NBQ3hGLENBQUM7O3FCQUVhLGlCQUFpQiIsImZpbGUiOiJjb21waWxlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFBvc3RncmVTUUwgU2NoZW1hIENvbXBpbGVyXG4vLyAtLS0tLS0tXG5cblxuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcbmltcG9ydCBTY2hlbWFDb21waWxlciBmcm9tICcuLi8uLi8uLi9zY2hlbWEvY29tcGlsZXInO1xuXG5mdW5jdGlvbiBTY2hlbWFDb21waWxlcl9QRygpIHtcbiAgU2NoZW1hQ29tcGlsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmluaGVyaXRzKFNjaGVtYUNvbXBpbGVyX1BHLCBTY2hlbWFDb21waWxlcik7XG5cbi8vIENoZWNrIHdoZXRoZXIgdGhlIGN1cnJlbnQgdGFibGVcblNjaGVtYUNvbXBpbGVyX1BHLnByb3RvdHlwZS5oYXNUYWJsZSA9IGZ1bmN0aW9uKHRhYmxlTmFtZSkge1xuICBsZXQgc3FsID0gJ3NlbGVjdCAqIGZyb20gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlcyB3aGVyZSB0YWJsZV9uYW1lID0gPyc7XG4gIGNvbnN0IGJpbmRpbmdzID0gW3RhYmxlTmFtZV07XG5cbiAgaWYgKHRoaXMuc2NoZW1hKSB7XG4gICAgc3FsICs9ICcgYW5kIHRhYmxlX3NjaGVtYSA9ID8nO1xuICAgIGJpbmRpbmdzLnB1c2godGhpcy5zY2hlbWEpO1xuICB9IGVsc2Uge1xuICAgIHNxbCArPSAnIGFuZCB0YWJsZV9zY2hlbWEgPSBjdXJyZW50X3NjaGVtYSc7XG4gIH1cblxuICB0aGlzLnB1c2hRdWVyeSh7XG4gICAgc3FsLFxuICAgIGJpbmRpbmdzLFxuICAgIG91dHB1dChyZXNwKSB7XG4gICAgICByZXR1cm4gcmVzcC5yb3dzLmxlbmd0aCA+IDA7XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIENvbXBpbGUgdGhlIHF1ZXJ5IHRvIGRldGVybWluZSBpZiBhIGNvbHVtbiBleGlzdHMgaW4gYSB0YWJsZS5cblNjaGVtYUNvbXBpbGVyX1BHLnByb3RvdHlwZS5oYXNDb2x1bW4gPSBmdW5jdGlvbih0YWJsZU5hbWUsIGNvbHVtbk5hbWUpIHtcbiAgbGV0IHNxbCA9ICdzZWxlY3QgKiBmcm9tIGluZm9ybWF0aW9uX3NjaGVtYS5jb2x1bW5zIHdoZXJlIHRhYmxlX25hbWUgPSA/IGFuZCBjb2x1bW5fbmFtZSA9ID8nO1xuICBjb25zdCBiaW5kaW5ncyA9IFt0YWJsZU5hbWUsIGNvbHVtbk5hbWVdO1xuXG4gIGlmICh0aGlzLnNjaGVtYSkge1xuICAgIHNxbCArPSAnIGFuZCB0YWJsZV9zY2hlbWEgPSA/JztcbiAgICBiaW5kaW5ncy5wdXNoKHRoaXMuc2NoZW1hKTtcbiAgfSBlbHNlIHtcbiAgICBzcWwgKz0gJyBhbmQgdGFibGVfc2NoZW1hID0gY3VycmVudF9zY2hlbWEnO1xuICB9XG5cbiAgdGhpcy5wdXNoUXVlcnkoe1xuICAgIHNxbCxcbiAgICBiaW5kaW5ncyxcbiAgICBvdXRwdXQocmVzcCkge1xuICAgICAgcmV0dXJuIHJlc3Aucm93cy5sZW5ndGggPiAwO1xuICAgIH1cbiAgfSk7XG59O1xuXG5TY2hlbWFDb21waWxlcl9QRy5wcm90b3R5cGUucXVhbGlmaWVkVGFibGVOYW1lID0gZnVuY3Rpb24odGFibGVOYW1lKSB7XG4gIGNvbnN0IG5hbWUgPSB0aGlzLnNjaGVtYSA/IGAke3RoaXMuc2NoZW1hfS4ke3RhYmxlTmFtZX1gIDogdGFibGVOYW1lO1xuICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIud3JhcChuYW1lKTtcbn07XG5cbi8vIENvbXBpbGUgYSByZW5hbWUgdGFibGUgY29tbWFuZC5cblNjaGVtYUNvbXBpbGVyX1BHLnByb3RvdHlwZS5yZW5hbWVUYWJsZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIHRoaXMucHVzaFF1ZXJ5KFxuICAgIGBhbHRlciB0YWJsZSAke3RoaXMucXVhbGlmaWVkVGFibGVOYW1lKGZyb20pfSByZW5hbWUgdG8gJHt0aGlzLmZvcm1hdHRlci53cmFwKHRvKX1gXG4gICk7XG59O1xuXG5TY2hlbWFDb21waWxlcl9QRy5wcm90b3R5cGUuY3JlYXRlU2NoZW1hID0gZnVuY3Rpb24oc2NoZW1hTmFtZSkge1xuICB0aGlzLnB1c2hRdWVyeShgY3JlYXRlIHNjaGVtYSAke3RoaXMuZm9ybWF0dGVyLndyYXAoc2NoZW1hTmFtZSl9YCk7XG59O1xuXG5TY2hlbWFDb21waWxlcl9QRy5wcm90b3R5cGUuY3JlYXRlU2NoZW1hSWZOb3RFeGlzdHMgPSBmdW5jdGlvbihzY2hlbWFOYW1lKSB7XG4gIHRoaXMucHVzaFF1ZXJ5KGBjcmVhdGUgc2NoZW1hIGlmIG5vdCBleGlzdHMgJHt0aGlzLmZvcm1hdHRlci53cmFwKHNjaGVtYU5hbWUpfWApO1xufTtcblxuU2NoZW1hQ29tcGlsZXJfUEcucHJvdG90eXBlLmRyb3BTY2hlbWEgPSBmdW5jdGlvbihzY2hlbWFOYW1lKSB7XG4gIHRoaXMucHVzaFF1ZXJ5KGBkcm9wIHNjaGVtYSAke3RoaXMuZm9ybWF0dGVyLndyYXAoc2NoZW1hTmFtZSl9YCk7XG59O1xuXG5TY2hlbWFDb21waWxlcl9QRy5wcm90b3R5cGUuZHJvcFNjaGVtYUlmRXhpc3RzID0gZnVuY3Rpb24oc2NoZW1hTmFtZSkge1xuICB0aGlzLnB1c2hRdWVyeShgZHJvcCBzY2hlbWEgaWYgZXhpc3RzICR7dGhpcy5mb3JtYXR0ZXIud3JhcChzY2hlbWFOYW1lKX1gKTtcbn07XG5cblNjaGVtYUNvbXBpbGVyX1BHLnByb3RvdHlwZS5kcm9wRXh0ZW5zaW9uID0gZnVuY3Rpb24oZXh0ZW5zaW9uTmFtZSkge1xuICB0aGlzLnB1c2hRdWVyeShgZHJvcCBleHRlbnNpb24gJHt0aGlzLmZvcm1hdHRlci53cmFwKGV4dGVuc2lvbk5hbWUpfWApO1xufTtcblxuU2NoZW1hQ29tcGlsZXJfUEcucHJvdG90eXBlLmRyb3BFeHRlbnNpb25JZkV4aXN0cyA9IGZ1bmN0aW9uKGV4dGVuc2lvbk5hbWUpIHtcbiAgdGhpcy5wdXNoUXVlcnkoYGRyb3AgZXh0ZW5zaW9uIGlmIGV4aXN0cyAke3RoaXMuZm9ybWF0dGVyLndyYXAoZXh0ZW5zaW9uTmFtZSl9YCk7XG59O1xuXG5TY2hlbWFDb21waWxlcl9QRy5wcm90b3R5cGUuY3JlYXRlRXh0ZW5zaW9uID0gZnVuY3Rpb24oZXh0ZW5zaW9uTmFtZSkge1xuICB0aGlzLnB1c2hRdWVyeShgY3JlYXRlIGV4dGVuc2lvbiAke3RoaXMuZm9ybWF0dGVyLndyYXAoZXh0ZW5zaW9uTmFtZSl9YCk7XG59O1xuXG5TY2hlbWFDb21waWxlcl9QRy5wcm90b3R5cGUuY3JlYXRlRXh0ZW5zaW9uSWZOb3RFeGlzdHMgPSBmdW5jdGlvbihleHRlbnNpb25OYW1lKSB7XG4gIHRoaXMucHVzaFF1ZXJ5KGBjcmVhdGUgZXh0ZW5zaW9uIGlmIG5vdCBleGlzdHMgJHt0aGlzLmZvcm1hdHRlci53cmFwKGV4dGVuc2lvbk5hbWUpfWApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgU2NoZW1hQ29tcGlsZXJfUEc7XG4iXX0=

/***/ },
/* 131 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 132 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	
	// SQLite3
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _promise = __webpack_require__(43);

	var _promise2 = _interopRequireDefault(_promise);

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _lodash = __webpack_require__(5);

	var _client = __webpack_require__(42);

	var _client2 = _interopRequireDefault(_client);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _queryCompiler = __webpack_require__(134);

	var _queryCompiler2 = _interopRequireDefault(_queryCompiler);

	var _schemaCompiler = __webpack_require__(135);

	var _schemaCompiler2 = _interopRequireDefault(_schemaCompiler);

	var _schemaColumncompiler = __webpack_require__(136);

	var _schemaColumncompiler2 = _interopRequireDefault(_schemaColumncompiler);

	var _schemaTablecompiler = __webpack_require__(137);

	var _schemaTablecompiler2 = _interopRequireDefault(_schemaTablecompiler);

	var _schemaDdl = __webpack_require__(138);

	var _schemaDdl2 = _interopRequireDefault(_schemaDdl);

	function Client_SQLite3(config) {
	  _client2['default'].call(this, config);
	  if (_lodash.isUndefined(config.useNullAsDefault)) {
	    helpers.warn('sqlite does not support inserting default values. Set the ' + '`useNullAsDefault` flag to hide this warning. ' + '(see docs http://knexjs.org/#Builder-insert).');
	  }
	}
	_inherits2['default'](Client_SQLite3, _client2['default']);

	_lodash.assign(Client_SQLite3.prototype, {

	  dialect: 'sqlite3',

	  driverName: 'sqlite3',

	  _driver: function _driver() {
	    return __webpack_require__(139);
	  },

	  SchemaCompiler: _schemaCompiler2['default'],

	  QueryCompiler: _queryCompiler2['default'],

	  ColumnCompiler: _schemaColumncompiler2['default'],

	  TableCompiler: _schemaTablecompiler2['default'],

	  ddl: function ddl(compiler, pragma, connection) {
	    return new _schemaDdl2['default'](this, compiler, pragma, connection);
	  },

	  // Get a raw connection from the database, returning a promise with the connection object.
	  acquireRawConnection: function acquireRawConnection() {
	    var client = this;
	    return new _promise2['default'](function (resolve, reject) {
	      var db = new client.driver.Database(client.connectionSettings.filename, function (err) {
	        if (err) return reject(err);
	        resolve(db);
	      });
	    });
	  },

	  // Used to explicitly close a connection, called internally by the pool when
	  // a connection times out or the pool is shutdown.
	  destroyRawConnection: function destroyRawConnection(connection, cb) {
	    connection.close();
	    cb();
	  },

	  // Runs the query on the specified connection, providing the bindings and any
	  // other necessary prep work.
	  _query: function _query(connection, obj) {
	    var method = obj.method;

	    var callMethod = undefined;
	    switch (method) {
	      case 'insert':
	      case 'update':
	      case 'counter':
	      case 'del':
	        callMethod = 'run';
	        break;
	      default:
	        callMethod = 'all';
	    }
	    return new _promise2['default'](function (resolver, rejecter) {
	      if (!connection || !connection[callMethod]) {
	        return rejecter(new Error('Error calling ' + callMethod + ' on connection.'));
	      }
	      connection[callMethod](obj.sql, obj.bindings, function (err, response) {
	        if (err) return rejecter(err);
	        obj.response = response;

	        // We need the context here, as it contains
	        // the "this.lastID" or "this.changes"
	        obj.context = this;
	        return resolver(obj);
	      });
	    });
	  },

	  _stream: function _stream(connection, sql, stream) {
	    var client = this;
	    return new _promise2['default'](function (resolver, rejecter) {
	      stream.on('error', rejecter);
	      stream.on('end', resolver);
	      return client._query(connection, sql).then(function (obj) {
	        return obj.response;
	      }).map(function (row) {
	        stream.write(row);
	      })['catch'](function (err) {
	        stream.emit('error', err);
	      }).then(function () {
	        stream.end();
	      });
	    });
	  },

	  // Ensures the response is returned in the same format as other clients.
	  processResponse: function processResponse(obj, runner) {
	    var ctx = obj.context;
	    var response = obj.response;

	    if (obj.output) return obj.output.call(runner, response);
	    switch (obj.method) {
	      case 'select':
	      case 'pluck':
	      case 'first':
	        response = helpers.skim(response);
	        if (obj.method === 'pluck') response = _lodash.map(response, obj.pluck);
	        return obj.method === 'first' ? response[0] : response;
	      case 'insert':
	        return [ctx.lastID];
	      case 'del':
	      case 'update':
	      case 'counter':
	        return ctx.changes;
	      default:
	        return response;
	    }
	  },

	  poolDefaults: function poolDefaults(config) {
	    return _lodash.assign(_client2['default'].prototype.poolDefaults.call(this, config), {
	      min: 1,
	      max: 1
	    });
	  },

	  ping: function ping(resource, callback) {
	    resource.each('SELECT 1', callback);
	  }

	});

	exports['default'] = Client_SQLite3;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy9zcWxpdGUzL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O3VCQUdvQixlQUFlOzs7O3dCQUVkLFVBQVU7Ozs7c0JBQ1UsUUFBUTs7c0JBRTlCLGNBQWM7Ozs7dUJBQ1IsZUFBZTs7SUFBNUIsT0FBTzs7NkJBRU8sa0JBQWtCOzs7OzhCQUNqQixtQkFBbUI7Ozs7b0NBQ25CLHlCQUF5Qjs7OzttQ0FDMUIsd0JBQXdCOzs7O3lCQUMxQixjQUFjOzs7O0FBRXRDLFNBQVMsY0FBYyxDQUFDLE1BQU0sRUFBRTtBQUM5QixzQkFBTyxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFBO0FBQ3pCLE1BQUksb0JBQVksTUFBTSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7QUFDeEMsV0FBTyxDQUFDLElBQUksQ0FDViw0REFBNEQsR0FDNUQsZ0RBQWdELEdBQ2hELCtDQUErQyxDQUNoRCxDQUFDO0dBQ0g7Q0FDRjtBQUNELHNCQUFTLGNBQWMsc0JBQVMsQ0FBQTs7QUFFaEMsZUFBTyxjQUFjLENBQUMsU0FBUyxFQUFFOztBQUUvQixTQUFPLEVBQUUsU0FBUzs7QUFFbEIsWUFBVSxFQUFFLFNBQVM7O0FBRXJCLFNBQU8sRUFBQSxtQkFBRztBQUNSLFdBQU8sT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFBO0dBQzFCOztBQUVELGdCQUFjLDZCQUFBOztBQUVkLGVBQWEsNEJBQUE7O0FBRWIsZ0JBQWMsbUNBQUE7O0FBRWQsZUFBYSxrQ0FBQTs7QUFFYixLQUFHLEVBQUEsYUFBQyxRQUFRLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRTtBQUNoQyxXQUFPLDJCQUFnQixJQUFJLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQTtHQUMzRDs7O0FBR0Qsc0JBQW9CLEVBQUEsZ0NBQUc7QUFDckIsUUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDO0FBQ3BCLFdBQU8seUJBQVksVUFBUyxP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WyJcbi8vIFNRTGl0ZTNcbi8vIC0tLS0tLS1cbmltcG9ydCBQcm9taXNlIGZyb20gJy4uLy4uL3Byb21pc2UnO1xuXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuaW1wb3J0IHsgaXNVbmRlZmluZWQsIG1hcCwgYXNzaWduIH0gZnJvbSAnbG9kYXNoJ1xuXG5pbXBvcnQgQ2xpZW50IGZyb20gJy4uLy4uL2NsaWVudCc7XG5pbXBvcnQgKiBhcyBoZWxwZXJzIGZyb20gJy4uLy4uL2hlbHBlcnMnO1xuXG5pbXBvcnQgUXVlcnlDb21waWxlciBmcm9tICcuL3F1ZXJ5L2NvbXBpbGVyJztcbmltcG9ydCBTY2hlbWFDb21waWxlciBmcm9tICcuL3NjaGVtYS9jb21waWxlcic7XG5pbXBvcnQgQ29sdW1uQ29tcGlsZXIgZnJvbSAnLi9zY2hlbWEvY29sdW1uY29tcGlsZXInO1xuaW1wb3J0IFRhYmxlQ29tcGlsZXIgZnJvbSAnLi9zY2hlbWEvdGFibGVjb21waWxlcic7XG5pbXBvcnQgU1FMaXRlM19EREwgZnJvbSAnLi9zY2hlbWEvZGRsJztcblxuZnVuY3Rpb24gQ2xpZW50X1NRTGl0ZTMoY29uZmlnKSB7XG4gIENsaWVudC5jYWxsKHRoaXMsIGNvbmZpZylcbiAgaWYgKGlzVW5kZWZpbmVkKGNvbmZpZy51c2VOdWxsQXNEZWZhdWx0KSkge1xuICAgIGhlbHBlcnMud2FybihcbiAgICAgICdzcWxpdGUgZG9lcyBub3Qgc3VwcG9ydCBpbnNlcnRpbmcgZGVmYXVsdCB2YWx1ZXMuIFNldCB0aGUgJyArXG4gICAgICAnYHVzZU51bGxBc0RlZmF1bHRgIGZsYWcgdG8gaGlkZSB0aGlzIHdhcm5pbmcuICcgK1xuICAgICAgJyhzZWUgZG9jcyBodHRwOi8va25leGpzLm9yZy8jQnVpbGRlci1pbnNlcnQpLidcbiAgICApO1xuICB9XG59XG5pbmhlcml0cyhDbGllbnRfU1FMaXRlMywgQ2xpZW50KVxuXG5hc3NpZ24oQ2xpZW50X1NRTGl0ZTMucHJvdG90eXBlLCB7XG5cbiAgZGlhbGVjdDogJ3NxbGl0ZTMnLFxuXG4gIGRyaXZlck5hbWU6ICdzcWxpdGUzJyxcblxuICBfZHJpdmVyKCkge1xuICAgIHJldHVybiByZXF1aXJlKCdzcWxpdGUzJylcbiAgfSxcblxuICBTY2hlbWFDb21waWxlcixcblxuICBRdWVyeUNvbXBpbGVyLFxuXG4gIENvbHVtbkNvbXBpbGVyLFxuXG4gIFRhYmxlQ29tcGlsZXIsXG5cbiAgZGRsKGNvbXBpbGVyLCBwcmFnbWEsIGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gbmV3IFNRTGl0ZTNfRERMKHRoaXMsIGNvbXBpbGVyLCBwcmFnbWEsIGNvbm5lY3Rpb24pXG4gIH0sXG5cbiAgLy8gR2V0IGEgcmF3IGNvbm5lY3Rpb24gZnJvbSB0aGUgZGF0YWJhc2UsIHJldHVybmluZyBhIHByb21pc2Ugd2l0aCB0aGUgY29ubmVjdGlvbiBvYmplY3QuXG4gIGFjcXVpcmVSYXdDb25uZWN0aW9uKCkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgY29uc3QgZGIgPSBuZXcgY2xpZW50LmRyaXZlci5EYXRhYmFzZShjbGllbnQuY29ubmVjdGlvblNldHRpbmdzLmZpbGVuYW1lLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICAgIHJlc29sdmUoZGIpXG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG5cbiAgLy8gVXNlZCB0byBleHBsaWNpdGx5IGNsb3NlIGEgY29ubmVjdGlvbiwgY2FsbGVkIGludGVybmFsbHkgYnkgdGhlIHBvb2wgd2hlblxuICAvLyBhIGNvbm5lY3Rpb24gdGltZXMgb3V0IG9yIHRoZSBwb29sIGlzIHNodXRkb3duLlxuICBkZXN0cm95UmF3Q29ubmVjdGlvbihjb25uZWN0aW9uLCBjYikge1xuICAgIGNvbm5lY3Rpb24uY2xvc2UoKVxuICAgIGNiKClcbiAgfSxcblxuICAvLyBSdW5zIHRoZSBxdWVyeSBvbiB0aGUgc3BlY2lmaWVkIGNvbm5lY3Rpb24sIHByb3ZpZGluZyB0aGUgYmluZGluZ3MgYW5kIGFueVxuICAvLyBvdGhlciBuZWNlc3NhcnkgcHJlcCB3b3JrLlxuICBfcXVlcnkoY29ubmVjdGlvbiwgb2JqKSB7XG4gICAgY29uc3QgeyBtZXRob2QgfSA9IG9iajtcbiAgICBsZXQgY2FsbE1ldGhvZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAnaW5zZXJ0JzpcbiAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICBjYXNlICdjb3VudGVyJzpcbiAgICAgIGNhc2UgJ2RlbCc6XG4gICAgICAgIGNhbGxNZXRob2QgPSAncnVuJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjYWxsTWV0aG9kID0gJ2FsbCc7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlciwgcmVqZWN0ZXIpIHtcbiAgICAgIGlmICghY29ubmVjdGlvbiB8fCAhY29ubmVjdGlvbltjYWxsTWV0aG9kXSkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZXIobmV3IEVycm9yKGBFcnJvciBjYWxsaW5nICR7Y2FsbE1ldGhvZH0gb24gY29ubmVjdGlvbi5gKSlcbiAgICAgIH1cbiAgICAgIGNvbm5lY3Rpb25bY2FsbE1ldGhvZF0ob2JqLnNxbCwgb2JqLmJpbmRpbmdzLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3RlcihlcnIpXG4gICAgICAgIG9iai5yZXNwb25zZSA9IHJlc3BvbnNlO1xuXG4gICAgICAgIC8vIFdlIG5lZWQgdGhlIGNvbnRleHQgaGVyZSwgYXMgaXQgY29udGFpbnNcbiAgICAgICAgLy8gdGhlIFwidGhpcy5sYXN0SURcIiBvciBcInRoaXMuY2hhbmdlc1wiXG4gICAgICAgIG9iai5jb250ZXh0ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHJlc29sdmVyKG9iailcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcblxuICBfc3RyZWFtKGNvbm5lY3Rpb24sIHNxbCwgc3RyZWFtKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZXIsIHJlamVjdGVyKSB7XG4gICAgICBzdHJlYW0ub24oJ2Vycm9yJywgcmVqZWN0ZXIpXG4gICAgICBzdHJlYW0ub24oJ2VuZCcsIHJlc29sdmVyKVxuICAgICAgcmV0dXJuIGNsaWVudC5fcXVlcnkoY29ubmVjdGlvbiwgc3FsKS50aGVuKG9iaiA9PiBvYmoucmVzcG9uc2UpLm1hcChmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgc3RyZWFtLndyaXRlKHJvdylcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0uZW5kKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcblxuICAvLyBFbnN1cmVzIHRoZSByZXNwb25zZSBpcyByZXR1cm5lZCBpbiB0aGUgc2FtZSBmb3JtYXQgYXMgb3RoZXIgY2xpZW50cy5cbiAgcHJvY2Vzc1Jlc3BvbnNlKG9iaiwgcnVubmVyKSB7XG4gICAgY29uc3QgY3R4ID0gb2JqLmNvbnRleHQ7XG4gICAgbGV0IHsgcmVzcG9uc2UgfSA9IG9iajtcbiAgICBpZiAob2JqLm91dHB1dCkgcmV0dXJuIG9iai5vdXRwdXQuY2FsbChydW5uZXIsIHJlc3BvbnNlKVxuICAgIHN3aXRjaCAob2JqLm1ldGhvZCkge1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGNhc2UgJ3BsdWNrJzpcbiAgICAgIGNhc2UgJ2ZpcnN0JzpcbiAgICAgICAgcmVzcG9uc2UgPSBoZWxwZXJzLnNraW0ocmVzcG9uc2UpXG4gICAgICAgIGlmIChvYmoubWV0aG9kID09PSAncGx1Y2snKSByZXNwb25zZSA9IG1hcChyZXNwb25zZSwgb2JqLnBsdWNrKVxuICAgICAgICByZXR1cm4gb2JqLm1ldGhvZCA9PT0gJ2ZpcnN0JyA/IHJlc3BvbnNlWzBdIDogcmVzcG9uc2U7XG4gICAgICBjYXNlICdpbnNlcnQnOlxuICAgICAgICByZXR1cm4gW2N0eC5sYXN0SURdO1xuICAgICAgY2FzZSAnZGVsJzpcbiAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICBjYXNlICdjb3VudGVyJzpcbiAgICAgICAgcmV0dXJuIGN0eC5jaGFuZ2VzO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgfSxcblxuICBwb29sRGVmYXVsdHMoY29uZmlnKSB7XG4gICAgcmV0dXJuIGFzc2lnbihDbGllbnQucHJvdG90eXBlLnBvb2xEZWZhdWx0cy5jYWxsKHRoaXMsIGNvbmZpZyksIHtcbiAgICAgIG1pbjogMSxcbiAgICAgIG1heDogMVxuICAgIH0pXG4gIH0sXG5cbiAgcGluZyhyZXNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICByZXNvdXJjZS5lYWNoKCdTRUxFQ1QgMScsIGNhbGxiYWNrKTtcbiAgfVxuXG59KVxuXG5leHBvcnQgZGVmYXVsdCBDbGllbnRfU1FMaXRlM1xuIl19

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	
	// SQLite3 Query Builder & Compiler

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _queryCompiler = __webpack_require__(75);

	var _queryCompiler2 = _interopRequireDefault(_queryCompiler);

	var _lodash = __webpack_require__(5);

	function QueryCompiler_SQLite3(client, builder) {
	  _queryCompiler2['default'].call(this, client, builder);
	}
	_inherits2['default'](QueryCompiler_SQLite3, _queryCompiler2['default']);

	_lodash.assign(QueryCompiler_SQLite3.prototype, {

	  // The locks are not applicable in SQLite3
	  forShare: emptyStr,

	  forUpdate: emptyStr,

	  // SQLite requires us to build the multi-row insert as a listing of select with
	  // unions joining them together. So we'll build out this list of columns and
	  // then join them all together with select unions to complete the queries.
	  insert: function insert() {
	    var insertValues = this.single.insert || [];
	    var sql = 'insert into ' + this.tableName + ' ';

	    if (Array.isArray(insertValues)) {
	      if (insertValues.length === 0) {
	        return '';
	      } else if (insertValues.length === 1 && insertValues[0] && _lodash.isEmpty(insertValues[0])) {
	        return sql + this._emptyInsertValue;
	      }
	    } else if (typeof insertValues === 'object' && _lodash.isEmpty(insertValues)) {
	      return sql + this._emptyInsertValue;
	    }

	    var insertData = this._prepInsert(insertValues);

	    if (_lodash.isString(insertData)) {
	      return sql + insertData;
	    }

	    if (insertData.columns.length === 0) {
	      return '';
	    }

	    sql += '(' + this.formatter.columnize(insertData.columns) + ')';

	    // backwards compatible error
	    if (this.client.valueForUndefined !== null) {
	      _lodash.each(insertData.values, function (bindings) {
	        _lodash.each(bindings, function (binding) {
	          if (binding === undefined) throw new TypeError('`sqlite` does not support inserting default values. Specify ' + 'values explicitly or use the `useNullAsDefault` config flag. ' + '(see docs http://knexjs.org/#Builder-insert).');
	        });
	      });
	    }

	    if (insertData.values.length === 1) {
	      var parameters = this.formatter.parameterize(insertData.values[0], this.client.valueForUndefined);
	      return sql + (' values (' + parameters + ')');
	    }

	    var blocks = [];
	    var i = -1;
	    while (++i < insertData.values.length) {
	      var i2 = -1;
	      var block = blocks[i] = [];
	      var current = insertData.values[i];
	      current = current === undefined ? this.client.valueForUndefined : current;
	      while (++i2 < insertData.columns.length) {
	        block.push(this.formatter.alias(this.formatter.parameter(current[i2]), this.formatter.wrap(insertData.columns[i2])));
	      }
	      blocks[i] = block.join(', ');
	    }
	    return sql + ' select ' + blocks.join(' union all select ');
	  },

	  // Compile a truncate table statement into SQL.
	  truncate: function truncate() {
	    var table = this.tableName;
	    return {
	      sql: 'delete from ' + table,
	      output: function output() {
	        return this.query({
	          sql: 'delete from sqlite_sequence where name = ' + table
	        })['catch'](_lodash.noop);
	      }
	    };
	  },

	  // Compiles a `columnInfo` query
	  columnInfo: function columnInfo() {
	    var column = this.single.columnInfo;
	    return {
	      sql: 'PRAGMA table_info(' + this.single.table + ')',
	      output: function output(resp) {
	        var maxLengthRegex = /.*\((\d+)\)/;
	        var out = _lodash.reduce(resp, function (columns, val) {
	          var type = val.type;

	          var maxLength = (maxLength = type.match(maxLengthRegex)) && maxLength[1];
	          type = maxLength ? type.split('(')[0] : type;
	          columns[val.name] = {
	            type: type.toLowerCase(),
	            maxLength: maxLength,
	            nullable: !val.notnull,
	            defaultValue: val.dflt_value
	          };
	          return columns;
	        }, {});
	        return column && out[column] || out;
	      }
	    };
	  },

	  limit: function limit() {
	    var noLimit = !this.single.limit && this.single.limit !== 0;
	    if (noLimit && !this.single.offset) return '';

	    // Workaround for offset only,
	    // see http://stackoverflow.com/questions/10491492/sqllite-with-skip-offset-only-not-limit
	    return 'limit ' + this.formatter.parameter(noLimit ? -1 : this.single.limit);
	  }

	});

	function emptyStr() {
	  return '';
	}

	exports['default'] = QueryCompiler_SQLite3;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9zcWxpdGUzL3F1ZXJ5L2NvbXBpbGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozt3QkFHcUIsVUFBVTs7Ozs2QkFDTCx5QkFBeUI7Ozs7c0JBQ1csUUFBUTs7QUFFdEUsU0FBUyxxQkFBcUIsQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFO0FBQzlDLDZCQUFjLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFBO0NBQzFDO0FBQ0Qsc0JBQVMscUJBQXFCLDZCQUFnQixDQUFBOztBQUU5QyxlQUFPLHFCQUFxQixDQUFDLFNBQVMsRUFBRTs7O0FBR3RDLFVBQVEsRUFBRyxRQUFROztBQUVuQixXQUFTLEVBQUUsUUFBUTs7Ozs7QUFLbkIsUUFBTSxFQUFBLGtCQUFHO0FBQ1AsUUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFBO0FBQzdDLFFBQUksR0FBRyxvQkFBa0IsSUFBSSxDQUFDLFNBQVMsTUFBRyxDQUFBOztBQUUxQyxRQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEVBQUU7QUFDL0IsVUFBSSxZQUFZLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtBQUM3QixlQUFPLEVBQUUsQ0FBQTtPQUNWLE1BQ0ksSUFBSSxZQUFZLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksZ0JBQVEsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7QUFDakYsZUFBTyxHQUFHLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFBO09BQ3BDO0tBQ0YsTUFBTSxJQUFJLE9BQU8sWUFBWSxLQUFLLFFBQVEsSUFBSSxnQkFBUSxZQUFZLENBQUMsRUFBRTtBQUNwRSxhQUFPLEdBQUcsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUE7S0FDcEM7O0FBRUQsUUFBTSxVQUFVLEdBQUcsSUFB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QUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBRTtHQUM3RTs7Q0FFRixDQUFDLENBQUE7O0FBRUYsU0FBUyxRQUFRLEdBQUc7QUFDbEIsU0FBTyxFQUFFLENBQUE7Q0FDVjs7cUJBR2MscUJBQXFCIiwiZmlsZSI6ImNvbXBpbGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBTUUxpdGUzIFF1ZXJ5IEJ1aWxkZXIgJiBDb21waWxlclxuXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuaW1wb3J0IFF1ZXJ5Q29tcGlsZXIgZnJvbSAnLi4vLi4vLi4vcXVlcnkvY29tcGlsZXInO1xuaW1wb3J0IHsgYXNzaWduLCBlYWNoLCBpc0VtcHR5LCBpc1N0cmluZywgbm9vcCwgcmVkdWNlIH0gZnJvbSAnbG9kYXNoJ1xuXG5mdW5jdGlvbiBRdWVyeUNvbXBpbGVyX1NRTGl0ZTMoY2xpZW50LCBidWlsZGVyKSB7XG4gIFF1ZXJ5Q29tcGlsZXIuY2FsbCh0aGlzLCBjbGllbnQsIGJ1aWxkZXIpXG59XG5pbmhlcml0cyhRdWVyeUNvbXBpbGVyX1NRTGl0ZTMsIFF1ZXJ5Q29tcGlsZXIpXG5cbmFzc2lnbihRdWVyeUNvbXBpbGVyX1NRTGl0ZTMucHJvdG90eXBlLCB7XG5cbiAgLy8gVGhlIGxvY2tzIGFyZSBub3QgYXBwbGljYWJsZSBpbiBTUUxpdGUzXG4gIGZvclNoYXJlOiAgZW1wdHlTdHIsXG5cbiAgZm9yVXBkYXRlOiBlbXB0eVN0cixcblxuICAvLyBTUUxpdGUgcmVxdWlyZXMgdXMgdG8gYnVpbGQgdGhlIG11bHRpLXJvdyBpbnNlcnQgYXMgYSBsaXN0aW5nIG9mIHNlbGVjdCB3aXRoXG4gIC8vIHVuaW9ucyBqb2luaW5nIHRoZW0gdG9nZXRoZXIuIFNvIHdlJ2xsIGJ1aWxkIG91dCB0aGlzIGxpc3Qgb2YgY29sdW1ucyBhbmRcbiAgLy8gdGhlbiBqb2luIHRoZW0gYWxsIHRvZ2V0aGVyIHdpdGggc2VsZWN0IHVuaW9ucyB0byBjb21wbGV0ZSB0aGUgcXVlcmllcy5cbiAgaW5zZXJ0KCkge1xuICAgIGNvbnN0IGluc2VydFZhbHVlcyA9IHRoaXMuc2luZ2xlLmluc2VydCB8fCBbXVxuICAgIGxldCBzcWwgPSBgaW5zZXJ0IGludG8gJHt0aGlzLnRhYmxlTmFtZX0gYFxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5zZXJ0VmFsdWVzKSkge1xuICAgICAgaWYgKGluc2VydFZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpbnNlcnRWYWx1ZXMubGVuZ3RoID09PSAxICYmIGluc2VydFZhbHVlc1swXSAmJiBpc0VtcHR5KGluc2VydFZhbHVlc1swXSkpIHtcbiAgICAgICAgcmV0dXJuIHNxbCArIHRoaXMuX2VtcHR5SW5zZXJ0VmFsdWVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnNlcnRWYWx1ZXMgPT09ICdvYmplY3QnICYmIGlzRW1wdHkoaW5zZXJ0VmFsdWVzKSkge1xuICAgICAgcmV0dXJuIHNxbCArIHRoaXMuX2VtcHR5SW5zZXJ0VmFsdWVcbiAgICB9XG5cbiAgICBjb25zdCBpbnNlcnREYXRhID0gdGhpcy5fcHJlcEluc2VydChpbnNlcnRWYWx1ZXMpXG5cbiAgICBpZiAoaXNTdHJpbmcoaW5zZXJ0RGF0YSkpIHtcbiAgICAgIHJldHVybiBzcWwgKyBpbnNlcnREYXRhXG4gICAgfVxuXG4gICAgaWYgKGluc2VydERhdGEuY29sdW1ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBzcWwgKz0gYCgke3RoaXMuZm9ybWF0dGVyLmNvbHVtbml6ZShpbnNlcnREYXRhLmNvbHVtbnMpfSlgXG5cbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZSBlcnJvclxuICAgIGlmICh0aGlzLmNsaWVudC52YWx1ZUZvclVuZGVmaW5lZCAhPT0gbnVsbCkge1xuICAgICAgZWFjaChpbnNlcnREYXRhLnZhbHVlcywgYmluZGluZ3MgPT4ge1xuICAgICAgICBlYWNoKGJpbmRpbmdzLCBiaW5kaW5nID0+IHtcbiAgICAgICAgICBpZiAoYmluZGluZyA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgJ2BzcWxpdGVgIGRvZXMgbm90IHN1cHBvcnQgaW5zZXJ0aW5nIGRlZmF1bHQgdmFsdWVzLiBTcGVjaWZ5ICcgK1xuICAgICAgICAgICAgJ3ZhbHVlcyBleHBsaWNpdGx5IG9yIHVzZSB0aGUgYHVzZU51bGxBc0RlZmF1bHRgIGNvbmZpZyBmbGFnLiAnICtcbiAgICAgICAgICAgICcoc2VlIGRvY3MgaHR0cDovL2tuZXhqcy5vcmcvI0J1aWxkZXItaW5zZXJ0KS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaW5zZXJ0RGF0YS52YWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdGhpcy5mb3JtYXR0ZXIucGFyYW1ldGVyaXplKFxuICAgICAgICBpbnNlcnREYXRhLnZhbHVlc1swXSwgdGhpcy5jbGllbnQudmFsdWVGb3JVbmRlZmluZWRcbiAgICAgICk7XG4gICAgICByZXR1cm4gc3FsICsgYCB2YWx1ZXMgKCR7cGFyYW1ldGVyc30pYFxuICAgIH1cblxuICAgIGNvbnN0IGJsb2NrcyA9IFtdXG4gICAgbGV0IGkgPSAtMVxuICAgIHdoaWxlICgrK2kgPCBpbnNlcnREYXRhLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIGxldCBpMiA9IC0xO1xuICAgICAgY29uc3QgYmxvY2sgPSBibG9ja3NbaV0gPSBbXTtcbiAgICAgIGxldCBjdXJyZW50ID0gaW5zZXJ0RGF0YS52YWx1ZXNbaV1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50ID09PSB1bmRlZmluZWQgPyB0aGlzLmNsaWVudC52YWx1ZUZvclVuZGVmaW5lZCA6IGN1cnJlbnRcbiAgICAgIHdoaWxlICgrK2kyIDwgaW5zZXJ0RGF0YS5jb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICBibG9jay5wdXNoKHRoaXMuZm9ybWF0dGVyLmFsaWFzKFxuICAgICAgICAgIHRoaXMuZm9ybWF0dGVyLnBhcmFtZXRlcihjdXJyZW50W2kyXSksXG4gICAgICAgICAgdGhpcy5mb3JtYXR0ZXIud3JhcChpbnNlcnREYXRhLmNvbHVtbnNbaTJdKVxuICAgICAgICApKVxuICAgICAgfVxuICAgICAgYmxvY2tzW2ldID0gYmxvY2suam9pbignLCAnKVxuICAgIH1cbiAgICByZXR1cm4gc3FsICsgJyBzZWxlY3QgJyArIGJsb2Nrcy5qb2luKCcgdW5pb24gYWxsIHNlbGVjdCAnKVxuICB9LFxuXG4gIC8vIENvbXBpbGUgYSB0cnVuY2F0ZSB0YWJsZSBzdGF0ZW1lbnQgaW50byBTUUwuXG4gIHRydW5jYXRlKCkge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy50YWJsZU5hbWVcbiAgICByZXR1cm4ge1xuICAgICAgc3FsOiBgZGVsZXRlIGZyb20gJHt0YWJsZX1gLFxuICAgICAgb3V0cHV0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeSh7XG4gICAgICAgICAgc3FsOiBgZGVsZXRlIGZyb20gc3FsaXRlX3NlcXVlbmNlIHdoZXJlIG5hbWUgPSAke3RhYmxlfWBcbiAgICAgICAgfSkuY2F0Y2gobm9vcClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gQ29tcGlsZXMgYSBgY29sdW1uSW5mb2AgcXVlcnlcbiAgY29sdW1uSW5mbygpIHtcbiAgICBjb25zdCBjb2x1bW4gPSB0aGlzLnNpbmdsZS5jb2x1bW5JbmZvXG4gICAgcmV0dXJuIHtcbiAgICAgIHNxbDogYFBSQUdNQSB0YWJsZV9pbmZvKCR7dGhpcy5zaW5nbGUudGFibGV9KWAsXG4gICAgICBvdXRwdXQocmVzcCkge1xuICAgICAgICBjb25zdCBtYXhMZW5ndGhSZWdleCA9IC8uKlxcKChcXGQrKVxcKS9cbiAgICAgICAgY29uc3Qgb3V0ID0gcmVkdWNlKHJlc3AsIGZ1bmN0aW9uIChjb2x1bW5zLCB2YWwpIHtcbiAgICAgICAgICBsZXQgeyB0eXBlIH0gPSB2YWxcbiAgICAgICAgICBsZXQgbWF4TGVuZ3RoID0gKG1heExlbmd0aCA9IHR5cGUubWF0Y2gobWF4TGVuZ3RoUmVnZXgpKSAmJiBtYXhMZW5ndGhbMV1cbiAgICAgICAgICB0eXBlID0gbWF4TGVuZ3RoID8gdHlwZS5zcGxpdCgnKCcpWzBdIDogdHlwZVxuICAgICAgICAgIGNvbHVtbnNbdmFsLm5hbWVdID0ge1xuICAgICAgICAgICAgdHlwZTogdHlwZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgbWF4TGVuZ3RoLFxuICAgICAgICAgICAgbnVsbGFibGU6ICF2YWwubm90bnVsbCxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdmFsLmRmbHRfdmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbHVtbnNcbiAgICAgICAgfSwge30pXG4gICAgICAgIHJldHVybiBjb2x1bW4gJiYgb3V0W2NvbHVtbl0gfHwgb3V0XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGxpbWl0KCkge1xuICAgIGNvbnN0IG5vTGltaXQgPSAhdGhpcy5zaW5nbGUubGltaXQgJiYgdGhpcy5zaW5nbGUubGltaXQgIT09IDBcbiAgICBpZiAobm9MaW1pdCAmJiAhdGhpcy5zaW5nbGUub2Zmc2V0KSByZXR1cm4gJydcblxuICAgIC8vIFdvcmthcm91bmQgZm9yIG9mZnNldCBvbmx5LFxuICAgIC8vIHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNDkxNDkyL3NxbGxpdGUtd2l0aC1za2lwLW9mZnNldC1vbmx5LW5vdC1saW1pdFxuICAgIHJldHVybiBgbGltaXQgJHt0aGlzLmZvcm1hdHRlci5wYXJhbWV0ZXIobm9MaW1pdCA/IC0xIDogdGhpcy5zaW5nbGUubGltaXQpfWBcbiAgfVxuXG59KVxuXG5mdW5jdGlvbiBlbXB0eVN0cigpIHtcbiAgcmV0dXJuICcnXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgUXVlcnlDb21waWxlcl9TUUxpdGUzXG4iXX0=

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	
	// SQLite3: Column Builder & Compiler
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _schemaCompiler = __webpack_require__(77);

	var _schemaCompiler2 = _interopRequireDefault(_schemaCompiler);

	var _lodash = __webpack_require__(5);

	// Schema Compiler
	// -------

	function SchemaCompiler_SQLite3() {
	  _schemaCompiler2['default'].apply(this, arguments);
	}
	_inherits2['default'](SchemaCompiler_SQLite3, _schemaCompiler2['default']);

	// Compile the query to determine if a table exists.
	SchemaCompiler_SQLite3.prototype.hasTable = function (tableName) {
	  var sql = 'select * from sqlite_master ' + ('where type = \'table\' and name = ' + this.formatter.parameter(tableName));
	  this.pushQuery({ sql: sql, output: function output(resp) {
	      return resp.length > 0;
	    } });
	};

	// Compile the query to determine if a column exists.
	SchemaCompiler_SQLite3.prototype.hasColumn = function (tableName, column) {
	  this.pushQuery({
	    sql: 'PRAGMA table_info(' + this.formatter.wrap(tableName) + ')',
	    output: function output(resp) {
	      return _lodash.some(resp, { name: column });
	    }
	  });
	};

	// Compile a rename table command.
	SchemaCompiler_SQLite3.prototype.renameTable = function (from, to) {
	  this.pushQuery('alter table ' + this.formatter.wrap(from) + ' rename to ' + this.formatter.wrap(to));
	};

	exports['default'] = SchemaCompiler_SQLite3;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9zcWxpdGUzL3NjaGVtYS9jb21waWxlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7d0JBR3FCLFVBQVU7Ozs7OEJBQ0osMEJBQTBCOzs7O3NCQUVoQyxRQUFROzs7OztBQUs3QixTQUFTLHNCQUFzQixHQUFHO0FBQ2hDLDhCQUFlLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7Q0FDdkM7QUFDRCxzQkFBUyxzQkFBc0IsOEJBQWlCLENBQUM7OztBQUdqRCxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsUUFBUSxHQUFHLFVBQVMsU0FBUyxFQUFFO0FBQzlELE1BQU0sR0FBRyxHQUNQLHlFQUNtQyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBRSxDQUFDO0FBQzNFLE1BQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxHQUFHLEVBQUgsR0FBRyxFQUFFLE1BQU0sRUFBRSxnQkFBQSxJQUFJO2FBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDO0tBQUEsRUFBRSxDQUFDLENBQUM7Q0FDMUQsQ0FBQzs7O0FBR0Ysc0JBQXNCLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxVQUFTLFNBQVMsRUFBRSxNQUFNLEVBQUU7QUFDdkUsTUFBSSxDQUFDLFNBQVMsQ0FBQztBQUNiLE9BQUcseUJBQXVCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFHO0FBQzNELFVBQU0sRUFBQSxnQkFBQyxJQUFJLEVBQUU7QUFDWCxhQUFPLGFBQUssSUFBSSxFQUFFLEVBQUMsSUFBSSxFQUFFLE1BQU0sRUFBQyxDQUFDLENBQUM7S0FDbkM7R0FDRixDQUFDLENBQUM7Q0FDSixDQUFDOzs7QUFHRixzQkFBc0IsQ0FBQyxTQUFTLENBQUMsV0FBVyxHQUFHLFVBQVMsSUFBSSxFQUFFLEVBQUUsRUFBRTtBQUNoRSxNQUFJLENBQUMsU0FBUyxrQkFBZ0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLG1CQUFjLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFHLENBQUM7Q0FDakcsQ0FBQzs7cUJBRWEsc0JBQXNCIiwiZmlsZSI6ImNvbXBpbGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBTUUxpdGUzOiBDb2x1bW4gQnVpbGRlciAmIENvbXBpbGVyXG4vLyAtLS0tLS0tXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuaW1wb3J0IFNjaGVtYUNvbXBpbGVyIGZyb20gJy4uLy4uLy4uL3NjaGVtYS9jb21waWxlcic7XG5cbmltcG9ydCB7IHNvbWUgfSBmcm9tICdsb2Rhc2gnXG5cbi8vIFNjaGVtYSBDb21waWxlclxuLy8gLS0tLS0tLVxuXG5mdW5jdGlvbiBTY2hlbWFDb21waWxlcl9TUUxpdGUzKCkge1xuICBTY2hlbWFDb21waWxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuaW5oZXJpdHMoU2NoZW1hQ29tcGlsZXJfU1FMaXRlMywgU2NoZW1hQ29tcGlsZXIpO1xuXG4vLyBDb21waWxlIHRoZSBxdWVyeSB0byBkZXRlcm1pbmUgaWYgYSB0YWJsZSBleGlzdHMuXG5TY2hlbWFDb21waWxlcl9TUUxpdGUzLnByb3RvdHlwZS5oYXNUYWJsZSA9IGZ1bmN0aW9uKHRhYmxlTmFtZSkge1xuICBjb25zdCBzcWwgPVxuICAgIGBzZWxlY3QgKiBmcm9tIHNxbGl0ZV9tYXN0ZXIgYCArXG4gICAgYHdoZXJlIHR5cGUgPSAndGFibGUnIGFuZCBuYW1lID0gJHt0aGlzLmZvcm1hdHRlci5wYXJhbWV0ZXIodGFibGVOYW1lKX1gO1xuICB0aGlzLnB1c2hRdWVyeSh7IHNxbCwgb3V0cHV0OiByZXNwID0+IHJlc3AubGVuZ3RoID4gMCB9KTtcbn07XG5cbi8vIENvbXBpbGUgdGhlIHF1ZXJ5IHRvIGRldGVybWluZSBpZiBhIGNvbHVtbiBleGlzdHMuXG5TY2hlbWFDb21waWxlcl9TUUxpdGUzLnByb3RvdHlwZS5oYXNDb2x1bW4gPSBmdW5jdGlvbih0YWJsZU5hbWUsIGNvbHVtbikge1xuICB0aGlzLnB1c2hRdWVyeSh7XG4gICAgc3FsOiBgUFJBR01BIHRhYmxlX2luZm8oJHt0aGlzLmZvcm1hdHRlci53cmFwKHRhYmxlTmFtZSl9KWAsXG4gICAgb3V0cHV0KHJlc3ApIHtcbiAgICAgIHJldHVybiBzb21lKHJlc3AsIHtuYW1lOiBjb2x1bW59KTtcbiAgICB9XG4gIH0pO1xufTtcblxuLy8gQ29tcGlsZSBhIHJlbmFtZSB0YWJsZSBjb21tYW5kLlxuU2NoZW1hQ29tcGlsZXJfU1FMaXRlMy5wcm90b3R5cGUucmVuYW1lVGFibGUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICB0aGlzLnB1c2hRdWVyeShgYWx0ZXIgdGFibGUgJHt0aGlzLmZvcm1hdHRlci53cmFwKGZyb20pfSByZW5hbWUgdG8gJHt0aGlzLmZvcm1hdHRlci53cmFwKHRvKX1gKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNjaGVtYUNvbXBpbGVyX1NRTGl0ZTM7XG4iXX0=

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _schemaColumncompiler = __webpack_require__(82);

	var _schemaColumncompiler2 = _interopRequireDefault(_schemaColumncompiler);

	// Column Compiler
	// -------

	function ColumnCompiler_SQLite3() {
	  this.modifiers = ['nullable', 'defaultTo'];
	  _schemaColumncompiler2['default'].apply(this, arguments);
	}
	_inherits2['default'](ColumnCompiler_SQLite3, _schemaColumncompiler2['default']);

	// Types
	// -------

	ColumnCompiler_SQLite3.prototype.double = ColumnCompiler_SQLite3.prototype.decimal = ColumnCompiler_SQLite3.prototype.floating = 'float';
	ColumnCompiler_SQLite3.prototype.timestamp = 'datetime';

	exports['default'] = ColumnCompiler_SQLite3;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9zcWxpdGUzL3NjaGVtYS9jb2x1bW5jb21waWxlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7d0JBQ3FCLFVBQVU7Ozs7b0NBQ0osZ0NBQWdDOzs7Ozs7O0FBSzNELFNBQVMsc0JBQXNCLEdBQUc7QUFDaEMsTUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLFVBQVUsRUFBRSxXQUFXLENBQUMsQ0FBQztBQUMzQyxvQ0FBZSxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0NBQ3ZDO0FBQ0Qsc0JBQVMsc0JBQXNCLG9DQUFpQixDQUFDOzs7OztBQUtqRCxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUN2QyxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsT0FBTyxHQUN4QyxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQztBQUNwRCxzQkFBc0IsQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFHLFVBQVUsQ0FBQzs7cUJBRXpDLHNCQUFzQiIsImZpbGUiOiJjb2x1bW5jb21waWxlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcbmltcG9ydCBDb2x1bW5Db21waWxlciBmcm9tICcuLi8uLi8uLi9zY2hlbWEvY29sdW1uY29tcGlsZXInO1xuXG4vLyBDb2x1bW4gQ29tcGlsZXJcbi8vIC0tLS0tLS1cblxuZnVuY3Rpb24gQ29sdW1uQ29tcGlsZXJfU1FMaXRlMygpIHtcbiAgdGhpcy5tb2RpZmllcnMgPSBbJ251bGxhYmxlJywgJ2RlZmF1bHRUbyddO1xuICBDb2x1bW5Db21waWxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuaW5oZXJpdHMoQ29sdW1uQ29tcGlsZXJfU1FMaXRlMywgQ29sdW1uQ29tcGlsZXIpO1xuXG4vLyBUeXBlc1xuLy8gLS0tLS0tLVxuXG5Db2x1bW5Db21waWxlcl9TUUxpdGUzLnByb3RvdHlwZS5kb3VibGUgPVxuQ29sdW1uQ29tcGlsZXJfU1FMaXRlMy5wcm90b3R5cGUuZGVjaW1hbCA9XG5Db2x1bW5Db21waWxlcl9TUUxpdGUzLnByb3RvdHlwZS5mbG9hdGluZyA9ICdmbG9hdCc7XG5Db2x1bW5Db21waWxlcl9TUUxpdGUzLnByb3RvdHlwZS50aW1lc3RhbXAgPSAnZGF0ZXRpbWUnO1xuXG5leHBvcnQgZGVmYXVsdCBDb2x1bW5Db21waWxlcl9TUUxpdGUzO1xuIl19

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _schemaTablecompiler = __webpack_require__(80);

	var _schemaTablecompiler2 = _interopRequireDefault(_schemaTablecompiler);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _lodash = __webpack_require__(5);

	// Table Compiler
	// -------

	function TableCompiler_SQLite3() {
	  _schemaTablecompiler2['default'].apply(this, arguments);
	  this.primaryKey = void 0;
	}
	_inherits2['default'](TableCompiler_SQLite3, _schemaTablecompiler2['default']);

	// Create a new table.
	TableCompiler_SQLite3.prototype.createQuery = function (columns, ifNot) {
	  var createStatement = ifNot ? 'create table if not exists ' : 'create table ';
	  var sql = createStatement + this.tableName() + ' (' + columns.sql.join(', ');

	  // SQLite forces primary keys to be added when the table is initially created
	  // so we will need to check for a primary key commands and add the columns
	  // to the table's declaration here so they can be created on the tables.
	  sql += this.foreignKeys() || '';
	  sql += this.primaryKeys() || '';
	  sql += ')';

	  this.pushQuery(sql);
	};

	TableCompiler_SQLite3.prototype.addColumns = function (columns) {
	  for (var i = 0, l = columns.sql.length; i < l; i++) {
	    this.pushQuery({
	      sql: 'alter table ' + this.tableName() + ' add column ' + columns.sql[i],
	      bindings: columns.bindings[i]
	    });
	  }
	};

	// Compile a drop unique key command.
	TableCompiler_SQLite3.prototype.dropUnique = function (columns, indexName) {
	  indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, columns);
	  this.pushQuery('drop index ' + indexName);
	};

	TableCompiler_SQLite3.prototype.dropIndex = function (columns, indexName) {
	  indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);
	  this.pushQuery('drop index ' + indexName);
	};

	// Compile a unique key command.
	TableCompiler_SQLite3.prototype.unique = function (columns, indexName) {
	  indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, columns);
	  columns = this.formatter.columnize(columns);
	  this.pushQuery('create unique index ' + indexName + ' on ' + this.tableName() + ' (' + columns + ')');
	};

	// Compile a plain index key command.
	TableCompiler_SQLite3.prototype.index = function (columns, indexName) {
	  indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);
	  columns = this.formatter.columnize(columns);
	  this.pushQuery('create index ' + indexName + ' on ' + this.tableName() + ' (' + columns + ')');
	};

	TableCompiler_SQLite3.prototype.primary = TableCompiler_SQLite3.prototype.foreign = function () {
	  if (this.method !== 'create' && this.method !== 'createIfNot') {
	    helpers.warn('SQLite3 Foreign & Primary keys may only be added on create');
	  }
	};

	TableCompiler_SQLite3.prototype.primaryKeys = function () {
	  var pks = _lodash.filter(this.grouped.alterTable || [], { method: 'primary' });
	  if (pks.length > 0 && pks[0].args.length > 0) {
	    var args = Array.isArray(pks[0].args[0]) ? pks[0].args[0] : pks[0].args;
	    return ', primary key (' + this.formatter.columnize(args) + ')';
	  }
	};

	TableCompiler_SQLite3.prototype.foreignKeys = function () {
	  var sql = '';
	  var foreignKeys = _lodash.filter(this.grouped.alterTable || [], { method: 'foreign' });
	  for (var i = 0, l = foreignKeys.length; i < l; i++) {
	    var foreign = foreignKeys[i].args[0];
	    var column = this.formatter.columnize(foreign.column);
	    var references = this.formatter.columnize(foreign.references);
	    var foreignTable = this.formatter.wrap(foreign.inTable);
	    sql += ', foreign key(' + column + ') references ' + foreignTable + '(' + references + ')';
	    if (foreign.onDelete) sql += ' on delete ' + foreign.onDelete;
	    if (foreign.onUpdate) sql += ' on update ' + foreign.onUpdate;
	  }
	  return sql;
	};

	TableCompiler_SQLite3.prototype.createTableBlock = function () {
	  return this.getColumns().concat().join(',');
	};

	// Compile a rename column command... very complex in sqlite
	TableCompiler_SQLite3.prototype.renameColumn = function (from, to) {
	  var compiler = this;
	  this.pushQuery({
	    sql: 'PRAGMA table_info(' + this.tableName() + ')',
	    output: function output(pragma) {
	      return compiler.client.ddl(compiler, pragma, this.connection).renameColumn(from, to);
	    }
	  });
	};

	TableCompiler_SQLite3.prototype.dropColumn = function (column) {
	  var compiler = this;
	  this.pushQuery({
	    sql: 'PRAGMA table_info(' + this.tableName() + ')',
	    output: function output(pragma) {
	      return compiler.client.ddl(compiler, pragma, this.connection).dropColumn(column);
	    }
	  });
	};

	exports['default'] = TableCompiler_SQLite3;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9zcWxpdGUzL3NjaGVtYS90YWJsZWNvbXBpbGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O3dCQUFxQixVQUFVOzs7O21DQUNMLCtCQUErQjs7Ozt1QkFDaEMsa0JBQWtCOztJQUEvQixPQUFPOztzQkFFSSxRQUFROzs7OztBQUsvQixTQUFTLHFCQUFxQixHQUFHO0FBQy9CLG1DQUFjLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDckMsTUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUMsQ0FBQztDQUMxQjtBQUNELHNCQUFTLHFCQUFxQixtQ0FBZ0IsQ0FBQzs7O0FBRy9DLHFCQUFxQixDQUFDLFNBQVMsQ0FBQyxXQUFXLEdBQUcsVUFBUyxPQUFPLEVBQUUsS0FBSyxFQUFFO0FBQ3JFLE1BQU0sZUFBZSxHQUFHLEtBQUssR0FBRyw2QkFBNkIsR0FBRyxlQUFlLENBQUM7QUFDaEYsTUFBSSxHQUFHLEdBQUcsZUFBZSxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsR0FBRyxJQUFJLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Ozs7O0FBSzdFLEtBQUcsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDO0FBQ2hDLEtBQUcsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDO0FBQ2hDLEtBQUcsSUFBSSxHQUFHLENBQUM7O0FBRVgsTUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQztDQUNyQixDQUFDOztBQUVGLHFCQUFxQixDQUFDLFNBQVMsQ0FBQyxVQUFVLEdBQUcsVUFBUyxPQUFPLEVBQUU7QUFDN0QsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FB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R0FBRyxDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUNsRjtHQUNGLENBQUMsQ0FBQztDQUNKLENBQUM7O3FCQUVhLHFCQUFxQiIsImZpbGUiOiJ0YWJsZWNvbXBpbGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGluaGVyaXRzIGZyb20gJ2luaGVyaXRzJztcbmltcG9ydCBUYWJsZUNvbXBpbGVyIGZyb20gJy4uLy4uLy4uL3NjaGVtYS90YWJsZWNvbXBpbGVyJztcbmltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSAnLi4vLi4vLi4vaGVscGVycyc7XG5cbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ2xvZGFzaCdcblxuLy8gVGFibGUgQ29tcGlsZXJcbi8vIC0tLS0tLS1cblxuZnVuY3Rpb24gVGFibGVDb21waWxlcl9TUUxpdGUzKCkge1xuICBUYWJsZUNvbXBpbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHRoaXMucHJpbWFyeUtleSA9IHZvaWQgMDtcbn1cbmluaGVyaXRzKFRhYmxlQ29tcGlsZXJfU1FMaXRlMywgVGFibGVDb21waWxlcik7XG5cbi8vIENyZWF0ZSBhIG5ldyB0YWJsZS5cblRhYmxlQ29tcGlsZXJfU1FMaXRlMy5wcm90b3R5cGUuY3JlYXRlUXVlcnkgPSBmdW5jdGlvbihjb2x1bW5zLCBpZk5vdCkge1xuICBjb25zdCBjcmVhdGVTdGF0ZW1lbnQgPSBpZk5vdCA/ICdjcmVhdGUgdGFibGUgaWYgbm90IGV4aXN0cyAnIDogJ2NyZWF0ZSB0YWJsZSAnO1xuICBsZXQgc3FsID0gY3JlYXRlU3RhdGVtZW50ICsgdGhpcy50YWJsZU5hbWUoKSArICcgKCcgKyBjb2x1bW5zLnNxbC5qb2luKCcsICcpO1xuXG4gIC8vIFNRTGl0ZSBmb3JjZXMgcHJpbWFyeSBrZXlzIHRvIGJlIGFkZGVkIHdoZW4gdGhlIHRhYmxlIGlzIGluaXRpYWxseSBjcmVhdGVkXG4gIC8vIHNvIHdlIHdpbGwgbmVlZCB0byBjaGVjayBmb3IgYSBwcmltYXJ5IGtleSBjb21tYW5kcyBhbmQgYWRkIHRoZSBjb2x1bW5zXG4gIC8vIHRvIHRoZSB0YWJsZSdzIGRlY2xhcmF0aW9uIGhlcmUgc28gdGhleSBjYW4gYmUgY3JlYXRlZCBvbiB0aGUgdGFibGVzLlxuICBzcWwgKz0gdGhpcy5mb3JlaWduS2V5cygpIHx8ICcnO1xuICBzcWwgKz0gdGhpcy5wcmltYXJ5S2V5cygpIHx8ICcnO1xuICBzcWwgKz0gJyknO1xuXG4gIHRoaXMucHVzaFF1ZXJ5KHNxbCk7XG59O1xuXG5UYWJsZUNvbXBpbGVyX1NRTGl0ZTMucHJvdG90eXBlLmFkZENvbHVtbnMgPSBmdW5jdGlvbihjb2x1bW5zKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gY29sdW1ucy5zcWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdGhpcy5wdXNoUXVlcnkoe1xuICAgICAgc3FsOiBgYWx0ZXIgdGFibGUgJHt0aGlzLnRhYmxlTmFtZSgpfSBhZGQgY29sdW1uICR7Y29sdW1ucy5zcWxbaV19YCxcbiAgICAgIGJpbmRpbmdzOiBjb2x1bW5zLmJpbmRpbmdzW2ldXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIENvbXBpbGUgYSBkcm9wIHVuaXF1ZSBrZXkgY29tbWFuZC5cblRhYmxlQ29tcGlsZXJfU1FMaXRlMy5wcm90b3R5cGUuZHJvcFVuaXF1ZSA9IGZ1bmN0aW9uKGNvbHVtbnMsIGluZGV4TmFtZSkge1xuICBpbmRleE5hbWUgPSBpbmRleE5hbWVcbiAgICA/IHRoaXMuZm9ybWF0dGVyLndyYXAoaW5kZXhOYW1lKVxuICAgIDogdGhpcy5faW5kZXhDb21tYW5kKCd1bmlxdWUnLCB0aGlzLnRhYmxlTmFtZVJhdywgY29sdW1ucyk7XG4gIHRoaXMucHVzaFF1ZXJ5KGBkcm9wIGluZGV4ICR7aW5kZXhOYW1lfWApO1xufTtcblxuVGFibGVDb21waWxlcl9TUUxpdGUzLnByb3RvdHlwZS5kcm9wSW5kZXggPSBmdW5jdGlvbihjb2x1bW5zLCBpbmRleE5hbWUpIHtcbiAgaW5kZXhOYW1lID0gaW5kZXhOYW1lXG4gICAgPyB0aGlzLmZvcm1hdHRlci53cmFwKGluZGV4TmFtZSlcbiAgICA6IHRoaXMuX2luZGV4Q29tbWFuZCgnaW5kZXgnLCB0aGlzLnRhYmxlTmFtZVJhdywgY29sdW1ucyk7XG4gIHRoaXMucHVzaFF1ZXJ5KGBkcm9wIGluZGV4ICR7aW5kZXhOYW1lfWApO1xufTtcblxuLy8gQ29tcGlsZSBhIHVuaXF1ZSBrZXkgY29tbWFuZC5cblRhYmxlQ29tcGlsZXJfU1FMaXRlMy5wcm90b3R5cGUudW5pcXVlID0gZnVuY3Rpb24oY29sdW1ucywgaW5kZXhOYW1lKSB7XG4gIGluZGV4TmFtZSA9IGluZGV4TmFtZVxuICAgID8gdGhpcy5mb3JtYXR0ZXIud3JhcChpbmRleE5hbWUpXG4gICAgOiB0aGlzLl9pbmRleENvbW1hbmQoJ3VuaXF1ZScsIHRoaXMudGFibGVOYW1lUmF3LCBjb2x1bW5zKTtcbiAgY29sdW1ucyA9IHRoaXMuZm9ybWF0dGVyLmNvbHVtbml6ZShjb2x1bW5zKTtcbiAgdGhpcy5wdXNoUXVlcnkoYGNyZWF0ZSB1bmlxdWUgaW5kZXggJHtpbmRleE5hbWV9IG9uICR7dGhpcy50YWJsZU5hbWUoKX0gKCR7Y29sdW1uc30pYCk7XG59O1xuXG4vLyBDb21waWxlIGEgcGxhaW4gaW5kZXgga2V5IGNvbW1hbmQuXG5UYWJsZUNvbXBpbGVyX1NRTGl0ZTMucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24oY29sdW1ucywgaW5kZXhOYW1lKSB7XG4gIGluZGV4TmFtZSA9IGluZGV4TmFtZVxuICAgID8gdGhpcy5mb3JtYXR0ZXIud3JhcChpbmRleE5hbWUpXG4gICAgOiB0aGlzLl9pbmRleENvbW1hbmQoJ2luZGV4JywgdGhpcy50YWJsZU5hbWVSYXcsIGNvbHVtbnMpO1xuICBjb2x1bW5zID0gdGhpcy5mb3JtYXR0ZXIuY29sdW1uaXplKGNvbHVtbnMpO1xuICB0aGlzLnB1c2hRdWVyeShgY3JlYXRlIGluZGV4ICR7aW5kZXhOYW1lfSBvbiAke3RoaXMudGFibGVOYW1lKCl9ICgke2NvbHVtbnN9KWApO1xufTtcblxuVGFibGVDb21waWxlcl9TUUxpdGUzLnByb3RvdHlwZS5wcmltYXJ5ID1cblRhYmxlQ29tcGlsZXJfU1FMaXRlMy5wcm90b3R5cGUuZm9yZWlnbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5tZXRob2QgIT09ICdjcmVhdGUnICYmIHRoaXMubWV0aG9kICE9PSAnY3JlYXRlSWZOb3QnKSB7XG4gICAgaGVscGVycy53YXJuKCdTUUxpdGUzIEZvcmVpZ24gJiBQcmltYXJ5IGtleXMgbWF5IG9ubHkgYmUgYWRkZWQgb24gY3JlYXRlJyk7XG4gIH1cbn07XG5cblRhYmxlQ29tcGlsZXJfU1FMaXRlMy5wcm90b3R5cGUucHJpbWFyeUtleXMgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgcGtzID0gZmlsdGVyKHRoaXMuZ3JvdXBlZC5hbHRlclRhYmxlIHx8IFtdLCB7bWV0aG9kOiAncHJpbWFyeSd9KTtcbiAgaWYgKHBrcy5sZW5ndGggPiAwICYmIHBrc1swXS5hcmdzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBhcmdzID0gQXJyYXkuaXNBcnJheShwa3NbMF0uYXJnc1swXSkgPyBwa3NbMF0uYXJnc1swXSA6IHBrc1swXS5hcmdzO1xuICAgIHJldHVybiBgLCBwcmltYXJ5IGtleSAoJHt0aGlzLmZvcm1hdHRlci5jb2x1bW5pemUoYXJncyl9KWA7XG4gIH1cbn07XG5cblRhYmxlQ29tcGlsZXJfU1FMaXRlMy5wcm90b3R5cGUuZm9yZWlnbktleXMgPSBmdW5jdGlvbigpIHtcbiAgbGV0IHNxbCA9ICcnO1xuICBjb25zdCBmb3JlaWduS2V5cyA9IGZpbHRlcih0aGlzLmdyb3VwZWQuYWx0ZXJUYWJsZSB8fCBbXSwge21ldGhvZDogJ2ZvcmVpZ24nfSk7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gZm9yZWlnbktleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgZm9yZWlnbiA9IGZvcmVpZ25LZXlzW2ldLmFyZ3NbMF07XG4gICAgY29uc3QgY29sdW1uID0gdGhpcy5mb3JtYXR0ZXIuY29sdW1uaXplKGZvcmVpZ24uY29sdW1uKTtcbiAgICBjb25zdCByZWZlcmVuY2VzID0gdGhpcy5mb3JtYXR0ZXIuY29sdW1uaXplKGZvcmVpZ24ucmVmZXJlbmNlcyk7XG4gICAgY29uc3QgZm9yZWlnblRhYmxlID0gdGhpcy5mb3JtYXR0ZXIud3JhcChmb3JlaWduLmluVGFibGUpO1xuICAgIHNxbCArPSBgLCBmb3JlaWduIGtleSgke2NvbHVtbn0pIHJlZmVyZW5jZXMgJHtmb3JlaWduVGFibGV9KCR7cmVmZXJlbmNlc30pYDtcbiAgICBpZiAoZm9yZWlnbi5vbkRlbGV0ZSkgc3FsICs9IGAgb24gZGVsZXRlICR7Zm9yZWlnbi5vbkRlbGV0ZX1gO1xuICAgIGlmIChmb3JlaWduLm9uVXBkYXRlKSBzcWwgKz0gYCBvbiB1cGRhdGUgJHtmb3JlaWduLm9uVXBkYXRlfWA7XG4gIH1cbiAgcmV0dXJuIHNxbDtcbn07XG5cblRhYmxlQ29tcGlsZXJfU1FMaXRlMy5wcm90b3R5cGUuY3JlYXRlVGFibGVCbG9jayA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5nZXRDb2x1bW5zKCkuY29uY2F0KCkuam9pbignLCcpO1xufTtcblxuLy8gQ29tcGlsZSBhIHJlbmFtZSBjb2x1bW4gY29tbWFuZC4uLiB2ZXJ5IGNvbXBsZXggaW4gc3FsaXRlXG5UYWJsZUNvbXBpbGVyX1NRTGl0ZTMucHJvdG90eXBlLnJlbmFtZUNvbHVtbiA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGNvbnN0IGNvbXBpbGVyID0gdGhpcztcbiAgdGhpcy5wdXNoUXVlcnkoe1xuICAgIHNxbDogYFBSQUdNQSB0YWJsZV9pbmZvKCR7dGhpcy50YWJsZU5hbWUoKX0pYCxcbiAgICBvdXRwdXQocHJhZ21hKSB7XG4gICAgICByZXR1cm4gY29tcGlsZXIuY2xpZW50LmRkbChjb21waWxlciwgcHJhZ21hLCB0aGlzLmNvbm5lY3Rpb24pLnJlbmFtZUNvbHVtbihmcm9tLCB0byk7XG4gICAgfVxuICB9KTtcbn07XG5cblRhYmxlQ29tcGlsZXJfU1FMaXRlMy5wcm90b3R5cGUuZHJvcENvbHVtbiA9IGZ1bmN0aW9uKGNvbHVtbikge1xuICBjb25zdCBjb21waWxlciA9IHRoaXM7XG4gIHRoaXMucHVzaFF1ZXJ5KHtcbiAgICBzcWw6IGBQUkFHTUEgdGFibGVfaW5mbygke3RoaXMudGFibGVOYW1lKCl9KWAsXG4gICAgb3V0cHV0KHByYWdtYSkge1xuICAgICAgcmV0dXJuIGNvbXBpbGVyLmNsaWVudC5kZGwoY29tcGlsZXIsIHByYWdtYSwgdGhpcy5jb25uZWN0aW9uKS5kcm9wQ29sdW1uKGNvbHVtbik7XG4gICAgfVxuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRhYmxlQ29tcGlsZXJfU1FMaXRlMztcbiJdfQ==

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	
	// SQLite3_DDL
	//
	// All of the SQLite3 specific DDL helpers for renaming/dropping
	// columns and changing datatypes.
	// -------

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _promise = __webpack_require__(43);

	var _promise2 = _interopRequireDefault(_promise);

	var _lodash = __webpack_require__(5);

	// So altering the schema in SQLite3 is a major pain.
	// We have our own object to deal with the renaming and altering the types
	// for sqlite3 things.
	function SQLite3_DDL(client, tableCompiler, pragma, connection) {
	  this.client = client;
	  this.tableCompiler = tableCompiler;
	  this.pragma = pragma;
	  this.tableName = this.tableCompiler.tableNameRaw;
	  this.alteredName = _lodash.uniqueId('_knex_temp_alter');
	  this.connection = connection;
	}

	_lodash.assign(SQLite3_DDL.prototype, {

	  getColumn: _promise2['default'].method(function (column) {
	    var currentCol = _lodash.find(this.pragma, { name: column });
	    if (!currentCol) throw new Error('The column ' + column + ' is not in the ' + this.tableName + ' table');
	    return currentCol;
	  }),

	  getTableSql: function getTableSql() {
	    return this.trx.raw('SELECT name, sql FROM sqlite_master WHERE type="table" AND name="' + this.tableName + '"');
	  },

	  renameTable: _promise2['default'].method(function () {
	    return this.trx.raw('ALTER TABLE "' + this.tableName + '" RENAME TO "' + this.alteredName + '"');
	  }),

	  dropOriginal: function dropOriginal() {
	    return this.trx.raw('DROP TABLE "' + this.tableName + '"');
	  },

	  dropTempTable: function dropTempTable() {
	    return this.trx.raw('DROP TABLE "' + this.alteredName + '"');
	  },

	  copyData: function copyData() {
	    return this.trx.raw('SELECT * FROM "' + this.tableName + '"').bind(this).then(this.insertChunked(20, this.alteredName));
	  },

	  reinsertData: function reinsertData(iterator) {
	    return function () {
	      return this.trx.raw('SELECT * FROM "' + this.alteredName + '"').bind(this).then(this.insertChunked(20, this.tableName, iterator));
	    };
	  },

	  insertChunked: function insertChunked(amount, target, iterator) {
	    iterator = iterator || _lodash.identity;
	    return function (result) {
	      var batch = [];
	      var ddl = this;
	      return _promise2['default'].reduce(result, function (memo, row) {
	        memo++;
	        batch.push(row);
	        if (memo % 20 === 0 || memo === result.length) {
	          return ddl.trx.queryBuilder().table(target).insert(_lodash.map(batch, iterator)).then(function () {
	            batch = [];
	          }).thenReturn(memo);
	        }
	        return memo;
	      }, 0);
	    };
	  },

	  createTempTable: function createTempTable(createTable) {
	    return function () {
	      return this.trx.raw(createTable.sql.replace(this.tableName, this.alteredName));
	    };
	  },

	  _doReplace: function _doReplace(sql, from, to) {
	    var matched = sql.match(/^CREATE TABLE (\S+) \((.*)\)/);

	    var tableName = matched[1];
	    var defs = matched[2];

	    if (!defs) {
	      throw new Error('No column definitions in this statement!');
	    }

	    var parens = 0,
	        args = [],
	        ptr = 0;
	    var i = 0;
	    var x = defs.length;
	    for (i = 0; i < x; i++) {
	      switch (defs[i]) {
	        case '(':
	          parens++;
	          break;
	        case ')':
	          parens--;
	          break;
	        case ',':
	          if (parens === 0) {
	            args.push(defs.slice(ptr, i));
	            ptr = i + 1;
	          }
	          break;
	        case ' ':
	          if (ptr === i) {
	            ptr = i + 1;
	          }
	          break;
	      }
	    }
	    args.push(defs.slice(ptr, i));

	    args = args.map(function (item) {
	      var split = item.split(' ');

	      if (split[0] === from) {
	        // column definition
	        if (to) {
	          split[0] = to;
	          return split.join(' ');
	        }
	        return ''; // for deletions
	      }

	      // skip constraint name
	      var idx = /constraint/i.test(split[0]) ? 2 : 0;

	      // primary key and unique constraints have one or more
	      // columns from this table listed between (); replace
	      // one if it matches
	      if (/primary|unique/i.test(split[idx])) {
	        return item.replace(/\(.*\)/, function (columns) {
	          return columns.replace(from, to);
	        });
	      }

	      // foreign keys have one or more columns from this table
	      // listed between (); replace one if it matches
	      // foreign keys also have a 'references' clause
	      // which may reference THIS table; if it does, replace
	      // column references in that too!
	      if (/foreign/.test(split[idx])) {
	        split = item.split(/ references /i);
	        // the quoted column names save us from having to do anything
	        // other than a straight replace here
	        split[0] = split[0].replace(from, to);

	        if (split[1].slice(0, tableName.length) === tableName) {
	          split[1] = split[1].replace(/\(.*\)/, function (columns) {
	            return columns.replace(from, to);
	          });
	        }
	        return split.join(' references ');
	      }

	      return item;
	    });
	    return sql.replace(/\(.*\)/, function () {
	      return '(' + args.join(', ') + ')';
	    }).replace(/,\s*([,)])/, '$1');
	  },

	  // Boy, this is quite a method.
	  renameColumn: _promise2['default'].method(function (from, to) {
	    var _this = this;

	    return this.client.transaction(function (trx) {
	      _this.trx = trx;
	      return _this.getColumn(from).bind(_this).then(_this.getTableSql).then(function (sql) {
	        var a = this.client.wrapIdentifier(from);
	        var b = this.client.wrapIdentifier(to);
	        var createTable = sql[0];
	        var newSql = this._doReplace(createTable.sql, a, b);
	        if (sql === newSql) {
	          throw new Error('Unable to find the column to change');
	        }
	        return _promise2['default'].bind(this).then(this.createTempTable(createTable)).then(this.copyData).then(this.dropOriginal).then(function () {
	          return this.trx.raw(newSql);
	        }).then(this.reinsertData(function (row) {
	          row[to] = row[from];
	          return _lodash.omit(row, from);
	        })).then(this.dropTempTable);
	      });
	    }, { connection: this.connection });
	  }),

	  dropColumn: _promise2['default'].method(function (column) {
	    var _this2 = this;

	    return this.client.transaction(function (trx) {
	      _this2.trx = trx;
	      return _this2.getColumn(column).bind(_this2).then(_this2.getTableSql).then(function (sql) {
	        var createTable = sql[0];
	        var a = this.client.wrapIdentifier(column);
	        var newSql = this._doReplace(createTable.sql, a, '');
	        if (sql === newSql) {
	          throw new Error('Unable to find the column to change');
	        }
	        return _promise2['default'].bind(this).then(this.createTempTable(createTable)).then(this.copyData).then(this.dropOriginal).then(function () {
	          return this.trx.raw(newSql);
	        }).then(this.reinsertData(function (row) {
	          return _lodash.omit(row, column);
	        })).then(this.dropTempTable);
	      });
	    }, { connection: this.connection });
	  })

	});

	exports['default'] = SQLite3_DDL;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9kaWFsZWN0cy9zcWxpdGUzL3NjaGVtYS9kZGwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozt1QkFPb0Isa0JBQWtCOzs7O3NCQUNzQixRQUFROzs7OztBQUtwRSxTQUFTLFdBQVcsQ0FBQyxNQUFNLEVBQUUsYUFBYSxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUU7QUFDOUQsTUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUE7QUFDcEIsTUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7QUFDbkMsTUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7QUFDckIsTUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQztBQUNqRCxNQUFJLENBQUMsV0FBVyxHQUFHLGlCQUFTLGtCQUFrQixDQUFDLENBQUM7QUFDaEQsTUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUE7Q0FDN0I7O0FBRUQsZUFBTyxXQUFXLENBQUMsU0FBUyxFQUFFOztBQUU1QixXQUFTLEVBQUUscUJBQVEsTUFBTSxDQUFDLFVBQVMsTUFBTSxFQUFFO0FBQ3pDLFFBQU0sVUFBVSxHQUFHLGFBQUssSUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFDLElBQUksRUFBRSxNQUFNLEVBQUMsQ0FBQyxDQUFDO0FBQ3JELFFBQUksQ0FBQyxVQUFVLEVBQUUsTUFBTSxJQUFJLEtBQUssaUJBQWUsTUFBTSx1QkFBa0IsSUFBSSxDQUFDLFNBQVMsWUFBUyxDQUFDO0FBQy9GLFdBQU8sVUFBVSxDQUFDO0dBQ25CLENBQUM7O0FBRUYsYUFBVyxFQUFBLHVCQUFHO0FBQ1osV0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsdUVBQ21ELElBQUksQ0FBQyxTQUFTLE9BQ25GLENBQUM7R0FDSDs7QUFFRCxhQUFXLEVBQUUscUJBQVEsTUFBTSxDQUFDLFlBQVc7QUFDckMsV0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEdB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QUN4RDtBQUNELGVBQU8scUJBQVEsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUN0QixJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUN2QyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUN2QixJQUFJLENBQUMsWUFBVztBQUNmLGlCQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQzdCLENBQUMsQ0FDRCxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFBLEdBQUc7aUJBQUksYUFBSyxHQUFHLEVBQUUsTUFBTSxDQUFDO1NBQUEsQ0FBQyxDQUFDLENBQ2pELElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7T0FDN0IsQ0FBQyxDQUFBO0tBQ0gsRUFBRSxFQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVSxFQUFDLENBQUMsQ0FBQTtHQUNsQyxDQUFDOztDQUVILENBQUMsQ0FBQTs7cUJBR2EsV0FBVyIsImZpbGUiOiJkZGwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8vIFNRTGl0ZTNfRERMXG4vL1xuLy8gQWxsIG9mIHRoZSBTUUxpdGUzIHNwZWNpZmljIERETCBoZWxwZXJzIGZvciByZW5hbWluZy9kcm9wcGluZ1xuLy8gY29sdW1ucyBhbmQgY2hhbmdpbmcgZGF0YXR5cGVzLlxuLy8gLS0tLS0tLVxuXG5pbXBvcnQgUHJvbWlzZSBmcm9tICcuLi8uLi8uLi9wcm9taXNlJztcbmltcG9ydCB7IGFzc2lnbiwgdW5pcXVlSWQsIGZpbmQsIGlkZW50aXR5LCBtYXAsIG9taXQgfSBmcm9tICdsb2Rhc2gnXG5cbi8vIFNvIGFsdGVyaW5nIHRoZSBzY2hlbWEgaW4gU1FMaXRlMyBpcyBhIG1ham9yIHBhaW4uXG4vLyBXZSBoYXZlIG91ciBvd24gb2JqZWN0IHRvIGRlYWwgd2l0aCB0aGUgcmVuYW1pbmcgYW5kIGFsdGVyaW5nIHRoZSB0eXBlc1xuLy8gZm9yIHNxbGl0ZTMgdGhpbmdzLlxuZnVuY3Rpb24gU1FMaXRlM19EREwoY2xpZW50LCB0YWJsZUNvbXBpbGVyLCBwcmFnbWEsIGNvbm5lY3Rpb24pIHtcbiAgdGhpcy5jbGllbnQgPSBjbGllbnRcbiAgdGhpcy50YWJsZUNvbXBpbGVyID0gdGFibGVDb21waWxlcjtcbiAgdGhpcy5wcmFnbWEgPSBwcmFnbWE7XG4gIHRoaXMudGFibGVOYW1lID0gdGhpcy50YWJsZUNvbXBpbGVyLnRhYmxlTmFtZVJhdztcbiAgdGhpcy5hbHRlcmVkTmFtZSA9IHVuaXF1ZUlkKCdfa25leF90ZW1wX2FsdGVyJyk7XG4gIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb25cbn1cblxuYXNzaWduKFNRTGl0ZTNfRERMLnByb3RvdHlwZSwge1xuXG4gIGdldENvbHVtbjogUHJvbWlzZS5tZXRob2QoZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgY29uc3QgY3VycmVudENvbCA9IGZpbmQodGhpcy5wcmFnbWEsIHtuYW1lOiBjb2x1bW59KTtcbiAgICBpZiAoIWN1cnJlbnRDb2wpIHRocm93IG5ldyBFcnJvcihgVGhlIGNvbHVtbiAke2NvbHVtbn0gaXMgbm90IGluIHRoZSAke3RoaXMudGFibGVOYW1lfSB0YWJsZWApO1xuICAgIHJldHVybiBjdXJyZW50Q29sO1xuICB9KSxcblxuICBnZXRUYWJsZVNxbCgpIHtcbiAgICByZXR1cm4gdGhpcy50cngucmF3KFxuICAgICAgYFNFTEVDVCBuYW1lLCBzcWwgRlJPTSBzcWxpdGVfbWFzdGVyIFdIRVJFIHR5cGU9XCJ0YWJsZVwiIEFORCBuYW1lPVwiJHt0aGlzLnRhYmxlTmFtZX1cImBcbiAgICApO1xuICB9LFxuXG4gIHJlbmFtZVRhYmxlOiBQcm9taXNlLm1ldGhvZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cngucmF3KGBBTFRFUiBUQUJMRSBcIiR7dGhpcy50YWJsZU5hbWV9XCIgUkVOQU1FIFRPIFwiJHt0aGlzLmFsdGVyZWROYW1lfVwiYCk7XG4gIH0pLFxuXG4gIGRyb3BPcmlnaW5hbCgpIHtcbiAgICByZXR1cm4gdGhpcy50cngucmF3KGBEUk9QIFRBQkxFIFwiJHt0aGlzLnRhYmxlTmFtZX1cImApO1xuICB9LFxuXG4gIGRyb3BUZW1wVGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJ4LnJhdyhgRFJPUCBUQUJMRSBcIiR7dGhpcy5hbHRlcmVkTmFtZX1cImApO1xuICB9LFxuXG4gIGNvcHlEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLnRyeC5yYXcoYFNFTEVDVCAqIEZST00gXCIke3RoaXMudGFibGVOYW1lfVwiYClcbiAgICAgIC5iaW5kKHRoaXMpXG4gICAgICAudGhlbih0aGlzLmluc2VydENodW5rZWQoMjAsIHRoaXMuYWx0ZXJlZE5hbWUpKTtcbiAgfSxcblxuICByZWluc2VydERhdGEoaXRlcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50cngucmF3KGBTRUxFQ1QgKiBGUk9NIFwiJHt0aGlzLmFsdGVyZWROYW1lfVwiYClcbiAgICAgICAgLmJpbmQodGhpcylcbiAgICAgICAgLnRoZW4odGhpcy5pbnNlcnRDaHVua2VkKDIwLCB0aGlzLnRhYmxlTmFtZSwgaXRlcmF0b3IpKTtcbiAgICB9O1xuICB9LFxuXG4gIGluc2VydENodW5rZWQoYW1vdW50LCB0YXJnZXQsIGl0ZXJhdG9yKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYXRvciB8fCBpZGVudGl0eTtcbiAgICByZXR1cm4gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICBsZXQgYmF0Y2ggPSBbXTtcbiAgICAgIGNvbnN0IGRkbCA9IHRoaXM7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWR1Y2UocmVzdWx0LCBmdW5jdGlvbihtZW1vLCByb3cpIHtcbiAgICAgICAgbWVtbysrO1xuICAgICAgICBiYXRjaC5wdXNoKHJvdyk7XG4gICAgICAgIGlmIChtZW1vICUgMjAgPT09IDAgfHwgbWVtbyA9PT0gcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBkZGwudHJ4LnF1ZXJ5QnVpbGRlcigpXG4gICAgICAgICAgICAudGFibGUodGFyZ2V0KVxuICAgICAgICAgICAgLmluc2VydChtYXAoYmF0Y2gsIGl0ZXJhdG9yKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkgeyBiYXRjaCA9IFtdOyB9KVxuICAgICAgICAgICAgLnRoZW5SZXR1cm4obWVtbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICB9LCAwKTtcbiAgICB9O1xuICB9LFxuXG4gIGNyZWF0ZVRlbXBUYWJsZShjcmVhdGVUYWJsZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyeC5yYXcoY3JlYXRlVGFibGUuc3FsLnJlcGxhY2UodGhpcy50YWJsZU5hbWUsIHRoaXMuYWx0ZXJlZE5hbWUpKTtcbiAgICB9O1xuICB9LFxuXG4gIF9kb1JlcGxhY2UgKHNxbCwgZnJvbSwgdG8pIHtcbiAgICBjb25zdCBtYXRjaGVkID0gc3FsLm1hdGNoKC9eQ1JFQVRFIFRBQkxFIChcXFMrKSBcXCgoLiopXFwpLyk7XG5cbiAgICBjb25zdCB0YWJsZU5hbWUgPSBtYXRjaGVkWzFdO1xuICAgIGNvbnN0IGRlZnMgPSBtYXRjaGVkWzJdO1xuXG4gICAgaWYgKCFkZWZzKSB7IHRocm93IG5ldyBFcnJvcignTm8gY29sdW1uIGRlZmluaXRpb25zIGluIHRoaXMgc3RhdGVtZW50IScpOyB9XG5cbiAgICBsZXQgcGFyZW5zID0gMCwgYXJncyA9IFsgXSwgcHRyID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3QgeCA9IGRlZnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCB4OyBpKyspIHtcbiAgICAgIHN3aXRjaCAoZGVmc1tpXSkge1xuICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICBwYXJlbnMrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnKSc6XG4gICAgICAgICAgcGFyZW5zLS07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgIGlmIChwYXJlbnMgPT09IDApIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChkZWZzLnNsaWNlKHB0ciwgaSkpO1xuICAgICAgICAgICAgcHRyID0gaSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICBpZiAocHRyID09PSBpKSB7XG4gICAgICAgICAgICBwdHIgPSBpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGFyZ3MucHVzaChkZWZzLnNsaWNlKHB0ciwgaSkpO1xuXG4gICAgYXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBsZXQgc3BsaXQgPSBpdGVtLnNwbGl0KCcgJyk7XG5cbiAgICAgIGlmIChzcGxpdFswXSA9PT0gZnJvbSkge1xuICAgICAgICAvLyBjb2x1bW4gZGVmaW5pdGlvblxuICAgICAgICBpZiAodG8pIHtcbiAgICAgICAgICBzcGxpdFswXSA9IHRvO1xuICAgICAgICAgIHJldHVybiBzcGxpdC5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnOyAvLyBmb3IgZGVsZXRpb25zXG4gICAgICB9XG5cbiAgICAgIC8vIHNraXAgY29uc3RyYWludCBuYW1lXG4gICAgICBjb25zdCBpZHggPSAoL2NvbnN0cmFpbnQvaS50ZXN0KHNwbGl0WzBdKSA/IDIgOiAwKTtcblxuICAgICAgLy8gcHJpbWFyeSBrZXkgYW5kIHVuaXF1ZSBjb25zdHJhaW50cyBoYXZlIG9uZSBvciBtb3JlXG4gICAgICAvLyBjb2x1bW5zIGZyb20gdGhpcyB0YWJsZSBsaXN0ZWQgYmV0d2VlbiAoKTsgcmVwbGFjZVxuICAgICAgLy8gb25lIGlmIGl0IG1hdGNoZXNcbiAgICAgIGlmICgvcHJpbWFyeXx1bmlxdWUvaS50ZXN0KHNwbGl0W2lkeF0pKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnJlcGxhY2UoL1xcKC4qXFwpLywgY29sdW1ucyA9PiBjb2x1bW5zLnJlcGxhY2UoZnJvbSwgdG8pKTtcbiAgICAgIH1cblxuICAgICAgLy8gZm9yZWlnbiBrZXlzIGhhdmUgb25lIG9yIG1vcmUgY29sdW1ucyBmcm9tIHRoaXMgdGFibGVcbiAgICAgIC8vIGxpc3RlZCBiZXR3ZWVuICgpOyByZXBsYWNlIG9uZSBpZiBpdCBtYXRjaGVzXG4gICAgICAvLyBmb3JlaWduIGtleXMgYWxzbyBoYXZlIGEgJ3JlZmVyZW5jZXMnIGNsYXVzZVxuICAgICAgLy8gd2hpY2ggbWF5IHJlZmVyZW5jZSBUSElTIHRhYmxlOyBpZiBpdCBkb2VzLCByZXBsYWNlXG4gICAgICAvLyBjb2x1bW4gcmVmZXJlbmNlcyBpbiB0aGF0IHRvbyFcbiAgICAgIGlmICgvZm9yZWlnbi8udGVzdChzcGxpdFtpZHhdKSkge1xuICAgICAgICBzcGxpdCA9IGl0ZW0uc3BsaXQoLyByZWZlcmVuY2VzIC9pKTtcbiAgICAgICAgLy8gdGhlIHF1b3RlZCBjb2x1bW4gbmFtZXMgc2F2ZSB1cyBmcm9tIGhhdmluZyB0byBkbyBhbnl0aGluZ1xuICAgICAgICAvLyBvdGhlciB0aGFuIGEgc3RyYWlnaHQgcmVwbGFjZSBoZXJlXG4gICAgICAgIHNwbGl0WzBdID0gc3BsaXRbMF0ucmVwbGFjZShmcm9tLCB0byk7XG5cbiAgICAgICAgaWYgKHNwbGl0WzFdLnNsaWNlKDAsIHRhYmxlTmFtZS5sZW5ndGgpID09PSB0YWJsZU5hbWUpIHtcbiAgICAgICAgICBzcGxpdFsxXSA9IHNwbGl0WzFdLnJlcGxhY2UoL1xcKC4qXFwpLywgY29sdW1ucyA9PiBjb2x1bW5zLnJlcGxhY2UoZnJvbSwgdG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXQuam9pbignIHJlZmVyZW5jZXMgJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pO1xuICAgIHJldHVybiBzcWwucmVwbGFjZSgvXFwoLipcXCkvLCAoKSA9PiBgKCR7YXJncy5qb2luKCcsICcpfSlgKS5yZXBsYWNlKC8sXFxzKihbLCldKS8sICckMScpO1xuICB9LFxuXG4gIC8vIEJveSwgdGhpcyBpcyBxdWl0ZSBhIG1ldGhvZC5cbiAgcmVuYW1lQ29sdW1uOiBQcm9taXNlLm1ldGhvZChmdW5jdGlvbihmcm9tLCB0bykge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC50cmFuc2FjdGlvbih0cnggPT4ge1xuICAgICAgdGhpcy50cnggPSB0cnhcbiAgICAgIHJldHVybiB0aGlzLmdldENvbHVtbihmcm9tKVxuICAgICAgICAuYmluZCh0aGlzKVxuICAgICAgICAudGhlbih0aGlzLmdldFRhYmxlU3FsKVxuICAgICAgICAudGhlbihmdW5jdGlvbihzcWwpIHtcbiAgICAgICAgICBjb25zdCBhID0gdGhpcy5jbGllbnQud3JhcElkZW50aWZpZXIoZnJvbSk7XG4gICAgICAgICAgY29uc3QgYiA9IHRoaXMuY2xpZW50LndyYXBJZGVudGlmaWVyKHRvKTtcbiAgICAgICAgICBjb25zdCBjcmVhdGVUYWJsZSA9IHNxbFswXTtcbiAgICAgICAgICBjb25zdCBuZXdTcWwgPSB0aGlzLl9kb1JlcGxhY2UoY3JlYXRlVGFibGUuc3FsLCBhLCBiKTtcbiAgICAgICAgICBpZiAoc3FsID09PSBuZXdTcWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgdGhlIGNvbHVtbiB0byBjaGFuZ2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UuYmluZCh0aGlzKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5jcmVhdGVUZW1wVGFibGUoY3JlYXRlVGFibGUpKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5jb3B5RGF0YSlcbiAgICAgICAgICAgIC50aGVuKHRoaXMuZHJvcE9yaWdpbmFsKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyeC5yYXcobmV3U3FsKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbih0aGlzLnJlaW5zZXJ0RGF0YShmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgICAgcm93W3RvXSA9IHJvd1tmcm9tXTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9taXQocm93LCBmcm9tKTtcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLnRoZW4odGhpcy5kcm9wVGVtcFRhYmxlKVxuICAgICAgICB9KVxuICAgIH0sIHtjb25uZWN0aW9uOiB0aGlzLmNvbm5lY3Rpb259KVxuICB9KSxcblxuICBkcm9wQ29sdW1uOiBQcm9taXNlLm1ldGhvZChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQudHJhbnNhY3Rpb24odHJ4ID0+IHtcbiAgICAgIHRoaXMudHJ4ID0gdHJ4XG4gICAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW4oY29sdW1uKVxuICAgICAgLmJpbmQodGhpcylcbiAgICAgIC50aGVuKHRoaXMuZ2V0VGFibGVTcWwpXG4gICAgICAudGhlbihmdW5jdGlvbihzcWwpIHtcbiAgICAgICAgY29uc3QgY3JlYXRlVGFibGUgPSBzcWxbMF07XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLmNsaWVudC53cmFwSWRlbnRpZmllcihjb2x1bW4pO1xuICAgICAgICBjb25zdCBuZXdTcWwgPSB0aGlzLl9kb1JlcGxhY2UoY3JlYXRlVGFibGUuc3FsLCBhLCAnJyk7XG4gICAgICAgIGlmIChzcWwgPT09IG5ld1NxbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgdGhlIGNvbHVtbiB0byBjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5iaW5kKHRoaXMpXG4gICAgICAgICAgLnRoZW4odGhpcy5jcmVhdGVUZW1wVGFibGUoY3JlYXRlVGFibGUpKVxuICAgICAgICAgIC50aGVuKHRoaXMuY29weURhdGEpXG4gICAgICAgICAgLnRoZW4odGhpcy5kcm9wT3JpZ2luYWwpXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cngucmF3KG5ld1NxbCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbih0aGlzLnJlaW5zZXJ0RGF0YShyb3cgPT4gb21pdChyb3csIGNvbHVtbikpKVxuICAgICAgICAgIC50aGVuKHRoaXMuZHJvcFRlbXBUYWJsZSk7XG4gICAgICB9KVxuICAgIH0sIHtjb25uZWN0aW9uOiB0aGlzLmNvbm5lY3Rpb259KVxuICB9KVxuXG59KVxuXG5cbmV4cG9ydCBkZWZhdWx0IFNRTGl0ZTNfRERMO1xuIl19

/***/ },
/* 139 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	
	// Oracle Client
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _oracle = __webpack_require__(114);

	var _oracle2 = _interopRequireDefault(_oracle);

	function Client_StrongOracle() {
	  _oracle2['default'].apply(this, arguments);
	}
	_inherits2['default'](Client_StrongOracle, _oracle2['default']);

	Client_StrongOracle.prototype._driver = function () {
	  return __webpack_require__(141)();
	};

	Client_StrongOracle.prototype.driverName = 'strong-oracle';

	exports['default'] = Client_StrongOracle;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy9zdHJvbmctb3JhY2xlL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozt3QkFHcUIsVUFBVTs7OztzQkFDTCxXQUFXOzs7O0FBRXJDLFNBQVMsbUJBQW1CLEdBQUc7QUFDN0Isc0JBQWMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztDQUN0QztBQUNELHNCQUFTLG1CQUFtQixzQkFBZ0IsQ0FBQzs7QUFFN0MsbUJBQW1CLENBQUMsU0FBUyxDQUFDLE9BQU8sR0FBRztTQUFNLE9BQU8sQ0FBQyxlQUFlLENBQUMsRUFBRTtDQUFBLENBQUE7O0FBRXhFLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxVQUFVLEdBQUcsZUFBZSxDQUFBOztxQkFFM0MsbUJBQW1CIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBPcmFjbGUgQ2xpZW50XG4vLyAtLS0tLS0tXG5pbXBvcnQgaW5oZXJpdHMgZnJvbSAnaW5oZXJpdHMnO1xuaW1wb3J0IENsaWVudF9PcmFjbGUgZnJvbSAnLi4vb3JhY2xlJztcblxuZnVuY3Rpb24gQ2xpZW50X1N0cm9uZ09yYWNsZSgpIHtcbiAgQ2xpZW50X09yYWNsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuaW5oZXJpdHMoQ2xpZW50X1N0cm9uZ09yYWNsZSwgQ2xpZW50X09yYWNsZSk7XG5cbkNsaWVudF9TdHJvbmdPcmFjbGUucHJvdG90eXBlLl9kcml2ZXIgPSAoKSA9PiByZXF1aXJlKCdzdHJvbmctb3JhY2xlJykoKVxuXG5DbGllbnRfU3Ryb25nT3JhY2xlLnByb3RvdHlwZS5kcml2ZXJOYW1lID0gJ3N0cm9uZy1vcmFjbGUnXG5cbmV4cG9ydCBkZWZhdWx0IENsaWVudF9TdHJvbmdPcmFjbGU7XG4iXX0=

/***/ },
/* 141 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/* globals openDatabase:false */

	// WebSQL
	// -------
	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _transaction = __webpack_require__(143);

	var _transaction2 = _interopRequireDefault(_transaction);

	var _sqlite3 = __webpack_require__(133);

	var _sqlite32 = _interopRequireDefault(_sqlite3);

	var _promise = __webpack_require__(43);

	var _promise2 = _interopRequireDefault(_promise);

	var _lodash = __webpack_require__(5);

	function Client_WebSQL(config) {
	  _sqlite32['default'].call(this, config);
	  this.name = config.name || 'knex_database';
	  this.version = config.version || '1.0';
	  this.displayName = config.displayName || this.name;
	  this.estimatedSize = config.estimatedSize || 5 * 1024 * 1024;
	}
	_inherits2['default'](Client_WebSQL, _sqlite32['default']);

	_lodash.assign(Client_WebSQL.prototype, {

	  Transaction: _transaction2['default'],

	  dialect: 'websql',

	  // Get a raw connection from the database, returning a promise with the connection object.
	  acquireConnection: function acquireConnection() {
	    var client = this;
	    return new _promise2['default'](function (resolve, reject) {
	      try {
	        /*jslint browser: true*/
	        var db = openDatabase(client.name, client.version, client.displayName, client.estimatedSize);
	        db.transaction(function (t) {
	          t.__knexUid = _lodash.uniqueId('__knexUid');
	          resolve(t);
	        });
	      } catch (e) {
	        reject(e);
	      }
	    });
	  },

	  // Used to explicitly close a connection, called internally by the pool
	  // when a connection times out or the pool is shutdown.
	  releaseConnection: function releaseConnection() {
	    return _promise2['default'].resolve();
	  },

	  // Runs the query on the specified connection,
	  // providing the bindings and any other necessary prep work.
	  _query: function _query(connection, obj) {
	    return new _promise2['default'](function (resolver, rejecter) {
	      if (!connection) return rejecter(new Error('No connection provided.'));
	      connection.executeSql(obj.sql, obj.bindings, function (trx, response) {
	        obj.response = response;
	        return resolver(obj);
	      }, function (trx, err) {
	        rejecter(err);
	      });
	    });
	  },

	  _stream: function _stream(connection, sql, stream) {
	    var client = this;
	    return new _promise2['default'](function (resolver, rejecter) {
	      stream.on('error', rejecter);
	      stream.on('end', resolver);
	      return client._query(connection, sql).then(function (obj) {
	        return client.processResponse(obj);
	      }).map(function (row) {
	        stream.write(row);
	      })['catch'](function (err) {
	        stream.emit('error', err);
	      }).then(function () {
	        stream.end();
	      });
	    });
	  },

	  processResponse: function processResponse(obj, runner) {
	    var resp = obj.response;
	    if (obj.output) return obj.output.call(runner, resp);
	    switch (obj.method) {
	      case 'pluck':
	      case 'first':
	      case 'select':
	        {
	          var results = [];
	          for (var i = 0, l = resp.rows.length; i < l; i++) {
	            results[i] = _lodash.clone(resp.rows.item(i));
	          }
	          if (obj.method === 'pluck') results = _lodash.map(results, obj.pluck);
	          return obj.method === 'first' ? results[0] : results;
	        }
	      case 'insert':
	        return [resp.insertId];
	      case 'delete':
	      case 'update':
	      case 'counter':
	        return resp.rowsAffected;
	      default:
	        return resp;
	    }
	  },

	  ping: function ping(resource, callback) {
	    callback();
	  }

	});

	exports['default'] = Client_WebSQL;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy93ZWJzcWwvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozt3QkFJcUIsVUFBVTs7OzsyQkFFUCxlQUFlOzs7O3VCQUNaLFlBQVk7Ozs7dUJBQ25CLGVBQWU7Ozs7c0JBQ1UsUUFBUTs7QUFFckQsU0FBUyxhQUFhLENBQUMsTUFBTSxFQUFFO0FBQzdCLHVCQUFlLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDbEMsTUFBSSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxJQUFJLGVBQWUsQ0FBQztBQUMzQyxNQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLElBQUksS0FBSyxDQUFDO0FBQ3ZDLE1BQUksQ0FBQyxXQUFXLEdBQUcsTUFBTSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDO0FBQ25ELE1BQUksQ0FBQyxhQUFhLEdBQUcsTUFBTSxDQUFDLGFBQWEsSUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQztDQUM5RDtBQUNELHNCQUFTLGFBQWEsdUJBQWlCLENBQUM7O0FBRXhDLGVBQU8sYUFBYSxDQUFDLFNBQVMsRUFBRTs7QUFFOUIsYUFBVywwQkFBQTs7QUFFWCxTQUFPLEVBQUUsUUFBUTs7O0FBR2pCLG1CQUFpQixFQUFBLDZCQUFHO0FBQ2xCLFFBQU0sTUFBTSxHQUFHLElBQUksQ0FBQztBQUNwQixXQUFPLHlCQUFZLFVBQVMsT0FBTyxFQUFFLE1BQU0sRUFBRTtBQUMzQyxVQUFJOztBQUVGLFlBQU0sRUFBRSxHQUFHLFlBQVksQ0FDckIsTUFBTSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxXQUFXLEVBQUUsTUFBTSxDQUFDLGFBQWEsQ0FDdEUsQ0FBQztBQUNGLFVBQUUsQ0FBQyxXQUFXLENBQUMsVUFBUyxDQUFDLEVBQUU7QUFDekIsV0FBQyxDQUFDLFNBQVMsR0FBRyxp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RUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDOUQsaUJBQU8sR0FBRyxDQUFDLE1BQU0sS0FBSyxPQUFPLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQztTQUN0RDtBQUFBLEFBQ0QsV0FBSyxRQUFRO0FBQ1gsZUFBTyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUFBLEFBQ3pCLFdBQUssUUFBUSxDQUFDO0FBQ2QsV0FBSyxRQUFRLENBQUM7QUFDZCxXQUFLLFNBQVM7QUFDWixlQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7QUFBQSxBQUMzQjtBQUNFLGVBQU8sSUFBSSxDQUFDO0FBQUEsS0FDZjtHQUNGOztBQUVELE1BQUksRUFBQSxjQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUU7QUFDdkIsWUFBUSxFQUFFLENBQUM7R0FDWjs7Q0FFRixDQUFDLENBQUE7O3FCQUVhLGFBQWEiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIG9wZW5EYXRhYmFzZTpmYWxzZSAqL1xuXG4vLyBXZWJTUUxcbi8vIC0tLS0tLS1cbmltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5cbmltcG9ydCBUcmFuc2FjdGlvbiBmcm9tICcuL3RyYW5zYWN0aW9uJztcbmltcG9ydCBDbGllbnRfU1FMaXRlMyBmcm9tICcuLi9zcWxpdGUzJztcbmltcG9ydCBQcm9taXNlIGZyb20gJy4uLy4uL3Byb21pc2UnO1xuaW1wb3J0IHsgYXNzaWduLCBtYXAsIHVuaXF1ZUlkLCBjbG9uZSB9IGZyb20gJ2xvZGFzaCdcblxuZnVuY3Rpb24gQ2xpZW50X1dlYlNRTChjb25maWcpIHtcbiAgQ2xpZW50X1NRTGl0ZTMuY2FsbCh0aGlzLCBjb25maWcpO1xuICB0aGlzLm5hbWUgPSBjb25maWcubmFtZSB8fCAna25leF9kYXRhYmFzZSc7XG4gIHRoaXMudmVyc2lvbiA9IGNvbmZpZy52ZXJzaW9uIHx8ICcxLjAnO1xuICB0aGlzLmRpc3BsYXlOYW1lID0gY29uZmlnLmRpc3BsYXlOYW1lIHx8IHRoaXMubmFtZTtcbiAgdGhpcy5lc3RpbWF0ZWRTaXplID0gY29uZmlnLmVzdGltYXRlZFNpemUgfHwgNSAqIDEwMjQgKiAxMDI0O1xufVxuaW5oZXJpdHMoQ2xpZW50X1dlYlNRTCwgQ2xpZW50X1NRTGl0ZTMpO1xuXG5hc3NpZ24oQ2xpZW50X1dlYlNRTC5wcm90b3R5cGUsIHtcblxuICBUcmFuc2FjdGlvbixcblxuICBkaWFsZWN0OiAnd2Vic3FsJyxcblxuICAvLyBHZXQgYSByYXcgY29ubmVjdGlvbiBmcm9tIHRoZSBkYXRhYmFzZSwgcmV0dXJuaW5nIGEgcHJvbWlzZSB3aXRoIHRoZSBjb25uZWN0aW9uIG9iamVjdC5cbiAgYWNxdWlyZUNvbm5lY3Rpb24oKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvKmpzbGludCBicm93c2VyOiB0cnVlKi9cbiAgICAgICAgY29uc3QgZGIgPSBvcGVuRGF0YWJhc2UoXG4gICAgICAgICAgY2xpZW50Lm5hbWUsIGNsaWVudC52ZXJzaW9uLCBjbGllbnQuZGlzcGxheU5hbWUsIGNsaWVudC5lc3RpbWF0ZWRTaXplXG4gICAgICAgICk7XG4gICAgICAgIGRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICB0Ll9fa25leFVpZCA9IHVuaXF1ZUlkKCdfX2tuZXhVaWQnKTtcbiAgICAgICAgICByZXNvbHZlKHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8vIFVzZWQgdG8gZXhwbGljaXRseSBjbG9zZSBhIGNvbm5lY3Rpb24sIGNhbGxlZCBpbnRlcm5hbGx5IGJ5IHRoZSBwb29sXG4gIC8vIHdoZW4gYSBjb25uZWN0aW9uIHRpbWVzIG91dCBvciB0aGUgcG9vbCBpcyBzaHV0ZG93bi5cbiAgcmVsZWFzZUNvbm5lY3Rpb24oKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH0sXG5cbiAgLy8gUnVucyB0aGUgcXVlcnkgb24gdGhlIHNwZWNpZmllZCBjb25uZWN0aW9uLFxuICAvLyBwcm92aWRpbmcgdGhlIGJpbmRpbmdzIGFuZCBhbnkgb3RoZXIgbmVjZXNzYXJ5IHByZXAgd29yay5cbiAgX3F1ZXJ5KGNvbm5lY3Rpb24sIG9iaikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlciwgcmVqZWN0ZXIpIHtcbiAgICAgIGlmICghY29ubmVjdGlvbikgcmV0dXJuIHJlamVjdGVyKG5ldyBFcnJvcignTm8gY29ubmVjdGlvbiBwcm92aWRlZC4nKSk7XG4gICAgICBjb25uZWN0aW9uLmV4ZWN1dGVTcWwob2JqLnNxbCwgb2JqLmJpbmRpbmdzLCBmdW5jdGlvbih0cngsIHJlc3BvbnNlKSB7XG4gICAgICAgIG9iai5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZXIob2JqKTtcbiAgICAgIH0sIGZ1bmN0aW9uKHRyeCwgZXJyKSB7XG4gICAgICAgIHJlamVjdGVyKGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcblxuICBfc3RyZWFtKGNvbm5lY3Rpb24sIHNxbCwgc3RyZWFtKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZXIsIHJlamVjdGVyKSB7XG4gICAgICBzdHJlYW0ub24oJ2Vycm9yJywgcmVqZWN0ZXIpXG4gICAgICBzdHJlYW0ub24oJ2VuZCcsIHJlc29sdmVyKVxuICAgICAgcmV0dXJuIGNsaWVudC5fcXVlcnkoY29ubmVjdGlvbiwgc3FsKS50aGVuKG9iaiA9PlxuICAgICAgICBjbGllbnQucHJvY2Vzc1Jlc3BvbnNlKG9iailcbiAgICAgICkubWFwKHJvdyA9PiB7XG4gICAgICAgIHN0cmVhbS53cml0ZShyb3cpXG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgc3RyZWFtLmVuZCgpXG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG5cbiAgcHJvY2Vzc1Jlc3BvbnNlKG9iaiwgcnVubmVyKSB7XG4gICAgY29uc3QgcmVzcCA9IG9iai5yZXNwb25zZTtcbiAgICBpZiAob2JqLm91dHB1dCkgcmV0dXJuIG9iai5vdXRwdXQuY2FsbChydW5uZXIsIHJlc3ApO1xuICAgIHN3aXRjaCAob2JqLm1ldGhvZCkge1xuICAgICAgY2FzZSAncGx1Y2snOlxuICAgICAgY2FzZSAnZmlyc3QnOlxuICAgICAgY2FzZSAnc2VsZWN0Jzoge1xuICAgICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHJlc3Aucm93cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICByZXN1bHRzW2ldID0gY2xvbmUocmVzcC5yb3dzLml0ZW0oaSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoubWV0aG9kID09PSAncGx1Y2snKSByZXN1bHRzID0gbWFwKHJlc3VsdHMsIG9iai5wbHVjayk7XG4gICAgICAgIHJldHVybiBvYmoubWV0aG9kID09PSAnZmlyc3QnID8gcmVzdWx0c1swXSA6IHJlc3VsdHM7XG4gICAgICB9XG4gICAgICBjYXNlICdpbnNlcnQnOlxuICAgICAgICByZXR1cm4gW3Jlc3AuaW5zZXJ0SWRdO1xuICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICBjYXNlICdjb3VudGVyJzpcbiAgICAgICAgcmV0dXJuIHJlc3Aucm93c0FmZmVjdGVkO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfVxuICB9LFxuXG4gIHBpbmcocmVzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG59KVxuXG5leHBvcnQgZGVmYXVsdCBDbGllbnRfV2ViU1FMO1xuIl19

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _utilMakeKnex = __webpack_require__(69);

	var _utilMakeKnex2 = _interopRequireDefault(_utilMakeKnex);

	var _promise = __webpack_require__(43);

	var _promise2 = _interopRequireDefault(_promise);

	var _helpers = __webpack_require__(4);

	var helpers = _interopRequireWildcard(_helpers);

	var _inherits = __webpack_require__(3);

	var _inherits2 = _interopRequireDefault(_inherits);

	var _events = __webpack_require__(18);

	function Transaction_WebSQL(client, container) {
	  helpers.warn('WebSQL transactions will run queries, but do not commit or rollback');
	  var trx = this;
	  this._promise = _promise2['default']['try'](function () {
	    container(_utilMakeKnex2['default'](makeClient(trx, client)));
	  });
	}
	_inherits2['default'](Transaction_WebSQL, _events.EventEmitter);

	function makeClient(trx, client) {

	  var trxClient = Object.create(client.constructor.prototype);
	  trxClient.config = client.config;
	  trxClient.connectionSettings = client.connectionSettings;
	  trxClient.transacting = true;

	  trxClient.on('query', function (arg) {
	    trx.emit('query', arg);
	    client.emit('query', arg);
	  });
	  trxClient.commit = function () {};
	  trxClient.rollback = function () {};

	  return trxClient;
	}

	var promiseInterface = ['then', 'bind', 'catch', 'finally', 'asCallback', 'spread', 'map', 'reduce', 'tap', 'thenReturn', 'return', 'yield', 'ensure', 'exec', 'reflect'];

	// Creates a method which "coerces" to a promise, by calling a
	// "then" method on the current `Target`
	promiseInterface.forEach(function (method) {
	  Transaction_WebSQL.prototype[method] = function () {
	    return this._promise = this._promise[method].apply(this._promise, arguments);
	  };
	});

	exports['default'] = Transaction_WebSQL;
	module.exports = exports['default'];
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kaWFsZWN0cy93ZWJzcWwvdHJhbnNhY3Rpb24uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7NEJBQ3FCLHNCQUFzQjs7Ozt1QkFDdkIsZUFBZTs7Ozt1QkFDVixlQUFlOztJQUE1QixPQUFPOzt3QkFDRSxVQUFVOzs7O3NCQUNGLFFBQVE7O0FBRXJDLFNBQVMsa0JBQWtCLENBQUMsTUFBTSxFQUFFLFNBQVMsRUFBRTtBQUM3QyxTQUFPLENBQUMsSUFBSSxDQUFDLHFFQUFxRSxDQUFDLENBQUE7QUFDbkYsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFBO0FBQ2hCLE1BQUksQ0FBQyxRQUFRLEdBQUcsMkJBQVcsQ0FBQyxZQUFXO0FBQ3JDLGFBQVMsQ0FBQywwQkFBUyxVQUFVLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQTtHQUM3QyxDQUFDLENBQUE7Q0FDSDtBQUNELHNCQUFTLGtCQUFrQix1QkFBZSxDQUFBOztBQUUxQyxTQUFTLFVBQVUsQ0FBQyxHQUFHLEVBQUUsTUFBTSxFQUFFOztBQUUvQixNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUE7QUFDN0QsV0FBUyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFBO0FBQ2hDLFdBQVMsQ0FBQyxrQkFBa0IsR0FBRyxNQUFNLENBQUMsa0JBQWtCLENBQUE7QUFDeEQsV0FBUyxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUE7O0FBRTVCLFdBQVMsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLFVBQVMsR0FBRyxFQUFFO0FBQ2xDLE9BQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFBO0FBQ3RCLFVBQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFBO0dBQzFCLENBQUMsQ0FBQTtBQUNGLFdBQVMsQ0FBQyxNQUFNLEdBQUcsWUFBVyxFQUFFLENBQUE7QUFDaEMsV0FBUyxDQUFDLFFBQVEsR0FBRyxZQUFXLEVBQUUsQ0FBQTs7QUFFbEMsU0FBTyxTQUFTLENBQUE7Q0FDakI7O0FBRUQsSUFBTSxnQkFBZ0IsR0FBRyxDQUN2QixNQUFNLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUNoRCxRQUFRLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUM5QyxRQUFRLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsU0FBUyxDQUMvQyxDQUFBOzs7O0FBSUQsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLFVBQVMsTUFBTSxFQUFFO0FBQ3hDLG9CQUFrQixDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsR0FBRyxZQUFXO0FBQ2hELFdBQVEsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0dBQy9FLENBQUE7Q0FDRixDQUFDLENBQUE7O3FCQUVhLGtCQUFrQiIsImZpbGUiOiJ0cmFuc2FjdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IG1ha2VLbmV4IGZyb20gJy4uLy4uL3V0aWwvbWFrZS1rbmV4JztcbmltcG9ydCBQcm9taXNlIGZyb20gJy4uLy4uL3Byb21pc2UnO1xuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuLi8uLi9oZWxwZXJzJztcbmltcG9ydCBpbmhlcml0cyBmcm9tICdpbmhlcml0cyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuXG5mdW5jdGlvbiBUcmFuc2FjdGlvbl9XZWJTUUwoY2xpZW50LCBjb250YWluZXIpIHtcbiAgaGVscGVycy53YXJuKCdXZWJTUUwgdHJhbnNhY3Rpb25zIHdpbGwgcnVuIHF1ZXJpZXMsIGJ1dCBkbyBub3QgY29tbWl0IG9yIHJvbGxiYWNrJylcbiAgY29uc3QgdHJ4ID0gdGhpc1xuICB0aGlzLl9wcm9taXNlID0gUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgY29udGFpbmVyKG1ha2VLbmV4KG1ha2VDbGllbnQodHJ4LCBjbGllbnQpKSlcbiAgfSlcbn1cbmluaGVyaXRzKFRyYW5zYWN0aW9uX1dlYlNRTCwgRXZlbnRFbWl0dGVyKVxuXG5mdW5jdGlvbiBtYWtlQ2xpZW50KHRyeCwgY2xpZW50KSB7XG5cbiAgY29uc3QgdHJ4Q2xpZW50ID0gT2JqZWN0LmNyZWF0ZShjbGllbnQuY29uc3RydWN0b3IucHJvdG90eXBlKVxuICB0cnhDbGllbnQuY29uZmlnID0gY2xpZW50LmNvbmZpZ1xuICB0cnhDbGllbnQuY29ubmVjdGlvblNldHRpbmdzID0gY2xpZW50LmNvbm5lY3Rpb25TZXR0aW5nc1xuICB0cnhDbGllbnQudHJhbnNhY3RpbmcgPSB0cnVlXG5cbiAgdHJ4Q2xpZW50Lm9uKCdxdWVyeScsIGZ1bmN0aW9uKGFyZykge1xuICAgIHRyeC5lbWl0KCdxdWVyeScsIGFyZylcbiAgICBjbGllbnQuZW1pdCgncXVlcnknLCBhcmcpXG4gIH0pXG4gIHRyeENsaWVudC5jb21taXQgPSBmdW5jdGlvbigpIHt9XG4gIHRyeENsaWVudC5yb2xsYmFjayA9IGZ1bmN0aW9uKCkge31cblxuICByZXR1cm4gdHJ4Q2xpZW50XG59XG5cbmNvbnN0IHByb21pc2VJbnRlcmZhY2UgPSBbXG4gICd0aGVuJywgJ2JpbmQnLCAnY2F0Y2gnLCAnZmluYWxseScsICdhc0NhbGxiYWNrJyxcbiAgJ3NwcmVhZCcsICdtYXAnLCAncmVkdWNlJywgJ3RhcCcsICd0aGVuUmV0dXJuJyxcbiAgJ3JldHVybicsICd5aWVsZCcsICdlbnN1cmUnLCAnZXhlYycsICdyZWZsZWN0J1xuXVxuXG4vLyBDcmVhdGVzIGEgbWV0aG9kIHdoaWNoIFwiY29lcmNlc1wiIHRvIGEgcHJvbWlzZSwgYnkgY2FsbGluZyBhXG4vLyBcInRoZW5cIiBtZXRob2Qgb24gdGhlIGN1cnJlbnQgYFRhcmdldGBcbnByb21pc2VJbnRlcmZhY2UuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgVHJhbnNhY3Rpb25fV2ViU1FMLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLl9wcm9taXNlID0gdGhpcy5fcHJvbWlzZVttZXRob2RdLmFwcGx5KHRoaXMuX3Byb21pc2UsIGFyZ3VtZW50cykpXG4gIH1cbn0pXG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zYWN0aW9uX1dlYlNRTFxuIl19

/***/ }
/******/ ])
});
;